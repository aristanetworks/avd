# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/inventory.v1/inventory.proto, arista/inventory.v1/services.gen.proto
# plugin: python-aristaproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import aristaproto
import grpclib
from aristaproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class StreamingStatus(aristaproto.Enum):
    """
    StreamingStatus defines the status of telemetry streaming for a device.
    """

    UNSPECIFIED = 0
    INACTIVE = 1
    """
    STREAMING_STATUS_INACTIVE indicates the device is not streaming telemetry.
    """

    ACTIVE = 2
    """STREAMING_STATUS_ACTIVE indicates the device is streaming telemetry."""


class OnboardingStatus(aristaproto.Enum):
    """
    OnboardingStatus defines the set of possible states in the onboarding process
     for a device.
    """

    UNSPECIFIED = 0
    IN_PROGRESS = 1
    """ONBOARDING_STATUS_IN_PROGRESS indicates onboarding is in progress."""

    FAILURE = 2
    """ONBOARDING_STATUS_FAILURE indicates onboarding failed."""

    SUCCESS = 3
    """ONBOARDING_STATUS_SUCCESS indicates onboarding succeeded."""


class DecommissioningStatus(aristaproto.Enum):
    """
    DecommissioningStatus defines the set of possible states in the decommissioning
     process for a device.
    """

    UNSPECIFIED = 0
    IN_PROGRESS = 1
    """
    DECOMMISSIONING_STATUS_IN_PROGRESS indicates decommissioning is in progress.
    """

    FAILURE = 2
    """DECOMMISSIONING_STATUS_FAILURE indicates decommissioning failed."""

    SUCCESS = 3
    """DECOMMISSIONING_STATUS_SUCCESS indicates decommissioning succeeded."""


class ProvisioningStatus(aristaproto.Enum):
    """
    ProvisioningStatus defines the set of possible states in the provisioning
     process for a device.
    """

    UNSPECIFIED = 0
    IN_PROGRESS = 1
    """
    PROVISIONING_STATUS_IN_PROGRESS indicates provisioning is in progress.
    """

    FAILURE = 2
    """PROVISIONING_STATUS_FAILURE indicates provisioning failed."""

    SUCCESS = 3
    """PROVISIONING_STATUS_SUCCESS indicates provisioning succeeded."""


@dataclass(eq=False, repr=False)
class ExtendedAttributes(aristaproto.Message):
    """
    ExtendedAttributes wraps any additional, potentially non-standard, features
     or attributes the device reports.
    """

    feature_enabled: Dict[str, bool] = aristaproto.map_field(
        1, aristaproto.TYPE_STRING, aristaproto.TYPE_BOOL
    )
    """
    feature_enabled is a map of feature name to enabled status.
     If a feature is missing from this map it can be assumed off.
    """


@dataclass(eq=False, repr=False)
class DeviceKey(aristaproto.Message):
    """DeviceKey uniquely identifies a single device."""

    device_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """device_id is the unique identifier of the device."""


@dataclass(eq=False, repr=False)
class DeviceConfiguration(aristaproto.Message):
    """
    DeviceConfiguration holds the device-specific configuration for a third-party
     device, as defined in https://github.com/aristanetworks/cloudvision-go.
    """

    options: Dict[str, str] = aristaproto.map_field(
        1, aristaproto.TYPE_STRING, aristaproto.TYPE_STRING
    )
    """
    options is a map from device option to value.

     E.g., for an SNMP device, this could be the following:

     "address":   "my_snmp_hostname",
     "community": "public"
    """


@dataclass(eq=False, repr=False)
class UuidKey(aristaproto.Message):
    """
    UUIDKey is a key that holds a UUID for an onboarding or decommissioning request.
    """

    request_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """request_id should be a UUID for the request."""


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfig(aristaproto.Message):
    """
    DeviceOnboardingConfig describes a device onboarding request. "Onboarding"
     refers to the process of initiating device streaming to CloudVision and
     adding the streaming device to CloudVision's inventory.

     The request flow works as follows:

     1. Set on DeviceOnboardingConfig sends an onboarding request with a UUID
        that the user is responsible for generating.
     2. Once the server receives the request, it validates and records it.
     3. Then, the server processes it, initiating the onboarding procedure and
        tracking the status of the onboarding attempt.
     4. The user may do a GetOne or Subscribe on DeviceOnboarding using the same
        UUID to see the status of the request.
    """

    key: "UuidKey" = aristaproto.message_field(1)
    """key identifies the request to onboard the device at hostname_or_ip."""

    hostname_or_ip: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    hostname_or_ip is a hostname or an IP at which the device can be reached.
    """

    device_type: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    device_type describes the method by which to retrieve information for the
     device. The value should be "eos" for eos devices. For third-party devices,
     supported values are: "openconfig", "snmp", "cvp", "mwm", and "vCenter".
    """

    device_config: "DeviceConfiguration" = aristaproto.message_field(4)
    """device_config is the configuration for a third-party device."""


@dataclass(eq=False, repr=False)
class DeviceOnboarding(aristaproto.Message):
    """DeviceOnboarding describes the status of an onboarding process."""

    key: "UuidKey" = aristaproto.message_field(1)
    """
    key identifies the request for which to retrieve an onboarding status.
    """

    device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """device_id is the unique device ID that is discovered via onboarding."""

    status: "OnboardingStatus" = aristaproto.enum_field(3)
    """status describes the onboarding status of the device."""

    error: Optional[str] = aristaproto.message_field(4, wraps=aristaproto.TYPE_STRING)
    """
    error is the error that caused status to become ONBOARDING_STATUS_FAILURE.
    """

    status_message: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    status_message contains information on the status of the onboarding attempt,
     if any. This is generally an unstructured log message that is for display
     purposes only (its structure and contents may change).
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfig(aristaproto.Message):
    """
    DeviceDecommissioningConfig describes a device decommissioning request.
     "Decommissioning" refers to the process of stopping device streaming to
     CloudVision and removing it from CloudVision's inventory.

     The request flow works as follows:

     1. Set on DeviceDecommissioningConfig sends a decommissioning request with
        a UUID that the user is responsible for generating.
     2. Once the server receives the request, it validates and records it.
     3. Then, the server processes it, initiating the decommissioning procedure
        and tracking the status of the decommissioning attempt.
     4. The user may do a GetOne or Subscribe on DeviceDecommissioning using the
        same UUID to see the status of the request.
    """

    key: "UuidKey" = aristaproto.message_field(1)
    """key identifies the request to decommission the device."""

    device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    device_id is the unique device ID that was discovered via onboarding.
    """

    force: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    force is a flag that indicates if the decommission is to be forced.
     Normally, if there are pending or in-progress tasks associated with the device
     the decommission would fail. In case of a forced decommission, such blocking
     tasks would be ignored and decommissioning will be continued.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioning(aristaproto.Message):
    """DeviceOnboarding describes the status of a decommissioning process."""

    key: "UuidKey" = aristaproto.message_field(1)
    """
    key identifies the request for which to retrieve a decommissioning status.
    """

    status: "DecommissioningStatus" = aristaproto.enum_field(2)
    """status describes the decommissioning status of the device."""

    error: Optional[str] = aristaproto.message_field(3, wraps=aristaproto.TYPE_STRING)
    """
    error is the error that caused status to become DECOMMISSIONING_STATUS_FAILURE.
    """

    status_message: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """
    status_message contains information on the status of the decommissioning attempt,
     if any. This is generally an unstructured log message that is for display
     purposes only (its structure and contents may change).
    """


@dataclass(eq=False, repr=False)
class Device(aristaproto.Message):
    """Device describes an onboarded device."""

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device."""

    software_version: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    software_version gives the currently running device software version.
    """

    model_name: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """model_name describes the hardware model of this device."""

    hardware_revision: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """hardware_revision describes any revisional data to the model name."""

    fqdn: Optional[str] = aristaproto.message_field(10, wraps=aristaproto.TYPE_STRING)
    """fqdn gives the device's fully qualified domain name."""

    hostname: Optional[str] = aristaproto.message_field(
        11, wraps=aristaproto.TYPE_STRING
    )
    """hostname is the hostname as reported on the device."""

    domain_name: Optional[str] = aristaproto.message_field(
        12, wraps=aristaproto.TYPE_STRING
    )
    """
    domain_name provides the domain name on which the device is registered.
    """

    system_mac_address: Optional[str] = aristaproto.message_field(
        13, wraps=aristaproto.TYPE_STRING
    )
    """system_mac_address provides the MAC address of the management port."""

    boot_time: datetime = aristaproto.message_field(20)
    """boot_time indicates when the device was last booted."""

    streaming_status: "StreamingStatus" = aristaproto.enum_field(30)
    """
    streaming_status is the status of telemetry streaming for this device.
    """

    extended_attributes: "ExtendedAttributes" = aristaproto.message_field(31)
    """
    extended_attributes wraps any additional, potentially non-standard, features
     or attributes that the device reports.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDevice(aristaproto.Message):
    """
    ProvisionedDevice describes the provisioning status of an onboarded device
     if the onboarded device is configured for provisioning.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device."""

    status: "ProvisioningStatus" = aristaproto.enum_field(2)
    """status describes the onboarded device's provisioning status."""

    error: Optional[str] = aristaproto.message_field(3, wraps=aristaproto.TYPE_STRING)
    """
    error is the error that caused status to become PROVISIONING_STATUS_FAILURE.
    """

    ztp_mode: Optional[bool] = aristaproto.message_field(4, wraps=aristaproto.TYPE_BOOL)
    """ztp_mode indicates whether the device is in ZTP mode."""

    ip_address: "___fmp__.IpAddress" = aristaproto.message_field(5)
    """
    ip_address is the current (post-provisioning) IP address of the device.
    """

    provisioning_group_name: Optional[str] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_STRING
    )
    """
    provisioning_group_name is the name of the group (also known as a container)
     to which the device belongs. Any provisioning operation performed on this
     group will also be performed on this device. If the device is not yet provisioned,
     this will not be set. Once it is provisioned, this will be set to "undefined_container"
     which indicates that the device does not yet belong to a group. At this point,
     a user may set it to an existing group.
    """


@dataclass(eq=False, repr=False)
class MetaResponse(aristaproto.Message):
    time: datetime = aristaproto.message_field(1)
    """
    Time holds the timestamp of the last item included in the metadata calculation.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(2)
    """
    Operation indicates how the value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """

    count: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_UINT32)
    """
    Count is the number of items present under the conditions of the request.
    """


@dataclass(eq=False, repr=False)
class DeviceRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Device instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceResponse(aristaproto.Message):
    value: "Device" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     Device instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceSomeResponse(aristaproto.Message):
    value: "Device" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Device"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Device at end.
         * Each Device response is fully-specified (all fields set).
       * start: Returns the state of each Device at start, followed by updates until now.
         * Each Device response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Device at start, followed by updates
         until end.
         * Each Device response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceStreamResponse(aristaproto.Message):
    value: "Device" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Device's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Device value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Device"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Device at end.
         * Each Device response is fully-specified (all fields set).
       * start: Returns the state of each Device at start, followed by updates until now.
         * Each Device response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Device at start, followed by updates
         until end.
         * Each Device response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningRequest(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceDecommissioning instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningResponse(aristaproto.Message):
    value: "DeviceDecommissioning" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceDecommissioning instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningSomeRequest(aristaproto.Message):
    keys: List["UuidKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningSomeResponse(aristaproto.Message):
    value: "DeviceDecommissioning" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceDecommissioningStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceDecommissioning"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceDecommissioning at end.
         * Each DeviceDecommissioning response is fully-specified (all fields set).
       * start: Returns the state of each DeviceDecommissioning at start, followed by updates until now.
         * Each DeviceDecommissioning response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceDecommissioning at start, followed by updates
         until end.
         * Each DeviceDecommissioning response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningStreamResponse(aristaproto.Message):
    value: "DeviceDecommissioning" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceDecommissioning's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceDecommissioning value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceDecommissioning"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceDecommissioning at end.
         * Each DeviceDecommissioning response is fully-specified (all fields set).
       * start: Returns the state of each DeviceDecommissioning at start, followed by updates until now.
         * Each DeviceDecommissioning response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceDecommissioning at start, followed by updates
         until end.
         * Each DeviceDecommissioning response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceDecommissioningStreamResponse"] = aristaproto.message_field(
        1
    )
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigRequest(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceDecommissioningConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigResponse(aristaproto.Message):
    value: "DeviceDecommissioningConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceDecommissioningConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSomeRequest(aristaproto.Message):
    keys: List["UuidKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSomeResponse(aristaproto.Message):
    value: "DeviceDecommissioningConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceDecommissioningConfig"] = aristaproto.message_field(
        1
    )
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceDecommissioningConfig at end.
         * Each DeviceDecommissioningConfig response is fully-specified (all fields set).
       * start: Returns the state of each DeviceDecommissioningConfig at start, followed by updates until now.
         * Each DeviceDecommissioningConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceDecommissioningConfig at start, followed by updates
         until end.
         * Each DeviceDecommissioningConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigStreamResponse(aristaproto.Message):
    value: "DeviceDecommissioningConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceDecommissioningConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceDecommissioningConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceDecommissioningConfig"] = aristaproto.message_field(
        1
    )
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceDecommissioningConfig at end.
         * Each DeviceDecommissioningConfig response is fully-specified (all fields set).
       * start: Returns the state of each DeviceDecommissioningConfig at start, followed by updates until now.
         * Each DeviceDecommissioningConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceDecommissioningConfig at start, followed by updates
         until end.
         * Each DeviceDecommissioningConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceDecommissioningConfigStreamResponse"] = (
        aristaproto.message_field(1)
    )
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSetRequest(aristaproto.Message):
    value: "DeviceDecommissioningConfig" = aristaproto.message_field(1)
    """
    DeviceDecommissioningConfig carries the value to set into the datastore.
     See the documentation on the DeviceDecommissioningConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSetResponse(aristaproto.Message):
    value: "DeviceDecommissioningConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DeviceDecommissioningConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSetSomeRequest(aristaproto.Message):
    values: List["DeviceDecommissioningConfig"] = aristaproto.message_field(1)
    """
    value contains a list of DeviceDecommissioningConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigSetSomeResponse(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteRequest(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key indicates which DeviceDecommissioningConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteResponse(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key echoes back the key of the deleted DeviceDecommissioningConfig instance.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["UuidKey"] = aristaproto.message_field(1)
    """key contains a list of DeviceDecommissioningConfig keys to delete"""


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteSomeResponse(aristaproto.Message):
    """
    DeviceDecommissioningConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "UuidKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceDecommissioningConfig"] = aristaproto.message_field(
        1
    )
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class DeviceDecommissioningConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "UuidKey" = aristaproto.message_field(3)
    """
    This is the key of the DeviceDecommissioningConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceOnboardingRequest(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceOnboarding instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingResponse(aristaproto.Message):
    value: "DeviceOnboarding" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceOnboarding instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingSomeRequest(aristaproto.Message):
    keys: List["UuidKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingSomeResponse(aristaproto.Message):
    value: "DeviceOnboarding" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceOnboardingStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceOnboarding"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceOnboarding at end.
         * Each DeviceOnboarding response is fully-specified (all fields set).
       * start: Returns the state of each DeviceOnboarding at start, followed by updates until now.
         * Each DeviceOnboarding response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceOnboarding at start, followed by updates
         until end.
         * Each DeviceOnboarding response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingStreamResponse(aristaproto.Message):
    value: "DeviceOnboarding" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceOnboarding's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceOnboarding value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceOnboarding"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceOnboarding at end.
         * Each DeviceOnboarding response is fully-specified (all fields set).
       * start: Returns the state of each DeviceOnboarding at start, followed by updates until now.
         * Each DeviceOnboarding response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceOnboarding at start, followed by updates
         until end.
         * Each DeviceOnboarding response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceOnboardingStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigRequest(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceOnboardingConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigResponse(aristaproto.Message):
    value: "DeviceOnboardingConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceOnboardingConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSomeRequest(aristaproto.Message):
    keys: List["UuidKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSomeResponse(aristaproto.Message):
    value: "DeviceOnboardingConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceOnboardingConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceOnboardingConfig at end.
         * Each DeviceOnboardingConfig response is fully-specified (all fields set).
       * start: Returns the state of each DeviceOnboardingConfig at start, followed by updates until now.
         * Each DeviceOnboardingConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceOnboardingConfig at start, followed by updates
         until end.
         * Each DeviceOnboardingConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigStreamResponse(aristaproto.Message):
    value: "DeviceOnboardingConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceOnboardingConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceOnboardingConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceOnboardingConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceOnboardingConfig at end.
         * Each DeviceOnboardingConfig response is fully-specified (all fields set).
       * start: Returns the state of each DeviceOnboardingConfig at start, followed by updates until now.
         * Each DeviceOnboardingConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceOnboardingConfig at start, followed by updates
         until end.
         * Each DeviceOnboardingConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceOnboardingConfigStreamResponse"] = aristaproto.message_field(
        1
    )
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSetRequest(aristaproto.Message):
    value: "DeviceOnboardingConfig" = aristaproto.message_field(1)
    """
    DeviceOnboardingConfig carries the value to set into the datastore.
     See the documentation on the DeviceOnboardingConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSetResponse(aristaproto.Message):
    value: "DeviceOnboardingConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DeviceOnboardingConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSetSomeRequest(aristaproto.Message):
    values: List["DeviceOnboardingConfig"] = aristaproto.message_field(1)
    """
    value contains a list of DeviceOnboardingConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigSetSomeResponse(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteRequest(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key indicates which DeviceOnboardingConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteResponse(aristaproto.Message):
    key: "UuidKey" = aristaproto.message_field(1)
    """
    Key echoes back the key of the deleted DeviceOnboardingConfig instance.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["UuidKey"] = aristaproto.message_field(1)
    """key contains a list of DeviceOnboardingConfig keys to delete"""


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteSomeResponse(aristaproto.Message):
    """
    DeviceOnboardingConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "UuidKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceOnboardingConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class DeviceOnboardingConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "UuidKey" = aristaproto.message_field(3)
    """
    This is the key of the DeviceOnboardingConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class ProvisionedDeviceRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a ProvisionedDevice instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceResponse(aristaproto.Message):
    value: "ProvisionedDevice" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     ProvisionedDevice instance in this response.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceSomeResponse(aristaproto.Message):
    value: "ProvisionedDevice" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class ProvisionedDeviceStreamRequest(aristaproto.Message):
    partial_eq_filter: List["ProvisionedDevice"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each ProvisionedDevice at end.
         * Each ProvisionedDevice response is fully-specified (all fields set).
       * start: Returns the state of each ProvisionedDevice at start, followed by updates until now.
         * Each ProvisionedDevice response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each ProvisionedDevice at start, followed by updates
         until end.
         * Each ProvisionedDevice response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceStreamResponse(aristaproto.Message):
    value: "ProvisionedDevice" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this ProvisionedDevice's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the ProvisionedDevice value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["ProvisionedDevice"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each ProvisionedDevice at end.
         * Each ProvisionedDevice response is fully-specified (all fields set).
       * start: Returns the state of each ProvisionedDevice at start, followed by updates until now.
         * Each ProvisionedDevice response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each ProvisionedDevice at start, followed by updates
         until end.
         * Each ProvisionedDevice response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class ProvisionedDeviceBatchedStreamResponse(aristaproto.Message):
    responses: List["ProvisionedDeviceStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


class DeviceServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_request: "DeviceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceService/GetOne",
            device_request,
            DeviceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_some_request: "DeviceSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/GetSome",
            device_some_request,
            DeviceSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_stream_request: "DeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/GetAll",
            device_stream_request,
            DeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_stream_request: "DeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/Subscribe",
            device_stream_request,
            DeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_stream_request: "DeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceService/GetMeta",
            device_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_stream_request: "DeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/SubscribeMeta",
            device_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_batched_stream_request: "DeviceBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/GetAllBatched",
            device_batched_stream_request,
            DeviceBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_batched_stream_request: "DeviceBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceService/SubscribeBatched",
            device_batched_stream_request,
            DeviceBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceDecommissioningServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_decommissioning_request: "DeviceDecommissioningRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningService/GetOne",
            device_decommissioning_request,
            DeviceDecommissioningResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_decommissioning_some_request: "DeviceDecommissioningSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/GetSome",
            device_decommissioning_some_request,
            DeviceDecommissioningSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/GetAll",
            device_decommissioning_stream_request,
            DeviceDecommissioningStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/Subscribe",
            device_decommissioning_stream_request,
            DeviceDecommissioningStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningService/GetMeta",
            device_decommissioning_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/SubscribeMeta",
            device_decommissioning_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_decommissioning_batched_stream_request: "DeviceDecommissioningBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/GetAllBatched",
            device_decommissioning_batched_stream_request,
            DeviceDecommissioningBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_decommissioning_batched_stream_request: "DeviceDecommissioningBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningService/SubscribeBatched",
            device_decommissioning_batched_stream_request,
            DeviceDecommissioningBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceDecommissioningConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_decommissioning_config_request: "DeviceDecommissioningConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningConfigResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetOne",
            device_decommissioning_config_request,
            DeviceDecommissioningConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_decommissioning_config_some_request: "DeviceDecommissioningConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetSome",
            device_decommissioning_config_some_request,
            DeviceDecommissioningConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetAll",
            device_decommissioning_config_stream_request,
            DeviceDecommissioningConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Subscribe",
            device_decommissioning_config_stream_request,
            DeviceDecommissioningConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetMeta",
            device_decommissioning_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/SubscribeMeta",
            device_decommissioning_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_decommissioning_config_set_request: "DeviceDecommissioningConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningConfigSetResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Set",
            device_decommissioning_config_set_request,
            DeviceDecommissioningConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        device_decommissioning_config_set_some_request: "DeviceDecommissioningConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/SetSome",
            device_decommissioning_config_set_some_request,
            DeviceDecommissioningConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        device_decommissioning_config_delete_request: "DeviceDecommissioningConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceDecommissioningConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Delete",
            device_decommissioning_config_delete_request,
            DeviceDecommissioningConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        device_decommissioning_config_delete_some_request: "DeviceDecommissioningConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/DeleteSome",
            device_decommissioning_config_delete_some_request,
            DeviceDecommissioningConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        device_decommissioning_config_delete_all_request: "DeviceDecommissioningConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/DeleteAll",
            device_decommissioning_config_delete_all_request,
            DeviceDecommissioningConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_decommissioning_config_batched_stream_request: "DeviceDecommissioningConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetAllBatched",
            device_decommissioning_config_batched_stream_request,
            DeviceDecommissioningConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_decommissioning_config_batched_stream_request: "DeviceDecommissioningConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceDecommissioningConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceDecommissioningConfigService/SubscribeBatched",
            device_decommissioning_config_batched_stream_request,
            DeviceDecommissioningConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceOnboardingServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_onboarding_request: "DeviceOnboardingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingService/GetOne",
            device_onboarding_request,
            DeviceOnboardingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_onboarding_some_request: "DeviceOnboardingSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/GetSome",
            device_onboarding_some_request,
            DeviceOnboardingSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_onboarding_stream_request: "DeviceOnboardingStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/GetAll",
            device_onboarding_stream_request,
            DeviceOnboardingStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_onboarding_stream_request: "DeviceOnboardingStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/Subscribe",
            device_onboarding_stream_request,
            DeviceOnboardingStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_onboarding_stream_request: "DeviceOnboardingStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingService/GetMeta",
            device_onboarding_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_onboarding_stream_request: "DeviceOnboardingStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/SubscribeMeta",
            device_onboarding_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_onboarding_batched_stream_request: "DeviceOnboardingBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/GetAllBatched",
            device_onboarding_batched_stream_request,
            DeviceOnboardingBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_onboarding_batched_stream_request: "DeviceOnboardingBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingService/SubscribeBatched",
            device_onboarding_batched_stream_request,
            DeviceOnboardingBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceOnboardingConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_onboarding_config_request: "DeviceOnboardingConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingConfigResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetOne",
            device_onboarding_config_request,
            DeviceOnboardingConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_onboarding_config_some_request: "DeviceOnboardingConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetSome",
            device_onboarding_config_some_request,
            DeviceOnboardingConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetAll",
            device_onboarding_config_stream_request,
            DeviceOnboardingConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/Subscribe",
            device_onboarding_config_stream_request,
            DeviceOnboardingConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetMeta",
            device_onboarding_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/SubscribeMeta",
            device_onboarding_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_onboarding_config_set_request: "DeviceOnboardingConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingConfigSetResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/Set",
            device_onboarding_config_set_request,
            DeviceOnboardingConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        device_onboarding_config_set_some_request: "DeviceOnboardingConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/SetSome",
            device_onboarding_config_set_some_request,
            DeviceOnboardingConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        device_onboarding_config_delete_request: "DeviceOnboardingConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceOnboardingConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.DeviceOnboardingConfigService/Delete",
            device_onboarding_config_delete_request,
            DeviceOnboardingConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        device_onboarding_config_delete_some_request: "DeviceOnboardingConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/DeleteSome",
            device_onboarding_config_delete_some_request,
            DeviceOnboardingConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        device_onboarding_config_delete_all_request: "DeviceOnboardingConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/DeleteAll",
            device_onboarding_config_delete_all_request,
            DeviceOnboardingConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_onboarding_config_batched_stream_request: "DeviceOnboardingConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetAllBatched",
            device_onboarding_config_batched_stream_request,
            DeviceOnboardingConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_onboarding_config_batched_stream_request: "DeviceOnboardingConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceOnboardingConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.DeviceOnboardingConfigService/SubscribeBatched",
            device_onboarding_config_batched_stream_request,
            DeviceOnboardingConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ProvisionedDeviceServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        provisioned_device_request: "ProvisionedDeviceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ProvisionedDeviceResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.ProvisionedDeviceService/GetOne",
            provisioned_device_request,
            ProvisionedDeviceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        provisioned_device_some_request: "ProvisionedDeviceSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/GetSome",
            provisioned_device_some_request,
            ProvisionedDeviceSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        provisioned_device_stream_request: "ProvisionedDeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/GetAll",
            provisioned_device_stream_request,
            ProvisionedDeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        provisioned_device_stream_request: "ProvisionedDeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/Subscribe",
            provisioned_device_stream_request,
            ProvisionedDeviceStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        provisioned_device_stream_request: "ProvisionedDeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.inventory.v1.ProvisionedDeviceService/GetMeta",
            provisioned_device_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        provisioned_device_stream_request: "ProvisionedDeviceStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/SubscribeMeta",
            provisioned_device_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        provisioned_device_batched_stream_request: "ProvisionedDeviceBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/GetAllBatched",
            provisioned_device_batched_stream_request,
            ProvisionedDeviceBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        provisioned_device_batched_stream_request: "ProvisionedDeviceBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ProvisionedDeviceBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.inventory.v1.ProvisionedDeviceService/SubscribeBatched",
            provisioned_device_batched_stream_request,
            ProvisionedDeviceBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceServiceBase(ServiceBase):

    async def get_one(self, device_request: "DeviceRequest") -> "DeviceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_some_request: "DeviceSomeRequest"
    ) -> AsyncIterator["DeviceSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_stream_request: "DeviceStreamRequest"
    ) -> AsyncIterator["DeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_stream_request: "DeviceStreamRequest"
    ) -> AsyncIterator["DeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, device_stream_request: "DeviceStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, device_stream_request: "DeviceStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, device_batched_stream_request: "DeviceBatchedStreamRequest"
    ) -> AsyncIterator["DeviceBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, device_batched_stream_request: "DeviceBatchedStreamRequest"
    ) -> AsyncIterator["DeviceBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DeviceRequest, DeviceResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self, stream: "grpclib.server.Stream[DeviceSomeRequest, DeviceSomeResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[DeviceStreamRequest, DeviceStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[DeviceStreamRequest, DeviceStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[DeviceStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[DeviceStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceBatchedStreamRequest, DeviceBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceBatchedStreamRequest, DeviceBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceRequest,
                DeviceResponse,
            ),
            "/arista.inventory.v1.DeviceService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceSomeRequest,
                DeviceSomeResponse,
            ),
            "/arista.inventory.v1.DeviceService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStreamRequest,
                DeviceStreamResponse,
            ),
            "/arista.inventory.v1.DeviceService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStreamRequest,
                DeviceStreamResponse,
            ),
            "/arista.inventory.v1.DeviceService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceBatchedStreamRequest,
                DeviceBatchedStreamResponse,
            ),
            "/arista.inventory.v1.DeviceService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceBatchedStreamRequest,
                DeviceBatchedStreamResponse,
            ),
        }


class DeviceDecommissioningServiceBase(ServiceBase):

    async def get_one(
        self, device_decommissioning_request: "DeviceDecommissioningRequest"
    ) -> "DeviceDecommissioningResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_decommissioning_some_request: "DeviceDecommissioningSomeRequest"
    ) -> AsyncIterator["DeviceDecommissioningSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self,
        device_decommissioning_stream_request: "DeviceDecommissioningStreamRequest",
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        device_decommissioning_batched_stream_request: "DeviceDecommissioningBatchedStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        device_decommissioning_batched_stream_request: "DeviceDecommissioningBatchedStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningRequest, DeviceDecommissioningResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningSomeRequest, DeviceDecommissioningSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningStreamRequest, DeviceDecommissioningStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningStreamRequest, DeviceDecommissioningStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningBatchedStreamRequest, DeviceDecommissioningBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningBatchedStreamRequest, DeviceDecommissioningBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceDecommissioningService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningRequest,
                DeviceDecommissioningResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningSomeRequest,
                DeviceDecommissioningSomeResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningStreamRequest,
                DeviceDecommissioningStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningStreamRequest,
                DeviceDecommissioningStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningBatchedStreamRequest,
                DeviceDecommissioningBatchedStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningBatchedStreamRequest,
                DeviceDecommissioningBatchedStreamResponse,
            ),
        }


class DeviceDecommissioningConfigServiceBase(ServiceBase):

    async def get_one(
        self,
        device_decommissioning_config_request: "DeviceDecommissioningConfigRequest",
    ) -> "DeviceDecommissioningConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self,
        device_decommissioning_config_some_request: "DeviceDecommissioningConfigSomeRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self,
        device_decommissioning_config_stream_request: "DeviceDecommissioningConfigStreamRequest",
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self,
        device_decommissioning_config_set_request: "DeviceDecommissioningConfigSetRequest",
    ) -> "DeviceDecommissioningConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self,
        device_decommissioning_config_set_some_request: "DeviceDecommissioningConfigSetSomeRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        device_decommissioning_config_delete_request: "DeviceDecommissioningConfigDeleteRequest",
    ) -> "DeviceDecommissioningConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        device_decommissioning_config_delete_some_request: "DeviceDecommissioningConfigDeleteSomeRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_decommissioning_config_delete_all_request: "DeviceDecommissioningConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        device_decommissioning_config_batched_stream_request: "DeviceDecommissioningConfigBatchedStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        device_decommissioning_config_batched_stream_request: "DeviceDecommissioningConfigBatchedStreamRequest",
    ) -> AsyncIterator["DeviceDecommissioningConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigRequest, DeviceDecommissioningConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigSomeRequest, DeviceDecommissioningConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigStreamRequest, DeviceDecommissioningConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigStreamRequest, DeviceDecommissioningConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigSetRequest, DeviceDecommissioningConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigSetSomeRequest, DeviceDecommissioningConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigDeleteRequest, DeviceDecommissioningConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigDeleteSomeRequest, DeviceDecommissioningConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigDeleteAllRequest, DeviceDecommissioningConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigBatchedStreamRequest, DeviceDecommissioningConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceDecommissioningConfigBatchedStreamRequest, DeviceDecommissioningConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigRequest,
                DeviceDecommissioningConfigResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigSomeRequest,
                DeviceDecommissioningConfigSomeResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigStreamRequest,
                DeviceDecommissioningConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigStreamRequest,
                DeviceDecommissioningConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigSetRequest,
                DeviceDecommissioningConfigSetResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigSetSomeRequest,
                DeviceDecommissioningConfigSetSomeResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceDecommissioningConfigDeleteRequest,
                DeviceDecommissioningConfigDeleteResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigDeleteSomeRequest,
                DeviceDecommissioningConfigDeleteSomeResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigDeleteAllRequest,
                DeviceDecommissioningConfigDeleteAllResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigBatchedStreamRequest,
                DeviceDecommissioningConfigBatchedStreamResponse,
            ),
            "/arista.inventory.v1.DeviceDecommissioningConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceDecommissioningConfigBatchedStreamRequest,
                DeviceDecommissioningConfigBatchedStreamResponse,
            ),
        }


class DeviceOnboardingServiceBase(ServiceBase):

    async def get_one(
        self, device_onboarding_request: "DeviceOnboardingRequest"
    ) -> "DeviceOnboardingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_onboarding_some_request: "DeviceOnboardingSomeRequest"
    ) -> AsyncIterator["DeviceOnboardingSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_onboarding_stream_request: "DeviceOnboardingStreamRequest"
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_onboarding_stream_request: "DeviceOnboardingStreamRequest"
    ) -> AsyncIterator["DeviceOnboardingStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, device_onboarding_stream_request: "DeviceOnboardingStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, device_onboarding_stream_request: "DeviceOnboardingStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        device_onboarding_batched_stream_request: "DeviceOnboardingBatchedStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        device_onboarding_batched_stream_request: "DeviceOnboardingBatchedStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingRequest, DeviceOnboardingResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingSomeRequest, DeviceOnboardingSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingStreamRequest, DeviceOnboardingStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingStreamRequest, DeviceOnboardingStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingBatchedStreamRequest, DeviceOnboardingBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingBatchedStreamRequest, DeviceOnboardingBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceOnboardingService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingRequest,
                DeviceOnboardingResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingSomeRequest,
                DeviceOnboardingSomeResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingStreamRequest,
                DeviceOnboardingStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingStreamRequest,
                DeviceOnboardingStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingBatchedStreamRequest,
                DeviceOnboardingBatchedStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingBatchedStreamRequest,
                DeviceOnboardingBatchedStreamResponse,
            ),
        }


class DeviceOnboardingConfigServiceBase(ServiceBase):

    async def get_one(
        self, device_onboarding_config_request: "DeviceOnboardingConfigRequest"
    ) -> "DeviceOnboardingConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_onboarding_config_some_request: "DeviceOnboardingConfigSomeRequest"
    ) -> AsyncIterator["DeviceOnboardingConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self,
        device_onboarding_config_stream_request: "DeviceOnboardingConfigStreamRequest",
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, device_onboarding_config_set_request: "DeviceOnboardingConfigSetRequest"
    ) -> "DeviceOnboardingConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self,
        device_onboarding_config_set_some_request: "DeviceOnboardingConfigSetSomeRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        device_onboarding_config_delete_request: "DeviceOnboardingConfigDeleteRequest",
    ) -> "DeviceOnboardingConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        device_onboarding_config_delete_some_request: "DeviceOnboardingConfigDeleteSomeRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_onboarding_config_delete_all_request: "DeviceOnboardingConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        device_onboarding_config_batched_stream_request: "DeviceOnboardingConfigBatchedStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        device_onboarding_config_batched_stream_request: "DeviceOnboardingConfigBatchedStreamRequest",
    ) -> AsyncIterator["DeviceOnboardingConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigRequest, DeviceOnboardingConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigSomeRequest, DeviceOnboardingConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigStreamRequest, DeviceOnboardingConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigStreamRequest, DeviceOnboardingConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigSetRequest, DeviceOnboardingConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigSetSomeRequest, DeviceOnboardingConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigDeleteRequest, DeviceOnboardingConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigDeleteSomeRequest, DeviceOnboardingConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigDeleteAllRequest, DeviceOnboardingConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigBatchedStreamRequest, DeviceOnboardingConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceOnboardingConfigBatchedStreamRequest, DeviceOnboardingConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigRequest,
                DeviceOnboardingConfigResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigSomeRequest,
                DeviceOnboardingConfigSomeResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigStreamRequest,
                DeviceOnboardingConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigStreamRequest,
                DeviceOnboardingConfigStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigSetRequest,
                DeviceOnboardingConfigSetResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigSetSomeRequest,
                DeviceOnboardingConfigSetSomeResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceOnboardingConfigDeleteRequest,
                DeviceOnboardingConfigDeleteResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigDeleteSomeRequest,
                DeviceOnboardingConfigDeleteSomeResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigDeleteAllRequest,
                DeviceOnboardingConfigDeleteAllResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigBatchedStreamRequest,
                DeviceOnboardingConfigBatchedStreamResponse,
            ),
            "/arista.inventory.v1.DeviceOnboardingConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceOnboardingConfigBatchedStreamRequest,
                DeviceOnboardingConfigBatchedStreamResponse,
            ),
        }


class ProvisionedDeviceServiceBase(ServiceBase):

    async def get_one(
        self, provisioned_device_request: "ProvisionedDeviceRequest"
    ) -> "ProvisionedDeviceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, provisioned_device_some_request: "ProvisionedDeviceSomeRequest"
    ) -> AsyncIterator["ProvisionedDeviceSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, provisioned_device_stream_request: "ProvisionedDeviceStreamRequest"
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, provisioned_device_stream_request: "ProvisionedDeviceStreamRequest"
    ) -> AsyncIterator["ProvisionedDeviceStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, provisioned_device_stream_request: "ProvisionedDeviceStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, provisioned_device_stream_request: "ProvisionedDeviceStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        provisioned_device_batched_stream_request: "ProvisionedDeviceBatchedStreamRequest",
    ) -> AsyncIterator["ProvisionedDeviceBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        provisioned_device_batched_stream_request: "ProvisionedDeviceBatchedStreamRequest",
    ) -> AsyncIterator["ProvisionedDeviceBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceRequest, ProvisionedDeviceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceSomeRequest, ProvisionedDeviceSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceStreamRequest, ProvisionedDeviceStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceStreamRequest, ProvisionedDeviceStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceBatchedStreamRequest, ProvisionedDeviceBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[ProvisionedDeviceBatchedStreamRequest, ProvisionedDeviceBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.inventory.v1.ProvisionedDeviceService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                ProvisionedDeviceRequest,
                ProvisionedDeviceResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceSomeRequest,
                ProvisionedDeviceSomeResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceStreamRequest,
                ProvisionedDeviceStreamResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceStreamRequest,
                ProvisionedDeviceStreamResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                ProvisionedDeviceStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceStreamRequest,
                MetaResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceBatchedStreamRequest,
                ProvisionedDeviceBatchedStreamResponse,
            ),
            "/arista.inventory.v1.ProvisionedDeviceService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                ProvisionedDeviceBatchedStreamRequest,
                ProvisionedDeviceBatchedStreamResponse,
            ),
        }
