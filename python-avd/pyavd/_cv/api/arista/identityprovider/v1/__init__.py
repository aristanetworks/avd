# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/identityprovider.v1/identityprovider.proto, arista/identityprovider.v1/services.gen.proto
# plugin: python-aristaproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import aristaproto
import grpclib
from aristaproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ProtocolBinding(aristaproto.Enum):
    """ProtocolBinding indicates SAML protocol binding to be used."""

    UNSPECIFIED = 0
    """
    PROTOCOL_BINDING_UNSPECIFIED indicates that a protocol binding is unspecified.
    """

    HTTP_POST = 1
    """
    PROTOCOL_BINDING_HTTP_POST indicates HTTP-POST SAML protocol binding.
    """

    HTTP_REDIRECT = 2
    """
    PROTOCOL_BINDING_HTTP_REDIRECT indicates HTTP-Redirect SAML protocol binding.
    """


@dataclass(eq=False, repr=False)
class OAuthKey(aristaproto.Message):
    """OAuthKey contains OAuth provider ID."""

    provider_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """provider_id is the ID of the OAuth provider."""


@dataclass(eq=False, repr=False)
class OAuthConfig(aristaproto.Message):
    """OAuthConfig holds the configuration for an OAuth provider."""

    key: "OAuthKey" = aristaproto.message_field(1)
    """key is the ID of the OAuth provider."""

    endpoint: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    endpoint is the URL that identifies an OAuth authorization server.
     This endpoint is used to interact with the provider. It must be a
     URI [RFC3986] with a scheme component that must be https, a host component,
     and optionally, port and path components, but no query or fragment components.
    """

    client_id: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    client_id is the ID that the OAuth authorization server issues to the
     registered client.
    """

    client_secret: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """
    client_secret is the secret that the OAuth authorization server issues
     to the registered client.
    """

    algorithms: "___fmp__.RepeatedString" = aristaproto.message_field(5)
    """
    algorithms is the set of signing algorithms. This is an optional field.
     If specified, only this set of algorithms may be used to sign the JWT.
     Otherwise, this defaults to the set of algorithms that the provider supports.
    """

    link_to_shared_provider: Optional[bool] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_BOOL
    )
    """
    link_to_shared_provider indicates whether or not use the provider as a shared
     provider. This is an optional field and set to false by default.
    """

    jwks_uri: Optional[str] = aristaproto.message_field(
        7, wraps=aristaproto.TYPE_STRING
    )
    """
    jwks_uri is where signing keys are downloaded. This is an optional field.
     Only needed if the default construction from endpoint would be incorrect.
    """

    permitted_email_domains: "___fmp__.RepeatedString" = aristaproto.message_field(8)
    """
    permitted_email_domains are domains of emails that users are allowed to use.
     This is an optional field. If not set, all domains are accepted by default.
    """

    roles_scope_name: Optional[str] = aristaproto.message_field(
        9, wraps=aristaproto.TYPE_STRING
    )
    """
    roles_scope_name is the name for a scope tied to a claim that holds
     CloudVision roles in ID Token. CloudVision uses scope values to specify
     what access privileges are being requested for id token. CloudVision
     appends this value to `scope` query parameter in the authorization request URL.
     This is an optional field. If not set, CloudVision determines that
     mapping roles from the provider is disabled. If it's set, roles_claim_name
     also needs to be set.
    """

    bearer_token_introspection_endpoint: Optional[str] = aristaproto.message_field(
        10, wraps=aristaproto.TYPE_STRING
    )
    """
    bearer_token_introspection_endpoint is the provider instrospection endpoint used
     in Bearer Token based login support for CloudVision. This is an optional field.
     If specified, this endpoint will be used to verify bearer tokens generated via
     the provider to log in automated user accounts.
    """

    roles_claim_name: Optional[str] = aristaproto.message_field(
        11, wraps=aristaproto.TYPE_STRING
    )
    """
    roles_claim_name is the name for a claim that holds CloudVision roles in ID Token.
     CloudVision uses this value to look up roles in the ID Token.
     This is an optional field. If not set, CloudVision determines that
     mapping roles from the provider is disabled. If it's set, roles_scope_name
     also needs to be set.
    """


@dataclass(eq=False, repr=False)
class SamlKey(aristaproto.Message):
    """SAMLKey contains SAML Provider ID."""

    provider_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """provider_id is the ID of the SAML provider."""


@dataclass(eq=False, repr=False)
class SamlConfig(aristaproto.Message):
    """SAMLConfig holds the configuration for a SAML provider."""

    key: "SamlKey" = aristaproto.message_field(1)
    """key is the ID of the SAML provider."""

    idp_issuer: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    idp_issuer identifies the SAML provider. There is no restriction on its format
     other than a string to carry the issuer's name.
    """

    idp_metadata_url: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    idp_metadata_url is the URL that CloudVision uses to fetch the
     SAML provider metadata.
    """

    authreq_binding: "ProtocolBinding" = aristaproto.enum_field(4)
    """
    authreq_binding specifies the ProtocolBinding used to send SAML authentication
     request to the SAML provider.
    """

    email_attrname: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    email_attrname specifies the Attribute name for email ID in Assertion of SAMLResponse
     from the SAML provider.
    """

    link_to_shared_provider: Optional[bool] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_BOOL
    )
    """
    link_to_shared_provider indicates whether or not use the provider as a shared
     provider. This is an optional field and set to false by default.
    """

    permitted_email_domains: "___fmp__.RepeatedString" = aristaproto.message_field(7)
    """
    permitted_email_domains are domains of emails that users are allowed to use.
     This is an optional field. If not set, all domains are accepted by default.
    """

    force_saml_authn: Optional[bool] = aristaproto.message_field(
        8, wraps=aristaproto.TYPE_BOOL
    )
    """
    force_saml_authn indicates wether or not enable force authentication in SAML login.
     This is an optional field. If not set, it defaults to false.
    """

    roles_attrname: Optional[str] = aristaproto.message_field(
        9, wraps=aristaproto.TYPE_STRING
    )
    """
    roles_attrname specifies the Attribute name for CloudVision roles in the Assertion
     of SAMLResponse. This is an optional field. If not set, CloudVision determines that
     mapping roles from the provider is disabled.
    """

    org_attrname: Optional[str] = aristaproto.message_field(
        10, wraps=aristaproto.TYPE_STRING
    )
    """
    org_attrname specifies the Attribute name for CloudVision organization/tenant in
     the Assertion of SAMLResponse. This is an optional field. CloudVision supports use
     of certain shared SAML Identity Providers for authenticating users across multiple
     CloudVision organizations/tenants. In case a given organization uses a shared provider,
     then, CloudVision needs this attribute to determine if the organization that
     the shared SAML Identity Provider is sending the assertion for is the same as the
     one the user requested to be logged into. For an existing user on CloudVision,
     the user's email is used to determine which organization the user belongs to do
     the same verification but in case a dynamic user creation is needed and the given
     user doesn't exist on CloudVision currently then the matching organization attribute
     from the shared Identity Privder becomes necessary. Dynamic user creation is
     disabled for a given organization using shared Identity Provider if this attribute
     is not specified.
    """

    username_attrname: Optional[str] = aristaproto.message_field(
        11, wraps=aristaproto.TYPE_STRING
    )
    """
    username_attrname specifies Attribute name for CloudVision users' username in the
     Assertion of SAMLResponse. This is an optional field as long as mapping roles from
     provider is not enabled. Once enabled, this field becomes mandatory.
    """


@dataclass(eq=False, repr=False)
class MetaResponse(aristaproto.Message):
    time: datetime = aristaproto.message_field(1)
    """
    Time holds the timestamp of the last item included in the metadata calculation.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(2)
    """
    Operation indicates how the value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """

    count: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_UINT32)
    """
    Count is the number of items present under the conditions of the request.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigRequest(aristaproto.Message):
    key: "OAuthKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a OAuthConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigResponse(aristaproto.Message):
    value: "OAuthConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     OAuthConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigSomeRequest(aristaproto.Message):
    keys: List["OAuthKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigSomeResponse(aristaproto.Message):
    value: "OAuthConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class OAuthConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["OAuthConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each OAuthConfig at end.
         * Each OAuthConfig response is fully-specified (all fields set).
       * start: Returns the state of each OAuthConfig at start, followed by updates until now.
         * Each OAuthConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each OAuthConfig at start, followed by updates
         until end.
         * Each OAuthConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigStreamResponse(aristaproto.Message):
    value: "OAuthConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this OAuthConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the OAuthConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["OAuthConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each OAuthConfig at end.
         * Each OAuthConfig response is fully-specified (all fields set).
       * start: Returns the state of each OAuthConfig at start, followed by updates until now.
         * Each OAuthConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each OAuthConfig at start, followed by updates
         until end.
         * Each OAuthConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["OAuthConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class OAuthConfigSetRequest(aristaproto.Message):
    value: "OAuthConfig" = aristaproto.message_field(1)
    """
    OAuthConfig carries the value to set into the datastore.
     See the documentation on the OAuthConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigSetResponse(aristaproto.Message):
    value: "OAuthConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the OAuthConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigSetSomeRequest(aristaproto.Message):
    values: List["OAuthConfig"] = aristaproto.message_field(1)
    """
    value contains a list of OAuthConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigSetSomeResponse(aristaproto.Message):
    key: "OAuthKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class OAuthConfigDeleteRequest(aristaproto.Message):
    key: "OAuthKey" = aristaproto.message_field(1)
    """
    Key indicates which OAuthConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigDeleteResponse(aristaproto.Message):
    key: "OAuthKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted OAuthConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["OAuthKey"] = aristaproto.message_field(1)
    """key contains a list of OAuthConfig keys to delete"""


@dataclass(eq=False, repr=False)
class OAuthConfigDeleteSomeResponse(aristaproto.Message):
    """OAuthConfigDeleteSomeResponse is only sent when there is an error."""

    key: "OAuthKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class OAuthConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["OAuthConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class OAuthConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "OAuthKey" = aristaproto.message_field(3)
    """
    This is the key of the OAuthConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class SamlConfigRequest(aristaproto.Message):
    key: "SamlKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a SAMLConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class SamlConfigResponse(aristaproto.Message):
    value: "SamlConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     SAMLConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class SamlConfigSomeRequest(aristaproto.Message):
    keys: List["SamlKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class SamlConfigSomeResponse(aristaproto.Message):
    value: "SamlConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class SamlConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["SamlConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each SAMLConfig at end.
         * Each SAMLConfig response is fully-specified (all fields set).
       * start: Returns the state of each SAMLConfig at start, followed by updates until now.
         * Each SAMLConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each SAMLConfig at start, followed by updates
         until end.
         * Each SAMLConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class SamlConfigStreamResponse(aristaproto.Message):
    value: "SamlConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this SAMLConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the SAMLConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class SamlConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["SamlConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each SAMLConfig at end.
         * Each SAMLConfig response is fully-specified (all fields set).
       * start: Returns the state of each SAMLConfig at start, followed by updates until now.
         * Each SAMLConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each SAMLConfig at start, followed by updates
         until end.
         * Each SAMLConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class SamlConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["SamlConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class SamlConfigSetRequest(aristaproto.Message):
    value: "SamlConfig" = aristaproto.message_field(1)
    """
    SAMLConfig carries the value to set into the datastore.
     See the documentation on the SAMLConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class SamlConfigSetResponse(aristaproto.Message):
    value: "SamlConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the SAMLConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class SamlConfigSetSomeRequest(aristaproto.Message):
    values: List["SamlConfig"] = aristaproto.message_field(1)
    """
    value contains a list of SAMLConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class SamlConfigSetSomeResponse(aristaproto.Message):
    key: "SamlKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class SamlConfigDeleteRequest(aristaproto.Message):
    key: "SamlKey" = aristaproto.message_field(1)
    """
    Key indicates which SAMLConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class SamlConfigDeleteResponse(aristaproto.Message):
    key: "SamlKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted SAMLConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class SamlConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["SamlKey"] = aristaproto.message_field(1)
    """key contains a list of SAMLConfig keys to delete"""


@dataclass(eq=False, repr=False)
class SamlConfigDeleteSomeResponse(aristaproto.Message):
    """SAMLConfigDeleteSomeResponse is only sent when there is an error."""

    key: "SamlKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class SamlConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["SamlConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class SamlConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "SamlKey" = aristaproto.message_field(3)
    """
    This is the key of the SAMLConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class OAuthConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        o_auth_config_request: "OAuthConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OAuthConfigResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.OAuthConfigService/GetOne",
            o_auth_config_request,
            OAuthConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        o_auth_config_some_request: "OAuthConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/GetSome",
            o_auth_config_some_request,
            OAuthConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        o_auth_config_stream_request: "OAuthConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/GetAll",
            o_auth_config_stream_request,
            OAuthConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        o_auth_config_stream_request: "OAuthConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/Subscribe",
            o_auth_config_stream_request,
            OAuthConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        o_auth_config_stream_request: "OAuthConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.OAuthConfigService/GetMeta",
            o_auth_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        o_auth_config_stream_request: "OAuthConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/SubscribeMeta",
            o_auth_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        o_auth_config_set_request: "OAuthConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OAuthConfigSetResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.OAuthConfigService/Set",
            o_auth_config_set_request,
            OAuthConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        o_auth_config_set_some_request: "OAuthConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/SetSome",
            o_auth_config_set_some_request,
            OAuthConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        o_auth_config_delete_request: "OAuthConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "OAuthConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.OAuthConfigService/Delete",
            o_auth_config_delete_request,
            OAuthConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        o_auth_config_delete_some_request: "OAuthConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/DeleteSome",
            o_auth_config_delete_some_request,
            OAuthConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        o_auth_config_delete_all_request: "OAuthConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/DeleteAll",
            o_auth_config_delete_all_request,
            OAuthConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        o_auth_config_batched_stream_request: "OAuthConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/GetAllBatched",
            o_auth_config_batched_stream_request,
            OAuthConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        o_auth_config_batched_stream_request: "OAuthConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["OAuthConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.OAuthConfigService/SubscribeBatched",
            o_auth_config_batched_stream_request,
            OAuthConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class SamlConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        saml_config_request: "SamlConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SamlConfigResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.SAMLConfigService/GetOne",
            saml_config_request,
            SamlConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        saml_config_some_request: "SamlConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/GetSome",
            saml_config_some_request,
            SamlConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        saml_config_stream_request: "SamlConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/GetAll",
            saml_config_stream_request,
            SamlConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        saml_config_stream_request: "SamlConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/Subscribe",
            saml_config_stream_request,
            SamlConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        saml_config_stream_request: "SamlConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.SAMLConfigService/GetMeta",
            saml_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        saml_config_stream_request: "SamlConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/SubscribeMeta",
            saml_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        saml_config_set_request: "SamlConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SamlConfigSetResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.SAMLConfigService/Set",
            saml_config_set_request,
            SamlConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        saml_config_set_some_request: "SamlConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/SetSome",
            saml_config_set_some_request,
            SamlConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        saml_config_delete_request: "SamlConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SamlConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.identityprovider.v1.SAMLConfigService/Delete",
            saml_config_delete_request,
            SamlConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        saml_config_delete_some_request: "SamlConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/DeleteSome",
            saml_config_delete_some_request,
            SamlConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        saml_config_delete_all_request: "SamlConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/DeleteAll",
            saml_config_delete_all_request,
            SamlConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        saml_config_batched_stream_request: "SamlConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/GetAllBatched",
            saml_config_batched_stream_request,
            SamlConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        saml_config_batched_stream_request: "SamlConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["SamlConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.identityprovider.v1.SAMLConfigService/SubscribeBatched",
            saml_config_batched_stream_request,
            SamlConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class OAuthConfigServiceBase(ServiceBase):

    async def get_one(
        self, o_auth_config_request: "OAuthConfigRequest"
    ) -> "OAuthConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, o_auth_config_some_request: "OAuthConfigSomeRequest"
    ) -> AsyncIterator["OAuthConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, o_auth_config_stream_request: "OAuthConfigStreamRequest"
    ) -> AsyncIterator["OAuthConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, o_auth_config_stream_request: "OAuthConfigStreamRequest"
    ) -> AsyncIterator["OAuthConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, o_auth_config_stream_request: "OAuthConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, o_auth_config_stream_request: "OAuthConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, o_auth_config_set_request: "OAuthConfigSetRequest"
    ) -> "OAuthConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, o_auth_config_set_some_request: "OAuthConfigSetSomeRequest"
    ) -> AsyncIterator["OAuthConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, o_auth_config_delete_request: "OAuthConfigDeleteRequest"
    ) -> "OAuthConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, o_auth_config_delete_some_request: "OAuthConfigDeleteSomeRequest"
    ) -> AsyncIterator["OAuthConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, o_auth_config_delete_all_request: "OAuthConfigDeleteAllRequest"
    ) -> AsyncIterator["OAuthConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, o_auth_config_batched_stream_request: "OAuthConfigBatchedStreamRequest"
    ) -> AsyncIterator["OAuthConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, o_auth_config_batched_stream_request: "OAuthConfigBatchedStreamRequest"
    ) -> AsyncIterator["OAuthConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[OAuthConfigRequest, OAuthConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[OAuthConfigSomeRequest, OAuthConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[OAuthConfigStreamRequest, OAuthConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[OAuthConfigStreamRequest, OAuthConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[OAuthConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[OAuthConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[OAuthConfigSetRequest, OAuthConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[OAuthConfigSetSomeRequest, OAuthConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[OAuthConfigDeleteRequest, OAuthConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[OAuthConfigDeleteSomeRequest, OAuthConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[OAuthConfigDeleteAllRequest, OAuthConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[OAuthConfigBatchedStreamRequest, OAuthConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[OAuthConfigBatchedStreamRequest, OAuthConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.identityprovider.v1.OAuthConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                OAuthConfigRequest,
                OAuthConfigResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigSomeRequest,
                OAuthConfigSomeResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigStreamRequest,
                OAuthConfigStreamResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigStreamRequest,
                OAuthConfigStreamResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                OAuthConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                OAuthConfigSetRequest,
                OAuthConfigSetResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigSetSomeRequest,
                OAuthConfigSetSomeResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                OAuthConfigDeleteRequest,
                OAuthConfigDeleteResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigDeleteSomeRequest,
                OAuthConfigDeleteSomeResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigDeleteAllRequest,
                OAuthConfigDeleteAllResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigBatchedStreamRequest,
                OAuthConfigBatchedStreamResponse,
            ),
            "/arista.identityprovider.v1.OAuthConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                OAuthConfigBatchedStreamRequest,
                OAuthConfigBatchedStreamResponse,
            ),
        }


class SamlConfigServiceBase(ServiceBase):

    async def get_one(
        self, saml_config_request: "SamlConfigRequest"
    ) -> "SamlConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, saml_config_some_request: "SamlConfigSomeRequest"
    ) -> AsyncIterator["SamlConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, saml_config_stream_request: "SamlConfigStreamRequest"
    ) -> AsyncIterator["SamlConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, saml_config_stream_request: "SamlConfigStreamRequest"
    ) -> AsyncIterator["SamlConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, saml_config_stream_request: "SamlConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, saml_config_stream_request: "SamlConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, saml_config_set_request: "SamlConfigSetRequest"
    ) -> "SamlConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, saml_config_set_some_request: "SamlConfigSetSomeRequest"
    ) -> AsyncIterator["SamlConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, saml_config_delete_request: "SamlConfigDeleteRequest"
    ) -> "SamlConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, saml_config_delete_some_request: "SamlConfigDeleteSomeRequest"
    ) -> AsyncIterator["SamlConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, saml_config_delete_all_request: "SamlConfigDeleteAllRequest"
    ) -> AsyncIterator["SamlConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, saml_config_batched_stream_request: "SamlConfigBatchedStreamRequest"
    ) -> AsyncIterator["SamlConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, saml_config_batched_stream_request: "SamlConfigBatchedStreamRequest"
    ) -> AsyncIterator["SamlConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[SamlConfigRequest, SamlConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[SamlConfigSomeRequest, SamlConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[SamlConfigStreamRequest, SamlConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[SamlConfigStreamRequest, SamlConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[SamlConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[SamlConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[SamlConfigSetRequest, SamlConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[SamlConfigSetSomeRequest, SamlConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[SamlConfigDeleteRequest, SamlConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[SamlConfigDeleteSomeRequest, SamlConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[SamlConfigDeleteAllRequest, SamlConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[SamlConfigBatchedStreamRequest, SamlConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[SamlConfigBatchedStreamRequest, SamlConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.identityprovider.v1.SAMLConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                SamlConfigRequest,
                SamlConfigResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigSomeRequest,
                SamlConfigSomeResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigStreamRequest,
                SamlConfigStreamResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigStreamRequest,
                SamlConfigStreamResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                SamlConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                SamlConfigSetRequest,
                SamlConfigSetResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigSetSomeRequest,
                SamlConfigSetSomeResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                SamlConfigDeleteRequest,
                SamlConfigDeleteResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigDeleteSomeRequest,
                SamlConfigDeleteSomeResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigDeleteAllRequest,
                SamlConfigDeleteAllResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigBatchedStreamRequest,
                SamlConfigBatchedStreamResponse,
            ),
            "/arista.identityprovider.v1.SAMLConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                SamlConfigBatchedStreamRequest,
                SamlConfigBatchedStreamResponse,
            ),
        }
