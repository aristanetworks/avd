# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/alert.v1/alert.proto, arista/alert.v1/services.gen.proto
# plugin: python-aristaproto
# This file has been @generated

from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import aristaproto
import grpclib
from aristaproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ConfigErrorType(aristaproto.Enum):
    """ConfigErrorType describes the set of possible config error types"""

    UNSPECIFIED = 0
    """CONFIG_ERROR_TYPE_UNSPECIFIED is the unspecified enum value"""

    INVALID_FORMAT = 2
    """
    CONFIG_ERROR_TYPE_INVALID_FORMAT is caused by invalid format for value (eg: url)
    """

    INVALID_SYNTAX = 3
    """
    CONFIG_ERROR_TYPE_INVALID_SYNTAX is caused by invalid syntax for value (eg: regex)
    """

    TEMPLATE_INVALID = 4
    """
    CONFIG_ERROR_TYPE_TEMPLATE_INVALID is caused by failure to parse a template
    """

    ILLEGAL_VALUE = 5
    """
    CONFIG_ERROR_TYPE_ILLEGAL_VALUE is caused by a value outside of its bounds
    """

    MISSING_REQUIRED = 6
    """
    CONFIG_ERROR_TYPE_MISSING_REQUIRED is caused by a missing required attribute
    """

    INVALID_TYPE = 7
    """
    CONFIG_ERROR_TYPE_INVALID_TYPE is caused by the wrong type found in backing store
    """


class EndpointErrorType(aristaproto.Enum):
    """EndpointErrorType describe the set of possible endpoint types"""

    UNSPECIFIED = 0
    """ENDPOINT_ERROR_TYPE_UNSPECIFIED is the unspecified enum value"""

    HTTP_POST_ERROR = 1
    """
    ENDPOINT_ERROR_TYPE_HTTP_POST_ERROR an error in sending HTTP request or reading a HTTP
     response
    """

    JSON_MARSHAL_ERROR = 2
    """
    ENDPOINT_ERROR_TYPE_JSON_MARSHAL_ERROR is caused by errors while encoding json
    """

    INVALID_CONFIG_ERROR = 3
    """
    ENDPOINT_ERROR_TYPE_INVALID_CONFIG_ERROR is an error caused by invalid config (missing,
     bad format, etc)
    """

    TEMPLATE_ERROR = 4
    """
    ENDPOINT_ERROR_TYPE_TEMPLATE_ERROR is caused by errors while executing templates
    """

    BAD_RESPONSE_ERROR = 5
    """
    ENDPOINT_ERROR_TYPE_BAD_RESPONSE_ERROR is caused by receiving a negative response from an
     endpoint indicating that the alert was not sent
    """

    SMTP_ERROR = 6
    """ENDPOINT_ERROR_TYPE_SMTP_ERROR is caused by errors with SMTP"""

    CONNECTION_ERROR = 7
    """
    ENDPOINT_ERROR_TYPE_CONNECTION_ERROR is caused by errors with a connection
    """

    TIMEOUT_ERROR = 8
    """
    ENDPOINT_ERROR_TYPE_TIMEOUT_ERROR is caused by errors with a connection
    """

    RATE_LIMIT_ERROR = 9
    """
    ENDPOINT_ERROR_TYPE_RATE_LIMIT_ERROR is caused by an Alerter rate limit being exceeded
    """

    ALERT_CAP_ERROR = 10
    """
    ENDPOINT_ERROR_TYPE_ALERT_CAP_ERROR is caused by the number of alerts sent to a sender
     exceeding the built-in limit
    """

    O_AUTH_ERROR = 11
    """
    ENDPOINT_ERROR_TYPE_O_AUTH_ERROR is caused when we failed authenticating using the
     OAuth apis
    """


class CueSyslogMessageFormat(aristaproto.Enum):
    """CueSyslogMessageFormat is the message format for cue syslog messages"""

    UNSPECIFIED = 0
    """CUE_SYSLOG_MESSAGE_FORMAT_UNSPECIFIED is the unspecified enum value"""

    PLAIN = 1
    """
    CUE_SYSLOG_MESSAGE_FORMAT_PLAIN format uses the text format for constructing the syslog message
    """

    IDMEF = 2
    """
    CUE_SYSLOG_MESSAGE_FORMAT_IDMEF uses IDMEF message format as described here:
     https://datatracker.ietf.org/doc/html/rfc4765
    """


class SnmpSecurityLevel(aristaproto.Enum):
    """SNMPSecurityLevel indicates what level of security should be used"""

    UNSPECIFIED = 0
    """SNMP_SECURITY_LEVEL_UNSPECIFIED is the unspecified enum value"""

    NO_AUTH_NO_PRIV = 1
    """SNMP_SECURITY_LEVEL_NO_AUTH_NO_PRIV use no security"""

    AUTH_NO_PRIV = 2
    """SNMP_SECURITY_LEVEL_AUTH_NO_PRIV use authentication without privacy"""

    AUTH_PRIV = 3
    """SNMP_SECURITY_LEVEL_AUTH_PRIV use both authentication and privacy"""


class SnmpAuthProtocol(aristaproto.Enum):
    """SNMPAuthProtocol represents the authentication protocol to be used"""

    UNSPECIFIED = 0
    """SNMP_AUTH_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    MD5 = 1
    """SNMP_AUTH_PROTOCOL_MD5 use the md5 protocol"""

    SHA = 2
    """SNMP_AUTH_PROTOCOL_SHA use the sha protocol"""

    SHA_224 = 3
    """SNMP_AUTH_PROTOCOL_SHA_224 use the sha224 protocol"""

    SHA_256 = 4
    """SNMP_AUTH_PROTOCOL_SHA_256 use the sha256 protocol"""

    SHA_384 = 5
    """SNMP_AUTH_PROTOCOL_SHA_384 use the sha384 protocol"""

    SHA_512 = 6
    """SNMP_AUTH_PROTOCOL_SHA_512 use the sha512 protocol"""


class SnmpPrivProtocol(aristaproto.Enum):
    """SNMPPrivProtocol represents the privacy protocol to be used"""

    UNSPECIFIED = 0
    """SNMP_PRIV_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    DES = 1
    """SNMP_PRIV_PROTOCOL_DES use the des protocol"""

    AES = 2
    """SNMP_PRIV_PROTOCOL_AES use the aes protocol"""

    AES_192 = 3
    """SNMP_PRIV_PROTOCOL_AES_192 use the aes192 protocol"""

    AES_256 = 4
    """SNMP_PRIV_PROTOCOL_AES_256 use the aes256 protocol"""

    AES_192C = 5
    """SNMP_PRIV_PROTOCOL_AES_192C use the aes192c protocol"""

    AES_256C = 6
    """SNMP_PRIV_PROTOCOL_AES_256C use the aes256c protocol"""


class CueSnmpAuthProtocol(aristaproto.Enum):
    """
    CueSNMPAuthProtocol represents the authentication protocol to be used
    """

    UNSPECIFIED = 0
    """CUE_SNMP_AUTH_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    MD5 = 1
    """CUE_SNMP_AUTH_PROTOCOL_MD5 use the md5 protocol"""

    SHA = 2
    """CUE_SNMP_AUTH_PROTOCOL_SHA use the sha protocol"""


class CueSnmpPrivProtocol(aristaproto.Enum):
    """CueSNMPPrivProtocol represents the privacy protocol to be used"""

    UNSPECIFIED = 0
    """CUE_SNMP_PRIV_PROTOCOL_UNSPECIFIED is the unspecified enum value"""

    DES = 1
    """CUE_SNMP_PRIV_PROTOCOL_DES use the des protocol"""

    AES = 2
    """CUE_SNMP_PRIV_PROTOCOL_AES use the aes protocol"""


class TemplateType(aristaproto.Enum):
    """TemplateType describes the types of Templates that are usable"""

    UNSPECIFIED = 0
    """TEMPLATE_TYPE_UNSPECIFIED is the unspecified enum value"""

    EMAIL_HTML = 1
    """
    TEMPLATE_TYPE_EMAIL_HTML is the key of the html template for sent emails
    """

    EMAIL_TEXT = 2
    """
    TEMPLATE_TYPE_EMAIL_TEXT is the key of the text template for sent emails
    """

    SLACK_MESSAGE = 3
    """
    TEMPLATE_TYPE_SLACK_MESSAGE is the key of the message template for sent slack messages
    """

    PUSHOVER_MESSAGE = 4
    """
    TEMPLATE_TYPE_PUSHOVER_MESSAGE is the key of the message template for sent pushover messages
    """

    PAGERDUTY_SUMMARY = 5
    """
    TEMPLATE_TYPE_PAGERDUTY_SUMMARY is the key of the summary template for sent pagerduty messages
    """

    VICTOROPS_DISPLAY_NAME = 6
    """
    TEMPLATE_TYPE_VICTOROPS_DISPLAY_NAME is the key of the display name template for sent victorops
     messages
    """

    VICTOROPS_STATE_MESSAGE = 7
    """
    TEMPLATE_TYPE_VICTOROPS_STATE_MESSAGE is the key of the state message template for sent
     victorops messages
    """

    GOOGLE_CHAT_MESSAGE = 8
    """
    TEMPLATE_TYPE_GOOGLE_CHAT_MESSAGE is the key of the message template for sent Google chat
     messages
    """

    MICROSOFT_TEAMS_MESSAGE = 9
    """
    TEMPLATE_TYPE_MICROSOFT_TEAMS_MESSAGE is the key of the message template for sent Microsoft
     teams messages
    """

    EMAIL_SUBJECT = 10
    """
    TEMPLATE_TYPE_EMAIL_SUBJECT is the key of the subject line template of a sent email
    """

    SYSLOG_MESSAGE = 11
    """
    TEMPLATE_TYPE_SYSLOG_MESSAGE is the key of the message template for a syslog message part
    """

    OPSGENIE_MESSAGE = 12
    """
    TEMPLATE_TYPE_OPSGENIE_MESSAGE is the key of the message template for a opsgenie alert
    """

    ZOOM_MESSAGE = 13
    """
    TEMPLATE_TYPE_ZOOM_MESSAGE is the key of the message template for sent Zoom messages
    """

    EMAIL_SINGLE_HTML = 14
    """
    TEMPLATE_TYPE_EMAIL_SINGLE_HTML is the key of the html template for sent emails when the
     single alert per email option is selected
    """

    EMAIL_SINGLE_TEXT = 15
    """
    TEMPLATE_TYPE_EMAIL_SINGLE_TEXT is the key of the text template for sent emails when the
     single alert per email option is selected
    """

    EMAIL_SINGLE_SUBJECT = 16
    """
    TEMPLATE_TYPE_EMAIL_SINGLE_SUBJECT is the key of the subject line template of a sent email
     when the single alert per email option is selected
    """

    WEBHOOK_SINGLE = 17
    """
    TEMPLATE_TYPE_WEBHOOK_SINGLE is the key of the template for webhook message body when the
     single_alert option is true
    """

    WEBHOOK_MULTIPLE = 18
    """
    TEMPLATE_TYPE_WEBHOOK_MULTIPLE is the key of the template for webhook message body when the
     single_alert option is false
    """


class TemplateOutput(aristaproto.Enum):
    """
    TemplateOutput is an enum of all of the possible output formats for templates
    """

    UNSPECIFIED = 0
    """TEMPLATE_OUTPUT_UNSPECIFIED is the unspecfied value."""

    TEXT = 1
    """TEMPLATE_OUTPUT_TEXT indicates the the template outputs plain text."""

    JSON = 2
    """TEMPLATE_OUTPUT_JSON indicates the the template outputs JSON."""

    HTML = 3
    """
    TEMPLATE_OUTPUT_HTML indicates the the template outputs HTML.
     This also indicates that "html/templates" will be used instead of "text/templates" so that
     html characters are automatically escaped from input.
    """


@dataclass(eq=False, repr=False)
class AlertConfig(aristaproto.Message):
    """AlertConfig is the configuration for sending alerts"""

    settings: "Settings" = aristaproto.message_field(1)
    """
    settings is the global default settings for various endpoints used in broadcast groups.
     Can be overwritten in individual endpoint settings
    """

    rules: "Rules" = aristaproto.message_field(2)
    """rules define how we route alerts to broadcast groups"""

    broadcast_groups: "BroadcastGroups" = aristaproto.message_field(3)
    """broadcast_groups are groups of endpoints that alerts are sent to"""


@dataclass(eq=False, repr=False)
class Alert(aristaproto.Message):
    """Alert is the current status of the alert system"""

    configuration_errors: "ConfigErrors" = aristaproto.message_field(1)
    """
    configuration_errors contain any configuration errors reported by the backend
    """

    endpoint_errors: "EndpointErrors" = aristaproto.message_field(2)
    """endpoint_errors contain any failed attempts to send alerts"""

    last_modified_at: datetime = aristaproto.message_field(3)
    """
    last_modified_at is the time at which the configuration was last modified
    """

    last_modified_by: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """last_modified_by is the user who last modified the configuration"""


@dataclass(eq=False, repr=False)
class ConfigErrors(aristaproto.Message):
    """ConfigErrors is a list of configuration-related errors"""

    values: List["ConfigError"] = aristaproto.message_field(1)
    """values is a list of errors"""


@dataclass(eq=False, repr=False)
class ConfigError(aristaproto.Message):
    """
    ConfigError is an error caused by an invalid config being rejected by the backend
    """

    path: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """
    path is the 'path' to the invalid config element,
     eg: path.userPathName.email_configs[1].to =
     the 'to' field of the second email config of the 'userPathName' broadcast_group
    """

    error_type: "ConfigErrorType" = aristaproto.enum_field(2)
    """
    error_type is the type of error, this allows custom handling of different error types
    """

    error: Optional[str] = aristaproto.message_field(3, wraps=aristaproto.TYPE_STRING)
    """error is a user-friendly error message"""


@dataclass(eq=False, repr=False)
class EndpointErrors(aristaproto.Message):
    """EndpointErrors is a set of errors related to sending of alerts"""

    values: List["EndpointError"] = aristaproto.message_field(1)
    """values is the list of errors"""


@dataclass(eq=False, repr=False)
class EndpointError(aristaproto.Message):
    """
    EndpointError is an error caused by a failure to send alert(s) for any reason
    """

    endpoint_type: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """
    endpoint_type indicates the type of endpoint which failed,
     or unknown if not endpoint-specific (eg: slack, opsgenie)
    """

    broadcast_group_name: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    broadcast_group_name is the name of the broadcast group which was being used,
     empty string if not group specific
    """

    config_index: Optional[int] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_INT32
    )
    """
    config_index is the index of the config on the broadcast group or -1 if not applicable
     eg: if there are two email config in one broadcast group, then the indices for each are 0 and 1
     note that these are done per type, so only counting email/slack/...
    """

    error_type: "EndpointErrorType" = aristaproto.enum_field(4)
    """
    error_type is the type of error, this allows custom handling of different error types
    """

    error: Optional[str] = aristaproto.message_field(5, wraps=aristaproto.TYPE_STRING)
    """error is a user-friendly error message"""


@dataclass(eq=False, repr=False)
class Settings(aristaproto.Message):
    """
    Settings portion of config, a list of default global settings used by broadcast groups
    """

    email: "EmailSettings" = aristaproto.message_field(1)
    """email is the global default settings for email"""

    http: "HttpSettings" = aristaproto.message_field(2)
    """http is the global default settings for http"""

    slack: "SlackSettings" = aristaproto.message_field(3)
    """slack is the global default settings for slack"""

    victorops: "VictoropsSettings" = aristaproto.message_field(4)
    """victorops is the global default settings for victorops"""

    pagerduty: "PagerdutySettings" = aristaproto.message_field(5)
    """pagerduty is the global default settings for pagerduty"""

    opsgenie: "OpsgenieSettings" = aristaproto.message_field(6)
    """opsgenie is the global default settings for opsgenie"""

    gchat: "GoogleChatSettings" = aristaproto.message_field(7)
    """gchat is the global default settings for google chat"""

    msteams: "MsTeamsSettings" = aristaproto.message_field(8)
    """msteams is the global default settings for ms teams"""

    inhibition: "InhibitionSettings" = aristaproto.message_field(9)
    """
    inhibition defines the inhibition rules for alerts, allowing events of certain types to be
     suppressed while another event type is active
    """

    base_url: Optional[str] = aristaproto.message_field(
        10, wraps=aristaproto.TYPE_STRING
    )
    """
    base_url is the root address of your CloudVision app. Used to generate links in notifications.
    """

    timezone: Optional[str] = aristaproto.message_field(
        11, wraps=aristaproto.TYPE_STRING
    )
    """
    timezone is used for formatting event times in notifications. E.g. 'UTC', 'US/Pacific'
    """

    syslog: "SyslogSettings" = aristaproto.message_field(12)
    """syslog is the global default settings for syslog"""

    snmp: "SnmpSettings" = aristaproto.message_field(13)
    """snmp is the global default settings for snmp"""

    sendgrid: "SendgridSettings" = aristaproto.message_field(14)
    """sendgrid is the global default settings for sendgrid"""

    cue_syslog: "CueSyslogSettings" = aristaproto.message_field(15)
    """cue_syslog is the global default settings for cue syslog"""

    cue_snmp: "CueSnmpSettings" = aristaproto.message_field(16)
    """cue_snmp is the global default settings for cue snmp"""

    cue_sendgrid: "CueSendgridSettings" = aristaproto.message_field(17)
    """cue_sendgrid is the global default settings for cue sendgrid"""

    hide_tags: Optional[bool] = aristaproto.message_field(
        18, wraps=aristaproto.TYPE_BOOL
    )
    """
    hide_tags is used to by the alerting system to omit tags and other "superfluous"
     values from the notifications that are sent out by the system
    """

    zoom: "ZoomSettings" = aristaproto.message_field(19)
    """zoom is the global default settings for zoom"""

    webhook: "WebhookSettings" = aristaproto.message_field(20)
    """webhook is the auth settings for webhook"""


@dataclass(eq=False, repr=False)
class EmailSettings(aristaproto.Message):
    """EmailSettings contain the settings for the sending of emails"""

    from_: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """from is the email address to send from"""

    smarthost: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """smarthost is the hostname and port of the SMTP server"""

    auth_username: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    auth_username the username to use when sending emails
     required for all auth methods
    """

    auth_password: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """auth_password the password to use when sending emails"""

    require_tls: Optional[bool] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_BOOL
    )
    """require_tls always use TLS connections when sending emails"""

    single_alert_per_email: Optional[bool] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_BOOL
    )
    """
    single_alert_per_email configures the Alerter such that each alert generates a separate email
     notification, the email will only have a single notification, the format will also be different
    """

    azure_o_auth: "AzureOAuth" = aristaproto.message_field(7)
    """
    azure_o_auth used for auth when using an Azure smtp server
     uses auth_username, scopes is not required as we use https://outlook.office365.com/.default
    """


@dataclass(eq=False, repr=False)
class AzureOAuth(aristaproto.Message):
    """
    AzureOAuth contains the settings for the sending of emails on Azure smtp server
    """

    client_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """client_id of the Azure environment"""

    tenant_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """tenant_id of the Azure environment"""

    client_secret: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """client_secret is a user generated secret key used for auth"""

    auth_uri: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """
    auth_uri is the URI used for OAuth
     this should always be https://login.microsoftonline.com/ unless using a very custom
     set up, where the Azure enviroment is not running on microsoft servers
    """

    scopes: "___fmp__.RepeatedString" = aristaproto.message_field(5)
    """scopes are the scopes that auth is granted for"""


@dataclass(eq=False, repr=False)
class HttpSettings(aristaproto.Message):
    """
    HttpSettings are the settings to be used when sending various message over a http connection
    """

    username: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """username is the username to use when connecting to the http proxy"""

    password: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """password is the password to use when connecting to the http proxy"""

    proxy_url: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """proxy_url is the url for the http proxy"""

    custom_headers: "HttpHeaders" = aristaproto.message_field(4)
    """
    custom_headers is custom http headers to be used along with the default headers
    """


@dataclass(eq=False, repr=False)
class HttpHeaders(aristaproto.Message):
    """HttpHeaders is a set of http headers"""

    values: Dict[str, "HeaderValues"] = aristaproto.map_field(
        1, aristaproto.TYPE_STRING, aristaproto.TYPE_MESSAGE
    )
    """values is a map of http header names to values"""


@dataclass(eq=False, repr=False)
class HeaderValues(aristaproto.Message):
    """HeaderValues is a set of values for this header"""

    values: List[str] = aristaproto.string_field(1)
    """values is the header values"""


@dataclass(eq=False, repr=False)
class SlackSettings(aristaproto.Message):
    """SlackSettings contain the settings for sending alerts to slack"""

    url: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """url is the url of the slack webhook to use"""


@dataclass(eq=False, repr=False)
class VictoropsSettings(aristaproto.Message):
    """
    VictoropsSettings contain the settings for sending alerts to victorops
    """

    key: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """key is the API key to use when talking to the VictorOps API"""

    url: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    url is the victorops url to use (without integration or routing key
     default: https://alert.victorops.com/integrations/generic/20131114/alert/
    """


@dataclass(eq=False, repr=False)
class PagerdutySettings(aristaproto.Message):
    """
    PagerdutySettings contain the settings for sending alerts to pagerduty
    """

    url: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """url is the url to use when sending alerts to pagerduty"""


@dataclass(eq=False, repr=False)
class OpsgenieSettings(aristaproto.Message):
    """OpsgenieSettings contain the settings for sending alerts to opsgenie"""

    key: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """key is the API key to use when talking to the OpsGenie API"""

    url: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """url is the url to use when sending alerts to opsgenie"""


@dataclass(eq=False, repr=False)
class GoogleChatSettings(aristaproto.Message):
    """
    GoogleChatSettings contain the settings for sending alerts to google chat
    """

    url: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """url is the url of the webhook to send alerts to"""


@dataclass(eq=False, repr=False)
class MsTeamsSettings(aristaproto.Message):
    """MsTeamsSettings contain the settings for sending alerts to MS Teams"""

    url: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """url is the url of the webhook to send alerts to"""


@dataclass(eq=False, repr=False)
class WebhookSettings(aristaproto.Message):
    """WebhookSettings contain the settings for sending alerts to a Webhook"""

    azure_o_auth: "AzureOAuth" = aristaproto.message_field(1)
    """
    azure_o_auth used for auth when using an Azure smtp server
     uses auth_username
    """


@dataclass(eq=False, repr=False)
class SyslogSettings(aristaproto.Message):
    """SyslogSettings contain the settings for sending alerts with syslog"""

    network: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """
    network is the network protocol to use, default is "udp",
     options also include: tcp,tcp4,tcp6,udp4,udp6
    """

    address: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """address is the network address to send syslog messages to"""

    facility: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_INT32)
    """
    facility is the syslog facility 0-23 inc. This is the syslog facility as defined in RFC-3164
    """

    priorities: "Priorities" = aristaproto.message_field(4)
    """
    priorities describes how CVP severity maps to syslog priority
     priority is a number between 0-7 inc. as defined in RFC-3164
    """

    tag: Optional[str] = aristaproto.message_field(5, wraps=aristaproto.TYPE_STRING)
    """
    tag is the syslog TAG as described in RFC-3164, it is the prefix to all syslog messages
    """

    per_device: Optional[bool] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_BOOL
    )
    """
    per_device allows message to optionally be sent per device,
     if an event concerns two devices the behaviour is changed based on this option:
       true: two messages are sent, one for each device
       false: a single message is sent
    """

    use_tls: Optional[bool] = aristaproto.message_field(7, wraps=aristaproto.TYPE_BOOL)
    """
    use_tls determines if the connection to the server should be secured with TLS
    """


@dataclass(eq=False, repr=False)
class Priorities(aristaproto.Message):
    """Priorities is a mapping of CV event severities to syslog severities"""

    critical: Optional[int] = aristaproto.message_field(1, wraps=aristaproto.TYPE_INT32)
    """critical priority, default = 2 (Critical)"""

    error: Optional[int] = aristaproto.message_field(2, wraps=aristaproto.TYPE_INT32)
    """error priority, default = 3 (Error)"""

    warn: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_INT32)
    """warn priority, default = 4 (Warning)"""

    info: Optional[int] = aristaproto.message_field(4, wraps=aristaproto.TYPE_INT32)
    """info priority, default = 6 (Informational)"""


@dataclass(eq=False, repr=False)
class CueData(aristaproto.Message):
    """CueData contains additional cue-specific data"""

    values: Dict[str, str] = aristaproto.map_field(
        1, aristaproto.TYPE_STRING, aristaproto.TYPE_STRING
    )
    """
    values can contain some additional data which is required by the cue specific provider
    """


@dataclass(eq=False, repr=False)
class CueSyslogSettings(aristaproto.Message):
    """
    CueSyslogSettings contain the settings for sending alerts with syslog for cue
    """

    network: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """
    network is the network protocol to use, default is "udp",
     options also include: tcp,tcp4,tcp6,udp4,udp6
    """

    address: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """address is the ip address to send syslog messages to"""

    port: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_INT32)
    """port is server's port to connect to"""

    message_format: "CueSyslogMessageFormat" = aristaproto.enum_field(4)
    """message_format defines the message format to use"""

    append_bom_header: Optional[bool] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_BOOL
    )
    """
    append_bom_header if true a BOM( Byte Order Mark ) will be appended to the outgoing message
     BOM will tell the server that is receiving the messages, that the format is UTF8.
    """

    data: "CueData" = aristaproto.message_field(6)
    """
    data is additional data that maybe required for constructing the message or sending it
    """


@dataclass(eq=False, repr=False)
class SnmpSettings(aristaproto.Message):
    """SNMPSettings contain the settings for sending alerts with SNMP"""

    target: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """target is an ipv4 address to send messages to"""

    port: Optional[int] = aristaproto.message_field(2, wraps=aristaproto.TYPE_INT32)
    """port is the network port to target"""

    transport: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    transport is the transport protocol to use ("udp" or "tcp"); if unset "udp" will be used
    """

    version: Optional[int] = aristaproto.message_field(4, wraps=aristaproto.TYPE_INT32)
    """
    version is the SNMP version, v1, v2c and v3 are supported and can be set
     with 1, 2 and 3 respectively
    """

    auth: "SnmpAuth" = aristaproto.message_field(5)
    """auth is optional authentication settings"""

    engine_id: Optional[str] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_STRING
    )
    """
    engine_id is the engine ID that will be used by the Alerter
     This should be a hexadecimal string, colon separators between bytes will be accepted when
     writing, but will be absent when reading
     optional: if excluded or left blank, this will be automatically generated
    """


@dataclass(eq=False, repr=False)
class SnmpAuth(aristaproto.Message):
    """SNMPAuth contain authentication information for SNMP"""

    community: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """
    community is the community string used for authentication in SNMPv1 and v2c
     required if version < 3
    """

    username: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """username the username for SNMPv3 auth"""

    security_level: "SnmpSecurityLevel" = aristaproto.enum_field(3)
    """security_level the security level for SNMPv3"""

    authentication_protocol: "SnmpAuthProtocol" = aristaproto.enum_field(4)
    """
    authentication_protocol is the protocol to use for authentication in SNMPv3
     required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    authentication_passphrase: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    authentication_passphrase is the passphrase to use for authentication in SNMPv3
     required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    privacy_protocol: "SnmpPrivProtocol" = aristaproto.enum_field(6)
    """
    privacy_protocol is the protocol to use for privacy in SNMPv3
     required for AUTH_PRIV security level
    """

    privacy_passphrase: Optional[str] = aristaproto.message_field(
        7, wraps=aristaproto.TYPE_STRING
    )
    """
    privacy_passphrase is the passphrase to use for privacy in SNMPv3
     required for AUTH_PRIV security level
    """


@dataclass(eq=False, repr=False)
class CueSnmpAuth(aristaproto.Message):
    """CueSNMPAuth is the authentication"""

    community: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """
    community is the community string used for authentication in SNMPv1 and v2c
     required if version < 3
    """

    username: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """username the username for SNMPv3 auth"""

    security_level: "SnmpSecurityLevel" = aristaproto.enum_field(3)
    """security_level the security level for SNMPv3"""

    authentication_protocol: "CueSnmpAuthProtocol" = aristaproto.enum_field(4)
    """
    authentication_protocol is the protocol to use for authentication in SNMPv3
     required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    authentication_passphrase: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    authentication_passphrase is the passphrase to use for authentication in SNMPv3
     required for AUTH_NO_PRIV/AUTH_PRIV security levels
    """

    privacy_protocol: "CueSnmpPrivProtocol" = aristaproto.enum_field(6)
    """
    privacy_protocol is the protocol to use for privacy in SNMPv3
     required for AUTH_PRIV security level
    """

    privacy_passphrase: Optional[str] = aristaproto.message_field(
        7, wraps=aristaproto.TYPE_STRING
    )
    """
    privacy_passphrase is the passphrase to use for privacy in SNMPv3
     required for AUTH_PRIV security level
    """


@dataclass(eq=False, repr=False)
class CueSnmpSettings(aristaproto.Message):
    """
    CueSNMPSettings contain the settings for sending cue alerts with SNMP
    """

    target: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """target is an ipv4 address to send messages to"""

    port: Optional[int] = aristaproto.message_field(2, wraps=aristaproto.TYPE_INT32)
    """port is the network port to target"""

    transport: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    transport is the transport protocol to use ("udp" or "tcp"); if unset "udp" will be used
    """

    version: Optional[int] = aristaproto.message_field(4, wraps=aristaproto.TYPE_INT32)
    """
    version is the SNMP version, v2c and v3 are supported and can be set with 2 and 3 respectively
    """

    auth: "CueSnmpAuth" = aristaproto.message_field(5)
    """auth is the optional authentication settings"""

    data: "CueData" = aristaproto.message_field(6)
    """
    data is additional data that maybe required for constructing the message or sending it
    """


@dataclass(eq=False, repr=False)
class SendgridSettings(aristaproto.Message):
    """
    SendgridSettings contain the settings for sending emails via sendgrid
    """

    api_key: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """api_key is the api key to use"""

    from_: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """from is the email address to send from"""


@dataclass(eq=False, repr=False)
class CueSendgridSettings(aristaproto.Message):
    """
    CueSendgridSettings contain the settings for sending cue alerts to sendgrid
    """

    api_key: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """api_key is the key used to connect to the sendgrid APIs"""

    from_: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """from is the sender's address in the email sent"""


@dataclass(eq=False, repr=False)
class ZoomSettings(aristaproto.Message):
    """ZoomSettings contain the settings for sending alerts to zoom"""

    url: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """url is the zoom incoming webhook URL to send messages to"""

    verification_token: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """verification_token is the verification token to authenticate with"""


@dataclass(eq=False, repr=False)
class InhibitionSettings(aristaproto.Message):
    """
    InhibitionSettings allows certain event types to be suppressed while other event types are active
    """

    values: Dict[str, "EventList"] = aristaproto.map_field(
        1, aristaproto.TYPE_STRING, aristaproto.TYPE_MESSAGE
    )
    """
    values is a map where the keys are event type which when active will suppress any events with
     event types in the related EventList
    """


@dataclass(eq=False, repr=False)
class EventList(aristaproto.Message):
    """EventList is a list of event types"""

    event_types: "___fmp__.RepeatedString" = aristaproto.message_field(1)
    """event_types contain the event types"""


@dataclass(eq=False, repr=False)
class Rules(aristaproto.Message):
    """
    Rules is a list of rules which dictates which events generate alerts for which broadcast groups
    """

    values: List["Rule"] = aristaproto.message_field(1)
    """values contains the rules"""


@dataclass(eq=False, repr=False)
class Rule(aristaproto.Message):
    """Rule is a rule to send to a certain broadcast group"""

    sends_to: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """
    sends_to is the name of the broadcast group top send matching alerts to
    """

    match_criteria: "Matches" = aristaproto.message_field(2)
    """
    match_criteria is the criteria that an alert must match to be sent to the broadcast group
    """

    continue_checks: Optional[bool] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_BOOL
    )
    """
    continue_checks if true, causes alerts matching this rule's criteria to continue
     checking against other rules, allowing for additional matches. If false,
     alerts matching this rule will not proceed with checking
    """

    comment: Optional[str] = aristaproto.message_field(4, wraps=aristaproto.TYPE_STRING)
    """comment is a comment to include that will be displayed in the alert"""

    suppress_for: timedelta = aristaproto.message_field(5)
    """
    suppress_for is a time duration that a rule will be debounced for after being called
    """


@dataclass(eq=False, repr=False)
class Matches(aristaproto.Message):
    """
    Matches is a set of restrictions that must be satisfied for a rule to be matched
     Empty fields are ignored for matching purposes. Condition contents are
     OR'd and then AND'd with the other criteria
    """

    severities: "___fmp__.RepeatedString" = aristaproto.message_field(1)
    """
    severities is a list of severities to filter on,
     if an event does not have one of these severities, it will not match
     Valid values are DEBUG, INFO, WARNING, ERROR and CRITICAL
    """

    devices: "___fmp__.RepeatedString" = aristaproto.message_field(2)
    """
    devices is a list of device IDs to filter on,
     if an event does not belong to one of these devices, it will not match
    """

    event_types: "___fmp__.RepeatedString" = aristaproto.message_field(3)
    """
    event_types is a list of event types to filter on,
     if an event does not have one of these event types, it will not match
    """

    device_tags: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """
    device_tags is a string tag query that is used to match on the event's device tags
    """

    intf_tags: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    intf_tags is a string tag query that is used to match on the event's interface tags
    """

    rule_ids: "___fmp__.RepeatedString" = aristaproto.message_field(6)
    """
    rule_ids is a list of rule IDs to filter on,
     if an event does not have one of these rule IDs, it will not match
    """


@dataclass(eq=False, repr=False)
class BroadcastGroups(aristaproto.Message):
    """BroadcastGroups is a collection of named broadcast groups"""

    values: Dict[str, "BroadcastGroup"] = aristaproto.map_field(
        1, aristaproto.TYPE_STRING, aristaproto.TYPE_MESSAGE
    )
    """
    values is a map of user defined ids to broadcast groups. No restrictions to naming applies
    """


@dataclass(eq=False, repr=False)
class BroadcastGroup(aristaproto.Message):
    """
    BroadcastGroup is a series of endpoints that alerts are sent to if routed there by a rule
     No restriction on the number of types of endpoints that can be defined
    """

    email: "EmailEndpoints" = aristaproto.message_field(1)
    """
    email is a set of email endpoints to send alerts to as part of this group
    """

    webhook: "WebhookEndpoints" = aristaproto.message_field(2)
    """
    webhook is a set of webhook endpoints to send alerts to as part of this group
    """

    slack: "SlackEndpoints" = aristaproto.message_field(3)
    """
    slack is a set of slack endpoints to send alerts to as part of this group
    """

    opsgenie: "OpsgenieEndpoints" = aristaproto.message_field(4)
    """
    opsgenie is a set of opsgenie endpoints to send alerts to as part of this group
    """

    pushover: "PushoverEndpoints" = aristaproto.message_field(5)
    """
    pushover is a set of pushover endpoints to send alerts to as part of this group
    """

    pagerduty: "PagerdutyEndpoints" = aristaproto.message_field(6)
    """
    pagerduty is a set of pagerduty endpoints to send alerts to as part of this group
    """

    victorops: "VictorOpsEndpoints" = aristaproto.message_field(7)
    """
    victorops is a set of victorops endpoints to send alerts to as part of this group
    """

    gchat: "GoogleChatEndpoints" = aristaproto.message_field(8)
    """
    gchat is a set of google chat endpoints to send alerts to as part of this group
    """

    msteams: "MsTeamsEndpoints" = aristaproto.message_field(9)
    """
    msteams is a set of MS teams endpoints to send alerts to as part of this group
    """

    sendgrid: "SendgridEndpoints" = aristaproto.message_field(10)
    """
    sendgrid is a set of sendgrid endpoints to send alerts to as part of this group
    """

    syslog: "SyslogEndpoints" = aristaproto.message_field(11)
    """
    syslog is a set of syslog endpoints to send alerts to as part of this group
    """

    snmp: "SnmpEndpoints" = aristaproto.message_field(12)
    """
    snmp is a set of snmp endpoints to send alerts to as part of this group
    """

    cue_syslog: "CueSyslogEndpoints" = aristaproto.message_field(13)
    """
    cue_syslog is a set of cue syslog endpoints to send alerts to as part of this group
    """

    cue_snmp: "CueSnmpEndpoints" = aristaproto.message_field(14)
    """
    cue_snmp is a set of cue snmp endpoints to send alerts to as part of this group
    """

    cue_sendgrid: "CueSendgridEndpoints" = aristaproto.message_field(15)
    """
    cue_sendgrid is a set of cue sendgrid endpoints to send alerts to as part of this group
    """

    zoom: "ZoomEndpoints" = aristaproto.message_field(16)
    """
    zoom is a set of zoom endpoints to send alerts to as part of this group
    """


@dataclass(eq=False, repr=False)
class EmailEndpoints(aristaproto.Message):
    """EmailEndpoints is a set of email endpoints"""

    values: List["EmailEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class WebhookEndpoints(aristaproto.Message):
    """WebhookEndpoints is a set of webhook endpoints"""

    values: List["WebhookEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SlackEndpoints(aristaproto.Message):
    """SlackEndpoints is a set of slack endpoints"""

    values: List["SlackEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class OpsgenieEndpoints(aristaproto.Message):
    """OpsgenieEndpoints is a set of opsgenie endpoints"""

    values: List["OpsgenieEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class PushoverEndpoints(aristaproto.Message):
    """PushoverEndpoints is a set of pushover endpoints"""

    values: List["PushoverEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class PagerdutyEndpoints(aristaproto.Message):
    """PagerdutyEndpoints is a set of pagerduty endpoints"""

    values: List["PagerdutyEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class VictorOpsEndpoints(aristaproto.Message):
    """VictorOpsEndpoints is a set of victorOps endpoints"""

    values: List["VictorOpsEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class GoogleChatEndpoints(aristaproto.Message):
    """GoogleChatEndpoints is a set of googleChat endpoints"""

    values: List["GoogleChatEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class MsTeamsEndpoints(aristaproto.Message):
    """MsTeamsEndpoints is a set of ms teams endpoints"""

    values: List["MsTeamsEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SendgridEndpoints(aristaproto.Message):
    """SendgridEndpoints is a set of sendgrid endpoints"""

    values: List["SendgridEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class CueSendgridEndpoints(aristaproto.Message):
    """CueSendgridEndpoints is a set of cue sendgrid endpoints"""

    values: List["CueSendgridEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SyslogEndpoints(aristaproto.Message):
    """SyslogEndpoints is a set of syslog endpoints"""

    values: List["SyslogEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class CueSyslogEndpoints(aristaproto.Message):
    """CueSyslogEndpoints is a set of cue syslog endpoints"""

    values: List["CueSyslogEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class SnmpEndpoints(aristaproto.Message):
    """SNMPEndpoints is a set of SNMP endpoints"""

    values: List["SnmpEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class CueSnmpEndpoints(aristaproto.Message):
    """CueSnmpEndpoints is a set of cue SNMP endpoints"""

    values: List["CueSnmpEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class ZoomEndpoints(aristaproto.Message):
    """ZoomEndpoints is a set of zoom endpoints"""

    values: List["ZoomEndpoint"] = aristaproto.message_field(1)
    """values are the elements of the set"""


@dataclass(eq=False, repr=False)
class EmailEndpoint(aristaproto.Message):
    """
    EmailEndpoint contains the required information for an alert to be sent to an email endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    to: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """to address to send email to"""


@dataclass(eq=False, repr=False)
class WebhookEndpoint(aristaproto.Message):
    """
    WebhookEndpoint contains the required information for an alert to be sent to a webhook endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    url: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """url is the url"""

    http_override: "HttpSettings" = aristaproto.message_field(3)
    """http_override is the override of the global http settings"""

    simple_output: Optional[bool] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_BOOL
    )
    """
    simple_output is a boolean flag to control the JSON structure of the webhook body.
     When false the output mimics the old alertmanager format.
     When true the output is a simple array of json objects which each represent an event.
    """

    single_alert: Optional[bool] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_BOOL
    )
    """
    single_alert is a boolean flag that will cause an individual webhook message to be sent per
     alert when true.
    """

    settings_override: "WebhookSettings" = aristaproto.message_field(6)
    """
    settings_override is the override for the webhook global endpoint settings
    """


@dataclass(eq=False, repr=False)
class SlackEndpoint(aristaproto.Message):
    """
    SlackEndpoint contains the required information for an alert to be sent to a slack endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    http_override: "HttpSettings" = aristaproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "SlackSettings" = aristaproto.message_field(3)
    """
    settings_override is the override for the slack global endpoint settings
    """


@dataclass(eq=False, repr=False)
class OpsgenieEndpoint(aristaproto.Message):
    """
    OpsgenieEndpoint contains the required information for an alert to be sent to an opsgenie endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    http_override: "HttpSettings" = aristaproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "OpsgenieSettings" = aristaproto.message_field(3)
    """
    settings_override is the override for the opsgenie global endpoint settings
    """


@dataclass(eq=False, repr=False)
class PushoverEndpoint(aristaproto.Message):
    """
    PushoverEndpoint contains the required information for an alert to be sent to a pushover endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    token: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    token is the user's registered application's API token, see https://pushover.net/apps
    """

    user_key: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """user_key is the user's user key"""

    http_override: "HttpSettings" = aristaproto.message_field(4)
    """http_override is the override of the global http settings"""


@dataclass(eq=False, repr=False)
class PagerdutyEndpoint(aristaproto.Message):
    """
    PagerdutyEndpoint contains the required information for an alert to be sent to a pagerduty endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    routing_key: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """routing_key is the routing key for sending pagerduty alerts"""

    http_override: "HttpSettings" = aristaproto.message_field(3)
    """http_override is the override of the global http settings"""

    settings_override: "PagerdutySettings" = aristaproto.message_field(4)
    """
    settings_override is the override for the pagerduty global endpoint settings
    """


@dataclass(eq=False, repr=False)
class VictorOpsEndpoint(aristaproto.Message):
    """
    VictorOpsEndpoint contains the required information for an alert to be sent to a victorOps endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    routing_key: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """routing_key is the PagerDuty integration key"""

    http_override: "HttpSettings" = aristaproto.message_field(3)
    """http_override is the override of the global http settings"""

    settings_override: "VictoropsSettings" = aristaproto.message_field(4)
    """
    settings_override is the override for the victorops global endpoint settings
    """


@dataclass(eq=False, repr=False)
class GoogleChatEndpoint(aristaproto.Message):
    """
    GoogleChatEndpoint contains the required information for an alert to be sent to a google chat endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    http_override: "HttpSettings" = aristaproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "GoogleChatSettings" = aristaproto.message_field(3)
    """
    settings_override is the override for the google chat global endpoint settings
    """


@dataclass(eq=False, repr=False)
class MsTeamsEndpoint(aristaproto.Message):
    """
    MsTeamsEndpoint contains the required information for an alert to be sent to an ms teams endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    http_override: "HttpSettings" = aristaproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "MsTeamsSettings" = aristaproto.message_field(3)
    """
    settings_override is the override for the microsoft teams global endpoint settings
    """


@dataclass(eq=False, repr=False)
class SendgridEndpoint(aristaproto.Message):
    """
    SendgridEndpoint contains the required information for an alert to be sent to a sendgrid endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    to: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """to address to send email to"""

    http_override: "HttpSettings" = aristaproto.message_field(3)
    """http_override is the override of the global http settings"""


@dataclass(eq=False, repr=False)
class CueSendgridEndpoint(aristaproto.Message):
    """
    CueSendgridEndpoint contains the required information for an alert to be sent to a cue sendgrid endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    to: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """to address to send email to"""

    http_override: "HttpSettings" = aristaproto.message_field(3)
    """
    http_override is the override of the global http settings
     This overrides the value used in Settings message in the global alert config
    """


@dataclass(eq=False, repr=False)
class SyslogEndpoint(aristaproto.Message):
    """
    SyslogEndpoint contains the required information for an alert to be sent to a syslog endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    settings_override: "SyslogSettings" = aristaproto.message_field(2)
    """
    settings_override is the override for the microsoft teams global endpoint settings
    """


@dataclass(eq=False, repr=False)
class CueSyslogEndpoint(aristaproto.Message):
    """
    CueSyslogEndpoint contains the required information for an alert to be sent to a cue syslog endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    settings_override: "CueSyslogSettings" = aristaproto.message_field(2)
    """
    settings_override is the override for the cue syslog global endpoint settings
    """


@dataclass(eq=False, repr=False)
class SnmpEndpoint(aristaproto.Message):
    """
    SNMPEndpoint contains the required information for an alert to be sent to an SNMP endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    settings_override: "SnmpSettings" = aristaproto.message_field(2)
    """
    settings_override is the override for the microsoft teams global endpoint settings
    """


@dataclass(eq=False, repr=False)
class CueSnmpEndpoint(aristaproto.Message):
    """
    CueSNMPEndpoint contains the required information for an alert to be sent to a cue SNMP endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    settings_override: "CueSnmpSettings" = aristaproto.message_field(2)
    """
    settings_override is the override for the cue snmp global endpoint settings
    """


@dataclass(eq=False, repr=False)
class ZoomEndpoint(aristaproto.Message):
    """
    ZoomEndpoint contains the required information for an alert to be sent to a zoom endpoint
    """

    send_resolved: Optional[bool] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_BOOL
    )
    """
    send_resolved send alerts when events are resolved along with when they are triggered
    """

    http_override: "HttpSettings" = aristaproto.message_field(2)
    """http_override is the override of the global http settings"""

    settings_override: "ZoomSettings" = aristaproto.message_field(3)
    """
    settings_override is the override for the zoom global endpoint settings
    """


@dataclass(eq=False, repr=False)
class TemplateKey(aristaproto.Message):
    """TemplateKey is used to identify templates for event notifications"""

    template_type: "TemplateType" = aristaproto.enum_field(1)
    """template_type is the enum value to match with the template"""


@dataclass(eq=False, repr=False)
class TemplateConfig(aristaproto.Message):
    """TemplateConfig represents a template configuration"""

    key: "TemplateKey" = aristaproto.message_field(1)
    """key identifies which template the configuration is for"""

    template: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    template is the string template value to be used
     Templates need to be compatible with their respective parsers
     Message templates are read and parsed by https://golang.org/pkg/text/template/
     Html templates are read and parsed by https://golang.org/pkg/html/template/
     Templates must output valid JSON for certain templates
     Templates must not fail for any valid input
    """


@dataclass(eq=False, repr=False)
class DefaultTemplate(aristaproto.Message):
    """
    DefaultTemplate is the system default template which is used when no user template has been set
    """

    key: "TemplateKey" = aristaproto.message_field(1)
    """key identifies which template the configuration is for"""

    template: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    template is the string template value to be used
     Templates need to be compatible with their respective parsers
     Message templates are read and parsed by https://golang.org/pkg/text/template/
     Html templates are read and parsed by https://golang.org/pkg/html/template/
     Templates must output valid JSON for certain templates
     Templates must not fail for any valid input
    """

    multi_alert: Optional[bool] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_BOOL
    )
    """
    multi_alert is true if this template uses a multiple alert context and false if a single
     alert context is used.
    """

    description: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """description is a description of the template."""

    external_documentation: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    external_documentation is a url to any relevant external documentation, or "" if there is no
     relevant documentation.
    """

    output_format: "TemplateOutput" = aristaproto.enum_field(6)
    """
    output_format is the expected output format of this template
     Any submitted template will be expected to output text with valid formatting for any input or
     may fail validation.
    """

    display_name: Optional[str] = aristaproto.message_field(
        7, wraps=aristaproto.TYPE_STRING
    )
    """
    display_name is the name that can be displayed to the user for this particular template type
    """


@dataclass(eq=False, repr=False)
class MetaResponse(aristaproto.Message):
    time: datetime = aristaproto.message_field(1)
    """
    Time holds the timestamp of the last item included in the metadata calculation.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(2)
    """
    Operation indicates how the value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """

    count: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_UINT32)
    """
    Count is the number of items present under the conditions of the request.
    """


@dataclass(eq=False, repr=False)
class AlertRequest(aristaproto.Message):
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class AlertResponse(aristaproto.Message):
    value: "Alert" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     Alert instance in this response.
    """


@dataclass(eq=False, repr=False)
class AlertStreamRequest(aristaproto.Message):
    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Alert at end.
         * Each Alert response is fully-specified (all fields set).
       * start: Returns the state of each Alert at start, followed by updates until now.
         * Each Alert response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Alert at start, followed by updates
         until end.
         * Each Alert response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class AlertStreamResponse(aristaproto.Message):
    value: "Alert" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Alert's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Alert value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class AlertConfigRequest(aristaproto.Message):
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class AlertConfigResponse(aristaproto.Message):
    value: "AlertConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     AlertConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class AlertConfigStreamRequest(aristaproto.Message):
    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each AlertConfig at end.
         * Each AlertConfig response is fully-specified (all fields set).
       * start: Returns the state of each AlertConfig at start, followed by updates until now.
         * Each AlertConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each AlertConfig at start, followed by updates
         until end.
         * Each AlertConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class AlertConfigStreamResponse(aristaproto.Message):
    value: "AlertConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this AlertConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the AlertConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class AlertConfigSetRequest(aristaproto.Message):
    value: "AlertConfig" = aristaproto.message_field(1)
    """
    AlertConfig carries the value to set into the datastore.
     See the documentation on the AlertConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class AlertConfigSetResponse(aristaproto.Message):
    value: "AlertConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the AlertConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateRequest(aristaproto.Message):
    key: "TemplateKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DefaultTemplate instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateResponse(aristaproto.Message):
    value: "DefaultTemplate" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DefaultTemplate instance in this response.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateSomeRequest(aristaproto.Message):
    keys: List["TemplateKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateSomeResponse(aristaproto.Message):
    value: "DefaultTemplate" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DefaultTemplateStreamRequest(aristaproto.Message):
    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DefaultTemplate at end.
         * Each DefaultTemplate response is fully-specified (all fields set).
       * start: Returns the state of each DefaultTemplate at start, followed by updates until now.
         * Each DefaultTemplate response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DefaultTemplate at start, followed by updates
         until end.
         * Each DefaultTemplate response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateStreamResponse(aristaproto.Message):
    value: "DefaultTemplate" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DefaultTemplate's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DefaultTemplate value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateBatchedStreamRequest(aristaproto.Message):
    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DefaultTemplate at end.
         * Each DefaultTemplate response is fully-specified (all fields set).
       * start: Returns the state of each DefaultTemplate at start, followed by updates until now.
         * Each DefaultTemplate response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DefaultTemplate at start, followed by updates
         until end.
         * Each DefaultTemplate response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DefaultTemplateBatchedStreamResponse(aristaproto.Message):
    responses: List["DefaultTemplateStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class TemplateConfigRequest(aristaproto.Message):
    key: "TemplateKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a TemplateConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigResponse(aristaproto.Message):
    value: "TemplateConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     TemplateConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSomeRequest(aristaproto.Message):
    keys: List["TemplateKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSomeResponse(aristaproto.Message):
    value: "TemplateConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class TemplateConfigStreamRequest(aristaproto.Message):
    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TemplateConfig at end.
         * Each TemplateConfig response is fully-specified (all fields set).
       * start: Returns the state of each TemplateConfig at start, followed by updates until now.
         * Each TemplateConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TemplateConfig at start, followed by updates
         until end.
         * Each TemplateConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigStreamResponse(aristaproto.Message):
    value: "TemplateConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this TemplateConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the TemplateConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigBatchedStreamRequest(aristaproto.Message):
    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TemplateConfig at end.
         * Each TemplateConfig response is fully-specified (all fields set).
       * start: Returns the state of each TemplateConfig at start, followed by updates until now.
         * Each TemplateConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TemplateConfig at start, followed by updates
         until end.
         * Each TemplateConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["TemplateConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetRequest(aristaproto.Message):
    value: "TemplateConfig" = aristaproto.message_field(1)
    """
    TemplateConfig carries the value to set into the datastore.
     See the documentation on the TemplateConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetResponse(aristaproto.Message):
    value: "TemplateConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the TemplateConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetSomeRequest(aristaproto.Message):
    values: List["TemplateConfig"] = aristaproto.message_field(1)
    """
    value contains a list of TemplateConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigSetSomeResponse(aristaproto.Message):
    key: "TemplateKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteRequest(aristaproto.Message):
    key: "TemplateKey" = aristaproto.message_field(1)
    """
    Key indicates which TemplateConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteResponse(aristaproto.Message):
    key: "TemplateKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted TemplateConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["TemplateKey"] = aristaproto.message_field(1)
    """key contains a list of TemplateConfig keys to delete"""


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteSomeResponse(aristaproto.Message):
    """
    TemplateConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "TemplateKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteAllRequest(aristaproto.Message):
    pass


@dataclass(eq=False, repr=False)
class TemplateConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TemplateKey" = aristaproto.message_field(3)
    """
    This is the key of the TemplateConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class AlertServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        alert_request: "AlertRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AlertResponse":
        return await self._unary_unary(
            "/arista.alert.v1.AlertService/GetOne",
            alert_request,
            AlertResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        alert_stream_request: "AlertStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AlertStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertService/GetAll",
            alert_stream_request,
            AlertStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        alert_stream_request: "AlertStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AlertStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertService/Subscribe",
            alert_stream_request,
            AlertStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_meta(
        self,
        alert_stream_request: "AlertStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertService/SubscribeMeta",
            alert_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class AlertConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        alert_config_request: "AlertConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AlertConfigResponse":
        return await self._unary_unary(
            "/arista.alert.v1.AlertConfigService/GetOne",
            alert_config_request,
            AlertConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        alert_config_stream_request: "AlertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AlertConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertConfigService/GetAll",
            alert_config_stream_request,
            AlertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        alert_config_stream_request: "AlertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AlertConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertConfigService/Subscribe",
            alert_config_stream_request,
            AlertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_meta(
        self,
        alert_config_stream_request: "AlertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.AlertConfigService/SubscribeMeta",
            alert_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        alert_config_set_request: "AlertConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AlertConfigSetResponse":
        return await self._unary_unary(
            "/arista.alert.v1.AlertConfigService/Set",
            alert_config_set_request,
            AlertConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class DefaultTemplateServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        default_template_request: "DefaultTemplateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DefaultTemplateResponse":
        return await self._unary_unary(
            "/arista.alert.v1.DefaultTemplateService/GetOne",
            default_template_request,
            DefaultTemplateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        default_template_some_request: "DefaultTemplateSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DefaultTemplateSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.DefaultTemplateService/GetSome",
            default_template_some_request,
            DefaultTemplateSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        default_template_stream_request: "DefaultTemplateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DefaultTemplateStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.DefaultTemplateService/GetAll",
            default_template_stream_request,
            DefaultTemplateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        default_template_stream_request: "DefaultTemplateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DefaultTemplateStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.DefaultTemplateService/Subscribe",
            default_template_stream_request,
            DefaultTemplateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        default_template_stream_request: "DefaultTemplateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.alert.v1.DefaultTemplateService/GetMeta",
            default_template_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        default_template_stream_request: "DefaultTemplateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.DefaultTemplateService/SubscribeMeta",
            default_template_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        default_template_batched_stream_request: "DefaultTemplateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DefaultTemplateBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.DefaultTemplateService/GetAllBatched",
            default_template_batched_stream_request,
            DefaultTemplateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        default_template_batched_stream_request: "DefaultTemplateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DefaultTemplateBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.DefaultTemplateService/SubscribeBatched",
            default_template_batched_stream_request,
            DefaultTemplateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class TemplateConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        template_config_request: "TemplateConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TemplateConfigResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/GetOne",
            template_config_request,
            TemplateConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        template_config_some_request: "TemplateConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/GetSome",
            template_config_some_request,
            TemplateConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        template_config_stream_request: "TemplateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/GetAll",
            template_config_stream_request,
            TemplateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        template_config_stream_request: "TemplateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/Subscribe",
            template_config_stream_request,
            TemplateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        template_config_stream_request: "TemplateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/GetMeta",
            template_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        template_config_stream_request: "TemplateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/SubscribeMeta",
            template_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        template_config_set_request: "TemplateConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TemplateConfigSetResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/Set",
            template_config_set_request,
            TemplateConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        template_config_set_some_request: "TemplateConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/SetSome",
            template_config_set_some_request,
            TemplateConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        template_config_delete_request: "TemplateConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TemplateConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.alert.v1.TemplateConfigService/Delete",
            template_config_delete_request,
            TemplateConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        template_config_delete_some_request: "TemplateConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/DeleteSome",
            template_config_delete_some_request,
            TemplateConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        template_config_delete_all_request: "TemplateConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/DeleteAll",
            template_config_delete_all_request,
            TemplateConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        template_config_batched_stream_request: "TemplateConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/GetAllBatched",
            template_config_batched_stream_request,
            TemplateConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        template_config_batched_stream_request: "TemplateConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TemplateConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.alert.v1.TemplateConfigService/SubscribeBatched",
            template_config_batched_stream_request,
            TemplateConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class AlertServiceBase(ServiceBase):

    async def get_one(self, alert_request: "AlertRequest") -> "AlertResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, alert_stream_request: "AlertStreamRequest"
    ) -> AsyncIterator["AlertStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, alert_stream_request: "AlertStreamRequest"
    ) -> AsyncIterator["AlertStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, alert_stream_request: "AlertStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[AlertRequest, AlertResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[AlertStreamRequest, AlertStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[AlertStreamRequest, AlertStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[AlertStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.AlertService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                AlertRequest,
                AlertResponse,
            ),
            "/arista.alert.v1.AlertService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertStreamRequest,
                AlertStreamResponse,
            ),
            "/arista.alert.v1.AlertService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertStreamRequest,
                AlertStreamResponse,
            ),
            "/arista.alert.v1.AlertService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertStreamRequest,
                MetaResponse,
            ),
        }


class AlertConfigServiceBase(ServiceBase):

    async def get_one(
        self, alert_config_request: "AlertConfigRequest"
    ) -> "AlertConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, alert_config_stream_request: "AlertConfigStreamRequest"
    ) -> AsyncIterator["AlertConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, alert_config_stream_request: "AlertConfigStreamRequest"
    ) -> AsyncIterator["AlertConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, alert_config_stream_request: "AlertConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, alert_config_set_request: "AlertConfigSetRequest"
    ) -> "AlertConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[AlertConfigRequest, AlertConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[AlertConfigStreamRequest, AlertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[AlertConfigStreamRequest, AlertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[AlertConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[AlertConfigSetRequest, AlertConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.AlertConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                AlertConfigRequest,
                AlertConfigResponse,
            ),
            "/arista.alert.v1.AlertConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertConfigStreamRequest,
                AlertConfigStreamResponse,
            ),
            "/arista.alert.v1.AlertConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertConfigStreamRequest,
                AlertConfigStreamResponse,
            ),
            "/arista.alert.v1.AlertConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                AlertConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.alert.v1.AlertConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                AlertConfigSetRequest,
                AlertConfigSetResponse,
            ),
        }


class DefaultTemplateServiceBase(ServiceBase):

    async def get_one(
        self, default_template_request: "DefaultTemplateRequest"
    ) -> "DefaultTemplateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, default_template_some_request: "DefaultTemplateSomeRequest"
    ) -> AsyncIterator["DefaultTemplateSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, default_template_stream_request: "DefaultTemplateStreamRequest"
    ) -> AsyncIterator["DefaultTemplateStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, default_template_stream_request: "DefaultTemplateStreamRequest"
    ) -> AsyncIterator["DefaultTemplateStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, default_template_stream_request: "DefaultTemplateStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, default_template_stream_request: "DefaultTemplateStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        default_template_batched_stream_request: "DefaultTemplateBatchedStreamRequest",
    ) -> AsyncIterator["DefaultTemplateBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        default_template_batched_stream_request: "DefaultTemplateBatchedStreamRequest",
    ) -> AsyncIterator["DefaultTemplateBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateRequest, DefaultTemplateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateSomeRequest, DefaultTemplateSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateStreamRequest, DefaultTemplateStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateStreamRequest, DefaultTemplateStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateBatchedStreamRequest, DefaultTemplateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DefaultTemplateBatchedStreamRequest, DefaultTemplateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.DefaultTemplateService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DefaultTemplateRequest,
                DefaultTemplateResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DefaultTemplateSomeRequest,
                DefaultTemplateSomeResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DefaultTemplateStreamRequest,
                DefaultTemplateStreamResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DefaultTemplateStreamRequest,
                DefaultTemplateStreamResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DefaultTemplateStreamRequest,
                MetaResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DefaultTemplateStreamRequest,
                MetaResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DefaultTemplateBatchedStreamRequest,
                DefaultTemplateBatchedStreamResponse,
            ),
            "/arista.alert.v1.DefaultTemplateService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DefaultTemplateBatchedStreamRequest,
                DefaultTemplateBatchedStreamResponse,
            ),
        }


class TemplateConfigServiceBase(ServiceBase):

    async def get_one(
        self, template_config_request: "TemplateConfigRequest"
    ) -> "TemplateConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, template_config_some_request: "TemplateConfigSomeRequest"
    ) -> AsyncIterator["TemplateConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, template_config_stream_request: "TemplateConfigStreamRequest"
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, template_config_stream_request: "TemplateConfigStreamRequest"
    ) -> AsyncIterator["TemplateConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, template_config_stream_request: "TemplateConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, template_config_stream_request: "TemplateConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, template_config_set_request: "TemplateConfigSetRequest"
    ) -> "TemplateConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, template_config_set_some_request: "TemplateConfigSetSomeRequest"
    ) -> AsyncIterator["TemplateConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, template_config_delete_request: "TemplateConfigDeleteRequest"
    ) -> "TemplateConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, template_config_delete_some_request: "TemplateConfigDeleteSomeRequest"
    ) -> AsyncIterator["TemplateConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, template_config_delete_all_request: "TemplateConfigDeleteAllRequest"
    ) -> AsyncIterator["TemplateConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        template_config_batched_stream_request: "TemplateConfigBatchedStreamRequest",
    ) -> AsyncIterator["TemplateConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        template_config_batched_stream_request: "TemplateConfigBatchedStreamRequest",
    ) -> AsyncIterator["TemplateConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[TemplateConfigRequest, TemplateConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[TemplateConfigSomeRequest, TemplateConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[TemplateConfigStreamRequest, TemplateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[TemplateConfigStreamRequest, TemplateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[TemplateConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[TemplateConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[TemplateConfigSetRequest, TemplateConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[TemplateConfigSetSomeRequest, TemplateConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[TemplateConfigDeleteRequest, TemplateConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[TemplateConfigDeleteSomeRequest, TemplateConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[TemplateConfigDeleteAllRequest, TemplateConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[TemplateConfigBatchedStreamRequest, TemplateConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[TemplateConfigBatchedStreamRequest, TemplateConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.alert.v1.TemplateConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigRequest,
                TemplateConfigResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigSomeRequest,
                TemplateConfigSomeResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigStreamRequest,
                TemplateConfigStreamResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigStreamRequest,
                TemplateConfigStreamResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigSetRequest,
                TemplateConfigSetResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigSetSomeRequest,
                TemplateConfigSetSomeResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                TemplateConfigDeleteRequest,
                TemplateConfigDeleteResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigDeleteSomeRequest,
                TemplateConfigDeleteSomeResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigDeleteAllRequest,
                TemplateConfigDeleteAllResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigBatchedStreamRequest,
                TemplateConfigBatchedStreamResponse,
            ),
            "/arista.alert.v1.TemplateConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TemplateConfigBatchedStreamRequest,
                TemplateConfigBatchedStreamResponse,
            ),
        }
