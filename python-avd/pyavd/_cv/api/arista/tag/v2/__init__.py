# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/tag.v2/services.gen.proto, arista/tag.v2/tag.proto
# plugin: python-aristaproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import aristaproto
import grpclib
from aristaproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ElementType(aristaproto.Enum):
    """
    ElementType enumerates the types of network elements that can
     be associated with tags.
    """

    UNSPECIFIED = 0
    """ELEMENT_TYPE_UNSPECIFIED is the default value."""

    DEVICE = 1
    """ELEMENT_TYPE_DEVICE is used for device tags."""

    INTERFACE = 2
    """ELEMENT_TYPE_INTERFACE is used for interface tags."""


class ElementSubType(aristaproto.Enum):
    """
    ElementSubType enumerates the sub-types of network elements that can
     be associated with tags.
    """

    UNSPECIFIED = 0
    """ELEMENT_SUB_TYPE_UNSPECIFIED is the default value."""

    DEVICE = 1
    """
    ELEMENT_SUB_TYPE_DEVICE is used for EOS or
     third-party devices discovered via LLDP/SNMP.
    """

    VDS = 2
    """
    ELEMENT_SUB_TYPE_VDS is used for VMWare vSphere Distributed Switch (VDS) tags.
    """

    WORKLOAD_SERVER = 3
    """
    ELEMENT_SUB_TYPE_WORKLOAD_SERVER is used for workload server
     tags (such as VMWare ESXi host).
     A workload server is a server/data storage device on which
     the hypervisor is installed.
    """

    VM = 4
    """
    ELEMENT_SUB_TYPE_VM is used for VM tags.
     A VM is a software computer that, like a physical computer,
     runs an operating system and applications.
    """


class CreatorType(aristaproto.Enum):
    """
    CreatorType enumerates the types of entities that can create
     a tag.
    """

    UNSPECIFIED = 0
    """CREATOR_TYPE_UNSPECIFIED is the default value."""

    SYSTEM = 1
    """CREATOR_TYPE_SYSTEM is used for system tags."""

    USER = 2
    """CREATOR_TYPE_USER is used for user tags."""

    EXTERNAL = 3
    """
    CREATOR_TYPE_EXTERNAL is used for tags created from external sources.
     For E.g., vCenter
    """


@dataclass(eq=False, repr=False)
class TagKey(aristaproto.Message):
    """TagKey uniquely identifies a tag."""

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """
    workspace_id is the ID of a workspace. The special ID ""
     identifies the location where merged tags reside.
    """

    element_type: "ElementType" = aristaproto.enum_field(2)
    """
    element_type is the category of network element to which
     this tag can be assigned.
    """

    label: Optional[str] = aristaproto.message_field(3, wraps=aristaproto.TYPE_STRING)
    """label is an arbitrary label."""

    value: Optional[str] = aristaproto.message_field(4, wraps=aristaproto.TYPE_STRING)
    """value is an arbitrary value."""

    element_sub_type: "ElementSubType" = aristaproto.enum_field(5)
    """
    element_sub_type is the sub-category of network element
     to which this tag can be assigned.
    """


@dataclass(eq=False, repr=False)
class TagConfig(aristaproto.Message):
    """
    TagConfig holds a configuration for a user tag.
     The tags that belong to entities other than ELEMENT_SUB_TYPE_DEVICE
     will always be present in mainline only.
    """

    key: "TagKey" = aristaproto.message_field(1)
    """
    key identifies a tag. The special workspace ID "" for
     merged tags should not be set here.
    """

    remove: Optional[bool] = aristaproto.message_field(2, wraps=aristaproto.TYPE_BOOL)
    """
    remove indicates whether to remove (true) or add (false,
     unset) the tag identified by the key if the encompassing
     workspace merges.
    """


@dataclass(eq=False, repr=False)
class Tag(aristaproto.Message):
    """
    Tag holds a merge-preview or the existing merged state (if the
     workspace ID is "") of a tag.
    """

    key: "TagKey" = aristaproto.message_field(1)
    """key identifies a tag."""

    creator_type: "CreatorType" = aristaproto.enum_field(2)
    """creator_type is the creator type of the tag."""


@dataclass(eq=False, repr=False)
class TagAssignmentKey(aristaproto.Message):
    """
    TagAssignmentKey uniquely identifies an assignment between
     a tag and a network element.
    """

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """
    workspace_id is the ID of a workspace. The special ID ""
     identifies the location where merged assignments reside.
    """

    element_type: "ElementType" = aristaproto.enum_field(2)
    """
    element_type is the element type of a tag. What should
     be set per element type:

     ELEMENT_TYPE_DEVICE: device_id
     ELEMENT_TYPE_INTERFACE: device_id, interface_id
    """

    label: Optional[str] = aristaproto.message_field(3, wraps=aristaproto.TYPE_STRING)
    """label is the label of a tag."""

    value: Optional[str] = aristaproto.message_field(4, wraps=aristaproto.TYPE_STRING)
    """value is the value of a tag."""

    device_id: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies a device."""

    interface_id: Optional[str] = aristaproto.message_field(
        6, wraps=aristaproto.TYPE_STRING
    )
    """interface_id identifies an interface on a device."""

    element_sub_type: "ElementSubType" = aristaproto.enum_field(7)
    """element_sub_type is the element sub-type of a tag."""


@dataclass(eq=False, repr=False)
class TagAssignmentConfig(aristaproto.Message):
    """
    TagAssignmentConfig holds a configuration for an assignment
     between a tag and a network element.
     The tag assignments that belong to entities other than ELEMENT_SUB_TYPE_DEVICE
     will always be present in mainline only.
    """

    key: "TagAssignmentKey" = aristaproto.message_field(1)
    """
    key identifies an assignment. The special workspace ID ""
     for merged assignments should not be set here.
    """

    remove: Optional[bool] = aristaproto.message_field(2, wraps=aristaproto.TYPE_BOOL)
    """
    remove indicates whether to remove (true) or add (false,
     unset) the assignment identified by the key if the
     encompassing workspace merges.
    """


@dataclass(eq=False, repr=False)
class TagAssignment(aristaproto.Message):
    """
    TagAssignment holds a merge-preview or the existing merged
     state (if the workspace ID is "") of an assignment between
     a tag and a network element.
    """

    key: "TagAssignmentKey" = aristaproto.message_field(1)
    """key identifies an assignment."""

    tag_creator_type: "CreatorType" = aristaproto.enum_field(2)
    """
    tag_creator_type is the creator type of the tag
     involved in the assignment.
    """


@dataclass(eq=False, repr=False)
class MetaResponse(aristaproto.Message):
    time: datetime = aristaproto.message_field(1)
    """
    Time holds the timestamp of the last item included in the metadata calculation.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(2)
    """
    Operation indicates how the value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """

    count: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_UINT32)
    """
    Count is the number of items present under the conditions of the request.
    """


@dataclass(eq=False, repr=False)
class TagRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Tag instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagResponse(aristaproto.Message):
    value: "Tag" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     Tag instance in this response.
    """


@dataclass(eq=False, repr=False)
class TagSomeRequest(aristaproto.Message):
    keys: List["TagKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagSomeResponse(aristaproto.Message):
    value: "Tag" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class TagStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Tag"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Tag at end.
         * Each Tag response is fully-specified (all fields set).
       * start: Returns the state of each Tag at start, followed by updates until now.
         * Each Tag response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Tag at start, followed by updates
         until end.
         * Each Tag response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class TagStreamResponse(aristaproto.Message):
    value: "Tag" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Tag's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Tag value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class TagBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Tag"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Tag at end.
         * Each Tag response is fully-specified (all fields set).
       * start: Returns the state of each Tag at start, followed by updates until now.
         * Each Tag response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Tag at start, followed by updates
         until end.
         * Each Tag response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class TagBatchedStreamResponse(aristaproto.Message):
    responses: List["TagStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class TagAssignmentRequest(aristaproto.Message):
    key: "TagAssignmentKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a TagAssignment instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentResponse(aristaproto.Message):
    value: "TagAssignment" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     TagAssignment instance in this response.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentSomeRequest(aristaproto.Message):
    keys: List["TagAssignmentKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentSomeResponse(aristaproto.Message):
    value: "TagAssignment" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class TagAssignmentStreamRequest(aristaproto.Message):
    partial_eq_filter: List["TagAssignment"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TagAssignment at end.
         * Each TagAssignment response is fully-specified (all fields set).
       * start: Returns the state of each TagAssignment at start, followed by updates until now.
         * Each TagAssignment response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TagAssignment at start, followed by updates
         until end.
         * Each TagAssignment response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentStreamResponse(aristaproto.Message):
    value: "TagAssignment" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this TagAssignment's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the TagAssignment value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["TagAssignment"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TagAssignment at end.
         * Each TagAssignment response is fully-specified (all fields set).
       * start: Returns the state of each TagAssignment at start, followed by updates until now.
         * Each TagAssignment response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TagAssignment at start, followed by updates
         until end.
         * Each TagAssignment response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentBatchedStreamResponse(aristaproto.Message):
    responses: List["TagAssignmentStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigRequest(aristaproto.Message):
    key: "TagAssignmentKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a TagAssignmentConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigResponse(aristaproto.Message):
    value: "TagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     TagAssignmentConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigSomeRequest(aristaproto.Message):
    keys: List["TagAssignmentKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigSomeResponse(aristaproto.Message):
    value: "TagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class TagAssignmentConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["TagAssignmentConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TagAssignmentConfig at end.
         * Each TagAssignmentConfig response is fully-specified (all fields set).
       * start: Returns the state of each TagAssignmentConfig at start, followed by updates until now.
         * Each TagAssignmentConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TagAssignmentConfig at start, followed by updates
         until end.
         * Each TagAssignmentConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigStreamResponse(aristaproto.Message):
    value: "TagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this TagAssignmentConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the TagAssignmentConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["TagAssignmentConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TagAssignmentConfig at end.
         * Each TagAssignmentConfig response is fully-specified (all fields set).
       * start: Returns the state of each TagAssignmentConfig at start, followed by updates until now.
         * Each TagAssignmentConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TagAssignmentConfig at start, followed by updates
         until end.
         * Each TagAssignmentConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["TagAssignmentConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigSetRequest(aristaproto.Message):
    value: "TagAssignmentConfig" = aristaproto.message_field(1)
    """
    TagAssignmentConfig carries the value to set into the datastore.
     See the documentation on the TagAssignmentConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigSetResponse(aristaproto.Message):
    value: "TagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the TagAssignmentConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigSetSomeRequest(aristaproto.Message):
    values: List["TagAssignmentConfig"] = aristaproto.message_field(1)
    """
    value contains a list of TagAssignmentConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigSetSomeResponse(aristaproto.Message):
    key: "TagAssignmentKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class TagAssignmentConfigDeleteRequest(aristaproto.Message):
    key: "TagAssignmentKey" = aristaproto.message_field(1)
    """
    Key indicates which TagAssignmentConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigDeleteResponse(aristaproto.Message):
    key: "TagAssignmentKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted TagAssignmentConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["TagAssignmentKey"] = aristaproto.message_field(1)
    """key contains a list of TagAssignmentConfig keys to delete"""


@dataclass(eq=False, repr=False)
class TagAssignmentConfigDeleteSomeResponse(aristaproto.Message):
    """
    TagAssignmentConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "TagAssignmentKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class TagAssignmentConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["TagAssignmentConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class TagAssignmentConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TagAssignmentKey" = aristaproto.message_field(3)
    """
    This is the key of the TagAssignmentConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class TagConfigRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a TagConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagConfigResponse(aristaproto.Message):
    value: "TagConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     TagConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class TagConfigSomeRequest(aristaproto.Message):
    keys: List["TagKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class TagConfigSomeResponse(aristaproto.Message):
    value: "TagConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class TagConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["TagConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TagConfig at end.
         * Each TagConfig response is fully-specified (all fields set).
       * start: Returns the state of each TagConfig at start, followed by updates until now.
         * Each TagConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TagConfig at start, followed by updates
         until end.
         * Each TagConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class TagConfigStreamResponse(aristaproto.Message):
    value: "TagConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this TagConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the TagConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class TagConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["TagConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each TagConfig at end.
         * Each TagConfig response is fully-specified (all fields set).
       * start: Returns the state of each TagConfig at start, followed by updates until now.
         * Each TagConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each TagConfig at start, followed by updates
         until end.
         * Each TagConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class TagConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["TagConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class TagConfigSetRequest(aristaproto.Message):
    value: "TagConfig" = aristaproto.message_field(1)
    """
    TagConfig carries the value to set into the datastore.
     See the documentation on the TagConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class TagConfigSetResponse(aristaproto.Message):
    value: "TagConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the TagConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class TagConfigSetSomeRequest(aristaproto.Message):
    values: List["TagConfig"] = aristaproto.message_field(1)
    """
    value contains a list of TagConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class TagConfigSetSomeResponse(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class TagConfigDeleteRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key indicates which TagConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class TagConfigDeleteResponse(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted TagConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class TagConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["TagKey"] = aristaproto.message_field(1)
    """key contains a list of TagConfig keys to delete"""


@dataclass(eq=False, repr=False)
class TagConfigDeleteSomeResponse(aristaproto.Message):
    """TagConfigDeleteSomeResponse is only sent when there is an error."""

    key: "TagKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class TagConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["TagConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class TagConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TagKey" = aristaproto.message_field(3)
    """This is the key of the TagConfig instance that failed to be deleted."""

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class TagServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        tag_request: "TagRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagService/GetOne",
            tag_request,
            TagResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        tag_some_request: "TagSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagService/GetSome",
            tag_some_request,
            TagSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        tag_stream_request: "TagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagService/GetAll",
            tag_stream_request,
            TagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        tag_stream_request: "TagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagService/Subscribe",
            tag_stream_request,
            TagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        tag_stream_request: "TagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagService/GetMeta",
            tag_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        tag_stream_request: "TagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagService/SubscribeMeta",
            tag_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        tag_batched_stream_request: "TagBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagService/GetAllBatched",
            tag_batched_stream_request,
            TagBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        tag_batched_stream_request: "TagBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagService/SubscribeBatched",
            tag_batched_stream_request,
            TagBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class TagAssignmentServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        tag_assignment_request: "TagAssignmentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagAssignmentResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagAssignmentService/GetOne",
            tag_assignment_request,
            TagAssignmentResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        tag_assignment_some_request: "TagAssignmentSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentService/GetSome",
            tag_assignment_some_request,
            TagAssignmentSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        tag_assignment_stream_request: "TagAssignmentStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentService/GetAll",
            tag_assignment_stream_request,
            TagAssignmentStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        tag_assignment_stream_request: "TagAssignmentStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentService/Subscribe",
            tag_assignment_stream_request,
            TagAssignmentStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        tag_assignment_stream_request: "TagAssignmentStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagAssignmentService/GetMeta",
            tag_assignment_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        tag_assignment_stream_request: "TagAssignmentStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentService/SubscribeMeta",
            tag_assignment_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        tag_assignment_batched_stream_request: "TagAssignmentBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentService/GetAllBatched",
            tag_assignment_batched_stream_request,
            TagAssignmentBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        tag_assignment_batched_stream_request: "TagAssignmentBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentService/SubscribeBatched",
            tag_assignment_batched_stream_request,
            TagAssignmentBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class TagAssignmentConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        tag_assignment_config_request: "TagAssignmentConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagAssignmentConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagAssignmentConfigService/GetOne",
            tag_assignment_config_request,
            TagAssignmentConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        tag_assignment_config_some_request: "TagAssignmentConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/GetSome",
            tag_assignment_config_some_request,
            TagAssignmentConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/GetAll",
            tag_assignment_config_stream_request,
            TagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/Subscribe",
            tag_assignment_config_stream_request,
            TagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagAssignmentConfigService/GetMeta",
            tag_assignment_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/SubscribeMeta",
            tag_assignment_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        tag_assignment_config_set_request: "TagAssignmentConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagAssignmentConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagAssignmentConfigService/Set",
            tag_assignment_config_set_request,
            TagAssignmentConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        tag_assignment_config_set_some_request: "TagAssignmentConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/SetSome",
            tag_assignment_config_set_some_request,
            TagAssignmentConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        tag_assignment_config_delete_request: "TagAssignmentConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagAssignmentConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagAssignmentConfigService/Delete",
            tag_assignment_config_delete_request,
            TagAssignmentConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        tag_assignment_config_delete_some_request: "TagAssignmentConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/DeleteSome",
            tag_assignment_config_delete_some_request,
            TagAssignmentConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        tag_assignment_config_delete_all_request: "TagAssignmentConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/DeleteAll",
            tag_assignment_config_delete_all_request,
            TagAssignmentConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        tag_assignment_config_batched_stream_request: "TagAssignmentConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/GetAllBatched",
            tag_assignment_config_batched_stream_request,
            TagAssignmentConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        tag_assignment_config_batched_stream_request: "TagAssignmentConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagAssignmentConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagAssignmentConfigService/SubscribeBatched",
            tag_assignment_config_batched_stream_request,
            TagAssignmentConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class TagConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        tag_config_request: "TagConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagConfigService/GetOne",
            tag_config_request,
            TagConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        tag_config_some_request: "TagConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/GetSome",
            tag_config_some_request,
            TagConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        tag_config_stream_request: "TagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/GetAll",
            tag_config_stream_request,
            TagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        tag_config_stream_request: "TagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/Subscribe",
            tag_config_stream_request,
            TagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        tag_config_stream_request: "TagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagConfigService/GetMeta",
            tag_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        tag_config_stream_request: "TagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/SubscribeMeta",
            tag_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        tag_config_set_request: "TagConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagConfigService/Set",
            tag_config_set_request,
            TagConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        tag_config_set_some_request: "TagConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/SetSome",
            tag_config_set_some_request,
            TagConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        tag_config_delete_request: "TagConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TagConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v2.TagConfigService/Delete",
            tag_config_delete_request,
            TagConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        tag_config_delete_some_request: "TagConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/DeleteSome",
            tag_config_delete_some_request,
            TagConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        tag_config_delete_all_request: "TagConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/DeleteAll",
            tag_config_delete_all_request,
            TagConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        tag_config_batched_stream_request: "TagConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/GetAllBatched",
            tag_config_batched_stream_request,
            TagConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        tag_config_batched_stream_request: "TagConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TagConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v2.TagConfigService/SubscribeBatched",
            tag_config_batched_stream_request,
            TagConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class TagServiceBase(ServiceBase):

    async def get_one(self, tag_request: "TagRequest") -> "TagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, tag_some_request: "TagSomeRequest"
    ) -> AsyncIterator["TagSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, tag_stream_request: "TagStreamRequest"
    ) -> AsyncIterator["TagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, tag_stream_request: "TagStreamRequest"
    ) -> AsyncIterator["TagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(self, tag_stream_request: "TagStreamRequest") -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, tag_stream_request: "TagStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, tag_batched_stream_request: "TagBatchedStreamRequest"
    ) -> AsyncIterator["TagBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, tag_batched_stream_request: "TagBatchedStreamRequest"
    ) -> AsyncIterator["TagBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[TagRequest, TagResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self, stream: "grpclib.server.Stream[TagSomeRequest, TagSomeResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[TagStreamRequest, TagStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[TagStreamRequest, TagStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[TagStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[TagStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[TagBatchedStreamRequest, TagBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[TagBatchedStreamRequest, TagBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v2.TagService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagRequest,
                TagResponse,
            ),
            "/arista.tag.v2.TagService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagSomeRequest,
                TagSomeResponse,
            ),
            "/arista.tag.v2.TagService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagStreamRequest,
                TagStreamResponse,
            ),
            "/arista.tag.v2.TagService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagStreamRequest,
                TagStreamResponse,
            ),
            "/arista.tag.v2.TagService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagBatchedStreamRequest,
                TagBatchedStreamResponse,
            ),
            "/arista.tag.v2.TagService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagBatchedStreamRequest,
                TagBatchedStreamResponse,
            ),
        }


class TagAssignmentServiceBase(ServiceBase):

    async def get_one(
        self, tag_assignment_request: "TagAssignmentRequest"
    ) -> "TagAssignmentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, tag_assignment_some_request: "TagAssignmentSomeRequest"
    ) -> AsyncIterator["TagAssignmentSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, tag_assignment_stream_request: "TagAssignmentStreamRequest"
    ) -> AsyncIterator["TagAssignmentStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, tag_assignment_stream_request: "TagAssignmentStreamRequest"
    ) -> AsyncIterator["TagAssignmentStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, tag_assignment_stream_request: "TagAssignmentStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, tag_assignment_stream_request: "TagAssignmentStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, tag_assignment_batched_stream_request: "TagAssignmentBatchedStreamRequest"
    ) -> AsyncIterator["TagAssignmentBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, tag_assignment_batched_stream_request: "TagAssignmentBatchedStreamRequest"
    ) -> AsyncIterator["TagAssignmentBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[TagAssignmentRequest, TagAssignmentResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[TagAssignmentSomeRequest, TagAssignmentSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[TagAssignmentStreamRequest, TagAssignmentStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[TagAssignmentStreamRequest, TagAssignmentStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[TagAssignmentStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[TagAssignmentStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[TagAssignmentBatchedStreamRequest, TagAssignmentBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[TagAssignmentBatchedStreamRequest, TagAssignmentBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v2.TagAssignmentService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagAssignmentRequest,
                TagAssignmentResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentSomeRequest,
                TagAssignmentSomeResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentStreamRequest,
                TagAssignmentStreamResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentStreamRequest,
                TagAssignmentStreamResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagAssignmentStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentBatchedStreamRequest,
                TagAssignmentBatchedStreamResponse,
            ),
            "/arista.tag.v2.TagAssignmentService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentBatchedStreamRequest,
                TagAssignmentBatchedStreamResponse,
            ),
        }


class TagAssignmentConfigServiceBase(ServiceBase):

    async def get_one(
        self, tag_assignment_config_request: "TagAssignmentConfigRequest"
    ) -> "TagAssignmentConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, tag_assignment_config_some_request: "TagAssignmentConfigSomeRequest"
    ) -> AsyncIterator["TagAssignmentConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest"
    ) -> AsyncIterator["TagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest"
    ) -> AsyncIterator["TagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, tag_assignment_config_stream_request: "TagAssignmentConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, tag_assignment_config_set_request: "TagAssignmentConfigSetRequest"
    ) -> "TagAssignmentConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self,
        tag_assignment_config_set_some_request: "TagAssignmentConfigSetSomeRequest",
    ) -> AsyncIterator["TagAssignmentConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, tag_assignment_config_delete_request: "TagAssignmentConfigDeleteRequest"
    ) -> "TagAssignmentConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        tag_assignment_config_delete_some_request: "TagAssignmentConfigDeleteSomeRequest",
    ) -> AsyncIterator["TagAssignmentConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        tag_assignment_config_delete_all_request: "TagAssignmentConfigDeleteAllRequest",
    ) -> AsyncIterator["TagAssignmentConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        tag_assignment_config_batched_stream_request: "TagAssignmentConfigBatchedStreamRequest",
    ) -> AsyncIterator["TagAssignmentConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        tag_assignment_config_batched_stream_request: "TagAssignmentConfigBatchedStreamRequest",
    ) -> AsyncIterator["TagAssignmentConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigRequest, TagAssignmentConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigSomeRequest, TagAssignmentConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigStreamRequest, TagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigStreamRequest, TagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigSetRequest, TagAssignmentConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigSetSomeRequest, TagAssignmentConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigDeleteRequest, TagAssignmentConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigDeleteSomeRequest, TagAssignmentConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigDeleteAllRequest, TagAssignmentConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigBatchedStreamRequest, TagAssignmentConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[TagAssignmentConfigBatchedStreamRequest, TagAssignmentConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v2.TagAssignmentConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagAssignmentConfigRequest,
                TagAssignmentConfigResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigSomeRequest,
                TagAssignmentConfigSomeResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigStreamRequest,
                TagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigStreamRequest,
                TagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagAssignmentConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagAssignmentConfigSetRequest,
                TagAssignmentConfigSetResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigSetSomeRequest,
                TagAssignmentConfigSetSomeResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagAssignmentConfigDeleteRequest,
                TagAssignmentConfigDeleteResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigDeleteSomeRequest,
                TagAssignmentConfigDeleteSomeResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigDeleteAllRequest,
                TagAssignmentConfigDeleteAllResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigBatchedStreamRequest,
                TagAssignmentConfigBatchedStreamResponse,
            ),
            "/arista.tag.v2.TagAssignmentConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagAssignmentConfigBatchedStreamRequest,
                TagAssignmentConfigBatchedStreamResponse,
            ),
        }


class TagConfigServiceBase(ServiceBase):

    async def get_one(
        self, tag_config_request: "TagConfigRequest"
    ) -> "TagConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, tag_config_some_request: "TagConfigSomeRequest"
    ) -> AsyncIterator["TagConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, tag_config_stream_request: "TagConfigStreamRequest"
    ) -> AsyncIterator["TagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, tag_config_stream_request: "TagConfigStreamRequest"
    ) -> AsyncIterator["TagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, tag_config_stream_request: "TagConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, tag_config_stream_request: "TagConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, tag_config_set_request: "TagConfigSetRequest"
    ) -> "TagConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, tag_config_set_some_request: "TagConfigSetSomeRequest"
    ) -> AsyncIterator["TagConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, tag_config_delete_request: "TagConfigDeleteRequest"
    ) -> "TagConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, tag_config_delete_some_request: "TagConfigDeleteSomeRequest"
    ) -> AsyncIterator["TagConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, tag_config_delete_all_request: "TagConfigDeleteAllRequest"
    ) -> AsyncIterator["TagConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, tag_config_batched_stream_request: "TagConfigBatchedStreamRequest"
    ) -> AsyncIterator["TagConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, tag_config_batched_stream_request: "TagConfigBatchedStreamRequest"
    ) -> AsyncIterator["TagConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[TagConfigRequest, TagConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[TagConfigSomeRequest, TagConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[TagConfigStreamRequest, TagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[TagConfigStreamRequest, TagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[TagConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[TagConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self, stream: "grpclib.server.Stream[TagConfigSetRequest, TagConfigSetResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[TagConfigSetSomeRequest, TagConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[TagConfigDeleteRequest, TagConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[TagConfigDeleteSomeRequest, TagConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[TagConfigDeleteAllRequest, TagConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[TagConfigBatchedStreamRequest, TagConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[TagConfigBatchedStreamRequest, TagConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v2.TagConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagConfigRequest,
                TagConfigResponse,
            ),
            "/arista.tag.v2.TagConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigSomeRequest,
                TagConfigSomeResponse,
            ),
            "/arista.tag.v2.TagConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigStreamRequest,
                TagConfigStreamResponse,
            ),
            "/arista.tag.v2.TagConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigStreamRequest,
                TagConfigStreamResponse,
            ),
            "/arista.tag.v2.TagConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.tag.v2.TagConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagConfigSetRequest,
                TagConfigSetResponse,
            ),
            "/arista.tag.v2.TagConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigSetSomeRequest,
                TagConfigSetSomeResponse,
            ),
            "/arista.tag.v2.TagConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                TagConfigDeleteRequest,
                TagConfigDeleteResponse,
            ),
            "/arista.tag.v2.TagConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigDeleteSomeRequest,
                TagConfigDeleteSomeResponse,
            ),
            "/arista.tag.v2.TagConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigDeleteAllRequest,
                TagConfigDeleteAllResponse,
            ),
            "/arista.tag.v2.TagConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigBatchedStreamRequest,
                TagConfigBatchedStreamResponse,
            ),
            "/arista.tag.v2.TagConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                TagConfigBatchedStreamRequest,
                TagConfigBatchedStreamResponse,
            ),
        }
