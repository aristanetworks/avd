# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.

from typing import Any, ClassVar

from pyavd._eos_cli_config_gen.schema import EosCliConfigGen
from pyavd._schema.loader import coerce_type
from pyavd._schema.models import AvdCollection, AvdModel
from pyavd._utils import Undefined, UndefinedType


class EosDesigns(AvdModel):
    class ApplicationClassification(EosCliConfigGen.ApplicationTrafficRecognition):
        pass

    class BfdMultihop(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "min_rx", "multiplier")
        _custom_data: dict[str, Any]
        interval: int
        min_rx: int
        multiplier: int

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            interval: int | UndefinedType = Undefined,
            min_rx: int | UndefinedType = Undefined,
            multiplier: int | UndefinedType = Undefined,
        ) -> None:
            """
            BfdMultihop.

            Args:
            -----
                _custom_data: _custom_data
                interval: interval
                min_rx: min_rx
                multiplier: multiplier

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class BgpDistance(EosCliConfigGen.RouterBgp.Distance):
        pass

    class BgpGracefulRestart(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}, "restart_time": {"type": int, "default": 300}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool
        """Enable or disable graceful-restart for all BGP peers."""
        restart_time: int | None
        """Restart time in seconds."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | UndefinedType = Undefined,
            restart_time: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            BgpGracefulRestart.

            Args:
            -----
                _custom_data: _custom_data
                enabled: Enable or disable graceful-restart for all BGP peers.
                restart_time: Restart time in seconds.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class BgpPeerGroups(AvdModel):
        class Ipv4UnderlayPeers(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "IPv4-UNDERLAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": False},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv4UnderlayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MlagIpv4UnderlayPeer(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "MLAG-IPv4-UNDERLAY-PEER"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": False},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                MlagIpv4UnderlayPeer.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EvpnOverlayPeers(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "EVPN-OVERLAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                EvpnOverlayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EvpnOverlayCore(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "EVPN-OVERLAY-CORE"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                EvpnOverlayCore.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MplsOverlayPeers(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "MPLS-OVERLAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                MplsOverlayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RrOverlayPeers(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "RR-OVERLAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                RrOverlayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpvpnGatewayPeers(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "IPVPN-GATEWAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """Type 7 encrypted password."""
            bfd: bool | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                IpvpnGatewayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password: Type 7 encrypted password.
                    bfd: bfd
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class WanOverlayPeers(AvdModel):
            class BfdTimers(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "interval": {"type": int, "default": 1000},
                    "min_rx": {"type": int, "default": 1000},
                    "multiplier": {"type": int, "default": 10},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | UndefinedType = Undefined,
                    min_rx: int | UndefinedType = Undefined,
                    multiplier: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    BfdTimers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "WAN-OVERLAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "bfd_timers": {"type": BfdTimers},
                "listen_range_prefixes": {"type": list, "items": str},
                "ttl_maximum_hops": {"type": int, "default": 1},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """
            Type 7 encrypted password.
            When configuring a password on the `wan_overlay_peers` BGP peer group,
            it
            may also be required to set a password for the `wan_rr_overlay_peers` BGP peer group.
            This is
            required in the case where one or more pathfinders use the same VTEP IP range as the edge routers.
            If the password is not set, the static BGP peerings between Pathfinders may not come up.
            """
            bfd: bool | None
            bfd_timers: BfdTimers
            """
            Specify the BFD timers to override the default values.
            It is recommended to keep BFD total timeout
            longer than the DPS timeout.
            The Default BFD timeout is 10 x 1 seconds and the default DPS timeout
            is 5 x 1 seconds.
            """
            listen_range_prefixes: list[str]
            """
            Only used for nodes where `wan_role` is `server` like AutoVPN RRs and Pathfinders.
            For clients, AVD
            will raise an error if the Loopback0 IP is not in any listen range.
            """
            ttl_maximum_hops: int | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                bfd_timers: BfdTimers | UndefinedType = Undefined,
                listen_range_prefixes: list[str] | UndefinedType = Undefined,
                ttl_maximum_hops: int | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                WanOverlayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password:
                       Type 7 encrypted password.
                       When configuring a password on the `wan_overlay_peers` BGP peer group,
                       it
                       may also be required to set a password for the `wan_rr_overlay_peers` BGP peer group.
                       This is
                       required in the case where one or more pathfinders use the same VTEP IP range as the edge routers.
                       If the password is not set, the static BGP peerings between Pathfinders may not come up.
                    bfd: bfd
                    bfd_timers:
                       Specify the BFD timers to override the default values.
                       It is recommended to keep BFD total timeout
                       longer than the DPS timeout.
                       The Default BFD timeout is 10 x 1 seconds and the default DPS timeout
                       is 5 x 1 seconds.
                    listen_range_prefixes:
                       Only used for nodes where `wan_role` is `server` like AutoVPN RRs and Pathfinders.
                       For clients, AVD
                       will raise an error if the Loopback0 IP is not in any listen range.
                    ttl_maximum_hops: ttl_maximum_hops
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class WanRrOverlayPeers(AvdModel):
            class BfdTimers(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "interval": {"type": int, "default": 1000},
                    "min_rx": {"type": int, "default": 1000},
                    "multiplier": {"type": int, "default": 10},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | UndefinedType = Undefined,
                    min_rx: int | UndefinedType = Undefined,
                    multiplier: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    BfdTimers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StructuredConfig(EosCliConfigGen.RouterBgp.PeerGroupsItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str, "default": "WAN-RR-OVERLAY-PEERS"},
                "password": {"type": str},
                "bfd": {"type": bool, "default": True},
                "bfd_timers": {"type": BfdTimers},
                "ttl_maximum_hops": {"type": int, "default": 1},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Name of peer group."""
            password: str | None
            """
            Type 7 encrypted password.
            When configuring a password on the `wan_overlay_peers` BGP peer group,
            it
            may also be required to set a password for the `wan_rr_overlay_peers` BGP peer group.
            This is
            required in the case where one or more pathfinders use the same VTEP IP range as the edge routers.
            If the password is not set, the static BGP peerings between Pathfinders may not come up.
            """
            bfd: bool | None
            bfd_timers: BfdTimers
            """
            Specify the BFD timers to override the default values.
            It is recommended to keep BFD total timeout
            longer than the DPS timeout.
            The Default BFD timeout is 10 x 1 seconds and the default DPS timeout
            is 5 x 1 seconds.
            """
            ttl_maximum_hops: int | None
            structured_config: StructuredConfig
            """Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                bfd_timers: BfdTimers | UndefinedType = Undefined,
                ttl_maximum_hops: int | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                WanRrOverlayPeers.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of peer group.
                    password:
                       Type 7 encrypted password.
                       When configuring a password on the `wan_overlay_peers` BGP peer group,
                       it
                       may also be required to set a password for the `wan_rr_overlay_peers` BGP peer group.
                       This is
                       required in the case where one or more pathfinders use the same VTEP IP range as the edge routers.
                       If the password is not set, the static BGP peerings between Pathfinders may not come up.
                    bfd: bfd
                    bfd_timers:
                       Specify the BFD timers to override the default values.
                       It is recommended to keep BFD total timeout
                       longer than the DPS timeout.
                       The Default BFD timeout is 10 x 1 seconds and the default DPS timeout
                       is 5 x 1 seconds.
                    ttl_maximum_hops: ttl_maximum_hops
                    structured_config: Custom structured config added under router_bgp.peer_groups.[name=<name>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "ipv4_underlay_peers": {"type": Ipv4UnderlayPeers},
            "mlag_ipv4_underlay_peer": {"type": MlagIpv4UnderlayPeer},
            "evpn_overlay_peers": {"type": EvpnOverlayPeers},
            "evpn_overlay_core": {"type": EvpnOverlayCore},
            "mpls_overlay_peers": {"type": MplsOverlayPeers},
            "rr_overlay_peers": {"type": RrOverlayPeers},
            "ipvpn_gateway_peers": {"type": IpvpnGatewayPeers},
            "wan_overlay_peers": {"type": WanOverlayPeers},
            "wan_rr_overlay_peers": {"type": WanRrOverlayPeers},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        ipv4_underlay_peers: Ipv4UnderlayPeers
        mlag_ipv4_underlay_peer: MlagIpv4UnderlayPeer
        evpn_overlay_peers: EvpnOverlayPeers
        evpn_overlay_core: EvpnOverlayCore
        mpls_overlay_peers: MplsOverlayPeers
        rr_overlay_peers: RrOverlayPeers
        ipvpn_gateway_peers: IpvpnGatewayPeers
        wan_overlay_peers: WanOverlayPeers
        wan_rr_overlay_peers: WanRrOverlayPeers
        """Configuration options for the peer-group created to peer between AutoVPN RRs or CV Pathfinders."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ipv4_underlay_peers: Ipv4UnderlayPeers | UndefinedType = Undefined,
            mlag_ipv4_underlay_peer: MlagIpv4UnderlayPeer | UndefinedType = Undefined,
            evpn_overlay_peers: EvpnOverlayPeers | UndefinedType = Undefined,
            evpn_overlay_core: EvpnOverlayCore | UndefinedType = Undefined,
            mpls_overlay_peers: MplsOverlayPeers | UndefinedType = Undefined,
            rr_overlay_peers: RrOverlayPeers | UndefinedType = Undefined,
            ipvpn_gateway_peers: IpvpnGatewayPeers | UndefinedType = Undefined,
            wan_overlay_peers: WanOverlayPeers | UndefinedType = Undefined,
            wan_rr_overlay_peers: WanRrOverlayPeers | UndefinedType = Undefined,
        ) -> None:
            """
            BgpPeerGroups.

            Args:
            -----
                _custom_data: _custom_data
                ipv4_underlay_peers: ipv4_underlay_peers
                mlag_ipv4_underlay_peer: mlag_ipv4_underlay_peer
                evpn_overlay_peers: evpn_overlay_peers
                evpn_overlay_core: evpn_overlay_core
                mpls_overlay_peers: mpls_overlay_peers
                rr_overlay_peers: rr_overlay_peers
                ipvpn_gateway_peers: ipvpn_gateway_peers
                wan_overlay_peers: wan_overlay_peers
                wan_rr_overlay_peers: Configuration options for the peer-group created to peer between AutoVPN RRs or CV Pathfinders.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ConnectedEndpointsKeysItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key": {"type": str}, "type": {"type": str}, "description": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "key")
        _custom_data: dict[str, Any]
        key: str
        type: str | None
        """Type used for documentation."""
        description: str | None
        """Description used for documentation."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            key: str | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            ConnectedEndpointsKeysItem.

            Args:
            -----
                _custom_data: _custom_data
                key: key
                type: Type used for documentation.
                description: Description used for documentation.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ConnectedEndpointsKeys(AvdCollection[str, ConnectedEndpointsKeysItem]):
        _primary_key: ClassVar[str] = "key"

    ConnectedEndpointsKeys._item_type = ConnectedEndpointsKeysItem

    class CoreInterfaces(AvdModel):
        class P2pLinksIpPoolsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "ipv4_pool": {"type": str},
                "prefix_size": {"type": int, "default": 31},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """P2P pool name."""
            ipv4_pool: str | None
            """IPv4 address/Mask."""
            prefix_size: int | None
            """Subnet mask size."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                ipv4_pool: str | None | UndefinedType = Undefined,
                prefix_size: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                P2pLinksIpPoolsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: P2P pool name.
                    ipv4_pool: IPv4 address/Mask.
                    prefix_size: Subnet mask size.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class P2pLinksIpPools(AvdCollection[str, P2pLinksIpPoolsItem]):
            _primary_key: ClassVar[str] = "name"

        P2pLinksIpPools._item_type = P2pLinksIpPoolsItem

        class P2pLinksProfilesItem(AvdModel):
            class Ptp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enable PTP."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ptp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable PTP.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class FlowTracking(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                name: str | None
                """Flow tracker name as defined in flow_tracking_settings."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracking.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        name: Flow tracker name as defined in flow_tracking_settings.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortChannel(AvdModel):
                class NodesChildInterfacesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "node": {"type": str},
                        "interfaces": {"type": list, "items": str},
                        "channel_id": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "node")
                    _custom_data: dict[str, Any]
                    node: str
                    interfaces: list[str]
                    """List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ]."""
                    channel_id: int | None
                    """
                    Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                    port channel.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        node: str | UndefinedType = Undefined,
                        interfaces: list[str] | UndefinedType = Undefined,
                        channel_id: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodesChildInterfacesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            node: node
                            interfaces: List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ].
                            channel_id:
                               Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                               port channel.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodesChildInterfaces(AvdCollection[str, NodesChildInterfacesItem]):
                    _primary_key: ClassVar[str] = "node"

                NodesChildInterfaces._item_type = NodesChildInterfacesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "description": {"type": str},
                    "mode": {"type": str, "default": "active"},
                    "nodes_child_interfaces": {"type": NodesChildInterfaces},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                description: str | None
                """
                Description or description template to be used on the port-channel interface.
                This can be a template
                using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                to/custom-descriptions-names.html#avd-string-formatter-syntax.
                The available template fields are:
                - `peer`: The name of the peer.
                  - `interface`: The local port-channel interface name.
                  -
                `peer_interface`: The port-channel interface on the peer.
                  - `port_channel_id`: The local port-
                channel ID.
                  - `peer_port_channel_id`: The ID of the port-channel on the peer.

                Falls back to the
                description on the `p2p_link` if set. Otherwise default description is set by
                `default_underlay_p2p_port_channel_description`.
                By default the description is templated from the
                name and port_channel interface of the peer.
                """
                mode: str | None
                nodes_child_interfaces: NodesChildInterfaces

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    nodes_child_interfaces: NodesChildInterfaces | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortChannel.

                    Args:
                    -----
                        _custom_data: _custom_data
                        description:
                           Description or description template to be used on the port-channel interface.
                           This can be a template
                           using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                           to/custom-descriptions-names.html#avd-string-formatter-syntax.
                           The available template fields are:
                           - `peer`: The name of the peer.
                             - `interface`: The local port-channel interface name.
                             -
                           `peer_interface`: The port-channel interface on the peer.
                             - `port_channel_id`: The local port-
                           channel ID.
                             - `peer_port_channel_id`: The ID of the port-channel on the peer.

                           Falls back to the
                           description on the `p2p_link` if set. Otherwise default description is set by
                           `default_underlay_p2p_port_channel_description`.
                           By default the description is templated from the
                           name and port_channel interface of the peer.
                        mode: mode
                        nodes_child_interfaces: nodes_child_interfaces

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "id": {"type": int},
                "speed": {"type": str},
                "ip_pool": {"type": str},
                "subnet": {"type": str},
                "ip": {"type": list, "items": str},
                "ipv6_enable": {"type": bool, "default": False},
                "nodes": {"type": list, "items": str},
                "interfaces": {"type": list, "items": str},
                "field_as": {"type": list, "key": "as", "items": str},
                "descriptions": {"type": list, "items": str},
                "include_in_underlay_protocol": {"type": bool, "default": True},
                "isis_hello_padding": {"type": bool, "default": False},
                "isis_metric": {"type": int},
                "isis_circuit_type": {"type": str},
                "isis_authentication_mode": {"type": str},
                "isis_authentication_key": {"type": str},
                "mpls_ip": {"type": bool},
                "mpls_ldp": {"type": bool},
                "mtu": {"type": int},
                "bfd": {"type": bool, "default": False},
                "ptp": {"type": Ptp},
                "sflow": {"type": bool},
                "underlay_multicast": {"type": bool, "default": False},
                "flow_tracking": {"type": FlowTracking},
                "qos_profile": {"type": str},
                "macsec_profile": {"type": str},
                "port_channel": {"type": PortChannel},
                "raw_eos_cli": {"type": str},
                "routing_protocol": {"type": str},
                "structured_config": {"type": dict},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """P2P profile name. Any variable supported under `p2p_links` can be inherited from a profile."""
            id: int | None
            """
            Unique id per subnet_summary. Used to calculate ip addresses.
            Required with ip_pool. ID starting
            from 1.
            """
            speed: str | None
            """
            Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
            <interface_speed>`.
            """
            ip_pool: str | None
            """
            P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
            link.
            """
            subnet: str | None
            """IPv4 address/Mask. Subnet used on this P2P link."""
            ip: list[str]
            """Specific IP addresses used on this P2P link."""
            ipv6_enable: bool | None
            """
            Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
            include_in_underlay_protocol).
            """
            nodes: list[str]
            """Nodes where this link should be configured."""
            interfaces: list[str]
            """Interfaces where this link should be configured and Required unless using port-channels."""
            field_as: list[str]
            """
            AS numbers for BGP.
            Required with bgp peering.
            """
            descriptions: list[str]
            """Interface descriptions."""
            include_in_underlay_protocol: bool | None
            """Add this interface to underlay routing protocol."""
            isis_hello_padding: bool | None
            isis_metric: int | None
            isis_circuit_type: str | None
            isis_authentication_mode: str | None
            isis_authentication_key: str | None
            """Type-7 encrypted password."""
            mpls_ip: bool | None
            """MPLS parameters. Default value is true if switch.mpls_lsr is true."""
            mpls_ldp: bool | None
            """MPLS parameters. Default value is true for ldp underlay variants, otherwise false."""
            mtu: int | None
            """MTU for this P2P link. Default value same as p2p_uplinks_mtu."""
            bfd: bool | None
            """Enable BFD (only considered for BGP)."""
            ptp: Ptp
            """PTP parameters."""
            sflow: bool | None
            """Enable sFlow. Overrides `fabric_sflow` setting."""
            underlay_multicast: bool | None
            """
            Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
            to be `true`.
            """
            flow_tracking: FlowTracking
            """Enable flow-tracking. Overrides `fabric_flow_tracking` setting."""
            qos_profile: str | None
            """QOS service profile."""
            macsec_profile: str | None
            """MAC security profile."""
            port_channel: PortChannel
            """Port-channel parameters."""
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the point-to-point interface in the final EOS configuration."""
            routing_protocol: str | None
            """
            Enables deviation of the routing protocol used on this link from the fabric underlay default.
            -
            ebgp: Enforce plain IPv4 BGP peering
            """
            structured_config: dict
            """
            Custom structured config for interfaces.
            Note! The content of this dictionary is _not_ validated by
            the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                id: int | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                ip_pool: str | None | UndefinedType = Undefined,
                subnet: str | None | UndefinedType = Undefined,
                ip: list[str] | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                nodes: list[str] | UndefinedType = Undefined,
                interfaces: list[str] | UndefinedType = Undefined,
                field_as: list[str] | UndefinedType = Undefined,
                descriptions: list[str] | UndefinedType = Undefined,
                include_in_underlay_protocol: bool | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_circuit_type: str | None | UndefinedType = Undefined,
                isis_authentication_mode: str | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                mpls_ip: bool | None | UndefinedType = Undefined,
                mpls_ldp: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                sflow: bool | None | UndefinedType = Undefined,
                underlay_multicast: bool | None | UndefinedType = Undefined,
                flow_tracking: FlowTracking | UndefinedType = Undefined,
                qos_profile: str | None | UndefinedType = Undefined,
                macsec_profile: str | None | UndefinedType = Undefined,
                port_channel: PortChannel | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                routing_protocol: str | None | UndefinedType = Undefined,
                structured_config: dict | UndefinedType = Undefined,
            ) -> None:
                """
                P2pLinksProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: P2P profile name. Any variable supported under `p2p_links` can be inherited from a profile.
                    id:
                       Unique id per subnet_summary. Used to calculate ip addresses.
                       Required with ip_pool. ID starting
                       from 1.
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    ip_pool:
                       P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
                       link.
                    subnet: IPv4 address/Mask. Subnet used on this P2P link.
                    ip: Specific IP addresses used on this P2P link.
                    ipv6_enable:
                       Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
                       include_in_underlay_protocol).
                    nodes: Nodes where this link should be configured.
                    interfaces: Interfaces where this link should be configured and Required unless using port-channels.
                    field_as:
                       AS numbers for BGP.
                       Required with bgp peering.
                    descriptions: Interface descriptions.
                    include_in_underlay_protocol: Add this interface to underlay routing protocol.
                    isis_hello_padding: isis_hello_padding
                    isis_metric: isis_metric
                    isis_circuit_type: isis_circuit_type
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    mpls_ip: MPLS parameters. Default value is true if switch.mpls_lsr is true.
                    mpls_ldp: MPLS parameters. Default value is true for ldp underlay variants, otherwise false.
                    mtu: MTU for this P2P link. Default value same as p2p_uplinks_mtu.
                    bfd: Enable BFD (only considered for BGP).
                    ptp: PTP parameters.
                    sflow: Enable sFlow. Overrides `fabric_sflow` setting.
                    underlay_multicast:
                       Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
                       to be `true`.
                    flow_tracking: Enable flow-tracking. Overrides `fabric_flow_tracking` setting.
                    qos_profile: QOS service profile.
                    macsec_profile: MAC security profile.
                    port_channel: Port-channel parameters.
                    raw_eos_cli: EOS CLI rendered directly on the point-to-point interface in the final EOS configuration.
                    routing_protocol:
                       Enables deviation of the routing protocol used on this link from the fabric underlay default.
                       -
                       ebgp: Enforce plain IPv4 BGP peering
                    structured_config:
                       Custom structured config for interfaces.
                       Note! The content of this dictionary is _not_ validated by
                       the schema, since it can be either ethernet_interfaces or port_channel_interfaces.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class P2pLinksProfiles(AvdCollection[str, P2pLinksProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        P2pLinksProfiles._item_type = P2pLinksProfilesItem

        class P2pLinksItem(AvdModel):
            class Ptp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enable PTP."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ptp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable PTP.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class FlowTracking(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                name: str | None
                """Flow tracker name as defined in flow_tracking_settings."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracking.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        name: Flow tracker name as defined in flow_tracking_settings.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortChannel(AvdModel):
                class NodesChildInterfacesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "node": {"type": str},
                        "interfaces": {"type": list, "items": str},
                        "channel_id": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "node")
                    _custom_data: dict[str, Any]
                    node: str
                    interfaces: list[str]
                    """List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ]."""
                    channel_id: int | None
                    """
                    Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                    port channel.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        node: str | UndefinedType = Undefined,
                        interfaces: list[str] | UndefinedType = Undefined,
                        channel_id: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodesChildInterfacesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            node: node
                            interfaces: List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ].
                            channel_id:
                               Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                               port channel.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodesChildInterfaces(AvdCollection[str, NodesChildInterfacesItem]):
                    _primary_key: ClassVar[str] = "node"

                NodesChildInterfaces._item_type = NodesChildInterfacesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "description": {"type": str},
                    "mode": {"type": str, "default": "active"},
                    "nodes_child_interfaces": {"type": NodesChildInterfaces},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                description: str | None
                """
                Description or description template to be used on the port-channel interface.
                This can be a template
                using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                to/custom-descriptions-names.html#avd-string-formatter-syntax.
                The available template fields are:
                - `peer`: The name of the peer.
                  - `interface`: The local port-channel interface name.
                  -
                `peer_interface`: The port-channel interface on the peer.
                  - `port_channel_id`: The local port-
                channel ID.
                  - `peer_port_channel_id`: The ID of the port-channel on the peer.

                Falls back to the
                description on the `p2p_link` if set. Otherwise default description is set by
                `default_underlay_p2p_port_channel_description`.
                By default the description is templated from the
                name and port_channel interface of the peer.
                """
                mode: str | None
                nodes_child_interfaces: NodesChildInterfaces

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    nodes_child_interfaces: NodesChildInterfaces | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortChannel.

                    Args:
                    -----
                        _custom_data: _custom_data
                        description:
                           Description or description template to be used on the port-channel interface.
                           This can be a template
                           using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                           to/custom-descriptions-names.html#avd-string-formatter-syntax.
                           The available template fields are:
                           - `peer`: The name of the peer.
                             - `interface`: The local port-channel interface name.
                             -
                           `peer_interface`: The port-channel interface on the peer.
                             - `port_channel_id`: The local port-
                           channel ID.
                             - `peer_port_channel_id`: The ID of the port-channel on the peer.

                           Falls back to the
                           description on the `p2p_link` if set. Otherwise default description is set by
                           `default_underlay_p2p_port_channel_description`.
                           By default the description is templated from the
                           name and port_channel interface of the peer.
                        mode: mode
                        nodes_child_interfaces: nodes_child_interfaces

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "nodes": {"type": list, "items": str},
                "profile": {"type": str},
                "id": {"type": int},
                "speed": {"type": str},
                "ip_pool": {"type": str},
                "subnet": {"type": str},
                "ip": {"type": list, "items": str},
                "ipv6_enable": {"type": bool, "default": False},
                "interfaces": {"type": list, "items": str},
                "field_as": {"type": list, "key": "as", "items": str},
                "descriptions": {"type": list, "items": str},
                "include_in_underlay_protocol": {"type": bool, "default": True},
                "isis_hello_padding": {"type": bool, "default": False},
                "isis_metric": {"type": int},
                "isis_circuit_type": {"type": str},
                "isis_authentication_mode": {"type": str},
                "isis_authentication_key": {"type": str},
                "mpls_ip": {"type": bool},
                "mpls_ldp": {"type": bool},
                "mtu": {"type": int},
                "bfd": {"type": bool, "default": False},
                "ptp": {"type": Ptp},
                "sflow": {"type": bool},
                "underlay_multicast": {"type": bool, "default": False},
                "flow_tracking": {"type": FlowTracking},
                "qos_profile": {"type": str},
                "macsec_profile": {"type": str},
                "port_channel": {"type": PortChannel},
                "raw_eos_cli": {"type": str},
                "routing_protocol": {"type": str},
                "structured_config": {"type": dict},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "nodes")
            _custom_data: dict[str, Any]
            nodes: list[str]
            """Nodes where this link should be configured."""
            profile: str | None
            """P2P profile name. Profile defined under p2p_profiles."""
            id: int | None
            """
            Unique id per subnet_summary. Used to calculate ip addresses.
            Required with ip_pool. ID starting
            from 1.
            """
            speed: str | None
            """
            Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
            <interface_speed>`.
            """
            ip_pool: str | None
            """
            P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
            link.
            """
            subnet: str | None
            """IPv4 address/Mask. Subnet used on this P2P link."""
            ip: list[str]
            """Specific IP addresses used on this P2P link."""
            ipv6_enable: bool | None
            """
            Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
            include_in_underlay_protocol).
            """
            interfaces: list[str]
            """Interfaces where this link should be configured and Required unless using port-channels."""
            field_as: list[str]
            """
            AS numbers for BGP.
            Required with bgp peering.
            """
            descriptions: list[str]
            """Interface descriptions."""
            include_in_underlay_protocol: bool | None
            """Add this interface to underlay routing protocol."""
            isis_hello_padding: bool | None
            isis_metric: int | None
            isis_circuit_type: str | None
            isis_authentication_mode: str | None
            isis_authentication_key: str | None
            """Type-7 encrypted password."""
            mpls_ip: bool | None
            """MPLS parameters. Default value is true if switch.mpls_lsr is true."""
            mpls_ldp: bool | None
            """MPLS parameters. Default value is true for ldp underlay variants, otherwise false."""
            mtu: int | None
            """MTU for this P2P link. Default value same as p2p_uplinks_mtu."""
            bfd: bool | None
            """Enable BFD (only considered for BGP)."""
            ptp: Ptp
            """PTP parameters."""
            sflow: bool | None
            """Enable sFlow. Overrides `fabric_sflow` setting."""
            underlay_multicast: bool | None
            """
            Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
            to be `true`.
            """
            flow_tracking: FlowTracking
            """Enable flow-tracking. Overrides `fabric_flow_tracking` setting."""
            qos_profile: str | None
            """QOS service profile."""
            macsec_profile: str | None
            """MAC security profile."""
            port_channel: PortChannel
            """Port-channel parameters."""
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the point-to-point interface in the final EOS configuration."""
            routing_protocol: str | None
            """
            Enables deviation of the routing protocol used on this link from the fabric underlay default.
            -
            ebgp: Enforce plain IPv4 BGP peering
            """
            structured_config: dict
            """
            Custom structured config for interfaces.
            Note! The content of this dictionary is _not_ validated by
            the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                nodes: list[str] | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                id: int | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                ip_pool: str | None | UndefinedType = Undefined,
                subnet: str | None | UndefinedType = Undefined,
                ip: list[str] | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                interfaces: list[str] | UndefinedType = Undefined,
                field_as: list[str] | UndefinedType = Undefined,
                descriptions: list[str] | UndefinedType = Undefined,
                include_in_underlay_protocol: bool | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_circuit_type: str | None | UndefinedType = Undefined,
                isis_authentication_mode: str | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                mpls_ip: bool | None | UndefinedType = Undefined,
                mpls_ldp: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                sflow: bool | None | UndefinedType = Undefined,
                underlay_multicast: bool | None | UndefinedType = Undefined,
                flow_tracking: FlowTracking | UndefinedType = Undefined,
                qos_profile: str | None | UndefinedType = Undefined,
                macsec_profile: str | None | UndefinedType = Undefined,
                port_channel: PortChannel | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                routing_protocol: str | None | UndefinedType = Undefined,
                structured_config: dict | UndefinedType = Undefined,
            ) -> None:
                """
                P2pLinksItem.

                Args:
                -----
                    _custom_data: _custom_data
                    nodes: Nodes where this link should be configured.
                    profile: P2P profile name. Profile defined under p2p_profiles.
                    id:
                       Unique id per subnet_summary. Used to calculate ip addresses.
                       Required with ip_pool. ID starting
                       from 1.
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    ip_pool:
                       P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
                       link.
                    subnet: IPv4 address/Mask. Subnet used on this P2P link.
                    ip: Specific IP addresses used on this P2P link.
                    ipv6_enable:
                       Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
                       include_in_underlay_protocol).
                    interfaces: Interfaces where this link should be configured and Required unless using port-channels.
                    field_as:
                       AS numbers for BGP.
                       Required with bgp peering.
                    descriptions: Interface descriptions.
                    include_in_underlay_protocol: Add this interface to underlay routing protocol.
                    isis_hello_padding: isis_hello_padding
                    isis_metric: isis_metric
                    isis_circuit_type: isis_circuit_type
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    mpls_ip: MPLS parameters. Default value is true if switch.mpls_lsr is true.
                    mpls_ldp: MPLS parameters. Default value is true for ldp underlay variants, otherwise false.
                    mtu: MTU for this P2P link. Default value same as p2p_uplinks_mtu.
                    bfd: Enable BFD (only considered for BGP).
                    ptp: PTP parameters.
                    sflow: Enable sFlow. Overrides `fabric_sflow` setting.
                    underlay_multicast:
                       Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
                       to be `true`.
                    flow_tracking: Enable flow-tracking. Overrides `fabric_flow_tracking` setting.
                    qos_profile: QOS service profile.
                    macsec_profile: MAC security profile.
                    port_channel: Port-channel parameters.
                    raw_eos_cli: EOS CLI rendered directly on the point-to-point interface in the final EOS configuration.
                    routing_protocol:
                       Enables deviation of the routing protocol used on this link from the fabric underlay default.
                       -
                       ebgp: Enforce plain IPv4 BGP peering
                    structured_config:
                       Custom structured config for interfaces.
                       Note! The content of this dictionary is _not_ validated by
                       the schema, since it can be either ethernet_interfaces or port_channel_interfaces.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "p2p_links_ip_pools": {"type": P2pLinksIpPools},
            "p2p_links_profiles": {"type": P2pLinksProfiles},
            "p2p_links": {"type": list, "items": P2pLinksItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        p2p_links_ip_pools: P2pLinksIpPools
        p2p_links_profiles: P2pLinksProfiles
        p2p_links: list[P2pLinksItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            p2p_links_ip_pools: P2pLinksIpPools | UndefinedType = Undefined,
            p2p_links_profiles: P2pLinksProfiles | UndefinedType = Undefined,
            p2p_links: list[P2pLinksItem] | UndefinedType = Undefined,
        ) -> None:
            """
            CoreInterfaces.

            Args:
            -----
                _custom_data: _custom_data
                p2p_links_ip_pools: p2p_links_ip_pools
                p2p_links_profiles: p2p_links_profiles
                p2p_links: p2p_links

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CvPathfinderGlobalSitesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "description": {"type": str}, "location": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """The site name."""
        description: str | None
        location: str | None
        """Location as a string is resolved on Cloudvision."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            location: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            CvPathfinderGlobalSitesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: The site name.
                description: description
                location: Location as a string is resolved on Cloudvision.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CvPathfinderGlobalSites(AvdCollection[str, CvPathfinderGlobalSitesItem]):
        _primary_key: ClassVar[str] = "name"

    CvPathfinderGlobalSites._item_type = CvPathfinderGlobalSitesItem

    class CvPathfinderInternetExitPoliciesItem(AvdModel):
        class Zscaler(AvdModel):
            class Firewall(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}, "ips": {"type": bool, "default": False}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enforce firewall controls."""
                ips: bool | None
                """Enable IPS Controls for the firewall."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    ips: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Firewall.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enforce firewall controls.
                        ips: Enable IPS Controls for the firewall.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipsec_key_salt": {"type": str},
                "domain_name": {"type": str},
                "encrypt_traffic": {"type": bool, "default": True},
                "download_bandwidth": {"type": int},
                "upload_bandwidth": {"type": int},
                "firewall": {"type": Firewall},
                "acceptable_use_policy": {"type": bool, "default": False},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipsec_key_salt", "domain_name")
            _custom_data: dict[str, Any]
            ipsec_key_salt: str
            """
            "Salt" used for auto generation of encryption keys for IPsec tunnels to Zscaler.
            The keys will be
            generated as a hash of `salt_<hostname>_<policy_name>`.
            Since this salt can be used to deduct the
            encryption key, it is recommended to use vault.
            """
            domain_name: str
            """Domain name as configured in Zscaler for the tenant. Used as UFQDN suffix for authentication."""
            encrypt_traffic: bool | None
            """
            When `true` the traffic going over the tunnels will be encrypted with AES-256-GCM. Otherwise the
            traffic will be using NULL encryption.
            Note that encryption requires a subscription on the Zscaler
            account.
            """
            download_bandwidth: int | None
            """Maximum allowed download bandwidth in Mbps for each device using this policy."""
            upload_bandwidth: int | None
            """Maximum allowed upload bandwidth in Mbps for each device using this policy."""
            firewall: Firewall
            acceptable_use_policy: bool | None
            """Display an Acceptable Use Policy (AUP) and require users to accept it."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipsec_key_salt: str | UndefinedType = Undefined,
                domain_name: str | UndefinedType = Undefined,
                encrypt_traffic: bool | None | UndefinedType = Undefined,
                download_bandwidth: int | None | UndefinedType = Undefined,
                upload_bandwidth: int | None | UndefinedType = Undefined,
                firewall: Firewall | UndefinedType = Undefined,
                acceptable_use_policy: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Zscaler.

                Args:
                -----
                    _custom_data: _custom_data
                    ipsec_key_salt:
                       "Salt" used for auto generation of encryption keys for IPsec tunnels to Zscaler.
                       The keys will be
                       generated as a hash of `salt_<hostname>_<policy_name>`.
                       Since this salt can be used to deduct the
                       encryption key, it is recommended to use vault.
                    domain_name: Domain name as configured in Zscaler for the tenant. Used as UFQDN suffix for authentication.
                    encrypt_traffic:
                       When `true` the traffic going over the tunnels will be encrypted with AES-256-GCM. Otherwise the
                       traffic will be using NULL encryption.
                       Note that encryption requires a subscription on the Zscaler
                       account.
                    download_bandwidth: Maximum allowed download bandwidth in Mbps for each device using this policy.
                    upload_bandwidth: Maximum allowed upload bandwidth in Mbps for each device using this policy.
                    firewall: firewall
                    acceptable_use_policy: Display an Acceptable Use Policy (AUP) and require users to accept it.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "type": {"type": str},
            "fallback_to_system_default": {"type": bool, "default": True},
            "zscaler": {"type": Zscaler},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "type")
        _custom_data: dict[str, Any]
        name: str
        """Internet-exit policy name."""
        type: str
        """
        Internet-exit policy type.
        direct: Exit directly over wan interfaces
        zscaler: Exit using Zscaler
        secure web gateway service
        """
        fallback_to_system_default: bool | None
        """Add system default exit-group at the end of the policy."""
        zscaler: Zscaler
        """Zscaler information. Only used if `type` is 'zscaler'."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            type: str | UndefinedType = Undefined,
            fallback_to_system_default: bool | None | UndefinedType = Undefined,
            zscaler: Zscaler | UndefinedType = Undefined,
        ) -> None:
            """
            CvPathfinderInternetExitPoliciesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Internet-exit policy name.
                type:
                   Internet-exit policy type.
                   direct: Exit directly over wan interfaces
                   zscaler: Exit using Zscaler
                   secure web gateway service
                fallback_to_system_default: Add system default exit-group at the end of the policy.
                zscaler: Zscaler information. Only used if `type` is 'zscaler'.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CvPathfinderInternetExitPolicies(AvdCollection[str, CvPathfinderInternetExitPoliciesItem]):
        _primary_key: ClassVar[str] = "name"

    CvPathfinderInternetExitPolicies._item_type = CvPathfinderInternetExitPoliciesItem

    class CvPathfinderRegionsItem(AvdModel):
        class SitesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "description": {"type": str},
                "id": {"type": int},
                "location": {"type": str},
                "site_contact": {"type": str},
                "site_after_hours_contact": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
            _custom_data: dict[str, Any]
            name: str
            """The site name."""
            description: str | None
            id: int
            """
            The site ID must be unique within a zone.
            Given that all the sites are placed in a zone named after
            the region, the site ID must be unique within a region.
            """
            location: str | None
            """Location as a string is resolved on Cloudvision."""
            site_contact: str | None
            site_after_hours_contact: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                location: str | None | UndefinedType = Undefined,
                site_contact: str | None | UndefinedType = Undefined,
                site_after_hours_contact: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                SitesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: The site name.
                    description: description
                    id:
                       The site ID must be unique within a zone.
                       Given that all the sites are placed in a zone named after
                       the region, the site ID must be unique within a region.
                    location: Location as a string is resolved on Cloudvision.
                    site_contact: site_contact
                    site_after_hours_contact: site_after_hours_contact

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sites(AvdCollection[str, SitesItem]):
            _primary_key: ClassVar[str] = "name"

        Sites._item_type = SitesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "id": {"type": int},
            "sites": {"type": Sites},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
        _custom_data: dict[str, Any]
        name: str
        description: str | None
        id: int
        """The region ID must be unique for the whole WAN deployment."""
        sites: Sites
        """All sites are placed in a default zone "<region_name>-ZONE" with ID 1."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            id: int | UndefinedType = Undefined,
            sites: Sites | UndefinedType = Undefined,
        ) -> None:
            """
            CvPathfinderRegionsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                description: description
                id: The region ID must be unique for the whole WAN deployment.
                sites: All sites are placed in a default zone "<region_name>-ZONE" with ID 1.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CvPathfinderRegions(AvdCollection[str, CvPathfinderRegionsItem]):
        _primary_key: ClassVar[str] = "name"

    CvPathfinderRegions._item_type = CvPathfinderRegionsItem

    class CvTopologyItem(AvdModel):
        class InterfacesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "neighbor": {"type": str}, "neighbor_interface": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            neighbor: str | None
            neighbor_interface: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                neighbor: str | None | UndefinedType = Undefined,
                neighbor_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                InterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    neighbor: neighbor
                    neighbor_interface: neighbor_interface

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Interfaces(AvdCollection[str, InterfacesItem]):
            _primary_key: ClassVar[str] = "name"

        Interfaces._item_type = InterfacesItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "hostname": {"type": str}, "platform": {"type": str}, "interfaces": {"type": Interfaces}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "platform", "interfaces")
        _custom_data: dict[str, Any]
        hostname: str
        platform: str
        interfaces: Interfaces

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            hostname: str | UndefinedType = Undefined,
            platform: str | UndefinedType = Undefined,
            interfaces: Interfaces | UndefinedType = Undefined,
        ) -> None:
            """
            CvTopologyItem.

            Args:
            -----
                _custom_data: _custom_data
                hostname: hostname
                platform: platform
                interfaces: interfaces

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CvTopology(AvdCollection[str, CvTopologyItem]):
        _primary_key: ClassVar[str] = "hostname"

    CvTopology._item_type = CvTopologyItem

    class DefaultInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "types": {"type": list, "items": str},
            "platforms": {"type": list, "items": str},
            "uplink_interfaces": {"type": list, "items": str},
            "mlag_interfaces": {"type": list, "items": str},
            "downlink_interfaces": {"type": list, "items": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "types", "platforms")
        _custom_data: dict[str, Any]
        types: list[str]
        """List of node type keys."""
        platforms: list[str]
        """
        List of platform families.
        This is defined as a Python regular expression that matches the full
        platform type.
        """
        uplink_interfaces: list[str]
        """List of uplink interfaces or uplink interface ranges."""
        mlag_interfaces: list[str]
        """List of MLAG interfaces or MLAG interface ranges."""
        downlink_interfaces: list[str]
        """List of downlink interfaces or downlink interface ranges."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            types: list[str] | UndefinedType = Undefined,
            platforms: list[str] | UndefinedType = Undefined,
            uplink_interfaces: list[str] | UndefinedType = Undefined,
            mlag_interfaces: list[str] | UndefinedType = Undefined,
            downlink_interfaces: list[str] | UndefinedType = Undefined,
        ) -> None:
            """
            DefaultInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                types: List of node type keys.
                platforms:
                   List of platform families.
                   This is defined as a Python regular expression that matches the full
                   platform type.
                uplink_interfaces: List of uplink interfaces or uplink interface ranges.
                mlag_interfaces: List of MLAG interfaces or MLAG interface ranges.
                downlink_interfaces: List of downlink interfaces or downlink interface ranges.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DefaultNodeTypesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "node_type": {"type": str}, "match_hostnames": {"type": list, "items": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "node_type", "match_hostnames")
        _custom_data: dict[str, Any]
        node_type: str
        """Resulting node type when regex matches."""
        match_hostnames: list[str]
        """Regular expressions to match against hostnames."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            node_type: str | UndefinedType = Undefined,
            match_hostnames: list[str] | UndefinedType = Undefined,
        ) -> None:
            """
            DefaultNodeTypesItem.

            Args:
            -----
                _custom_data: _custom_data
                node_type: Resulting node type when regex matches.
                match_hostnames: Regular expressions to match against hostnames.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DefaultNodeTypes(AvdCollection[str, DefaultNodeTypesItem]):
        _primary_key: ClassVar[str] = "node_type"

    DefaultNodeTypes._item_type = DefaultNodeTypesItem

    class Design(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str, "default": "l3ls-evpn"}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        type: str | None
        """
        By setting the design.type variable, the default node-types and templates described in these
        documents will be used.
        """

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, type: str | None | UndefinedType = Undefined) -> None:
            """
            Design.

            Args:
            -----
                _custom_data: _custom_data
                type:
                   By setting the design.type variable, the default node-types and templates described in these
                   documents will be used.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EosDesignsCustomTemplatesItem(AvdModel):
        class Options(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "list_merge": {"type": str, "default": "append_rp"},
                "strip_empty_keys": {"type": bool, "default": True},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            list_merge: str | None
            """Merge strategy for lists."""
            strip_empty_keys: bool | None
            """Filter out keys from the generated output if value is null/none/undefined."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                list_merge: str | None | UndefinedType = Undefined,
                strip_empty_keys: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Options.

                Args:
                -----
                    _custom_data: _custom_data
                    list_merge: Merge strategy for lists.
                    strip_empty_keys: Filter out keys from the generated output if value is null/none/undefined.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "template": {"type": str}, "options": {"type": Options}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "template")
        _custom_data: dict[str, Any]
        template: str
        """Template file."""
        options: Options
        """Template options."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            template: str | UndefinedType = Undefined,
            options: Options | UndefinedType = Undefined,
        ) -> None:
            """
            EosDesignsCustomTemplatesItem.

            Args:
            -----
                _custom_data: _custom_data
                template: Template file.
                options: Template options.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EosDesignsDocumentation(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enable": {"type": bool, "default": True},
            "connected_endpoints": {"type": bool, "default": False},
            "topology_csv": {"type": bool, "default": False},
            "p2p_links_csv": {"type": bool, "default": False},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable: bool | None
        """Generate fabric-wide documentation."""
        connected_endpoints: bool | None
        """
        Include connected endpoints in the fabric-wide documentation.
        This is `false` by default to avoid
        cluttering documentation for projects with thousands of endpoints.
        """
        topology_csv: bool | None
        """Generate Topology CSV with all interfaces towards other devices."""
        p2p_links_csv: bool | None
        """Generate P2P links CSV with all routed point-to-point links between devices."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enable: bool | None | UndefinedType = Undefined,
            connected_endpoints: bool | None | UndefinedType = Undefined,
            topology_csv: bool | None | UndefinedType = Undefined,
            p2p_links_csv: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            EosDesignsDocumentation.

            Args:
            -----
                _custom_data: _custom_data
                enable: Generate fabric-wide documentation.
                connected_endpoints:
                   Include connected endpoints in the fabric-wide documentation.
                   This is `false` by default to avoid
                   cluttering documentation for projects with thousands of endpoints.
                topology_csv: Generate Topology CSV with all interfaces towards other devices.
                p2p_links_csv: Generate P2P links CSV with all routed point-to-point links between devices.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EventHandlersItem(AvdModel):
        class Actions(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bash_command": {"type": str},
                "log": {"type": bool},
                "increment_device_health_metric": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bash_command: str | None
            """Define BASH command action. Command could be multiline also."""
            log: bool | None
            """Log a message when the event is triggered."""
            increment_device_health_metric: str | None
            """Name of device-health metric."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bash_command: str | None | UndefinedType = Undefined,
                log: bool | None | UndefinedType = Undefined,
                increment_device_health_metric: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Actions.

                Args:
                -----
                    _custom_data: _custom_data
                    bash_command: Define BASH command action. Command could be multiline also.
                    log: Log a message when the event is triggered.
                    increment_device_health_metric: Name of device-health metric.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnCounters(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "condition": {"type": str},
                "granularity_per_source": {"type": bool},
                "poll_interval": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            condition: str | None
            """Set the logical expression to evaluate."""
            granularity_per_source: bool | None
            """
            Set the granularity of event counting for a wildcarded condition.
            Example -
              condition (
            Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
              [* wildcard is used
            here]
            """
            poll_interval: int | None
            """Set the polling interval in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                condition: str | None | UndefinedType = Undefined,
                granularity_per_source: bool | None | UndefinedType = Undefined,
                poll_interval: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnCounters.

                Args:
                -----
                    _custom_data: _custom_data
                    condition: Set the logical expression to evaluate.
                    granularity_per_source:
                       Set the granularity of event counting for a wildcarded condition.
                       Example -
                         condition (
                       Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
                         [* wildcard is used
                       here]
                    poll_interval: Set the polling interval in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnLogging(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "poll_interval": {"type": int}, "regex": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            poll_interval: int | None
            """Set the polling interval in seconds."""
            regex: str | None
            """Regular expression to use for searching log messages."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                poll_interval: int | None | UndefinedType = Undefined,
                regex: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnLogging.

                Args:
                -----
                    _custom_data: _custom_data
                    poll_interval: Set the polling interval in seconds.
                    regex: Regular expression to use for searching log messages.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnIntf(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "interface": {"type": str},
                "ip": {"type": bool},
                "ipv6": {"type": bool},
                "operstatus": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "interface")
            _custom_data: dict[str, Any]
            interface: str
            """
            Interface name.
            Example - Ethernet4
                      Loopback4-6
                      Port-channel4,7
            """
            ip: bool | None
            """Action is triggered upon changes to interface IP address assignment."""
            ipv6: bool | None
            """Action is triggered upon changes to interface ipv6 address assignment."""
            operstatus: bool | None
            """Action is triggered upon changes to interface operStatus."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interface: str | UndefinedType = Undefined,
                ip: bool | None | UndefinedType = Undefined,
                ipv6: bool | None | UndefinedType = Undefined,
                operstatus: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnIntf.

                Args:
                -----
                    _custom_data: _custom_data
                    interface:
                       Interface name.
                       Example - Ethernet4
                                 Loopback4-6
                                 Port-channel4,7
                    ip: Action is triggered upon changes to interface IP address assignment.
                    ipv6: Action is triggered upon changes to interface ipv6 address assignment.
                    operstatus: Action is triggered upon changes to interface operStatus.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnMaintenance(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "operation": {"type": str},
                "bgp_peer": {"type": str},
                "action": {"type": str},
                "stage": {"type": str},
                "vrf": {"type": str},
                "interface": {"type": str},
                "unit": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "operation", "action")
            _custom_data: dict[str, Any]
            operation: str
            bgp_peer: str | None
            """
            Ipv4/Ipv6 address or peer group name.
            Trigger condition occurs on maintenance operation of specified
            BGP peer.
            """
            action: str
            """Action for maintenance operation."""
            stage: str | None
            """Action is triggered after/before specified stage."""
            vrf: str | None
            """VRF name. VRF can be defined for "bgp_peer" only."""
            interface: str | None
            """Trigger condition occurs on maintenance operation of specified interface."""
            unit: str | None
            """Name of unit. Trigger condition occurs on maintenance operation of specified unit"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                operation: str | UndefinedType = Undefined,
                bgp_peer: str | None | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
                stage: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                interface: str | None | UndefinedType = Undefined,
                unit: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnMaintenance.

                Args:
                -----
                    _custom_data: _custom_data
                    operation: operation
                    bgp_peer:
                       Ipv4/Ipv6 address or peer group name.
                       Trigger condition occurs on maintenance operation of specified
                       BGP peer.
                    action: Action for maintenance operation.
                    stage: Action is triggered after/before specified stage.
                    vrf: VRF name. VRF can be defined for "bgp_peer" only.
                    interface: Trigger condition occurs on maintenance operation of specified interface.
                    unit: Name of unit. Trigger condition occurs on maintenance operation of specified unit

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "actions": {"type": Actions},
            "delay": {"type": int},
            "trigger": {"type": str},
            "trigger_on_counters": {"type": TriggerOnCounters},
            "trigger_on_logging": {"type": TriggerOnLogging},
            "trigger_on_intf": {"type": TriggerOnIntf},
            "trigger_on_maintenance": {"type": TriggerOnMaintenance},
            "asynchronous": {"type": bool, "default": False},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Event Handler Name."""
        actions: Actions
        """Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`."""
        delay: int | None
        """Event-handler delay in seconds."""
        trigger: str | None
        """Configure event trigger condition."""
        trigger_on_counters: TriggerOnCounters
        trigger_on_logging: TriggerOnLogging
        trigger_on_intf: TriggerOnIntf
        """
        Trigger condition occurs on specified interface changes.
        Note: Any one of the `ip`, `ipv6` and
        `operstatus` key needs to be defined along with the `interface`.
        """
        trigger_on_maintenance: TriggerOnMaintenance
        """Settings required for trigger 'on-maintenance'."""
        asynchronous: bool | None
        """Set the action to be non-blocking."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            actions: Actions | UndefinedType = Undefined,
            delay: int | None | UndefinedType = Undefined,
            trigger: str | None | UndefinedType = Undefined,
            trigger_on_counters: TriggerOnCounters | UndefinedType = Undefined,
            trigger_on_logging: TriggerOnLogging | UndefinedType = Undefined,
            trigger_on_intf: TriggerOnIntf | UndefinedType = Undefined,
            trigger_on_maintenance: TriggerOnMaintenance | UndefinedType = Undefined,
            asynchronous: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            EventHandlersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Event Handler Name.
                actions: Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
                delay: Event-handler delay in seconds.
                trigger: Configure event trigger condition.
                trigger_on_counters: trigger_on_counters
                trigger_on_logging: trigger_on_logging
                trigger_on_intf:
                   Trigger condition occurs on specified interface changes.
                   Note: Any one of the `ip`, `ipv6` and
                   `operstatus` key needs to be defined along with the `interface`.
                trigger_on_maintenance: Settings required for trigger 'on-maintenance'.
                asynchronous: Set the action to be non-blocking.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EventHandlers(AvdCollection[str, EventHandlersItem]):
        _primary_key: ClassVar[str] = "name"

    EventHandlers._item_type = EventHandlersItem

    class EvpnHostflapDetection(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool, "default": True},
            "threshold": {"type": int, "default": 5},
            "window": {"type": int, "default": 180},
            "expiry_timeout": {"type": int},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None
        """If set to false it will disable EVPN host-flap detection."""
        threshold: int | None
        """Minimum number of MAC moves that indicate a MAC duplication issue."""
        window: int | None
        """Time (in seconds) to detect a MAC duplication issue."""
        expiry_timeout: int | None
        """Time (in seconds) to purge a MAC duplication issue."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            threshold: int | None | UndefinedType = Undefined,
            window: int | None | UndefinedType = Undefined,
            expiry_timeout: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            EvpnHostflapDetection.

            Args:
            -----
                _custom_data: _custom_data
                enabled: If set to false it will disable EVPN host-flap detection.
                threshold: Minimum number of MAC moves that indicate a MAC duplication issue.
                window: Time (in seconds) to detect a MAC duplication issue.
                expiry_timeout: Time (in seconds) to purge a MAC duplication issue.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EvpnVlanBundlesItem(AvdModel):
        class Bgp(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "raw_eos_cli": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            raw_eos_cli: str | None
            """EOS cli commands rendered on router_bgp.vlans-aware-bundle."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, raw_eos_cli: str | None | UndefinedType = Undefined) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    raw_eos_cli: EOS cli commands rendered on router_bgp.vlans-aware-bundle.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "id": {"type": int},
            "rt_override": {"type": str},
            "rd_override": {"type": str},
            "evpn_l2_multi_domain": {"type": bool},
            "bgp": {"type": Bgp},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
        _custom_data: dict[str, Any]
        name: str
        """
        Specify an EVPN vlan-aware-bundle name.
        EVPN vlan-aware-bundles group L2 VLANs and define common
        settings.
        """
        id: int
        """
        "id" may be used for vlan-aware-bundle RD/RT ID so it should not overlap with l2vlan IDs which are
        not part of this bundle.
        See "overlay_rd_type" and "overlay_rt_type" for details.
        """
        rt_override: str | None
        """
        By default the MAC VRF bundle RT will be derived from mac_vrf_id_base + bundle_id.
        The rt_override
        allows us to override this value and statically define it.
        rt_override will default to vni_override
        if set.

        rt_override supports two formats:
          - A single number which will be used in the RT fields
        instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
          - A full RT string with
        colon separator which will override the full RT.
        """
        rd_override: str | None
        """
        By default the MAC VRF bundle RD will be derived from mac_vrf_id_base + bundle_id.
        The rt_override
        allows us to override this value and statically define it.
        rd_override will default to rt_override
        or vni_override if set.

        rd_override supports two formats:
          - A single number which will be used in
        the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
        - A full RD string with colon separator which will override the full RD.
        """
        evpn_l2_multi_domain: bool | None
        """
        Explicitly extend VLAN-Aware Bundle to remote EVPN domains.
        Overrides
        `<network_services_key>.[].evpn_l2_multi_domain`.
        """
        bgp: Bgp

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            id: int | UndefinedType = Undefined,
            rt_override: str | None | UndefinedType = Undefined,
            rd_override: str | None | UndefinedType = Undefined,
            evpn_l2_multi_domain: bool | None | UndefinedType = Undefined,
            bgp: Bgp | UndefinedType = Undefined,
        ) -> None:
            """
            EvpnVlanBundlesItem.

            Args:
            -----
                _custom_data: _custom_data
                name:
                   Specify an EVPN vlan-aware-bundle name.
                   EVPN vlan-aware-bundles group L2 VLANs and define common
                   settings.
                id:
                   "id" may be used for vlan-aware-bundle RD/RT ID so it should not overlap with l2vlan IDs which are
                   not part of this bundle.
                   See "overlay_rd_type" and "overlay_rt_type" for details.
                rt_override:
                   By default the MAC VRF bundle RT will be derived from mac_vrf_id_base + bundle_id.
                   The rt_override
                   allows us to override this value and statically define it.
                   rt_override will default to vni_override
                   if set.

                   rt_override supports two formats:
                     - A single number which will be used in the RT fields
                   instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                     - A full RT string with
                   colon separator which will override the full RT.
                rd_override:
                   By default the MAC VRF bundle RD will be derived from mac_vrf_id_base + bundle_id.
                   The rt_override
                   allows us to override this value and statically define it.
                   rd_override will default to rt_override
                   or vni_override if set.

                   rd_override supports two formats:
                     - A single number which will be used in
                   the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                   - A full RD string with colon separator which will override the full RD.
                evpn_l2_multi_domain:
                   Explicitly extend VLAN-Aware Bundle to remote EVPN domains.
                   Overrides
                   `<network_services_key>.[].evpn_l2_multi_domain`.
                bgp: bgp

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EvpnVlanBundles(AvdCollection[str, EvpnVlanBundlesItem]):
        _primary_key: ClassVar[str] = "name"

    EvpnVlanBundles._item_type = EvpnVlanBundlesItem

    class FabricFlowTracking(AvdModel):
        class Uplinks(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Uplinks.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Downlinks(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Downlinks.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Endpoints(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Endpoints.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L3Edge(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                L3Edge.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CoreInterfaces(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                CoreInterfaces.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MlagInterfaces(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                MlagInterfaces.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L3Interfaces(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                L3Interfaces.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DpsInterfaces(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DpsInterfaces.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DirectWanHaLinks(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DirectWanHaLinks.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "uplinks": {"type": Uplinks},
            "downlinks": {"type": Downlinks},
            "endpoints": {"type": Endpoints},
            "l3_edge": {"type": L3Edge},
            "core_interfaces": {"type": CoreInterfaces},
            "mlag_interfaces": {"type": MlagInterfaces},
            "l3_interfaces": {"type": L3Interfaces},
            "dps_interfaces": {"type": DpsInterfaces},
            "direct_wan_ha_links": {"type": DirectWanHaLinks},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        uplinks: Uplinks
        """Enable flow-tracking on all fabric uplinks."""
        downlinks: Downlinks
        """Enable flow-tracking on all fabric downlinks."""
        endpoints: Endpoints
        """Enable flow-tracking on all endpoints ports."""
        l3_edge: L3Edge
        """Enable flow-tracking on all p2p_links defined under l3_edge."""
        core_interfaces: CoreInterfaces
        """Enable flow-tracking on all p2p_links defined under core_interfaces."""
        mlag_interfaces: MlagInterfaces
        """Enable flow-tracking on all MLAG peer interfaces."""
        l3_interfaces: L3Interfaces
        """Enable flow-tracking on all node.l3_interfaces and network-services tenants.vrfs.l3_interfaces."""
        dps_interfaces: DpsInterfaces
        """Enable flow-tracking on all dps_interfaces."""
        direct_wan_ha_links: DirectWanHaLinks
        """Enable flow-tracking on all direct WAN HA links."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            uplinks: Uplinks | UndefinedType = Undefined,
            downlinks: Downlinks | UndefinedType = Undefined,
            endpoints: Endpoints | UndefinedType = Undefined,
            l3_edge: L3Edge | UndefinedType = Undefined,
            core_interfaces: CoreInterfaces | UndefinedType = Undefined,
            mlag_interfaces: MlagInterfaces | UndefinedType = Undefined,
            l3_interfaces: L3Interfaces | UndefinedType = Undefined,
            dps_interfaces: DpsInterfaces | UndefinedType = Undefined,
            direct_wan_ha_links: DirectWanHaLinks | UndefinedType = Undefined,
        ) -> None:
            """
            FabricFlowTracking.

            Args:
            -----
                _custom_data: _custom_data
                uplinks: Enable flow-tracking on all fabric uplinks.
                downlinks: Enable flow-tracking on all fabric downlinks.
                endpoints: Enable flow-tracking on all endpoints ports.
                l3_edge: Enable flow-tracking on all p2p_links defined under l3_edge.
                core_interfaces: Enable flow-tracking on all p2p_links defined under core_interfaces.
                mlag_interfaces: Enable flow-tracking on all MLAG peer interfaces.
                l3_interfaces: Enable flow-tracking on all node.l3_interfaces and network-services tenants.vrfs.l3_interfaces.
                dps_interfaces: Enable flow-tracking on all dps_interfaces.
                direct_wan_ha_links: Enable flow-tracking on all direct WAN HA links.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class FabricIpAddressing(AvdModel):
        class Mlag(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "algorithm": {"type": str, "default": "first_id"},
                "ipv4_prefix_length": {"type": int, "default": 31},
                "ipv6_prefix_length": {"type": int, "default": 64},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            algorithm: str | None
            """
            This variable defines the Multi-chassis Link Aggregation (MLAG) algorithm used.
            Each MLAG link will
            have a /31 subnet with each subnet allocated from the relevant MLAG pool via a calculated offset.
            The offset is calculated using one of the following algorithms:
              - first_id: `(mlag_primary_id - 1)
            * 2` where `mlag_primary_id` is the ID of the first node defined under the node_group.
                This
            allocation method will skip every other /31 subnet making it less space efficient than `odd_id`.
            - odd_id: `(odd_id - 1) / 2`. Requires the node_group to have a node with an odd ID and a node with
            an even ID.
              - same_subnet: the offset will always be zero.
                This allocation method will cause
            every MLAG link to be addressed with the same /31 subnet.
             The prefix length is configurable with
            a default of /31.
            """
            ipv4_prefix_length: int | None
            """IPv4 prefix length used for MLAG peer-vlan and L3 point-to-point SVIs over the MLAG peer-link."""
            ipv6_prefix_length: int | None
            """IPv6 prefix length used for MLAG peer-vlan and L3 point-to-point SVIs over the MLAG peer-link."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                algorithm: str | None | UndefinedType = Undefined,
                ipv4_prefix_length: int | None | UndefinedType = Undefined,
                ipv6_prefix_length: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Mlag.

                Args:
                -----
                    _custom_data: _custom_data
                    algorithm:
                       This variable defines the Multi-chassis Link Aggregation (MLAG) algorithm used.
                       Each MLAG link will
                       have a /31 subnet with each subnet allocated from the relevant MLAG pool via a calculated offset.
                       The offset is calculated using one of the following algorithms:
                         - first_id: `(mlag_primary_id - 1)
                       * 2` where `mlag_primary_id` is the ID of the first node defined under the node_group.
                           This
                       allocation method will skip every other /31 subnet making it less space efficient than `odd_id`.
                       - odd_id: `(odd_id - 1) / 2`. Requires the node_group to have a node with an odd ID and a node with
                       an even ID.
                         - same_subnet: the offset will always be zero.
                           This allocation method will cause
                       every MLAG link to be addressed with the same /31 subnet.
                        The prefix length is configurable with
                       a default of /31.
                    ipv4_prefix_length: IPv4 prefix length used for MLAG peer-vlan and L3 point-to-point SVIs over the MLAG peer-link.
                    ipv6_prefix_length: IPv6 prefix length used for MLAG peer-vlan and L3 point-to-point SVIs over the MLAG peer-link.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class P2pUplinks(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_prefix_length": {"type": int, "default": 31}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4_prefix_length: int | None
            """IPv4 prefix length used for L3 point-to-point uplinks."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4_prefix_length: int | None | UndefinedType = Undefined) -> None:
                """
                P2pUplinks.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_prefix_length: IPv4 prefix length used for L3 point-to-point uplinks.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class WanHa(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_prefix_length": {"type": int, "default": 31}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4_prefix_length: int | None
            """IPv4 prefix length used for point-to-point interface for direct WAN HA link."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4_prefix_length: int | None | UndefinedType = Undefined) -> None:
                """
                WanHa.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_prefix_length: IPv4 prefix length used for point-to-point interface for direct WAN HA link.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mlag": {"type": Mlag}, "p2p_uplinks": {"type": P2pUplinks}, "wan_ha": {"type": WanHa}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mlag: Mlag
        p2p_uplinks: P2pUplinks
        wan_ha: WanHa
        """Allow to manipulate the IP addressing scheme for WAN HA direct subnets."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            mlag: Mlag | UndefinedType = Undefined,
            p2p_uplinks: P2pUplinks | UndefinedType = Undefined,
            wan_ha: WanHa | UndefinedType = Undefined,
        ) -> None:
            """
            FabricIpAddressing.

            Args:
            -----
                _custom_data: _custom_data
                mlag: mlag
                p2p_uplinks: p2p_uplinks
                wan_ha: Allow to manipulate the IP addressing scheme for WAN HA direct subnets.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class FabricSflow(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "uplinks": {"type": bool},
            "downlinks": {"type": bool},
            "endpoints": {"type": bool},
            "l3_edge": {"type": bool},
            "core_interfaces": {"type": bool},
            "mlag_interfaces": {"type": bool},
            "l3_interfaces": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        uplinks: bool | None
        """Enable sFlow on all fabric uplinks."""
        downlinks: bool | None
        """Enable sFlow on all fabric downlinks."""
        endpoints: bool | None
        """Enable sFlow on all endpoints ports."""
        l3_edge: bool | None
        """Enable sFlow on all p2p_links defined under l3_edge."""
        core_interfaces: bool | None
        """Enable sFlow on all p2p_links defined under core_interfaces."""
        mlag_interfaces: bool | None
        """Enable sFlow on all MLAG peer interfaces."""
        l3_interfaces: bool | None
        """Enable sFlow on all l3 interfaces."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            uplinks: bool | None | UndefinedType = Undefined,
            downlinks: bool | None | UndefinedType = Undefined,
            endpoints: bool | None | UndefinedType = Undefined,
            l3_edge: bool | None | UndefinedType = Undefined,
            core_interfaces: bool | None | UndefinedType = Undefined,
            mlag_interfaces: bool | None | UndefinedType = Undefined,
            l3_interfaces: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            FabricSflow.

            Args:
            -----
                _custom_data: _custom_data
                uplinks: Enable sFlow on all fabric uplinks.
                downlinks: Enable sFlow on all fabric downlinks.
                endpoints: Enable sFlow on all endpoints ports.
                l3_edge: Enable sFlow on all p2p_links defined under l3_edge.
                core_interfaces: Enable sFlow on all p2p_links defined under core_interfaces.
                mlag_interfaces: Enable sFlow on all MLAG peer interfaces.
                l3_interfaces: Enable sFlow on all l3 interfaces.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class FlowTrackingSettings(AvdModel):
        class Sampled(AvdModel):
            class Encapsulation(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_ipv6": {"type": bool}, "mpls": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4_ipv6: bool | None
                mpls: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4_ipv6: bool | None | UndefinedType = Undefined,
                    mpls: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Encapsulation.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_ipv6: ipv4_ipv6
                        mpls: mpls

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HardwareOffload(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": bool}, "ipv6": {"type": bool}, "threshold_minimum": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4: bool | None
                """Configure hardware offload for IPv4 traffic."""
                ipv6: bool | None
                """Configure hardware offload for IPv6 traffic."""
                threshold_minimum: int | None
                """Minimum number of samples."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4: bool | None | UndefinedType = Undefined,
                    ipv6: bool | None | UndefinedType = Undefined,
                    threshold_minimum: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HardwareOffload.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: Configure hardware offload for IPv4 traffic.
                        ipv6: Configure hardware offload for IPv6 traffic.
                        threshold_minimum: Minimum number of samples.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "encapsulation": {"type": Encapsulation},
                "sample": {"type": int, "default": 10000},
                "hardware_offload": {"type": HardwareOffload},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            encapsulation: Encapsulation
            sample: int | None
            hardware_offload: HardwareOffload

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                encapsulation: Encapsulation | UndefinedType = Undefined,
                sample: int | None | UndefinedType = Undefined,
                hardware_offload: HardwareOffload | UndefinedType = Undefined,
            ) -> None:
                """
                Sampled.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation: encapsulation
                    sample: sample
                    hardware_offload: hardware_offload

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hardware(AvdModel):
            class Record(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "format_ipfix_standard_timestamps_counters": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                format_ipfix_standard_timestamps_counters: bool | None
                """Enable software export of IPFIX data records."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    format_ipfix_standard_timestamps_counters: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Record.

                    Args:
                    -----
                        _custom_data: _custom_data
                        format_ipfix_standard_timestamps_counters: Enable software export of IPFIX data records.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "record": {"type": Record}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            record: Record

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, record: Record | UndefinedType = Undefined) -> None:
                """
                Hardware.

                Args:
                -----
                    _custom_data: _custom_data
                    record: record

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TrackersItem(AvdModel):
            class Sampled(AvdModel):
                class RecordExport(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mpls": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    mpls: bool | None
                    """Export MPLS forwarding information."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mpls: bool | None | UndefinedType = Undefined) -> None:
                        """
                        RecordExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mpls: Export MPLS forwarding information.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "table_size": {"type": int}, "record_export": {"type": RecordExport}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                table_size: int | None
                """Maximum number of entries in flow table."""
                record_export: RecordExport

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    table_size: int | None | UndefinedType = Undefined,
                    record_export: RecordExport | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sampled.

                    Args:
                    -----
                        _custom_data: _custom_data
                        table_size: Maximum number of entries in flow table.
                        record_export: record_export

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RecordExport(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "on_inactive_timeout": {"type": int}, "on_interval": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                on_inactive_timeout: int | None
                """Flow record inactive export timeout in milliseconds"""
                on_interval: int | None
                """Flow record export interval in milliseconds"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    on_inactive_timeout: int | None | UndefinedType = Undefined,
                    on_interval: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RecordExport.

                    Args:
                    -----
                        _custom_data: _custom_data
                        on_inactive_timeout: Flow record inactive export timeout in milliseconds
                        on_interval: Flow record export interval in milliseconds

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ExportersItem(AvdModel):
                class Collector(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "host": {"type": str}, "port": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    host: str | None
                    """Collector IPv4 address or IPv6 address or fully qualified domain name"""
                    port: int | None
                    """Collector Port Number"""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        host: str | None | UndefinedType = Undefined,
                        port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Collector.

                        Args:
                        -----
                            _custom_data: _custom_data
                            host: Collector IPv4 address or IPv6 address or fully qualified domain name
                            port: Collector Port Number

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Format(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipfix_version": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    ipfix_version: int | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipfix_version: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Format.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ipfix_version: ipfix_version

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "collector": {"type": Collector},
                    "format": {"type": Format},
                    "local_interface": {"type": str},
                    "template_interval": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Exporter Name"""
                collector: Collector
                format: Format
                local_interface: str | None
                """Local Source Interface"""
                template_interval: int | None
                """Template interval in milliseconds"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    collector: Collector | UndefinedType = Undefined,
                    format: Format | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    template_interval: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ExportersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Exporter Name
                        collector: collector
                        format: format
                        local_interface: Local Source Interface
                        template_interval: Template interval in milliseconds

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Exporters(AvdCollection[str, ExportersItem]):
                _primary_key: ClassVar[str] = "name"

            Exporters._item_type = ExportersItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "sampled": {"type": Sampled},
                "record_export": {"type": RecordExport},
                "exporters": {"type": Exporters},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Tracker Name"""
            sampled: Sampled
            """The options relevant only for flow tracker type sampled."""
            record_export: RecordExport
            exporters: Exporters

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                sampled: Sampled | UndefinedType = Undefined,
                record_export: RecordExport | UndefinedType = Undefined,
                exporters: Exporters | UndefinedType = Undefined,
            ) -> None:
                """
                TrackersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Tracker Name
                    sampled: The options relevant only for flow tracker type sampled.
                    record_export: record_export
                    exporters: exporters

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Trackers(AvdCollection[str, TrackersItem]):
            _primary_key: ClassVar[str] = "name"

        Trackers._item_type = TrackersItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "sampled": {"type": Sampled},
            "hardware": {"type": Hardware},
            "trackers": {
                "type": Trackers,
                "default": lambda cls: coerce_type(
                    [
                        {
                            "name": "FLOW-TRACKER",
                            "record_export": {"on_inactive_timeout": 70000, "on_interval": 300000},
                            "exporters": [
                                {"name": "CV-TELEMETRY", "collector": {"host": "127.0.0.1"}, "local_interface": "Loopback0", "template_interval": 3600000}
                            ],
                        }
                    ],
                    target_type=cls,
                ),
            },
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        sampled: Sampled
        """The options relevant only for flow tracker type sampled."""
        hardware: Hardware
        """The options relevant only for flow tracker type hardware."""
        trackers: Trackers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            sampled: Sampled | UndefinedType = Undefined,
            hardware: Hardware | UndefinedType = Undefined,
            trackers: Trackers | UndefinedType = Undefined,
        ) -> None:
            """
            FlowTrackingSettings.

            Args:
            -----
                _custom_data: _custom_data
                sampled: The options relevant only for flow tracker type sampled.
                hardware: The options relevant only for flow tracker type hardware.
                trackers: trackers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class GenerateCvTags(AvdModel):
        class InterfaceTagsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "data_path": {"type": str}, "value": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Tag name to be assigned to generated tags."""
            data_path: str | None
            """
            Structured config field/key path to be used to find the value for the tag. Dot notation is supported
            to reference values inside dictionaries.
            For Example: 'data_path: channel_group.id' would set the
            tag with the value of the channel id of the interface. If there is no channel id, the tag is not
            created.
            `data_path` is ignored if `value` is set.
            """
            value: str | None
            """Value to be assigned to the tag."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                data_path: str | None | UndefinedType = Undefined,
                value: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceTagsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Tag name to be assigned to generated tags.
                    data_path:
                       Structured config field/key path to be used to find the value for the tag. Dot notation is supported
                       to reference values inside dictionaries.
                       For Example: 'data_path: channel_group.id' would set the
                       tag with the value of the channel id of the interface. If there is no channel id, the tag is not
                       created.
                       `data_path` is ignored if `value` is set.
                    value: Value to be assigned to the tag.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class InterfaceTags(AvdCollection[str, InterfaceTagsItem]):
            _primary_key: ClassVar[str] = "name"

        InterfaceTags._item_type = InterfaceTagsItem

        class DeviceTagsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "data_path": {"type": str}, "value": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Tag name to be assigned to generated tags."""
            data_path: str | None
            """
            Structured config field/key path to be used to find the value for the tag. Dot notation is supported
            to reference values inside dictionaries.
            For Example: 'data_path: router_bfd.multihop.interval'
            would set the tag with the value of the interval for multihop bfd. If this value is not specified in
            the structured config, the tag is not created.
            `data_path` is ignored if `value` is set.
            """
            value: str | None
            """Value to be assigned to the tag."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                data_path: str | None | UndefinedType = Undefined,
                value: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DeviceTagsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Tag name to be assigned to generated tags.
                    data_path:
                       Structured config field/key path to be used to find the value for the tag. Dot notation is supported
                       to reference values inside dictionaries.
                       For Example: 'data_path: router_bfd.multihop.interval'
                       would set the tag with the value of the interval for multihop bfd. If this value is not specified in
                       the structured config, the tag is not created.
                       `data_path` is ignored if `value` is set.
                    value: Value to be assigned to the tag.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "topology_hints": {"type": bool, "default": False},
            "interface_tags": {"type": InterfaceTags},
            "device_tags": {"type": list, "items": DeviceTagsItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        topology_hints: bool | None
        """Enable the generation of CloudVision Topology Tags (hints)."""
        interface_tags: InterfaceTags
        """List of interface tags that should be generated."""
        device_tags: list[DeviceTagsItem]
        """List of device tags that should be generated."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            topology_hints: bool | None | UndefinedType = Undefined,
            interface_tags: InterfaceTags | UndefinedType = Undefined,
            device_tags: list[DeviceTagsItem] | UndefinedType = Undefined,
        ) -> None:
            """
            GenerateCvTags.

            Args:
            -----
                _custom_data: _custom_data
                topology_hints: Enable the generation of CloudVision Topology Tags (hints).
                interface_tags: List of interface tags that should be generated.
                device_tags: List of device tags that should be generated.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class HardwareCounters(EosCliConfigGen.HardwareCounters):
        pass

    class InternalVlanOrder(AvdModel):
        class Range(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "beginning": {"type": int}, "ending": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "beginning", "ending")
            _custom_data: dict[str, Any]
            beginning: int
            """First VLAN ID."""
            ending: int
            """Last VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                beginning: int | UndefinedType = Undefined,
                ending: int | UndefinedType = Undefined,
            ) -> None:
                """
                Range.

                Args:
                -----
                    _custom_data: _custom_data
                    beginning: First VLAN ID.
                    ending: Last VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "allocation": {"type": str}, "range": {"type": Range}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "allocation")
        _custom_data: dict[str, Any]
        allocation: str
        range: Range

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            allocation: str | UndefinedType = Undefined,
            range: Range | UndefinedType = Undefined,
        ) -> None:
            """
            InternalVlanOrder.

            Args:
            -----
                _custom_data: _custom_data
                allocation: allocation
                range: range

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv4AclsItem(AvdModel):
        class EntriesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "source": {"type": str},
                "destination": {"type": str},
                "sequence": {"type": int},
                "remark": {"type": str},
                "action": {"type": str},
                "protocol": {"type": str},
                "source_ports_match": {"type": str, "default": "eq"},
                "source_ports": {"type": list, "items": str},
                "destination_ports_match": {"type": str, "default": "eq"},
                "destination_ports": {"type": list, "items": str},
                "tcp_flags": {"type": list, "items": str},
                "fragments": {"type": bool},
                "log": {"type": bool},
                "ttl": {"type": int},
                "ttl_match": {"type": str, "default": "eq"},
                "icmp_type": {"type": str},
                "icmp_code": {"type": str},
                "nexthop_group": {"type": str},
                "tracked": {"type": bool},
                "dscp": {"type": str},
                "vlan_number": {"type": int},
                "vlan_inner": {"type": bool, "default": False},
                "vlan_mask": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            source: str | None
            """
            This field supports substitution of the fields "interface_ip" for SVIs and both "interface_ip" and
            "peer_ip" for Layer 3 interfaces.
            Alternatively it can be set with a static value of "any",
            "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            destination: str | None
            """
            This field supports substitution of the fields "interface_ip" for SVIs and both "interface_ip" and
            "peer_ip" for Layer 3 interfaces.
            Alternatively it can be set with a static value of "any",
            "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            sequence: int | None
            """ACL entry sequence number."""
            remark: str | None
            """
            Comment up to 100 characters.
            If remark is defined, other keys in the ACL entry will be ignored.
            """
            action: str | None
            """
            ACL action.
            Required except for remarks.
            """
            protocol: str | None
            """
            "ip", "tcp", "udp", "icmp" or other protocol name or number.
            Required except for remarks.
            """
            source_ports_match: str | None
            source_ports: list[str]
            destination_ports_match: str | None
            destination_ports: list[str]
            tcp_flags: list[str]
            fragments: bool | None
            """Match non-head fragment packets."""
            log: bool | None
            """Log matches against this rule."""
            ttl: int | None
            """TTL value."""
            ttl_match: str | None
            icmp_type: str | None
            """Message type name/number for ICMP packets."""
            icmp_code: str | None
            """Message code for ICMP packets."""
            nexthop_group: str | None
            """nexthop-group name."""
            tracked: bool | None
            """Match packets in existing ICMP/UDP/TCP connections."""
            dscp: str | None
            """DSCP value or name."""
            vlan_number: int | None
            vlan_inner: bool | None
            vlan_mask: str | None
            """0x000-0xFFF VLAN mask."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
                destination: str | None | UndefinedType = Undefined,
                sequence: int | None | UndefinedType = Undefined,
                remark: str | None | UndefinedType = Undefined,
                action: str | None | UndefinedType = Undefined,
                protocol: str | None | UndefinedType = Undefined,
                source_ports_match: str | None | UndefinedType = Undefined,
                source_ports: list[str] | UndefinedType = Undefined,
                destination_ports_match: str | None | UndefinedType = Undefined,
                destination_ports: list[str] | UndefinedType = Undefined,
                tcp_flags: list[str] | UndefinedType = Undefined,
                fragments: bool | None | UndefinedType = Undefined,
                log: bool | None | UndefinedType = Undefined,
                ttl: int | None | UndefinedType = Undefined,
                ttl_match: str | None | UndefinedType = Undefined,
                icmp_type: str | None | UndefinedType = Undefined,
                icmp_code: str | None | UndefinedType = Undefined,
                nexthop_group: str | None | UndefinedType = Undefined,
                tracked: bool | None | UndefinedType = Undefined,
                dscp: str | None | UndefinedType = Undefined,
                vlan_number: int | None | UndefinedType = Undefined,
                vlan_inner: bool | None | UndefinedType = Undefined,
                vlan_mask: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source:
                       This field supports substitution of the fields "interface_ip" for SVIs and both "interface_ip" and
                       "peer_ip" for Layer 3 interfaces.
                       Alternatively it can be set with a static value of "any",
                       "<ip>/<mask>" or "<ip>".
                       "<ip>" without a mask means host.
                       Required except for remarks.
                    destination:
                       This field supports substitution of the fields "interface_ip" for SVIs and both "interface_ip" and
                       "peer_ip" for Layer 3 interfaces.
                       Alternatively it can be set with a static value of "any",
                       "<ip>/<mask>" or "<ip>".
                       "<ip>" without a mask means host.
                       Required except for remarks.
                    sequence: ACL entry sequence number.
                    remark:
                       Comment up to 100 characters.
                       If remark is defined, other keys in the ACL entry will be ignored.
                    action:
                       ACL action.
                       Required except for remarks.
                    protocol:
                       "ip", "tcp", "udp", "icmp" or other protocol name or number.
                       Required except for remarks.
                    source_ports_match: source_ports_match
                    source_ports: source_ports
                    destination_ports_match: destination_ports_match
                    destination_ports: destination_ports
                    tcp_flags: tcp_flags
                    fragments: Match non-head fragment packets.
                    log: Log matches against this rule.
                    ttl: TTL value.
                    ttl_match: ttl_match
                    icmp_type: Message type name/number for ICMP packets.
                    icmp_code: Message code for ICMP packets.
                    nexthop_group: nexthop-group name.
                    tracked: Match packets in existing ICMP/UDP/TCP connections.
                    dscp: DSCP value or name.
                    vlan_number: vlan_number
                    vlan_inner: vlan_inner
                    vlan_mask: 0x000-0xFFF VLAN mask.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "entries": {"type": list, "items": EntriesItem},
            "counters_per_entry": {"type": bool},
            "permit_response_traffic": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "entries")
        _custom_data: dict[str, Any]
        name: str
        """
        Access-list name.
        When using substitution for any fields, the interface name will be appended to the
        ACL name.
        """
        entries: list[EntriesItem]
        """ACL Entries."""
        counters_per_entry: bool | None
        permit_response_traffic: str | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            entries: list[EntriesItem] | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            permit_response_traffic: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv4AclsItem.

            Args:
            -----
                _custom_data: _custom_data
                name:
                   Access-list name.
                   When using substitution for any fields, the interface name will be appended to the
                   ACL name.
                entries: ACL Entries.
                counters_per_entry: counters_per_entry
                permit_response_traffic:
                   Permit response traffic automatically based on NAT translations.
                   Minimum EOS version requirement
                   4.32.2F.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv4Acls(AvdCollection[str, Ipv4AclsItem]):
        _primary_key: ClassVar[str] = "name"

    Ipv4Acls._item_type = Ipv4AclsItem

    class Ipv4PrefixListCatalogItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 10.255.0.0/27 eq 32"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "permit 10.255.0.0/27 eq 32"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv4PrefixListCatalogItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Prefix-list Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv4PrefixListCatalog(AvdCollection[str, Ipv4PrefixListCatalogItem]):
        _primary_key: ClassVar[str] = "name"

    Ipv4PrefixListCatalog._item_type = Ipv4PrefixListCatalogItem

    class IsisTiLfa(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool, "default": False},
            "protection": {"type": str},
            "local_convergence_delay": {"type": int, "default": 10000},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None
        protection: str | None
        local_convergence_delay: int | None
        """Local convergence delay in milliseconds."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            protection: str | None | UndefinedType = Undefined,
            local_convergence_delay: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            IsisTiLfa.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                protection: protection
                local_convergence_delay: Local convergence delay in milliseconds.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class L3Edge(AvdModel):
        class P2pLinksIpPoolsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "ipv4_pool": {"type": str},
                "prefix_size": {"type": int, "default": 31},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """P2P pool name."""
            ipv4_pool: str | None
            """IPv4 address/Mask."""
            prefix_size: int | None
            """Subnet mask size."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                ipv4_pool: str | None | UndefinedType = Undefined,
                prefix_size: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                P2pLinksIpPoolsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: P2P pool name.
                    ipv4_pool: IPv4 address/Mask.
                    prefix_size: Subnet mask size.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class P2pLinksIpPools(AvdCollection[str, P2pLinksIpPoolsItem]):
            _primary_key: ClassVar[str] = "name"

        P2pLinksIpPools._item_type = P2pLinksIpPoolsItem

        class P2pLinksProfilesItem(AvdModel):
            class Ptp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enable PTP."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ptp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable PTP.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class FlowTracking(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                name: str | None
                """Flow tracker name as defined in flow_tracking_settings."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracking.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        name: Flow tracker name as defined in flow_tracking_settings.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortChannel(AvdModel):
                class NodesChildInterfacesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "node": {"type": str},
                        "interfaces": {"type": list, "items": str},
                        "channel_id": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "node")
                    _custom_data: dict[str, Any]
                    node: str
                    interfaces: list[str]
                    """List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ]."""
                    channel_id: int | None
                    """
                    Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                    port channel.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        node: str | UndefinedType = Undefined,
                        interfaces: list[str] | UndefinedType = Undefined,
                        channel_id: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodesChildInterfacesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            node: node
                            interfaces: List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ].
                            channel_id:
                               Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                               port channel.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodesChildInterfaces(AvdCollection[str, NodesChildInterfacesItem]):
                    _primary_key: ClassVar[str] = "node"

                NodesChildInterfaces._item_type = NodesChildInterfacesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "description": {"type": str},
                    "mode": {"type": str, "default": "active"},
                    "nodes_child_interfaces": {"type": NodesChildInterfaces},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                description: str | None
                """
                Description or description template to be used on the port-channel interface.
                This can be a template
                using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                to/custom-descriptions-names.html#avd-string-formatter-syntax.
                The available template fields are:
                - `peer`: The name of the peer.
                  - `interface`: The local port-channel interface name.
                  -
                `peer_interface`: The port-channel interface on the peer.
                  - `port_channel_id`: The local port-
                channel ID.
                  - `peer_port_channel_id`: The ID of the port-channel on the peer.

                Falls back to the
                description on the `p2p_link` if set. Otherwise default description is set by
                `default_underlay_p2p_port_channel_description`.
                By default the description is templated from the
                name and port_channel interface of the peer.
                """
                mode: str | None
                nodes_child_interfaces: NodesChildInterfaces

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    nodes_child_interfaces: NodesChildInterfaces | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortChannel.

                    Args:
                    -----
                        _custom_data: _custom_data
                        description:
                           Description or description template to be used on the port-channel interface.
                           This can be a template
                           using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                           to/custom-descriptions-names.html#avd-string-formatter-syntax.
                           The available template fields are:
                           - `peer`: The name of the peer.
                             - `interface`: The local port-channel interface name.
                             -
                           `peer_interface`: The port-channel interface on the peer.
                             - `port_channel_id`: The local port-
                           channel ID.
                             - `peer_port_channel_id`: The ID of the port-channel on the peer.

                           Falls back to the
                           description on the `p2p_link` if set. Otherwise default description is set by
                           `default_underlay_p2p_port_channel_description`.
                           By default the description is templated from the
                           name and port_channel interface of the peer.
                        mode: mode
                        nodes_child_interfaces: nodes_child_interfaces

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "id": {"type": int},
                "speed": {"type": str},
                "ip_pool": {"type": str},
                "subnet": {"type": str},
                "ip": {"type": list, "items": str},
                "ipv6_enable": {"type": bool, "default": False},
                "nodes": {"type": list, "items": str},
                "interfaces": {"type": list, "items": str},
                "field_as": {"type": list, "key": "as", "items": str},
                "descriptions": {"type": list, "items": str},
                "include_in_underlay_protocol": {"type": bool, "default": True},
                "isis_hello_padding": {"type": bool, "default": False},
                "isis_metric": {"type": int},
                "isis_circuit_type": {"type": str},
                "isis_authentication_mode": {"type": str},
                "isis_authentication_key": {"type": str},
                "mpls_ip": {"type": bool},
                "mpls_ldp": {"type": bool},
                "mtu": {"type": int},
                "bfd": {"type": bool, "default": False},
                "ptp": {"type": Ptp},
                "sflow": {"type": bool},
                "underlay_multicast": {"type": bool, "default": False},
                "flow_tracking": {"type": FlowTracking},
                "qos_profile": {"type": str},
                "macsec_profile": {"type": str},
                "port_channel": {"type": PortChannel},
                "raw_eos_cli": {"type": str},
                "routing_protocol": {"type": str},
                "structured_config": {"type": dict},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """P2P profile name. Any variable supported under `p2p_links` can be inherited from a profile."""
            id: int | None
            """
            Unique id per subnet_summary. Used to calculate ip addresses.
            Required with ip_pool. ID starting
            from 1.
            """
            speed: str | None
            """
            Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
            <interface_speed>`.
            """
            ip_pool: str | None
            """
            P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
            link.
            """
            subnet: str | None
            """IPv4 address/Mask. Subnet used on this P2P link."""
            ip: list[str]
            """Specific IP addresses used on this P2P link."""
            ipv6_enable: bool | None
            """
            Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
            include_in_underlay_protocol).
            """
            nodes: list[str]
            """Nodes where this link should be configured."""
            interfaces: list[str]
            """Interfaces where this link should be configured and Required unless using port-channels."""
            field_as: list[str]
            """
            AS numbers for BGP.
            Required with bgp peering.
            """
            descriptions: list[str]
            """Interface descriptions."""
            include_in_underlay_protocol: bool | None
            """Add this interface to underlay routing protocol."""
            isis_hello_padding: bool | None
            isis_metric: int | None
            isis_circuit_type: str | None
            isis_authentication_mode: str | None
            isis_authentication_key: str | None
            """Type-7 encrypted password."""
            mpls_ip: bool | None
            """MPLS parameters. Default value is true if switch.mpls_lsr is true."""
            mpls_ldp: bool | None
            """MPLS parameters. Default value is true for ldp underlay variants, otherwise false."""
            mtu: int | None
            """MTU for this P2P link. Default value same as p2p_uplinks_mtu."""
            bfd: bool | None
            """Enable BFD (only considered for BGP)."""
            ptp: Ptp
            """PTP parameters."""
            sflow: bool | None
            """Enable sFlow. Overrides `fabric_sflow` setting."""
            underlay_multicast: bool | None
            """
            Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
            to be `true`.
            """
            flow_tracking: FlowTracking
            """Enable flow-tracking. Overrides `fabric_flow_tracking` setting."""
            qos_profile: str | None
            """QOS service profile."""
            macsec_profile: str | None
            """MAC security profile."""
            port_channel: PortChannel
            """Port-channel parameters."""
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the point-to-point interface in the final EOS configuration."""
            routing_protocol: str | None
            """
            Enables deviation of the routing protocol used on this link from the fabric underlay default.
            -
            ebgp: Enforce plain IPv4 BGP peering
            """
            structured_config: dict
            """
            Custom structured config for interfaces.
            Note! The content of this dictionary is _not_ validated by
            the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                id: int | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                ip_pool: str | None | UndefinedType = Undefined,
                subnet: str | None | UndefinedType = Undefined,
                ip: list[str] | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                nodes: list[str] | UndefinedType = Undefined,
                interfaces: list[str] | UndefinedType = Undefined,
                field_as: list[str] | UndefinedType = Undefined,
                descriptions: list[str] | UndefinedType = Undefined,
                include_in_underlay_protocol: bool | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_circuit_type: str | None | UndefinedType = Undefined,
                isis_authentication_mode: str | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                mpls_ip: bool | None | UndefinedType = Undefined,
                mpls_ldp: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                sflow: bool | None | UndefinedType = Undefined,
                underlay_multicast: bool | None | UndefinedType = Undefined,
                flow_tracking: FlowTracking | UndefinedType = Undefined,
                qos_profile: str | None | UndefinedType = Undefined,
                macsec_profile: str | None | UndefinedType = Undefined,
                port_channel: PortChannel | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                routing_protocol: str | None | UndefinedType = Undefined,
                structured_config: dict | UndefinedType = Undefined,
            ) -> None:
                """
                P2pLinksProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: P2P profile name. Any variable supported under `p2p_links` can be inherited from a profile.
                    id:
                       Unique id per subnet_summary. Used to calculate ip addresses.
                       Required with ip_pool. ID starting
                       from 1.
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    ip_pool:
                       P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
                       link.
                    subnet: IPv4 address/Mask. Subnet used on this P2P link.
                    ip: Specific IP addresses used on this P2P link.
                    ipv6_enable:
                       Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
                       include_in_underlay_protocol).
                    nodes: Nodes where this link should be configured.
                    interfaces: Interfaces where this link should be configured and Required unless using port-channels.
                    field_as:
                       AS numbers for BGP.
                       Required with bgp peering.
                    descriptions: Interface descriptions.
                    include_in_underlay_protocol: Add this interface to underlay routing protocol.
                    isis_hello_padding: isis_hello_padding
                    isis_metric: isis_metric
                    isis_circuit_type: isis_circuit_type
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    mpls_ip: MPLS parameters. Default value is true if switch.mpls_lsr is true.
                    mpls_ldp: MPLS parameters. Default value is true for ldp underlay variants, otherwise false.
                    mtu: MTU for this P2P link. Default value same as p2p_uplinks_mtu.
                    bfd: Enable BFD (only considered for BGP).
                    ptp: PTP parameters.
                    sflow: Enable sFlow. Overrides `fabric_sflow` setting.
                    underlay_multicast:
                       Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
                       to be `true`.
                    flow_tracking: Enable flow-tracking. Overrides `fabric_flow_tracking` setting.
                    qos_profile: QOS service profile.
                    macsec_profile: MAC security profile.
                    port_channel: Port-channel parameters.
                    raw_eos_cli: EOS CLI rendered directly on the point-to-point interface in the final EOS configuration.
                    routing_protocol:
                       Enables deviation of the routing protocol used on this link from the fabric underlay default.
                       -
                       ebgp: Enforce plain IPv4 BGP peering
                    structured_config:
                       Custom structured config for interfaces.
                       Note! The content of this dictionary is _not_ validated by
                       the schema, since it can be either ethernet_interfaces or port_channel_interfaces.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class P2pLinksProfiles(AvdCollection[str, P2pLinksProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        P2pLinksProfiles._item_type = P2pLinksProfilesItem

        class P2pLinksItem(AvdModel):
            class Ptp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enable PTP."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ptp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable PTP.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class FlowTracking(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                name: str | None
                """Flow tracker name as defined in flow_tracking_settings."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    FlowTracking.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        name: Flow tracker name as defined in flow_tracking_settings.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortChannel(AvdModel):
                class NodesChildInterfacesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "node": {"type": str},
                        "interfaces": {"type": list, "items": str},
                        "channel_id": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "node")
                    _custom_data: dict[str, Any]
                    node: str
                    interfaces: list[str]
                    """List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ]."""
                    channel_id: int | None
                    """
                    Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                    port channel.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        node: str | UndefinedType = Undefined,
                        interfaces: list[str] | UndefinedType = Undefined,
                        channel_id: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodesChildInterfacesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            node: node
                            interfaces: List of node interfaces. Ex.- [ 'node1 interface1', 'node1 interface2' ].
                            channel_id:
                               Port-Channel ID. If no channel_id is specified, an id is generated from the first switch port in the
                               port channel.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodesChildInterfaces(AvdCollection[str, NodesChildInterfacesItem]):
                    _primary_key: ClassVar[str] = "node"

                NodesChildInterfaces._item_type = NodesChildInterfacesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "description": {"type": str},
                    "mode": {"type": str, "default": "active"},
                    "nodes_child_interfaces": {"type": NodesChildInterfaces},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                description: str | None
                """
                Description or description template to be used on the port-channel interface.
                This can be a template
                using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                to/custom-descriptions-names.html#avd-string-formatter-syntax.
                The available template fields are:
                - `peer`: The name of the peer.
                  - `interface`: The local port-channel interface name.
                  -
                `peer_interface`: The port-channel interface on the peer.
                  - `port_channel_id`: The local port-
                channel ID.
                  - `peer_port_channel_id`: The ID of the port-channel on the peer.

                Falls back to the
                description on the `p2p_link` if set. Otherwise default description is set by
                `default_underlay_p2p_port_channel_description`.
                By default the description is templated from the
                name and port_channel interface of the peer.
                """
                mode: str | None
                nodes_child_interfaces: NodesChildInterfaces

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    nodes_child_interfaces: NodesChildInterfaces | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortChannel.

                    Args:
                    -----
                        _custom_data: _custom_data
                        description:
                           Description or description template to be used on the port-channel interface.
                           This can be a template
                           using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                           to/custom-descriptions-names.html#avd-string-formatter-syntax.
                           The available template fields are:
                           - `peer`: The name of the peer.
                             - `interface`: The local port-channel interface name.
                             -
                           `peer_interface`: The port-channel interface on the peer.
                             - `port_channel_id`: The local port-
                           channel ID.
                             - `peer_port_channel_id`: The ID of the port-channel on the peer.

                           Falls back to the
                           description on the `p2p_link` if set. Otherwise default description is set by
                           `default_underlay_p2p_port_channel_description`.
                           By default the description is templated from the
                           name and port_channel interface of the peer.
                        mode: mode
                        nodes_child_interfaces: nodes_child_interfaces

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "nodes": {"type": list, "items": str},
                "profile": {"type": str},
                "id": {"type": int},
                "speed": {"type": str},
                "ip_pool": {"type": str},
                "subnet": {"type": str},
                "ip": {"type": list, "items": str},
                "ipv6_enable": {"type": bool, "default": False},
                "interfaces": {"type": list, "items": str},
                "field_as": {"type": list, "key": "as", "items": str},
                "descriptions": {"type": list, "items": str},
                "include_in_underlay_protocol": {"type": bool, "default": True},
                "isis_hello_padding": {"type": bool, "default": False},
                "isis_metric": {"type": int},
                "isis_circuit_type": {"type": str},
                "isis_authentication_mode": {"type": str},
                "isis_authentication_key": {"type": str},
                "mpls_ip": {"type": bool},
                "mpls_ldp": {"type": bool},
                "mtu": {"type": int},
                "bfd": {"type": bool, "default": False},
                "ptp": {"type": Ptp},
                "sflow": {"type": bool},
                "underlay_multicast": {"type": bool, "default": False},
                "flow_tracking": {"type": FlowTracking},
                "qos_profile": {"type": str},
                "macsec_profile": {"type": str},
                "port_channel": {"type": PortChannel},
                "raw_eos_cli": {"type": str},
                "routing_protocol": {"type": str},
                "structured_config": {"type": dict},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "nodes")
            _custom_data: dict[str, Any]
            nodes: list[str]
            """Nodes where this link should be configured."""
            profile: str | None
            """P2P profile name. Profile defined under p2p_profiles."""
            id: int | None
            """
            Unique id per subnet_summary. Used to calculate ip addresses.
            Required with ip_pool. ID starting
            from 1.
            """
            speed: str | None
            """
            Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
            <interface_speed>`.
            """
            ip_pool: str | None
            """
            P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
            link.
            """
            subnet: str | None
            """IPv4 address/Mask. Subnet used on this P2P link."""
            ip: list[str]
            """Specific IP addresses used on this P2P link."""
            ipv6_enable: bool | None
            """
            Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
            include_in_underlay_protocol).
            """
            interfaces: list[str]
            """Interfaces where this link should be configured and Required unless using port-channels."""
            field_as: list[str]
            """
            AS numbers for BGP.
            Required with bgp peering.
            """
            descriptions: list[str]
            """Interface descriptions."""
            include_in_underlay_protocol: bool | None
            """Add this interface to underlay routing protocol."""
            isis_hello_padding: bool | None
            isis_metric: int | None
            isis_circuit_type: str | None
            isis_authentication_mode: str | None
            isis_authentication_key: str | None
            """Type-7 encrypted password."""
            mpls_ip: bool | None
            """MPLS parameters. Default value is true if switch.mpls_lsr is true."""
            mpls_ldp: bool | None
            """MPLS parameters. Default value is true for ldp underlay variants, otherwise false."""
            mtu: int | None
            """MTU for this P2P link. Default value same as p2p_uplinks_mtu."""
            bfd: bool | None
            """Enable BFD (only considered for BGP)."""
            ptp: Ptp
            """PTP parameters."""
            sflow: bool | None
            """Enable sFlow. Overrides `fabric_sflow` setting."""
            underlay_multicast: bool | None
            """
            Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
            to be `true`.
            """
            flow_tracking: FlowTracking
            """Enable flow-tracking. Overrides `fabric_flow_tracking` setting."""
            qos_profile: str | None
            """QOS service profile."""
            macsec_profile: str | None
            """MAC security profile."""
            port_channel: PortChannel
            """Port-channel parameters."""
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the point-to-point interface in the final EOS configuration."""
            routing_protocol: str | None
            """
            Enables deviation of the routing protocol used on this link from the fabric underlay default.
            -
            ebgp: Enforce plain IPv4 BGP peering
            """
            structured_config: dict
            """
            Custom structured config for interfaces.
            Note! The content of this dictionary is _not_ validated by
            the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                nodes: list[str] | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                id: int | None | UndefinedType = Undefined,
                speed: str | None | UndefinedType = Undefined,
                ip_pool: str | None | UndefinedType = Undefined,
                subnet: str | None | UndefinedType = Undefined,
                ip: list[str] | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                interfaces: list[str] | UndefinedType = Undefined,
                field_as: list[str] | UndefinedType = Undefined,
                descriptions: list[str] | UndefinedType = Undefined,
                include_in_underlay_protocol: bool | None | UndefinedType = Undefined,
                isis_hello_padding: bool | None | UndefinedType = Undefined,
                isis_metric: int | None | UndefinedType = Undefined,
                isis_circuit_type: str | None | UndefinedType = Undefined,
                isis_authentication_mode: str | None | UndefinedType = Undefined,
                isis_authentication_key: str | None | UndefinedType = Undefined,
                mpls_ip: bool | None | UndefinedType = Undefined,
                mpls_ldp: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                ptp: Ptp | UndefinedType = Undefined,
                sflow: bool | None | UndefinedType = Undefined,
                underlay_multicast: bool | None | UndefinedType = Undefined,
                flow_tracking: FlowTracking | UndefinedType = Undefined,
                qos_profile: str | None | UndefinedType = Undefined,
                macsec_profile: str | None | UndefinedType = Undefined,
                port_channel: PortChannel | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                routing_protocol: str | None | UndefinedType = Undefined,
                structured_config: dict | UndefinedType = Undefined,
            ) -> None:
                """
                P2pLinksItem.

                Args:
                -----
                    _custom_data: _custom_data
                    nodes: Nodes where this link should be configured.
                    profile: P2P profile name. Profile defined under p2p_profiles.
                    id:
                       Unique id per subnet_summary. Used to calculate ip addresses.
                       Required with ip_pool. ID starting
                       from 1.
                    speed:
                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                       <interface_speed>`.
                    ip_pool:
                       P2P pool name. IP Pool defined under p2p_links_ip_pools. A /31 will be taken from the pool per P2P
                       link.
                    subnet: IPv4 address/Mask. Subnet used on this P2P link.
                    ip: Specific IP addresses used on this P2P link.
                    ipv6_enable:
                       Allows turning on ipv6 for the link or profile (also autodetected based on underlay_rfc5549 and
                       include_in_underlay_protocol).
                    interfaces: Interfaces where this link should be configured and Required unless using port-channels.
                    field_as:
                       AS numbers for BGP.
                       Required with bgp peering.
                    descriptions: Interface descriptions.
                    include_in_underlay_protocol: Add this interface to underlay routing protocol.
                    isis_hello_padding: isis_hello_padding
                    isis_metric: isis_metric
                    isis_circuit_type: isis_circuit_type
                    isis_authentication_mode: isis_authentication_mode
                    isis_authentication_key: Type-7 encrypted password.
                    mpls_ip: MPLS parameters. Default value is true if switch.mpls_lsr is true.
                    mpls_ldp: MPLS parameters. Default value is true for ldp underlay variants, otherwise false.
                    mtu: MTU for this P2P link. Default value same as p2p_uplinks_mtu.
                    bfd: Enable BFD (only considered for BGP).
                    ptp: PTP parameters.
                    sflow: Enable sFlow. Overrides `fabric_sflow` setting.
                    underlay_multicast:
                       Enable PIM sparse mode. Requires `include_in_underlay_protocol` and the global `underlay_multicast`
                       to be `true`.
                    flow_tracking: Enable flow-tracking. Overrides `fabric_flow_tracking` setting.
                    qos_profile: QOS service profile.
                    macsec_profile: MAC security profile.
                    port_channel: Port-channel parameters.
                    raw_eos_cli: EOS CLI rendered directly on the point-to-point interface in the final EOS configuration.
                    routing_protocol:
                       Enables deviation of the routing protocol used on this link from the fabric underlay default.
                       -
                       ebgp: Enforce plain IPv4 BGP peering
                    structured_config:
                       Custom structured config for interfaces.
                       Note! The content of this dictionary is _not_ validated by
                       the schema, since it can be either ethernet_interfaces or port_channel_interfaces.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "p2p_links_ip_pools": {"type": P2pLinksIpPools},
            "p2p_links_profiles": {"type": P2pLinksProfiles},
            "p2p_links": {"type": list, "items": P2pLinksItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        p2p_links_ip_pools: P2pLinksIpPools
        p2p_links_profiles: P2pLinksProfiles
        p2p_links: list[P2pLinksItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            p2p_links_ip_pools: P2pLinksIpPools | UndefinedType = Undefined,
            p2p_links_profiles: P2pLinksProfiles | UndefinedType = Undefined,
            p2p_links: list[P2pLinksItem] | UndefinedType = Undefined,
        ) -> None:
            """
            L3Edge.

            Args:
            -----
                _custom_data: _custom_data
                p2p_links_ip_pools: p2p_links_ip_pools
                p2p_links_profiles: p2p_links_profiles
                p2p_links: p2p_links

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class L3InterfaceProfilesItem(AvdModel):
        class Bgp(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "peer_as": {"type": str},
                "ipv4_prefix_list_in": {"type": str},
                "ipv4_prefix_list_out": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
            _custom_data: dict[str, Any]
            peer_as: str
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            ipv4_prefix_list_in: str | None
            """
            Prefix List Name. Accept routes for only these prefixes from the peer.
            Required for wan interfaces.
            """
            ipv4_prefix_list_out: str | None
            """
            Prefix List Name. Advertise routes for only these prefixes.
            If not specified, nothing would be
            advertised.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                peer_as: str | UndefinedType = Undefined,
                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    peer_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    ipv4_prefix_list_in:
                       Prefix List Name. Accept routes for only these prefixes from the peer.
                       Required for wan interfaces.
                    ipv4_prefix_list_out:
                       Prefix List Name. Advertise routes for only these prefixes.
                       If not specified, nothing would be
                       advertised.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StaticRoutesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
            _custom_data: dict[str, Any]
            prefix: str
            """IPv4_network/Mask."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                """
                StaticRoutesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix: IPv4_network/Mask.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CvPathfinderInternetExit(AvdModel):
            class PoliciesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Internet-exit policy name."""
                tunnel_interface_numbers: str | None
                """
                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                interface.
                Examples: '1-3' or '100,200,300'
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Internet-exit policy name.
                        tunnel_interface_numbers:
                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                           interface.
                           Examples: '1-3' or '100,200,300'

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Policies(AvdCollection[str, PoliciesItem]):
                _primary_key: ClassVar[str] = "name"

            Policies._item_type = PoliciesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            policies: Policies
            """List of Internet-exit policies using this interface as exit."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined) -> None:
                """
                CvPathfinderInternetExit.

                Args:
                -----
                    _custom_data: _custom_data
                    policies: List of Internet-exit policies using this interface as exit.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FlowTracking(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracking.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "profile": {"type": str},
            "name": {"type": str},
            "description": {"type": str},
            "ip_address": {"type": str},
            "dhcp_ip": {"type": str},
            "public_ip": {"type": str},
            "encapsulation_dot1q_vlan": {"type": int},
            "dhcp_accept_default_route": {"type": bool, "default": True},
            "enabled": {"type": bool, "default": True},
            "speed": {"type": str},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_ip": {"type": str},
            "bgp": {"type": Bgp},
            "ipv4_acl_in": {"type": str},
            "ipv4_acl_out": {"type": str},
            "static_routes": {"type": list, "items": StaticRoutesItem},
            "qos_profile": {"type": str},
            "wan_carrier": {"type": str},
            "wan_circuit_id": {"type": str},
            "connected_to_pathfinder": {"type": bool, "default": True},
            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
            "raw_eos_cli": {"type": str},
            "flow_tracking": {"type": FlowTracking},
            "structured_config": {"type": StructuredConfig},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "profile")
        _custom_data: dict[str, Any]
        profile: str
        """
        L3 interface profile name. Any variable supported under `l3_interfaces` can be inherited from a
        profile.
        """
        name: str | None
        """
        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
        For a
        subinterface, the parent physical interface is automatically created.
        """
        description: str | None
        """
        Interface description.
        If not set a default description will be configured with '[<peer>[
        <peer_interface>]]'.
        """
        ip_address: str | None
        """Node IPv4 address/Mask or 'dhcp'."""
        dhcp_ip: str | None
        """
        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
        IPv4 address
        (without mask) to be allocated on the interface if known.
        This is not rendered in the configuration
        but can be used for substitution of 'interface_ip' in the Access-list
        set under `ipv4_acl_in` and
        `ipv4_acl_out`.
        """
        public_ip: str | None
        """
        Node IPv4 address (no mask).

        This is used to get the public IP (if known) when the device is behind
        NAT.
        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
        with the following preference:
          `wan_route_servers.path_groups.interfaces.ip_address`
              ->
        `l3_interfaces.public_ip`
                  -> `l3_interfaces.ip_address`

        The determined Public IP is used
        by WAN routers when peering with this interface.
        """
        encapsulation_dot1q_vlan: int | None
        """
        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
        specified.
        """
        dhcp_accept_default_route: bool | None
        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
        enabled: bool | None
        """Enable or Shutdown the interface."""
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        peer: str | None
        """The peer device name. Used for description and documentation."""
        peer_interface: str | None
        """The peer device interface. Used for description and documentation."""
        peer_ip: str | None
        """
        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
        and `ip` is an IP address.
        """
        bgp: Bgp
        """Enforce IPv4 BGP peering for the peer"""
        ipv4_acl_in: str | None
        """
        Name of the IPv4 access-list to be assigned in the ingress direction.
        The access-list must be
        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
        Required
        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
        `wan_carriers`.
        """
        ipv4_acl_out: str | None
        """
        Name of the IPv4 Access-list to be assigned in the egress direction.
        The access-list must be defined
        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
        """
        static_routes: list[StaticRoutesItem]
        """Configure IPv4 static routes pointing to `peer_ip`."""
        qos_profile: str | None
        """QOS service profile."""
        wan_carrier: str | None
        """
        The WAN carrier this interface is connected to.
        This is used to infer the path-groups in which this
        interface should be configured.
        Unless the carrier is marked as 'trusted' under `wan_carriers`,
        `ipv4_acl_in` is also required on all WAN interfaces.
        """
        wan_circuit_id: str | None
        """
        The WAN circuit ID for this interface.
        This is not rendered in the configuration but used for WAN
        designs.
        """
        connected_to_pathfinder: bool | None
        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
        cv_pathfinder_internet_exit: CvPathfinderInternetExit
        """PREVIEW: This key is in preview mode"""
        raw_eos_cli: str | None
        """EOS CLI rendered directly on the interface in the final EOS configuration."""
        flow_tracking: FlowTracking
        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
        structured_config: StructuredConfig
        """Custom structured config for the Ethernet interface."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            profile: str | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            dhcp_ip: str | None | UndefinedType = Undefined,
            public_ip: str | None | UndefinedType = Undefined,
            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            speed: str | None | UndefinedType = Undefined,
            peer: str | None | UndefinedType = Undefined,
            peer_interface: str | None | UndefinedType = Undefined,
            peer_ip: str | None | UndefinedType = Undefined,
            bgp: Bgp | UndefinedType = Undefined,
            ipv4_acl_in: str | None | UndefinedType = Undefined,
            ipv4_acl_out: str | None | UndefinedType = Undefined,
            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
            qos_profile: str | None | UndefinedType = Undefined,
            wan_carrier: str | None | UndefinedType = Undefined,
            wan_circuit_id: str | None | UndefinedType = Undefined,
            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
            raw_eos_cli: str | None | UndefinedType = Undefined,
            flow_tracking: FlowTracking | UndefinedType = Undefined,
            structured_config: StructuredConfig | UndefinedType = Undefined,
        ) -> None:
            """
            L3InterfaceProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                profile:
                   L3 interface profile name. Any variable supported under `l3_interfaces` can be inherited from a
                   profile.
                name:
                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                   For a
                   subinterface, the parent physical interface is automatically created.
                description:
                   Interface description.
                   If not set a default description will be configured with '[<peer>[
                   <peer_interface>]]'.
                ip_address: Node IPv4 address/Mask or 'dhcp'.
                dhcp_ip:
                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                   IPv4 address
                   (without mask) to be allocated on the interface if known.
                   This is not rendered in the configuration
                   but can be used for substitution of 'interface_ip' in the Access-list
                   set under `ipv4_acl_in` and
                   `ipv4_acl_out`.
                public_ip:
                   Node IPv4 address (no mask).

                   This is used to get the public IP (if known) when the device is behind
                   NAT.
                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                   with the following preference:
                     `wan_route_servers.path_groups.interfaces.ip_address`
                         ->
                   `l3_interfaces.public_ip`
                             -> `l3_interfaces.ip_address`

                   The determined Public IP is used
                   by WAN routers when peering with this interface.
                encapsulation_dot1q_vlan:
                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                   specified.
                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                enabled: Enable or Shutdown the interface.
                speed:
                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                peer: The peer device name. Used for description and documentation.
                peer_interface: The peer device interface. Used for description and documentation.
                peer_ip:
                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                   and `ip` is an IP address.
                bgp: Enforce IPv4 BGP peering for the peer
                ipv4_acl_in:
                   Name of the IPv4 access-list to be assigned in the ingress direction.
                   The access-list must be
                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                   Required
                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                   `wan_carriers`.
                ipv4_acl_out:
                   Name of the IPv4 Access-list to be assigned in the egress direction.
                   The access-list must be defined
                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                qos_profile: QOS service profile.
                wan_carrier:
                   The WAN carrier this interface is connected to.
                   This is used to infer the path-groups in which this
                   interface should be configured.
                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                   `ipv4_acl_in` is also required on all WAN interfaces.
                wan_circuit_id:
                   The WAN circuit ID for this interface.
                   This is not rendered in the configuration but used for WAN
                   designs.
                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                structured_config: Custom structured config for the Ethernet interface.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class L3InterfaceProfiles(AvdCollection[str, L3InterfaceProfilesItem]):
        _primary_key: ClassVar[str] = "profile"

    L3InterfaceProfiles._item_type = L3InterfaceProfilesItem

    class LocalUsersItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "disabled": {"type": bool},
            "privilege": {"type": int},
            "role": {"type": str},
            "sha512_password": {"type": str},
            "no_password": {"type": bool},
            "ssh_key": {"type": str},
            "secondary_ssh_key": {"type": str},
            "shell": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Username."""
        disabled: bool | None
        """
        If true, the user will be removed and all other settings are ignored.
        Useful for removing the
        default "admin" user.
        """
        privilege: int | None
        """Initial privilege level with local EXEC authorization."""
        role: str | None
        """EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator"."""
        sha512_password: str | None
        """
        SHA512 Hash of Password.
        Must be the hash of the password. By default EOS salts the password with
        the username, so the simplest is to generate the hash on an EOS device using the same username.
        """
        no_password: bool | None
        """
        If set a password will not be configured for this user. "sha512_password" MUST not be defined for
        this user.
        """
        ssh_key: str | None
        secondary_ssh_key: str | None
        shell: str | None
        """Specify shell for the user."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            privilege: int | None | UndefinedType = Undefined,
            role: str | None | UndefinedType = Undefined,
            sha512_password: str | None | UndefinedType = Undefined,
            no_password: bool | None | UndefinedType = Undefined,
            ssh_key: str | None | UndefinedType = Undefined,
            secondary_ssh_key: str | None | UndefinedType = Undefined,
            shell: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            LocalUsersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Username.
                disabled:
                   If true, the user will be removed and all other settings are ignored.
                   Useful for removing the
                   default "admin" user.
                privilege: Initial privilege level with local EXEC authorization.
                role: EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator".
                sha512_password:
                   SHA512 Hash of Password.
                   Must be the hash of the password. By default EOS salts the password with
                   the username, so the simplest is to generate the hash on an EOS device using the same username.
                no_password:
                   If set a password will not be configured for this user. "sha512_password" MUST not be defined for
                   this user.
                ssh_key: ssh_key
                secondary_ssh_key: secondary_ssh_key
                shell: Specify shell for the user.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LocalUsers(AvdCollection[str, LocalUsersItem]):
        _primary_key: ClassVar[str] = "name"

    LocalUsers._item_type = LocalUsersItem

    class MacAddressTable(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "aging_time": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        aging_time: int | None
        """
        Aging time in seconds 10-1000000.
        Enter 0 to disable aging.
        """

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, aging_time: int | None | UndefinedType = Undefined) -> None:
            """
            MacAddressTable.

            Args:
            -----
                _custom_data: _custom_data
                aging_time:
                   Aging time in seconds 10-1000000.
                   Enter 0 to disable aging.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementEapi(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enable_http": {"type": bool, "default": False},
            "enable_https": {"type": bool, "default": True},
            "default_services": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable_http: bool | None
        enable_https: bool | None
        default_services: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enable_http: bool | None | UndefinedType = Undefined,
            enable_https: bool | None | UndefinedType = Undefined,
            default_services: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementEapi.

            Args:
            -----
                _custom_data: _custom_data
                enable_http: enable_http
                enable_https: enable_https
                default_services: default_services

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MlagIbgpPeeringVrfs(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "base_vlan": {"type": int, "default": 3000}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        base_vlan: int | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, base_vlan: int | None | UndefinedType = Undefined) -> None:
            """
            MlagIbgpPeeringVrfs.

            Args:
            -----
                _custom_data: _custom_data
                base_vlan: base_vlan

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class NetworkPortsItem(AvdModel):
        class Flowcontrol(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "received": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            received: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, received: str | None | UndefinedType = Undefined) -> None:
                """
                Flowcontrol.

                Args:
                -----
                    _custom_data: _custom_data
                    received: received

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ptp(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool, "default": False},
                "endpoint_role": {"type": str, "default": "follower"},
                "profile": {"type": str, "default": "aes67-r16-2016"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            endpoint_role: str | None
            profile: str | None
            """
            Default available profiles are:
              - "aes67"
              - "aes67-r16-2016"
              - "smpte2059-2"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                endpoint_role: str | None | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ptp.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    endpoint_role: endpoint_role
                    profile:
                       Default available profiles are:
                         - "aes67"
                         - "aes67-r16-2016"
                         - "smpte2059-2"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FlowTracking(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracking.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTracking(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """
            Tracking group name.
            The default group name is taken from fabric variable of the switch,
            `link_tracking.groups[0].name` with default value being "LT_GROUP1".
            Optional if default
            link_tracking settings are configured on the node.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LinkTracking.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name:
                       Tracking group name.
                       The default group name is taken from fabric variable of the switch,
                       `link_tracking.groups[0].name` with default value being "LT_GROUP1".
                       Optional if default
                       link_tracking settings are configured on the node.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdModel):
            class Pae(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | None | UndefinedType = Undefined) -> None:
                    """
                    Pae.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AuthenticationFailure(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}, "allow_vlan": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                action: str | None
                allow_vlan: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    action: str | None | UndefinedType = Undefined,
                    allow_vlan: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AuthenticationFailure.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: action
                        allow_vlan: allow_vlan

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HostMode(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multi_host_authenticated": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                multi_host_authenticated: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    multi_host_authenticated: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostMode.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        multi_host_authenticated: multi_host_authenticated

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MacBasedAuthentication(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "always": {"type": bool},
                    "host_mode_common": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always: bool | None
                host_mode_common: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    host_mode_common: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    MacBasedAuthentication.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        host_mode_common: host_mode_common

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timeout(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "idle_host": {"type": int},
                    "quiet_period": {"type": int},
                    "reauth_period": {"type": str},
                    "reauth_timeout_ignore": {"type": bool},
                    "tx_period": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                idle_host: int | None
                quiet_period: int | None
                reauth_period: str | None
                """Range 60-4294967295 or "server"."""
                reauth_timeout_ignore: bool | None
                tx_period: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    idle_host: int | None | UndefinedType = Undefined,
                    quiet_period: int | None | UndefinedType = Undefined,
                    reauth_period: str | None | UndefinedType = Undefined,
                    reauth_timeout_ignore: bool | None | UndefinedType = Undefined,
                    tx_period: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timeout.

                    Args:
                    -----
                        _custom_data: _custom_data
                        idle_host: idle_host
                        quiet_period: quiet_period
                        reauth_period: Range 60-4294967295 or "server".
                        reauth_timeout_ignore: reauth_timeout_ignore
                        tx_period: tx_period

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Unauthorized(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "access_vlan_membership_egress": {"type": bool},
                    "native_vlan_membership_egress": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                access_vlan_membership_egress: bool | None
                native_vlan_membership_egress: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    access_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                    native_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Unauthorized.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_vlan_membership_egress: access_vlan_membership_egress
                        native_vlan_membership_egress: native_vlan_membership_egress

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "port_control": {"type": str},
                "port_control_force_authorized_phone": {"type": bool},
                "reauthentication": {"type": bool},
                "pae": {"type": Pae},
                "authentication_failure": {"type": AuthenticationFailure},
                "host_mode": {"type": HostMode},
                "mac_based_authentication": {"type": MacBasedAuthentication},
                "timeout": {"type": Timeout},
                "reauthorization_request_limit": {"type": int},
                "unauthorized": {"type": Unauthorized},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            port_control: str | None
            port_control_force_authorized_phone: bool | None
            reauthentication: bool | None
            pae: Pae
            authentication_failure: AuthenticationFailure
            host_mode: HostMode
            mac_based_authentication: MacBasedAuthentication
            timeout: Timeout
            reauthorization_request_limit: int | None
            unauthorized: Unauthorized

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                port_control: str | None | UndefinedType = Undefined,
                port_control_force_authorized_phone: bool | None | UndefinedType = Undefined,
                reauthentication: bool | None | UndefinedType = Undefined,
                pae: Pae | UndefinedType = Undefined,
                authentication_failure: AuthenticationFailure | UndefinedType = Undefined,
                host_mode: HostMode | UndefinedType = Undefined,
                mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                timeout: Timeout | UndefinedType = Undefined,
                reauthorization_request_limit: int | None | UndefinedType = Undefined,
                unauthorized: Unauthorized | UndefinedType = Undefined,
            ) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    port_control: port_control
                    port_control_force_authorized_phone: port_control_force_authorized_phone
                    reauthentication: reauthentication
                    pae: pae
                    authentication_failure: authentication_failure
                    host_mode: host_mode
                    mac_based_authentication: mac_based_authentication
                    timeout: timeout
                    reauthorization_request_limit: reauthorization_request_limit
                    unauthorized: unauthorized

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Poe(EosCliConfigGen.EthernetInterfacesItem.Poe):
            pass

        class StormControl(AvdModel):
            class All(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    All.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Broadcast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Broadcast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Multicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class UnknownUnicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnknownUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            all: All
            broadcast: Broadcast
            multicast: Multicast
            unknown_unicast: UnknownUnicast

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                all: All | UndefinedType = Undefined,
                broadcast: Broadcast | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
            ) -> None:
                """
                StormControl.

                Args:
                -----
                    _custom_data: _custom_data
                    all: all
                    broadcast: broadcast
                    multicast: multicast
                    unknown_unicast: unknown_unicast

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MonitorSessionsItem(AvdModel):
            class SourceSettings(AvdModel):
                class AccessGroup(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}, "priority": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    type: str | None
                    name: str | None
                    """ACL name."""
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        type: str | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessGroup.

                        Args:
                        -----
                            _custom_data: _custom_data
                            type: type
                            name: ACL name.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction": {"type": str}, "access_group": {"type": AccessGroup}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                direction: str | None
                access_group: AccessGroup
                """This can only be set when `session_settings.access_group` is not set."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    direction: str | None | UndefinedType = Undefined,
                    access_group: AccessGroup | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourceSettings.

                    Args:
                    -----
                        _custom_data: _custom_data
                        direction: direction
                        access_group: This can only be set when `session_settings.access_group` is not set.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SessionSettings(AvdModel):
                class AccessGroup(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    type: str | None
                    name: str | None
                    """ACL name."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        type: str | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessGroup.

                        Args:
                        -----
                            _custom_data: _custom_data
                            type: type
                            name: ACL name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Truncate(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "size": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    size: int | None
                    """Size in bytes."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        size: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Truncate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            size: Size in bytes.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "encapsulation_gre_metadata_tx": {"type": bool},
                    "header_remove_size": {"type": int},
                    "access_group": {"type": AccessGroup},
                    "rate_limit_per_ingress_chip": {"type": str},
                    "rate_limit_per_egress_chip": {"type": str},
                    "sample": {"type": int},
                    "truncate": {"type": Truncate},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                encapsulation_gre_metadata_tx: bool | None
                header_remove_size: int | None
                """Number of bytes to remove from header."""
                access_group: AccessGroup
                rate_limit_per_ingress_chip: str | None
                """
                Ratelimit and unit as string.
                Examples:
                  "100000 bps"
                  "100 kbps"
                  "10 mbps"
                """
                rate_limit_per_egress_chip: str | None
                """
                Ratelimit and unit as string.
                Examples:
                  "100000 bps"
                  "100 kbps"
                  "10 mbps"
                """
                sample: int | None
                truncate: Truncate

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    encapsulation_gre_metadata_tx: bool | None | UndefinedType = Undefined,
                    header_remove_size: int | None | UndefinedType = Undefined,
                    access_group: AccessGroup | UndefinedType = Undefined,
                    rate_limit_per_ingress_chip: str | None | UndefinedType = Undefined,
                    rate_limit_per_egress_chip: str | None | UndefinedType = Undefined,
                    sample: int | None | UndefinedType = Undefined,
                    truncate: Truncate | UndefinedType = Undefined,
                ) -> None:
                    """
                    SessionSettings.

                    Args:
                    -----
                        _custom_data: _custom_data
                        encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                        header_remove_size: Number of bytes to remove from header.
                        access_group: access_group
                        rate_limit_per_ingress_chip:
                           Ratelimit and unit as string.

                    Examples:
                             "100000 bps"
                             "100 kbps"
                             "10 mbps"
                        rate_limit_per_egress_chip:
                           Ratelimit and unit as string.

                    Examples:
                             "100000 bps"
                             "100 kbps"
                             "10 mbps"
                        sample: sample
                        truncate: truncate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "role": {"type": str},
                "source_settings": {"type": SourceSettings},
                "session_settings": {"type": SessionSettings},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Session name."""
            role: str | None
            source_settings: SourceSettings
            session_settings: SessionSettings
            """
            Session settings are defined per session name.
            Different session_settings for the same session name
            will be combined/merged.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                source_settings: SourceSettings | UndefinedType = Undefined,
                session_settings: SessionSettings | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorSessionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Session name.
                    role: role
                    source_settings: source_settings
                    session_settings:
                       Session settings are defined per session name.
                       Different session_settings for the same session name
                       will be combined/merged.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EthernetSegment(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "short_esi": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_algorithm": {"type": str},
                "designated_forwarder_preferences": {"type": list, "items": int},
                "dont_preempt": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "short_esi")
            _custom_data: dict[str, Any]
            short_esi: str
            """
            In format xxxx:xxxx:xxxx or "auto".
            Define a manual short-esi (be careful using this on profiles) or
            set the value to "auto" to automatically generate the value.
            Please see the notes under "EVPN A/A
            ESI dual and single-attached endpoint scenarios" before setting `short_esi: auto`.
            """
            redundancy: str | None
            """
            If omitted, Port-Channels use the EOS default of all-active.
            If omitted, Ethernet interfaces are
            configured as single-active.
            """
            designated_forwarder_algorithm: str | None
            """
            Configure DF algorithm and preferences.
            - auto: Use preference-based algorithm and assign preference
            based on position of device in the 'switches' list,
              e.g., assuming a list of three switches, this
            would assign a preference of 200 to the first switch, 100 to the 2nd, and 0 to the third.
            -
            preference: Set preference for each switch manually using designated_forwarder_preferences key.
            -
            modulus: Use the default modulus-based algorithm.
            If omitted, Port-Channels use the EOS default of
            modulus.
            If omitted, Ethernet interfaces default to the 'auto' mechanism detailed above.
            """
            designated_forwarder_preferences: list[int]
            """Manual preference as described above, required only for preference algorithm."""
            dont_preempt: bool | None
            """Disable preemption for single-active forwarding when auto/manual DF preference is configured."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                short_esi: str | UndefinedType = Undefined,
                redundancy: str | None | UndefinedType = Undefined,
                designated_forwarder_algorithm: str | None | UndefinedType = Undefined,
                designated_forwarder_preferences: list[int] | UndefinedType = Undefined,
                dont_preempt: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                EthernetSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    short_esi:
                       In format xxxx:xxxx:xxxx or "auto".
                       Define a manual short-esi (be careful using this on profiles) or
                       set the value to "auto" to automatically generate the value.
                       Please see the notes under "EVPN A/A
                       ESI dual and single-attached endpoint scenarios" before setting `short_esi: auto`.
                    redundancy:
                       If omitted, Port-Channels use the EOS default of all-active.
                       If omitted, Ethernet interfaces are
                       configured as single-active.
                    designated_forwarder_algorithm:
                       Configure DF algorithm and preferences.
                       - auto: Use preference-based algorithm and assign preference
                       based on position of device in the 'switches' list,
                         e.g., assuming a list of three switches, this
                       would assign a preference of 200 to the first switch, 100 to the 2nd, and 0 to the third.
                       -
                       preference: Set preference for each switch manually using designated_forwarder_preferences key.
                       -
                       modulus: Use the default modulus-based algorithm.
                       If omitted, Port-Channels use the EOS default of
                       modulus.
                       If omitted, Ethernet interfaces default to the 'auto' mechanism detailed above.
                    designated_forwarder_preferences: Manual preference as described above, required only for preference algorithm.
                    dont_preempt: Disable preemption for single-active forwarding when auto/manual DF preference is configured.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PortChannel(AvdModel):
            class LacpFallback(AvdModel):
                class Individual(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    profile: str | None
                    """Port-profile name to inherit configuration."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined) -> None:
                        """
                        Individual.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: Port-profile name to inherit configuration.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "individual": {"type": Individual}, "timeout": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                """
                Either static or individual mode is supported.
                If the mode is set to "individual" the
                "individual.profile" setting must be defined.
                """
                individual: Individual
                """
                Define parameters for port-channel member interfaces. Applies only if LACP fallback is set to
                "individual".
                """
                timeout: int | None
                """Timeout in seconds. EOS default is 90 seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    individual: Individual | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LacpFallback.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode:
                           Either static or individual mode is supported.
                           If the mode is set to "individual" the
                           "individual.profile" setting must be defined.
                        individual:
                           Define parameters for port-channel member interfaces. Applies only if LACP fallback is set to
                           "individual".
                        timeout: Timeout in seconds. EOS default is 90 seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LacpTimer(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multiplier": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                """LACP mode for interface members."""
                multiplier: int | None
                """Number of LACP BPDUs lost before deeming the peer down. EOS default is 3."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LacpTimer.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: LACP mode for interface members.
                        multiplier: Number of LACP BPDUs lost before deeming the peer down. EOS default is 3.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SubinterfacesItem(AvdModel):
                class EncapsulationVlan(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "client_dot1q": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    client_dot1q: int | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, client_dot1q: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        EncapsulationVlan.

                        Args:
                        -----
                            _custom_data: _custom_data
                            client_dot1q: client_dot1q

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "number": {"type": int},
                    "short_esi": {"type": str},
                    "vlan_id": {"type": int},
                    "encapsulation_vlan": {"type": EncapsulationVlan},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                number: int | None
                """Subinterface number."""
                short_esi: str | None
                """
                In format xxxx:xxxx:xxxx or "auto".
                Required for multihomed port-channels with subinterfaces.
                """
                vlan_id: int | None
                """
                VLAN ID to bridge.
                Default is subinterface number.
                """
                encapsulation_vlan: EncapsulationVlan
                """
                Client VLAN ID encapsulation.
                Default is subinterface number.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    number: int | None | UndefinedType = Undefined,
                    short_esi: str | None | UndefinedType = Undefined,
                    vlan_id: int | None | UndefinedType = Undefined,
                    encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                ) -> None:
                    """
                    SubinterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        number: Subinterface number.
                        short_esi:
                           In format xxxx:xxxx:xxxx or "auto".
                           Required for multihomed port-channels with subinterfaces.
                        vlan_id:
                           VLAN ID to bridge.
                           Default is subinterface number.
                        encapsulation_vlan:
                           Client VLAN ID encapsulation.
                           Default is subinterface number.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "mode": {"type": str},
                "channel_id": {"type": int},
                "description": {"type": str},
                "endpoint_port_channel": {"type": str},
                "enabled": {"type": bool, "default": True},
                "ptp_mpass": {"type": bool, "default": False},
                "lacp_fallback": {"type": LacpFallback},
                "lacp_timer": {"type": LacpTimer},
                "subinterfaces": {"type": list, "items": SubinterfacesItem},
                "raw_eos_cli": {"type": str},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mode: str | None
            """Port-Channel Mode."""
            channel_id: int | None
            """
            Port-Channel ID.
            If no channel_id is specified, an id is generated from the first switch port in the
            port channel.
            """
            description: str | None
            """
            Description or description template to be used on the port-channel interface.
            This can be a template
            using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
            to/custom-descriptions-names.html#avd-string-formatter-syntax.
            The available template fields are:
            - `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
              -
            `endpoint` - The name of the connected endpoint
              - `endpoint_port_channel` - The value from
            `endpoint_port_channel` if set.
              - `port_channel_id` - The port-channel number for the switch.
              -
            `adapter_description` - The adapter's description if set.
              - `adapter_description_or_endpoint` -
            Helper alias of the adapter_description or endpoint.

            The default description is set by
            `default_connected_endpoints_port_channel_description`.
            By default the description is templated from
            the type, name and port_channel interface of the endpoint if set.
            """
            endpoint_port_channel: str | None
            """
            Name of the port-channel interface on the endpoint.
            Used for the port-channel description template
            with the field name `peer_interface`
            """
            enabled: bool | None
            """
            Port-Channel administrative state.
            Setting to false will set port to 'shutdown' in intended
            configuration.
            """
            ptp_mpass: bool | None
            """
            When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
            logical device.
            Arista PTP enabled devices always place PTP messages on the same physical link
            within the port-channel.
            Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
            devices.
            """
            lacp_fallback: LacpFallback
            """LACP fallback configuration."""
            lacp_timer: LacpTimer
            """LACP timer configuration. Applies only when Port-channel mode is not "on"."""
            subinterfaces: list[SubinterfacesItem]
            """
            Port-Channel L2 Subinterfaces
            Subinterfaces are only supported on routed port-channels, which means
            they cannot be configured on MLAG port-channels.
            Setting short_esi: auto generates the short_esi
            automatically using a hash of configuration elements.
            Please see the notes under "EVPN A/A ESI dual-
            attached endpoint scenario" before setting short_esi: auto.
            """
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""
            structured_config: StructuredConfig
            """
            Custom structured config added under port_channel_interfaces.[name=<interface>] for
            eos_cli_config_gen.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                channel_id: int | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                endpoint_port_channel: str | None | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                ptp_mpass: bool | None | UndefinedType = Undefined,
                lacp_fallback: LacpFallback | UndefinedType = Undefined,
                lacp_timer: LacpTimer | UndefinedType = Undefined,
                subinterfaces: list[SubinterfacesItem] | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                PortChannel.

                Args:
                -----
                    _custom_data: _custom_data
                    mode: Port-Channel Mode.
                    channel_id:
                       Port-Channel ID.
                       If no channel_id is specified, an id is generated from the first switch port in the
                       port channel.
                    description:
                       Description or description template to be used on the port-channel interface.
                       This can be a template
                       using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                       to/custom-descriptions-names.html#avd-string-formatter-syntax.
                       The available template fields are:
                       - `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                         -
                       `endpoint` - The name of the connected endpoint
                         - `endpoint_port_channel` - The value from
                       `endpoint_port_channel` if set.
                         - `port_channel_id` - The port-channel number for the switch.
                         -
                       `adapter_description` - The adapter's description if set.
                         - `adapter_description_or_endpoint` -
                       Helper alias of the adapter_description or endpoint.

                       The default description is set by
                       `default_connected_endpoints_port_channel_description`.
                       By default the description is templated from
                       the type, name and port_channel interface of the endpoint if set.
                    endpoint_port_channel:
                       Name of the port-channel interface on the endpoint.
                       Used for the port-channel description template
                       with the field name `peer_interface`
                    enabled:
                       Port-Channel administrative state.
                       Setting to false will set port to 'shutdown' in intended
                       configuration.
                    ptp_mpass:
                       When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                       logical device.
                       Arista PTP enabled devices always place PTP messages on the same physical link
                       within the port-channel.
                       Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                       devices.
                    lacp_fallback: LACP fallback configuration.
                    lacp_timer: LACP timer configuration. Applies only when Port-channel mode is not "on".
                    subinterfaces:
                       Port-Channel L2 Subinterfaces
                       Subinterfaces are only supported on routed port-channels, which means
                       they cannot be configured on MLAG port-channels.
                       Setting short_esi: auto generates the short_esi
                       automatically using a hash of configuration elements.
                       Please see the notes under "EVPN A/A ESI dual-
                       attached endpoint scenario" before setting short_esi: auto.
                    raw_eos_cli: EOS CLI rendered directly on the port-channel interface in the final EOS configuration.
                    structured_config:
                       Custom structured config added under port_channel_interfaces.[name=<interface>] for
                       eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "switches": {"type": list, "items": str},
            "switch_ports": {"type": list, "items": str},
            "description": {"type": str},
            "endpoint": {"type": str},
            "speed": {"type": str},
            "profile": {"type": str},
            "enabled": {"type": bool, "default": True},
            "mode": {"type": str},
            "mtu": {"type": int},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "phone_vlan": {"type": int},
            "phone_trunk_mode": {"type": str},
            "trunk_groups": {"type": list, "items": str},
            "vlans": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "flowcontrol": {"type": Flowcontrol},
            "qos_profile": {"type": str},
            "ptp": {"type": Ptp},
            "sflow": {"type": bool},
            "flow_tracking": {"type": FlowTracking},
            "link_tracking": {"type": LinkTracking},
            "dot1x": {"type": Dot1x},
            "poe": {"type": Poe},
            "storm_control": {"type": StormControl},
            "monitor_sessions": {"type": list, "items": MonitorSessionsItem},
            "ethernet_segment": {"type": EthernetSegment},
            "port_channel": {"type": PortChannel},
            "validate_state": {"type": bool},
            "raw_eos_cli": {"type": str},
            "structured_config": {"type": StructuredConfig},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        switches: list[str]
        """
        Regex matching the full hostname of one or more switches.
        The regular expression must match the full
        hostname.
        """
        switch_ports: list[str]
        """
        List of ranges using AVD range_expand syntax.
        For example:

        switch_ports:
          - Ethernet1
          -
        Ethernet2-48

        All switch_ports ranges are expanded into individual port configurations.

        For more
        details and examples of the `range_expand` syntax, see the [`arista.avd.range_expand`
        documentation](../../../docs/plugins/Filter_plugins/range_expand.md).
        """
        description: str | None
        """
        Description or description template to be used on all ports.
        This can be a template using the AVD
        string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
        descriptions-names.html#avd-string-formatter-syntax.
        The available template fields are:
          -
        `endpoint_type` - always set to `network_port`.
          - `endpoint` - content of the `endpoint` key if
        set.

        The default description is set by `default_network_ports_description`.
        By default the
        description is templated from the `endpoint` key if set.
        """
        endpoint: str | None
        """Name or description of the endpoints connected to these ports."""
        speed: str | None
        """
        Set adapter speed in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        If not specified speed will be auto.
        """
        profile: str | None
        """Port-profile name to inherit configuration."""
        enabled: bool | None
        """
        Administrative state, setting to false will set the port to 'shutdown' in the intended
        configuration.
        """
        mode: str | None
        """Interface mode."""
        mtu: int | None
        l2_mtu: int | None
        l2_mru: int | None
        native_vlan: int | None
        """
        Native VLAN for a trunk port.
        If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag`
        takes precedence.
        """
        native_vlan_tag: bool | None
        """If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag` takes precedence."""
        phone_vlan: int | None
        """
        Phone VLAN for a mode `trunk phone` port.
        Requires `mode: trunk phone` to be set.
        """
        phone_trunk_mode: str | None
        """
        Specify if the phone traffic is tagged or untagged.
        If both data and phone traffic are untagged,
        MAC-Based VLAN Assignment (MBVA) is used, if supported by the model of switch.
        """
        trunk_groups: list[str]
        """
        Required with `enable_trunk_groups: true`.
        Trunk Groups are used for limiting VLANs on trunk ports
        to VLANs with the same Trunk Group.
        """
        vlans: str | None
        """
        Interface VLANs - if not set, the EOS default is that all VLANs are allowed for trunk ports, and
        VLAN 1 will be used for access ports.
        """
        spanning_tree_portfast: str | None
        spanning_tree_bpdufilter: str | None
        spanning_tree_bpduguard: str | None
        flowcontrol: Flowcontrol
        qos_profile: str | None
        """QOS profile name."""
        ptp: Ptp
        """
        The global PTP profile parameters will be applied to all connected endpoints where `ptp` is manually
        enabled.
        `ptp role master` is set to ensure control over the PTP topology.
        """
        sflow: bool | None
        """Configures sFlow on the interface. Overrides `fabric_sflow.endpoints` setting."""
        flow_tracking: FlowTracking
        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.endpoints` setting."""
        link_tracking: LinkTracking
        """
        Configure the downstream interfaces of a respective Link Tracking Group.
        If `port_channel` is
        defined in an adapter, then the port-channel interface is configured to be the downstream.
        Else all
        the ethernet interfaces will be configured as downstream -> to configure single-active EVPN
        multihomed networks.
        """
        dot1x: Dot1x
        """802.1x"""
        poe: Poe
        """Power Over Ethernet settings applied on port. Only configured if platform supports PoE."""
        storm_control: StormControl
        """Storm control settings applied on port toward the endpoint."""
        monitor_sessions: list[MonitorSessionsItem]
        """Used to define switchports as source or destination for monitoring sessions."""
        ethernet_segment: EthernetSegment
        """Settings for all or single-active EVPN multihoming."""
        port_channel: PortChannel
        """Used for port-channel adapter."""
        validate_state: bool | None
        """Set to false to disable interface validation by the `eos_validate_state` role."""
        raw_eos_cli: str | None
        """EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""
        structured_config: StructuredConfig
        """Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            switches: list[str] | UndefinedType = Undefined,
            switch_ports: list[str] | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            endpoint: str | None | UndefinedType = Undefined,
            speed: str | None | UndefinedType = Undefined,
            profile: str | None | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            l2_mtu: int | None | UndefinedType = Undefined,
            l2_mru: int | None | UndefinedType = Undefined,
            native_vlan: int | None | UndefinedType = Undefined,
            native_vlan_tag: bool | None | UndefinedType = Undefined,
            phone_vlan: int | None | UndefinedType = Undefined,
            phone_trunk_mode: str | None | UndefinedType = Undefined,
            trunk_groups: list[str] | UndefinedType = Undefined,
            vlans: str | None | UndefinedType = Undefined,
            spanning_tree_portfast: str | None | UndefinedType = Undefined,
            spanning_tree_bpdufilter: str | None | UndefinedType = Undefined,
            spanning_tree_bpduguard: str | None | UndefinedType = Undefined,
            flowcontrol: Flowcontrol | UndefinedType = Undefined,
            qos_profile: str | None | UndefinedType = Undefined,
            ptp: Ptp | UndefinedType = Undefined,
            sflow: bool | None | UndefinedType = Undefined,
            flow_tracking: FlowTracking | UndefinedType = Undefined,
            link_tracking: LinkTracking | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            poe: Poe | UndefinedType = Undefined,
            storm_control: StormControl | UndefinedType = Undefined,
            monitor_sessions: list[MonitorSessionsItem] | UndefinedType = Undefined,
            ethernet_segment: EthernetSegment | UndefinedType = Undefined,
            port_channel: PortChannel | UndefinedType = Undefined,
            validate_state: bool | None | UndefinedType = Undefined,
            raw_eos_cli: str | None | UndefinedType = Undefined,
            structured_config: StructuredConfig | UndefinedType = Undefined,
        ) -> None:
            """
            NetworkPortsItem.

            Args:
            -----
                _custom_data: _custom_data
                switches:
                   Regex matching the full hostname of one or more switches.
                   The regular expression must match the full
                   hostname.
                switch_ports:
                   List of ranges using AVD range_expand syntax.
                   For example:

                   switch_ports:
                     - Ethernet1
                     -
                   Ethernet2-48

                   All switch_ports ranges are expanded into individual port configurations.

                   For more
                   details and examples of the `range_expand` syntax, see the [`arista.avd.range_expand`
                   documentation](../../../docs/plugins/Filter_plugins/range_expand.md).
                description:
                   Description or description template to be used on all ports.
                   This can be a template using the AVD
                   string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
                   descriptions-names.html#avd-string-formatter-syntax.
                   The available template fields are:
                     -
                   `endpoint_type` - always set to `network_port`.
                     - `endpoint` - content of the `endpoint` key if
                   set.

                   The default description is set by `default_network_ports_description`.
                   By default the
                   description is templated from the `endpoint` key if set.
                endpoint: Name or description of the endpoints connected to these ports.
                speed:
                   Set adapter speed in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                   If not specified speed will be auto.
                profile: Port-profile name to inherit configuration.
                enabled:
                   Administrative state, setting to false will set the port to 'shutdown' in the intended
                   configuration.
                mode: Interface mode.
                mtu: mtu
                l2_mtu: l2_mtu
                l2_mru: l2_mru
                native_vlan:
                   Native VLAN for a trunk port.
                   If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag`
                   takes precedence.
                native_vlan_tag: If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag` takes precedence.
                phone_vlan:
                   Phone VLAN for a mode `trunk phone` port.
                   Requires `mode: trunk phone` to be set.
                phone_trunk_mode:
                   Specify if the phone traffic is tagged or untagged.
                   If both data and phone traffic are untagged,
                   MAC-Based VLAN Assignment (MBVA) is used, if supported by the model of switch.
                trunk_groups:
                   Required with `enable_trunk_groups: true`.
                   Trunk Groups are used for limiting VLANs on trunk ports
                   to VLANs with the same Trunk Group.
                vlans:
                   Interface VLANs - if not set, the EOS default is that all VLANs are allowed for trunk ports, and
                   VLAN 1 will be used for access ports.
                spanning_tree_portfast: spanning_tree_portfast
                spanning_tree_bpdufilter: spanning_tree_bpdufilter
                spanning_tree_bpduguard: spanning_tree_bpduguard
                flowcontrol: flowcontrol
                qos_profile: QOS profile name.
                ptp:
                   The global PTP profile parameters will be applied to all connected endpoints where `ptp` is manually
                   enabled.
                   `ptp role master` is set to ensure control over the PTP topology.
                sflow: Configures sFlow on the interface. Overrides `fabric_sflow.endpoints` setting.
                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.endpoints` setting.
                link_tracking:
                   Configure the downstream interfaces of a respective Link Tracking Group.
                   If `port_channel` is
                   defined in an adapter, then the port-channel interface is configured to be the downstream.
                   Else all
                   the ethernet interfaces will be configured as downstream -> to configure single-active EVPN
                   multihomed networks.
                dot1x: 802.1x
                poe: Power Over Ethernet settings applied on port. Only configured if platform supports PoE.
                storm_control: Storm control settings applied on port toward the endpoint.
                monitor_sessions: Used to define switchports as source or destination for monitoring sessions.
                ethernet_segment: Settings for all or single-active EVPN multihoming.
                port_channel: Used for port-channel adapter.
                validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                raw_eos_cli: EOS CLI rendered directly on the ethernet interface in the final EOS configuration.
                structured_config: Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class NetworkServicesKeysItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined) -> None:
            """
            NetworkServicesKeysItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class NetworkServicesKeys(AvdCollection[str, NetworkServicesKeysItem]):
        _primary_key: ClassVar[str] = "name"

    NetworkServicesKeys._item_type = NetworkServicesKeysItem

    class CustomNodeTypeKeysItem(AvdModel):
        class NetworkServices(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "l1": {"type": bool, "default": False},
                "l2": {"type": bool, "default": False},
                "l3": {"type": bool, "default": False},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            l1: bool | None
            """??"""
            l2: bool | None
            """Vlans"""
            l3: bool | None
            """
            VRFs, SVIs (if l2 is true).
            Only supported with underlay_router.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                l1: bool | None | UndefinedType = Undefined,
                l2: bool | None | UndefinedType = Undefined,
                l3: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                NetworkServices.

                Args:
                -----
                    _custom_data: _custom_data
                    l1: ??
                    l2: Vlans
                    l3:
                       VRFs, SVIs (if l2 is true).
                       Only supported with underlay_router.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpAddressing(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "python_module": {"type": str},
                "python_class_name": {"type": str},
                "router_id": {"type": str},
                "router_id_ipv6": {"type": str},
                "mlag_ip_primary": {"type": str},
                "mlag_ip_secondary": {"type": str},
                "mlag_l3_ip_primary": {"type": str},
                "mlag_l3_ip_secondary": {"type": str},
                "mlag_ibgp_peering_ip_primary": {"type": str},
                "mlag_ibgp_peering_ip_secondary": {"type": str},
                "p2p_uplinks_ip": {"type": str},
                "p2p_uplinks_peer_ip": {"type": str},
                "vtep_ip_mlag": {"type": str},
                "vtep_ip": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            python_module: str | None
            """Custom Python Module to import for IP addressing."""
            python_class_name: str | None
            """Name of Custom Python Class to import for IP addressing."""
            router_id: str | None
            """Path to Custom J2 template."""
            router_id_ipv6: str | None
            """Path to Custom J2 template."""
            mlag_ip_primary: str | None
            """Path to Custom J2 template."""
            mlag_ip_secondary: str | None
            """Path to Custom J2 template."""
            mlag_l3_ip_primary: str | None
            """Path to Custom J2 template."""
            mlag_l3_ip_secondary: str | None
            """Path to Custom J2 template."""
            mlag_ibgp_peering_ip_primary: str | None
            """Path to Custom J2 template."""
            mlag_ibgp_peering_ip_secondary: str | None
            """Path to Custom J2 template."""
            p2p_uplinks_ip: str | None
            """Path to Custom J2 template."""
            p2p_uplinks_peer_ip: str | None
            """Path to Custom J2 template."""
            vtep_ip_mlag: str | None
            """Path to Custom J2 template."""
            vtep_ip: str | None
            """Path to Custom J2 template."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                python_module: str | None | UndefinedType = Undefined,
                python_class_name: str | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                router_id_ipv6: str | None | UndefinedType = Undefined,
                mlag_ip_primary: str | None | UndefinedType = Undefined,
                mlag_ip_secondary: str | None | UndefinedType = Undefined,
                mlag_l3_ip_primary: str | None | UndefinedType = Undefined,
                mlag_l3_ip_secondary: str | None | UndefinedType = Undefined,
                mlag_ibgp_peering_ip_primary: str | None | UndefinedType = Undefined,
                mlag_ibgp_peering_ip_secondary: str | None | UndefinedType = Undefined,
                p2p_uplinks_ip: str | None | UndefinedType = Undefined,
                p2p_uplinks_peer_ip: str | None | UndefinedType = Undefined,
                vtep_ip_mlag: str | None | UndefinedType = Undefined,
                vtep_ip: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpAddressing.

                Args:
                -----
                    _custom_data: _custom_data
                    python_module: Custom Python Module to import for IP addressing.
                    python_class_name: Name of Custom Python Class to import for IP addressing.
                    router_id: Path to Custom J2 template.
                    router_id_ipv6: Path to Custom J2 template.
                    mlag_ip_primary: Path to Custom J2 template.
                    mlag_ip_secondary: Path to Custom J2 template.
                    mlag_l3_ip_primary: Path to Custom J2 template.
                    mlag_l3_ip_secondary: Path to Custom J2 template.
                    mlag_ibgp_peering_ip_primary: Path to Custom J2 template.
                    mlag_ibgp_peering_ip_secondary: Path to Custom J2 template.
                    p2p_uplinks_ip: Path to Custom J2 template.
                    p2p_uplinks_peer_ip: Path to Custom J2 template.
                    vtep_ip_mlag: Path to Custom J2 template.
                    vtep_ip: Path to Custom J2 template.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class InterfaceDescriptions(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "python_module": {"type": str},
                "python_class_name": {"type": str},
                "underlay_ethernet_interfaces": {"type": str},
                "underlay_port_channel_interfaces": {"type": str},
                "mlag_ethernet_interfaces": {"type": str},
                "mlag_port_channel_interfaces": {"type": str},
                "connected_endpoints_ethernet_interfaces": {"type": str},
                "connected_endpoints_port_channel_interfaces": {"type": str},
                "router_id_loopback_interface": {"type": str},
                "vtep_loopback_interface": {"type": str},
                "overlay_loopback_interface": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            python_module: str | None
            """Custom Python Module to import for interface descriptions."""
            python_class_name: str | None
            """Name of Custom Python Class to import for interface descriptions."""
            underlay_ethernet_interfaces: str | None
            """Path to Custom J2 template."""
            underlay_port_channel_interfaces: str | None
            """Path to Custom J2 template."""
            mlag_ethernet_interfaces: str | None
            """Path to Custom J2 template."""
            mlag_port_channel_interfaces: str | None
            """Path to Custom J2 template."""
            connected_endpoints_ethernet_interfaces: str | None
            """Path to Custom J2 template."""
            connected_endpoints_port_channel_interfaces: str | None
            """Path to Custom J2 template."""
            router_id_loopback_interface: str | None
            """Path to Custom J2 template."""
            vtep_loopback_interface: str | None
            """Path to Custom J2 template."""
            overlay_loopback_interface: str | None
            """Path to Custom J2 template."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                python_module: str | None | UndefinedType = Undefined,
                python_class_name: str | None | UndefinedType = Undefined,
                underlay_ethernet_interfaces: str | None | UndefinedType = Undefined,
                underlay_port_channel_interfaces: str | None | UndefinedType = Undefined,
                mlag_ethernet_interfaces: str | None | UndefinedType = Undefined,
                mlag_port_channel_interfaces: str | None | UndefinedType = Undefined,
                connected_endpoints_ethernet_interfaces: str | None | UndefinedType = Undefined,
                connected_endpoints_port_channel_interfaces: str | None | UndefinedType = Undefined,
                router_id_loopback_interface: str | None | UndefinedType = Undefined,
                vtep_loopback_interface: str | None | UndefinedType = Undefined,
                overlay_loopback_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceDescriptions.

                Args:
                -----
                    _custom_data: _custom_data
                    python_module: Custom Python Module to import for interface descriptions.
                    python_class_name: Name of Custom Python Class to import for interface descriptions.
                    underlay_ethernet_interfaces: Path to Custom J2 template.
                    underlay_port_channel_interfaces: Path to Custom J2 template.
                    mlag_ethernet_interfaces: Path to Custom J2 template.
                    mlag_port_channel_interfaces: Path to Custom J2 template.
                    connected_endpoints_ethernet_interfaces: Path to Custom J2 template.
                    connected_endpoints_port_channel_interfaces: Path to Custom J2 template.
                    router_id_loopback_interface: Path to Custom J2 template.
                    vtep_loopback_interface: Path to Custom J2 template.
                    overlay_loopback_interface: Path to Custom J2 template.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "key": {"type": str},
            "type": {"type": str},
            "connected_endpoints": {"type": bool, "default": False},
            "default_evpn_role": {"type": str, "default": "none"},
            "default_ptp_priority1": {"type": int, "default": 127},
            "default_underlay_routing_protocol": {"type": str, "default": "ebgp"},
            "default_overlay_routing_protocol": {"type": str, "default": "ebgp"},
            "default_mpls_overlay_role": {"type": str},
            "default_overlay_address_families": {"type": list, "items": str},
            "default_evpn_encapsulation": {"type": str},
            "default_wan_role": {"type": str},
            "default_flow_tracker_type": {"type": str, "default": "sampled"},
            "mlag_support": {"type": bool, "default": False},
            "network_services": {"type": NetworkServices},
            "underlay_router": {"type": bool, "default": True},
            "uplink_type": {"type": str, "default": "p2p"},
            "vtep": {"type": bool, "default": False},
            "mpls_lsr": {"type": bool, "default": False},
            "ip_addressing": {"type": IpAddressing},
            "interface_descriptions": {"type": InterfaceDescriptions},
            "cv_tags_topology_type": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "key")
        _custom_data: dict[str, Any]
        key: str
        type: str | None
        """Type value matching this node_type_key."""
        connected_endpoints: bool | None
        """Are endpoints connected to this node type."""
        default_evpn_role: str | None
        """Default evpn_role. Can be overridden in topology vars."""
        default_ptp_priority1: int | None
        """Default PTP priority 1"""
        default_underlay_routing_protocol: str | None
        """
        Set the default underlay routing_protocol.
        Can be overridden by setting "underlay_routing_protocol"
        host/group_vars.
        """
        default_overlay_routing_protocol: str | None
        """
        Set the default overlay routing_protocol.
        Can be overridden by setting "overlay_routing_protocol"
        host/group_vars.
        """
        default_mpls_overlay_role: str | None
        """
        Set the default mpls overlay role.
        Acting role in overlay control plane.
        """
        default_overlay_address_families: list[str]
        """Set the default overlay address families."""
        default_evpn_encapsulation: str | None
        """Set the default evpn encapsulation."""
        default_wan_role: str | None
        """
        Set the default WAN role.

        This is used both for AutoVPN and Pathfinder designs.
        That means if
        `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
        `server` indicates that the
        router is a route-reflector.

        Only supported if `overlay_routing_protocol` is set to `ibgp`.
        """
        default_flow_tracker_type: str | None
        """Set the default flow tracker type."""
        mlag_support: bool | None
        """Can this node type support mlag."""
        network_services: NetworkServices
        """Will network services be deployed on this node type."""
        underlay_router: bool | None
        """Is this node type a L3 device."""
        uplink_type: str | None
        """
        `uplink_type` must be `p2p`, `p2p-vrfs` or `lan` if `vtep` or `underlay_router` is true.

        For
        `p2p-vrfs`, the uplinks are configured as L3 interfaces with a subinterface for each VRF
        in
        `network_services` present on both the uplink and the downlink switch.
        The subinterface ID is the
        `vrf_id`.
        'underlay_router' and 'network_services.l3' must be set to true.
        VRF `default` is always
        configured on the physical interface using the underlay routing protocol.
        All subinterfaces use the
        same IP address as the physical interface.
        Multicast is not supported.
        Only BGP is supported for
        subinterfaces.

        For `lan`, a single uplink interface is supported and will be configured as an L3
        Interface with
        subinterfaces for each SVI defined under the VRFs in `network_services` as long as
        the uplink switch also
        has the VLAN permitted by tag/tenant filtering.
        """
        vtep: bool | None
        """Is this switch an EVPN VTEP."""
        mpls_lsr: bool | None
        """Is this switch an MPLS LSR."""
        ip_addressing: IpAddressing
        """Override ip_addressing templates."""
        interface_descriptions: InterfaceDescriptions
        """
        Override interface_descriptions templates.
        If description templates use Jinja2, they have to strip
        whitespaces using {%- -%} on any code blocks.
        """
        cv_tags_topology_type: str | None
        """
        PREVIEW: This key is currently not supported
        Type that CloudVision should use when generating the
        Topology.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            key: str | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            connected_endpoints: bool | None | UndefinedType = Undefined,
            default_evpn_role: str | None | UndefinedType = Undefined,
            default_ptp_priority1: int | None | UndefinedType = Undefined,
            default_underlay_routing_protocol: str | None | UndefinedType = Undefined,
            default_overlay_routing_protocol: str | None | UndefinedType = Undefined,
            default_mpls_overlay_role: str | None | UndefinedType = Undefined,
            default_overlay_address_families: list[str] | UndefinedType = Undefined,
            default_evpn_encapsulation: str | None | UndefinedType = Undefined,
            default_wan_role: str | None | UndefinedType = Undefined,
            default_flow_tracker_type: str | None | UndefinedType = Undefined,
            mlag_support: bool | None | UndefinedType = Undefined,
            network_services: NetworkServices | UndefinedType = Undefined,
            underlay_router: bool | None | UndefinedType = Undefined,
            uplink_type: str | None | UndefinedType = Undefined,
            vtep: bool | None | UndefinedType = Undefined,
            mpls_lsr: bool | None | UndefinedType = Undefined,
            ip_addressing: IpAddressing | UndefinedType = Undefined,
            interface_descriptions: InterfaceDescriptions | UndefinedType = Undefined,
            cv_tags_topology_type: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            CustomNodeTypeKeysItem.

            Args:
            -----
                _custom_data: _custom_data
                key: key
                type: Type value matching this node_type_key.
                connected_endpoints: Are endpoints connected to this node type.
                default_evpn_role: Default evpn_role. Can be overridden in topology vars.
                default_ptp_priority1: Default PTP priority 1
                default_underlay_routing_protocol:
                   Set the default underlay routing_protocol.
                   Can be overridden by setting "underlay_routing_protocol"
                   host/group_vars.
                default_overlay_routing_protocol:
                   Set the default overlay routing_protocol.
                   Can be overridden by setting "overlay_routing_protocol"
                   host/group_vars.
                default_mpls_overlay_role:
                   Set the default mpls overlay role.
                   Acting role in overlay control plane.
                default_overlay_address_families: Set the default overlay address families.
                default_evpn_encapsulation: Set the default evpn encapsulation.
                default_wan_role:
                   Set the default WAN role.

                   This is used both for AutoVPN and Pathfinder designs.
                   That means if
                   `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                   `server` indicates that the
                   router is a route-reflector.

                   Only supported if `overlay_routing_protocol` is set to `ibgp`.
                default_flow_tracker_type: Set the default flow tracker type.
                mlag_support: Can this node type support mlag.
                network_services: Will network services be deployed on this node type.
                underlay_router: Is this node type a L3 device.
                uplink_type:
                   `uplink_type` must be `p2p`, `p2p-vrfs` or `lan` if `vtep` or `underlay_router` is true.

                   For
                   `p2p-vrfs`, the uplinks are configured as L3 interfaces with a subinterface for each VRF
                   in
                   `network_services` present on both the uplink and the downlink switch.
                   The subinterface ID is the
                   `vrf_id`.
                   'underlay_router' and 'network_services.l3' must be set to true.
                   VRF `default` is always
                   configured on the physical interface using the underlay routing protocol.
                   All subinterfaces use the
                   same IP address as the physical interface.
                   Multicast is not supported.
                   Only BGP is supported for
                   subinterfaces.

                   For `lan`, a single uplink interface is supported and will be configured as an L3
                   Interface with
                   subinterfaces for each SVI defined under the VRFs in `network_services` as long as
                   the uplink switch also
                   has the VLAN permitted by tag/tenant filtering.
                vtep: Is this switch an EVPN VTEP.
                mpls_lsr: Is this switch an MPLS LSR.
                ip_addressing: Override ip_addressing templates.
                interface_descriptions:
                   Override interface_descriptions templates.
                   If description templates use Jinja2, they have to strip
                   whitespaces using {%- -%} on any code blocks.
                cv_tags_topology_type:
                   PREVIEW: This key is currently not supported
                   Type that CloudVision should use when generating the
                   Topology.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CustomNodeTypeKeys(AvdCollection[str, CustomNodeTypeKeysItem]):
        _primary_key: ClassVar[str] = "key"

    CustomNodeTypeKeys._item_type = CustomNodeTypeKeysItem

    class NodeTypeKeysItem(AvdModel):
        class NetworkServices(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "l1": {"type": bool, "default": False},
                "l2": {"type": bool, "default": False},
                "l3": {"type": bool, "default": False},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            l1: bool | None
            """??"""
            l2: bool | None
            """Vlans"""
            l3: bool | None
            """
            VRFs, SVIs (if l2 is true).
            Only supported with underlay_router.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                l1: bool | None | UndefinedType = Undefined,
                l2: bool | None | UndefinedType = Undefined,
                l3: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                NetworkServices.

                Args:
                -----
                    _custom_data: _custom_data
                    l1: ??
                    l2: Vlans
                    l3:
                       VRFs, SVIs (if l2 is true).
                       Only supported with underlay_router.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpAddressing(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "python_module": {"type": str},
                "python_class_name": {"type": str},
                "router_id": {"type": str},
                "router_id_ipv6": {"type": str},
                "mlag_ip_primary": {"type": str},
                "mlag_ip_secondary": {"type": str},
                "mlag_l3_ip_primary": {"type": str},
                "mlag_l3_ip_secondary": {"type": str},
                "mlag_ibgp_peering_ip_primary": {"type": str},
                "mlag_ibgp_peering_ip_secondary": {"type": str},
                "p2p_uplinks_ip": {"type": str},
                "p2p_uplinks_peer_ip": {"type": str},
                "vtep_ip_mlag": {"type": str},
                "vtep_ip": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            python_module: str | None
            """Custom Python Module to import for IP addressing."""
            python_class_name: str | None
            """Name of Custom Python Class to import for IP addressing."""
            router_id: str | None
            """Path to Custom J2 template."""
            router_id_ipv6: str | None
            """Path to Custom J2 template."""
            mlag_ip_primary: str | None
            """Path to Custom J2 template."""
            mlag_ip_secondary: str | None
            """Path to Custom J2 template."""
            mlag_l3_ip_primary: str | None
            """Path to Custom J2 template."""
            mlag_l3_ip_secondary: str | None
            """Path to Custom J2 template."""
            mlag_ibgp_peering_ip_primary: str | None
            """Path to Custom J2 template."""
            mlag_ibgp_peering_ip_secondary: str | None
            """Path to Custom J2 template."""
            p2p_uplinks_ip: str | None
            """Path to Custom J2 template."""
            p2p_uplinks_peer_ip: str | None
            """Path to Custom J2 template."""
            vtep_ip_mlag: str | None
            """Path to Custom J2 template."""
            vtep_ip: str | None
            """Path to Custom J2 template."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                python_module: str | None | UndefinedType = Undefined,
                python_class_name: str | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                router_id_ipv6: str | None | UndefinedType = Undefined,
                mlag_ip_primary: str | None | UndefinedType = Undefined,
                mlag_ip_secondary: str | None | UndefinedType = Undefined,
                mlag_l3_ip_primary: str | None | UndefinedType = Undefined,
                mlag_l3_ip_secondary: str | None | UndefinedType = Undefined,
                mlag_ibgp_peering_ip_primary: str | None | UndefinedType = Undefined,
                mlag_ibgp_peering_ip_secondary: str | None | UndefinedType = Undefined,
                p2p_uplinks_ip: str | None | UndefinedType = Undefined,
                p2p_uplinks_peer_ip: str | None | UndefinedType = Undefined,
                vtep_ip_mlag: str | None | UndefinedType = Undefined,
                vtep_ip: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpAddressing.

                Args:
                -----
                    _custom_data: _custom_data
                    python_module: Custom Python Module to import for IP addressing.
                    python_class_name: Name of Custom Python Class to import for IP addressing.
                    router_id: Path to Custom J2 template.
                    router_id_ipv6: Path to Custom J2 template.
                    mlag_ip_primary: Path to Custom J2 template.
                    mlag_ip_secondary: Path to Custom J2 template.
                    mlag_l3_ip_primary: Path to Custom J2 template.
                    mlag_l3_ip_secondary: Path to Custom J2 template.
                    mlag_ibgp_peering_ip_primary: Path to Custom J2 template.
                    mlag_ibgp_peering_ip_secondary: Path to Custom J2 template.
                    p2p_uplinks_ip: Path to Custom J2 template.
                    p2p_uplinks_peer_ip: Path to Custom J2 template.
                    vtep_ip_mlag: Path to Custom J2 template.
                    vtep_ip: Path to Custom J2 template.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class InterfaceDescriptions(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "python_module": {"type": str},
                "python_class_name": {"type": str},
                "underlay_ethernet_interfaces": {"type": str},
                "underlay_port_channel_interfaces": {"type": str},
                "mlag_ethernet_interfaces": {"type": str},
                "mlag_port_channel_interfaces": {"type": str},
                "connected_endpoints_ethernet_interfaces": {"type": str},
                "connected_endpoints_port_channel_interfaces": {"type": str},
                "router_id_loopback_interface": {"type": str},
                "vtep_loopback_interface": {"type": str},
                "overlay_loopback_interface": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            python_module: str | None
            """Custom Python Module to import for interface descriptions."""
            python_class_name: str | None
            """Name of Custom Python Class to import for interface descriptions."""
            underlay_ethernet_interfaces: str | None
            """Path to Custom J2 template."""
            underlay_port_channel_interfaces: str | None
            """Path to Custom J2 template."""
            mlag_ethernet_interfaces: str | None
            """Path to Custom J2 template."""
            mlag_port_channel_interfaces: str | None
            """Path to Custom J2 template."""
            connected_endpoints_ethernet_interfaces: str | None
            """Path to Custom J2 template."""
            connected_endpoints_port_channel_interfaces: str | None
            """Path to Custom J2 template."""
            router_id_loopback_interface: str | None
            """Path to Custom J2 template."""
            vtep_loopback_interface: str | None
            """Path to Custom J2 template."""
            overlay_loopback_interface: str | None
            """Path to Custom J2 template."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                python_module: str | None | UndefinedType = Undefined,
                python_class_name: str | None | UndefinedType = Undefined,
                underlay_ethernet_interfaces: str | None | UndefinedType = Undefined,
                underlay_port_channel_interfaces: str | None | UndefinedType = Undefined,
                mlag_ethernet_interfaces: str | None | UndefinedType = Undefined,
                mlag_port_channel_interfaces: str | None | UndefinedType = Undefined,
                connected_endpoints_ethernet_interfaces: str | None | UndefinedType = Undefined,
                connected_endpoints_port_channel_interfaces: str | None | UndefinedType = Undefined,
                router_id_loopback_interface: str | None | UndefinedType = Undefined,
                vtep_loopback_interface: str | None | UndefinedType = Undefined,
                overlay_loopback_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceDescriptions.

                Args:
                -----
                    _custom_data: _custom_data
                    python_module: Custom Python Module to import for interface descriptions.
                    python_class_name: Name of Custom Python Class to import for interface descriptions.
                    underlay_ethernet_interfaces: Path to Custom J2 template.
                    underlay_port_channel_interfaces: Path to Custom J2 template.
                    mlag_ethernet_interfaces: Path to Custom J2 template.
                    mlag_port_channel_interfaces: Path to Custom J2 template.
                    connected_endpoints_ethernet_interfaces: Path to Custom J2 template.
                    connected_endpoints_port_channel_interfaces: Path to Custom J2 template.
                    router_id_loopback_interface: Path to Custom J2 template.
                    vtep_loopback_interface: Path to Custom J2 template.
                    overlay_loopback_interface: Path to Custom J2 template.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "key": {"type": str},
            "type": {"type": str},
            "connected_endpoints": {"type": bool, "default": False},
            "default_evpn_role": {"type": str, "default": "none"},
            "default_ptp_priority1": {"type": int, "default": 127},
            "default_underlay_routing_protocol": {"type": str, "default": "ebgp"},
            "default_overlay_routing_protocol": {"type": str, "default": "ebgp"},
            "default_mpls_overlay_role": {"type": str},
            "default_overlay_address_families": {"type": list, "items": str},
            "default_evpn_encapsulation": {"type": str},
            "default_wan_role": {"type": str},
            "default_flow_tracker_type": {"type": str, "default": "sampled"},
            "mlag_support": {"type": bool, "default": False},
            "network_services": {"type": NetworkServices},
            "underlay_router": {"type": bool, "default": True},
            "uplink_type": {"type": str, "default": "p2p"},
            "vtep": {"type": bool, "default": False},
            "mpls_lsr": {"type": bool, "default": False},
            "ip_addressing": {"type": IpAddressing},
            "interface_descriptions": {"type": InterfaceDescriptions},
            "cv_tags_topology_type": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "key")
        _custom_data: dict[str, Any]
        key: str
        type: str | None
        """Type value matching this node_type_key."""
        connected_endpoints: bool | None
        """Are endpoints connected to this node type."""
        default_evpn_role: str | None
        """Default evpn_role. Can be overridden in topology vars."""
        default_ptp_priority1: int | None
        """Default PTP priority 1"""
        default_underlay_routing_protocol: str | None
        """
        Set the default underlay routing_protocol.
        Can be overridden by setting "underlay_routing_protocol"
        host/group_vars.
        """
        default_overlay_routing_protocol: str | None
        """
        Set the default overlay routing_protocol.
        Can be overridden by setting "overlay_routing_protocol"
        host/group_vars.
        """
        default_mpls_overlay_role: str | None
        """
        Set the default mpls overlay role.
        Acting role in overlay control plane.
        """
        default_overlay_address_families: list[str]
        """Set the default overlay address families."""
        default_evpn_encapsulation: str | None
        """Set the default evpn encapsulation."""
        default_wan_role: str | None
        """
        Set the default WAN role.

        This is used both for AutoVPN and Pathfinder designs.
        That means if
        `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
        `server` indicates that the
        router is a route-reflector.

        Only supported if `overlay_routing_protocol` is set to `ibgp`.
        """
        default_flow_tracker_type: str | None
        """Set the default flow tracker type."""
        mlag_support: bool | None
        """Can this node type support mlag."""
        network_services: NetworkServices
        """Will network services be deployed on this node type."""
        underlay_router: bool | None
        """Is this node type a L3 device."""
        uplink_type: str | None
        """
        `uplink_type` must be `p2p`, `p2p-vrfs` or `lan` if `vtep` or `underlay_router` is true.

        For
        `p2p-vrfs`, the uplinks are configured as L3 interfaces with a subinterface for each VRF
        in
        `network_services` present on both the uplink and the downlink switch.
        The subinterface ID is the
        `vrf_id`.
        'underlay_router' and 'network_services.l3' must be set to true.
        VRF `default` is always
        configured on the physical interface using the underlay routing protocol.
        All subinterfaces use the
        same IP address as the physical interface.
        Multicast is not supported.
        Only BGP is supported for
        subinterfaces.

        For `lan`, a single uplink interface is supported and will be configured as an L3
        Interface with
        subinterfaces for each SVI defined under the VRFs in `network_services` as long as
        the uplink switch also
        has the VLAN permitted by tag/tenant filtering.
        """
        vtep: bool | None
        """Is this switch an EVPN VTEP."""
        mpls_lsr: bool | None
        """Is this switch an MPLS LSR."""
        ip_addressing: IpAddressing
        """Override ip_addressing templates."""
        interface_descriptions: InterfaceDescriptions
        """
        Override interface_descriptions templates.
        If description templates use Jinja2, they have to strip
        whitespaces using {%- -%} on any code blocks.
        """
        cv_tags_topology_type: str | None
        """
        PREVIEW: This key is currently not supported
        Type that CloudVision should use when generating the
        Topology.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            key: str | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            connected_endpoints: bool | None | UndefinedType = Undefined,
            default_evpn_role: str | None | UndefinedType = Undefined,
            default_ptp_priority1: int | None | UndefinedType = Undefined,
            default_underlay_routing_protocol: str | None | UndefinedType = Undefined,
            default_overlay_routing_protocol: str | None | UndefinedType = Undefined,
            default_mpls_overlay_role: str | None | UndefinedType = Undefined,
            default_overlay_address_families: list[str] | UndefinedType = Undefined,
            default_evpn_encapsulation: str | None | UndefinedType = Undefined,
            default_wan_role: str | None | UndefinedType = Undefined,
            default_flow_tracker_type: str | None | UndefinedType = Undefined,
            mlag_support: bool | None | UndefinedType = Undefined,
            network_services: NetworkServices | UndefinedType = Undefined,
            underlay_router: bool | None | UndefinedType = Undefined,
            uplink_type: str | None | UndefinedType = Undefined,
            vtep: bool | None | UndefinedType = Undefined,
            mpls_lsr: bool | None | UndefinedType = Undefined,
            ip_addressing: IpAddressing | UndefinedType = Undefined,
            interface_descriptions: InterfaceDescriptions | UndefinedType = Undefined,
            cv_tags_topology_type: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            NodeTypeKeysItem.

            Args:
            -----
                _custom_data: _custom_data
                key: key
                type: Type value matching this node_type_key.
                connected_endpoints: Are endpoints connected to this node type.
                default_evpn_role: Default evpn_role. Can be overridden in topology vars.
                default_ptp_priority1: Default PTP priority 1
                default_underlay_routing_protocol:
                   Set the default underlay routing_protocol.
                   Can be overridden by setting "underlay_routing_protocol"
                   host/group_vars.
                default_overlay_routing_protocol:
                   Set the default overlay routing_protocol.
                   Can be overridden by setting "overlay_routing_protocol"
                   host/group_vars.
                default_mpls_overlay_role:
                   Set the default mpls overlay role.
                   Acting role in overlay control plane.
                default_overlay_address_families: Set the default overlay address families.
                default_evpn_encapsulation: Set the default evpn encapsulation.
                default_wan_role:
                   Set the default WAN role.

                   This is used both for AutoVPN and Pathfinder designs.
                   That means if
                   `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                   `server` indicates that the
                   router is a route-reflector.

                   Only supported if `overlay_routing_protocol` is set to `ibgp`.
                default_flow_tracker_type: Set the default flow tracker type.
                mlag_support: Can this node type support mlag.
                network_services: Will network services be deployed on this node type.
                underlay_router: Is this node type a L3 device.
                uplink_type:
                   `uplink_type` must be `p2p`, `p2p-vrfs` or `lan` if `vtep` or `underlay_router` is true.

                   For
                   `p2p-vrfs`, the uplinks are configured as L3 interfaces with a subinterface for each VRF
                   in
                   `network_services` present on both the uplink and the downlink switch.
                   The subinterface ID is the
                   `vrf_id`.
                   'underlay_router' and 'network_services.l3' must be set to true.
                   VRF `default` is always
                   configured on the physical interface using the underlay routing protocol.
                   All subinterfaces use the
                   same IP address as the physical interface.
                   Multicast is not supported.
                   Only BGP is supported for
                   subinterfaces.

                   For `lan`, a single uplink interface is supported and will be configured as an L3
                   Interface with
                   subinterfaces for each SVI defined under the VRFs in `network_services` as long as
                   the uplink switch also
                   has the VLAN permitted by tag/tenant filtering.
                vtep: Is this switch an EVPN VTEP.
                mpls_lsr: Is this switch an MPLS LSR.
                ip_addressing: Override ip_addressing templates.
                interface_descriptions:
                   Override interface_descriptions templates.
                   If description templates use Jinja2, they have to strip
                   whitespaces using {%- -%} on any code blocks.
                cv_tags_topology_type:
                   PREVIEW: This key is currently not supported
                   Type that CloudVision should use when generating the
                   Topology.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class NodeTypeKeys(AvdCollection[str, NodeTypeKeysItem]):
        _primary_key: ClassVar[str] = "key"

    NodeTypeKeys._item_type = NodeTypeKeysItem

    class NtpSettings(AvdModel):
        class ServersItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "burst": {"type": bool},
                "iburst": {"type": bool},
                "key": {"type": int},
                "maxpoll": {"type": int},
                "minpoll": {"type": int},
                "version": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            burst: bool | None
            iburst: bool | None
            key: int | None
            maxpoll: int | None
            minpoll: int | None
            version: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                burst: bool | None | UndefinedType = Undefined,
                iburst: bool | None | UndefinedType = Undefined,
                key: int | None | UndefinedType = Undefined,
                maxpoll: int | None | UndefinedType = Undefined,
                minpoll: int | None | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                ServersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    burst: burst
                    iburst: iburst
                    key: key
                    maxpoll: maxpoll
                    minpoll: minpoll
                    version: version

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AuthenticationKeysItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "hash_algorithm": {"type": str},
                "key": {"type": str},
                "key_type": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """Key identifier."""
            hash_algorithm: str | None
            key: str | None
            """Obfuscated key."""
            key_type: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
                key_type: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                AuthenticationKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: Key identifier.
                    hash_algorithm: hash_algorithm
                    key: Obfuscated key.
                    key_type: key_type

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AuthenticationKeys(AvdCollection[int, AuthenticationKeysItem]):
            _primary_key: ClassVar[str] = "id"

        AuthenticationKeys._item_type = AuthenticationKeysItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "server_vrf": {"type": str},
            "servers": {"type": list, "items": ServersItem},
            "authenticate": {"type": bool},
            "authenticate_servers_only": {"type": bool},
            "authentication_keys": {"type": AuthenticationKeys},
            "trusted_keys": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        server_vrf: str | None
        """
        EOS only supports NTP servers in one VRF, so this VRF is used for all NTP servers and one local-
        interface.
        - `use_mgmt_interface_vrf` will configure the NTP server(s) under the VRF set with
        `mgmt_interface_vrf` and set the `mgmt_interface` as NTP local-interface.
          An error will be raised
        if `mgmt_ip` or `ipv6_mgmt_ip` are not configured for the device.
        - `use_inband_mgmt_vrf` will
        configure the NTP server(s) under the VRF set with `inband_mgmt_vrf` and set the
        `inband_mgmt_interface` as NTP local-interface.
          An error will be raised if inband management is
        not configured for the device.
        - Any other string will be used directly as the VRF name but local
        interface must be set with `custom_structured_configuration_ntp` if needed.
        If not set, the VRF is
        automatically picked up from the global setting `default_mgmt_method`.
        """
        servers: list[ServersItem]
        """The first server is always set as "preferred"."""
        authenticate: bool | None
        authenticate_servers_only: bool | None
        authentication_keys: AuthenticationKeys
        trusted_keys: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            server_vrf: str | None | UndefinedType = Undefined,
            servers: list[ServersItem] | UndefinedType = Undefined,
            authenticate: bool | None | UndefinedType = Undefined,
            authenticate_servers_only: bool | None | UndefinedType = Undefined,
            authentication_keys: AuthenticationKeys | UndefinedType = Undefined,
            trusted_keys: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            NtpSettings.

            Args:
            -----
                _custom_data: _custom_data
                server_vrf:
                   EOS only supports NTP servers in one VRF, so this VRF is used for all NTP servers and one local-
                   interface.
                   - `use_mgmt_interface_vrf` will configure the NTP server(s) under the VRF set with
                   `mgmt_interface_vrf` and set the `mgmt_interface` as NTP local-interface.
                     An error will be raised
                   if `mgmt_ip` or `ipv6_mgmt_ip` are not configured for the device.
                   - `use_inband_mgmt_vrf` will
                   configure the NTP server(s) under the VRF set with `inband_mgmt_vrf` and set the
                   `inband_mgmt_interface` as NTP local-interface.
                     An error will be raised if inband management is
                   not configured for the device.
                   - Any other string will be used directly as the VRF name but local
                   interface must be set with `custom_structured_configuration_ntp` if needed.
                   If not set, the VRF is
                   automatically picked up from the global setting `default_mgmt_method`.
                servers: The first server is always set as "preferred".
                authenticate: authenticate
                authenticate_servers_only: authenticate_servers_only
                authentication_keys: authentication_keys
                trusted_keys: trusted_keys

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class OverlayRdType(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "admin_subfield": {"type": str, "default": "router_id"},
            "admin_subfield_offset": {"type": str},
            "vrf_admin_subfield": {"type": str},
            "vrf_admin_subfield_offset": {"type": str},
            "vlan_assigned_number_subfield": {"type": str, "default": "mac_vrf_id"},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        admin_subfield: str | None
        """
        The method for deriving RD Administrator subfield (first part of RD):
        - 'router_id' means the IP
        address of Loopback0.
        - 'vtep_loopback' means the IP address of the VTEP loopback interface.
        -
        'bgp_as' means the AS number of the device.
        - 'switch_id' means the 'id' value of the device.
        - Any
        <IPv4 Address> without mask.
        - Integer between <0-65535>.
        - Integer between <0-4294967295>.
        -
        'overlay_loopback_ip' means the IP address of Loopback0. (deprecated - use 'router_id' instead)
        """
        admin_subfield_offset: str | None
        """
        Offset can only be used if admin_subfield is an integer between <0-4294967295> or 'switch_id'.
        Total
        value of admin_subfield + admin_subfield_offset must be <= 4294967295.
        """
        vrf_admin_subfield: str | None
        """
        The method for deriving RD Administrator subfield (first part of RD) for VRF services:
        - 'router_id'
        means the IP address of Loopback0.
        - 'vtep_loopback' means the IP address of the VTEP loopback
        interface.
        - 'bgp_as' means the AS number of the device.
        - 'switch_id' means the 'id' value of the
        device.
        - Any <IPv4 Address> without mask.
        - Integer between <0-65535>.
        - Integer between
        <0-4294967295>.
        - 'overlay_loopback_ip' means the IP address of Loopback0. (deprecated - use
        'router_id' instead)

        'vrf_admin_subfield' takes precedence for VRF RDs if set. Otherwise the
        'admin_subfield' value will be used.
        """
        vrf_admin_subfield_offset: str | None
        """
        Offset can only be used if 'vrf_admin_subfield' is an integer between <0-4294967295> or 'switch_id'.
        Total value of 'vrf_admin_subfield' + 'vrf_admin_subfield_offset' must be <= 4294967295.
        """
        vlan_assigned_number_subfield: str | None
        """
        The method for deriving RD Assigned Number subfield for VLAN services (second part of RD):
        -
        'mac_vrf_id' means `(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id`.
        - 'mac_vrf_vni' means
        `(mac_vrf_vni_base or mac_vrf_id_base) + vlan_id`.
        - 'vlan_id' will only use the 'vlan_id' and
        ignores all base values.

        These methods can be overridden per VLAN if either 'rd_override',
        'rt_override' or 'vni_override' is set (preferred in this order).
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            admin_subfield: str | None | UndefinedType = Undefined,
            admin_subfield_offset: str | None | UndefinedType = Undefined,
            vrf_admin_subfield: str | None | UndefinedType = Undefined,
            vrf_admin_subfield_offset: str | None | UndefinedType = Undefined,
            vlan_assigned_number_subfield: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            OverlayRdType.

            Args:
            -----
                _custom_data: _custom_data
                admin_subfield:
                   The method for deriving RD Administrator subfield (first part of RD):
                   - 'router_id' means the IP
                   address of Loopback0.
                   - 'vtep_loopback' means the IP address of the VTEP loopback interface.
                   -
                   'bgp_as' means the AS number of the device.
                   - 'switch_id' means the 'id' value of the device.
                   - Any
                   <IPv4 Address> without mask.
                   - Integer between <0-65535>.
                   - Integer between <0-4294967295>.
                   -
                   'overlay_loopback_ip' means the IP address of Loopback0. (deprecated - use 'router_id' instead)
                admin_subfield_offset:
                   Offset can only be used if admin_subfield is an integer between <0-4294967295> or 'switch_id'.
                   Total
                   value of admin_subfield + admin_subfield_offset must be <= 4294967295.
                vrf_admin_subfield:
                   The method for deriving RD Administrator subfield (first part of RD) for VRF services:
                   - 'router_id'
                   means the IP address of Loopback0.
                   - 'vtep_loopback' means the IP address of the VTEP loopback
                   interface.
                   - 'bgp_as' means the AS number of the device.
                   - 'switch_id' means the 'id' value of the
                   device.
                   - Any <IPv4 Address> without mask.
                   - Integer between <0-65535>.
                   - Integer between
                   <0-4294967295>.
                   - 'overlay_loopback_ip' means the IP address of Loopback0. (deprecated - use
                   'router_id' instead)

                   'vrf_admin_subfield' takes precedence for VRF RDs if set. Otherwise the
                   'admin_subfield' value will be used.
                vrf_admin_subfield_offset:
                   Offset can only be used if 'vrf_admin_subfield' is an integer between <0-4294967295> or 'switch_id'.
                   Total value of 'vrf_admin_subfield' + 'vrf_admin_subfield_offset' must be <= 4294967295.
                vlan_assigned_number_subfield:
                   The method for deriving RD Assigned Number subfield for VLAN services (second part of RD):
                   -
                   'mac_vrf_id' means `(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id`.
                   - 'mac_vrf_vni' means
                   `(mac_vrf_vni_base or mac_vrf_id_base) + vlan_id`.
                   - 'vlan_id' will only use the 'vlan_id' and
                   ignores all base values.

                   These methods can be overridden per VLAN if either 'rd_override',
                   'rt_override' or 'vni_override' is set (preferred in this order).

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class OverlayRtType(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "admin_subfield": {"type": str, "default": "vrf_id"},
            "vrf_admin_subfield": {"type": str, "default": "vrf_id"},
            "vlan_assigned_number_subfield": {"type": str, "default": "mac_vrf_id"},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        admin_subfield: str | None
        """
        The method for deriving RT Administrator subfield (first part of RT):
        - 'vrf_id' means
        `(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id` for VLANs, `(vrf_id or vrf_vni)` for VRFs and `id`
        for bundles defined under 'evpn_vlan_bundles'.
        - 'vrf_vni' means `(mac_vrf_vni_base or
        mac_vrf_id_base) + vlan_id` for VLANs, `(vrf_vni or vrf_id)` for VRFs and `id` for bundles defined
        under 'evpn_vlan_bundles'.
        - 'id' means `vlan_id` for VLANs, `(vrf_id or vrf_vni)` for VRFs and `id`
        for bundles defined under 'evpn_vlan_bundles'.
        - 'bgp_as' means the AS number of the device.
        -
        Integer between <0-65535>.
        - Integer between <0-4294967295>.

        The 'vrf_id' and 'vrf_vni' methods can
        be overridden per VLAN if either 'rt_override' or 'vni_override' is set (preferred in this order).
        The 'vrf_id', 'vrf_vni' and 'id' methods can be overridden per bundle defined under
        `evpn_vlan_bundles` using 'rt_override'.
        """
        vrf_admin_subfield: str | None
        """
        The method for deriving RT Administrator subfield (first part of RT) for VRF services:
        - 'id' means
        `(vrf_id or vrf_vni)`.
        - 'vrf_id' means `(vrf_id or vrf_vni)`.
        - 'vrf_vni' means `(vrf_vni or
        vrf_id)`.
        - 'bgp_as' means the AS number of the device.
        - Integer between <0-65535>.
        - Integer
        between <0-4294967295>.

        'vrf_admin_subfield' takes precedence for VRF RDs if set. Otherwise the
        'admin_subfield' value will be used.
        """
        vlan_assigned_number_subfield: str | None
        """
        The method for deriving RT Assigned Number subfield for VLAN services (second part of RT):
        -
        'mac_vrf_id' means `(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id`.
        - 'mac_vrf_vni' means
        `(mac_vrf_vni_base or mac_vrf_id_base) + vlan_id`.
        - 'vlan_id' will only use the 'vlan_id' and
        ignores all base values.

        These methods can be overridden per VLAN if either 'rt_override' or
        'vni_override' is set (preferred in this order).
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            admin_subfield: str | None | UndefinedType = Undefined,
            vrf_admin_subfield: str | None | UndefinedType = Undefined,
            vlan_assigned_number_subfield: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            OverlayRtType.

            Args:
            -----
                _custom_data: _custom_data
                admin_subfield:
                   The method for deriving RT Administrator subfield (first part of RT):
                   - 'vrf_id' means
                   `(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id` for VLANs, `(vrf_id or vrf_vni)` for VRFs and `id`
                   for bundles defined under 'evpn_vlan_bundles'.
                   - 'vrf_vni' means `(mac_vrf_vni_base or
                   mac_vrf_id_base) + vlan_id` for VLANs, `(vrf_vni or vrf_id)` for VRFs and `id` for bundles defined
                   under 'evpn_vlan_bundles'.
                   - 'id' means `vlan_id` for VLANs, `(vrf_id or vrf_vni)` for VRFs and `id`
                   for bundles defined under 'evpn_vlan_bundles'.
                   - 'bgp_as' means the AS number of the device.
                   -
                   Integer between <0-65535>.
                   - Integer between <0-4294967295>.

                   The 'vrf_id' and 'vrf_vni' methods can
                   be overridden per VLAN if either 'rt_override' or 'vni_override' is set (preferred in this order).
                   The 'vrf_id', 'vrf_vni' and 'id' methods can be overridden per bundle defined under
                   `evpn_vlan_bundles` using 'rt_override'.
                vrf_admin_subfield:
                   The method for deriving RT Administrator subfield (first part of RT) for VRF services:
                   - 'id' means
                   `(vrf_id or vrf_vni)`.
                   - 'vrf_id' means `(vrf_id or vrf_vni)`.
                   - 'vrf_vni' means `(vrf_vni or
                   vrf_id)`.
                   - 'bgp_as' means the AS number of the device.
                   - Integer between <0-65535>.
                   - Integer
                   between <0-4294967295>.

                   'vrf_admin_subfield' takes precedence for VRF RDs if set. Otherwise the
                   'admin_subfield' value will be used.
                vlan_assigned_number_subfield:
                   The method for deriving RT Assigned Number subfield for VLAN services (second part of RT):
                   -
                   'mac_vrf_id' means `(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id`.
                   - 'mac_vrf_vni' means
                   `(mac_vrf_vni_base or mac_vrf_id_base) + vlan_id`.
                   - 'vlan_id' will only use the 'vlan_id' and
                   ignores all base values.

                   These methods can be overridden per VLAN if either 'rt_override' or
                   'vni_override' is set (preferred in this order).

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CustomPlatformSettingsItem(AvdModel):
        class ReloadDelay(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mlag": {"type": int}, "non_mlag": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mlag: int | None
            """In seconds."""
            non_mlag: int | None
            """In seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mlag: int | None | UndefinedType = Undefined,
                non_mlag: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                ReloadDelay.

                Args:
                -----
                    _custom_data: _custom_data
                    mlag: In seconds.
                    non_mlag: In seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FeatureSupport(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "queue_monitor_length_notify": {"type": bool, "default": True},
                "interface_storm_control": {"type": bool, "default": True},
                "poe": {"type": bool, "default": False},
                "per_interface_mtu": {"type": bool, "default": True},
                "bgp_update_wait_install": {"type": bool, "default": True},
                "bgp_update_wait_for_convergence": {"type": bool, "default": True},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            queue_monitor_length_notify: bool | None
            interface_storm_control: bool | None
            poe: bool | None
            per_interface_mtu: bool | None
            """
            Support for configuration of per interface MTU for p2p links, MLAG SVIs and Network Services.
            Effectively this means that all settings regarding interface MTU will be ignored if this is false.
            Platforms without support for per interface MTU can use a single default interface MTU setting. Set
            this via "default_interface_mtu"
            """
            bgp_update_wait_install: bool | None
            """
            Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
            convergence state is reached.
            Can be overridden by setting "bgp_update_wait_install"
            host/group_vars.
            """
            bgp_update_wait_for_convergence: bool | None
            """
            Do not advertise reachability to a prefix until that prefix has been installed in hardware.
            This
            will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
            that may not yet be installed into the forwarding plane.
            Can be overridden by setting
            "bgp_update_wait_for_convergence" host/group_vars.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                queue_monitor_length_notify: bool | None | UndefinedType = Undefined,
                interface_storm_control: bool | None | UndefinedType = Undefined,
                poe: bool | None | UndefinedType = Undefined,
                per_interface_mtu: bool | None | UndefinedType = Undefined,
                bgp_update_wait_install: bool | None | UndefinedType = Undefined,
                bgp_update_wait_for_convergence: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                FeatureSupport.

                Args:
                -----
                    _custom_data: _custom_data
                    queue_monitor_length_notify: queue_monitor_length_notify
                    interface_storm_control: interface_storm_control
                    poe: poe
                    per_interface_mtu:
                       Support for configuration of per interface MTU for p2p links, MLAG SVIs and Network Services.
                       Effectively this means that all settings regarding interface MTU will be ignored if this is false.
                       Platforms without support for per interface MTU can use a single default interface MTU setting. Set
                       this via "default_interface_mtu"
                    bgp_update_wait_install:
                       Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                       convergence state is reached.
                       Can be overridden by setting "bgp_update_wait_install"
                       host/group_vars.
                    bgp_update_wait_for_convergence:
                       Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                       This
                       will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                       that may not yet be installed into the forwarding plane.
                       Can be overridden by setting
                       "bgp_update_wait_for_convergence" host/group_vars.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SecurityEntropySources(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "hardware": {"type": bool},
                "haveged": {"type": bool},
                "cpu_jitter": {"type": bool},
                "hardware_exclusive": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            hardware: bool | None
            """Use a hardware based source."""
            haveged: bool | None
            """Use the HAVEGE algorithm."""
            cpu_jitter: bool | None
            """Use the Jitter RNG algorithm of a CPU based source."""
            hardware_exclusive: bool | None
            """Only use entropy from the hardware source."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                hardware: bool | None | UndefinedType = Undefined,
                haveged: bool | None | UndefinedType = Undefined,
                cpu_jitter: bool | None | UndefinedType = Undefined,
                hardware_exclusive: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                SecurityEntropySources.

                Args:
                -----
                    _custom_data: _custom_data
                    hardware: Use a hardware based source.
                    haveged: Use the HAVEGE algorithm.
                    cpu_jitter: Use the Jitter RNG algorithm of a CPU based source.
                    hardware_exclusive: Only use entropy from the hardware source.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StructuredConfig(EosCliConfigGen):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "platforms": {"type": list, "items": str},
            "trident_forwarding_table_partition": {"type": str},
            "reload_delay": {"type": ReloadDelay},
            "tcam_profile": {"type": str},
            "lag_hardware_only": {"type": bool},
            "default_interface_mtu": {"type": int},
            "p2p_uplinks_mtu": {"type": int},
            "feature_support": {"type": FeatureSupport},
            "management_interface": {"type": str, "default": "Management1"},
            "security_entropy_sources": {"type": SecurityEntropySources},
            "structured_config": {"type": StructuredConfig},
            "raw_eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        platforms: list[str]
        trident_forwarding_table_partition: str | None
        """Only applied when evpn_multicast is true."""
        reload_delay: ReloadDelay
        tcam_profile: str | None
        lag_hardware_only: bool | None
        default_interface_mtu: int | None
        """
        Default interface MTU configured on EOS under "interface defaults".
        Takes precedence over the root
        key "default_interface_mtu".
        """
        p2p_uplinks_mtu: int | None
        """
        Set MTU on point to point uplink interfaces.
        Takes precedence over the root key "p2p_uplinks_mtu".
        <node_type>.uplink_mtu -> platform_settings.p2p_uplinks_mtu -> p2p_uplinks_mtu -> 9214.
        """
        feature_support: FeatureSupport
        management_interface: str | None
        security_entropy_sources: SecurityEntropySources
        """Entropy source improves the randomness of the numbers used to generate MACsec's cryptographic keys."""
        structured_config: StructuredConfig
        """Custom structured config for eos_cli_config_gen."""
        raw_eos_cli: str | None
        """EOS CLI rendered directly on the root level of the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            platforms: list[str] | UndefinedType = Undefined,
            trident_forwarding_table_partition: str | None | UndefinedType = Undefined,
            reload_delay: ReloadDelay | UndefinedType = Undefined,
            tcam_profile: str | None | UndefinedType = Undefined,
            lag_hardware_only: bool | None | UndefinedType = Undefined,
            default_interface_mtu: int | None | UndefinedType = Undefined,
            p2p_uplinks_mtu: int | None | UndefinedType = Undefined,
            feature_support: FeatureSupport | UndefinedType = Undefined,
            management_interface: str | None | UndefinedType = Undefined,
            security_entropy_sources: SecurityEntropySources | UndefinedType = Undefined,
            structured_config: StructuredConfig | UndefinedType = Undefined,
            raw_eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            CustomPlatformSettingsItem.

            Args:
            -----
                _custom_data: _custom_data
                platforms: platforms
                trident_forwarding_table_partition: Only applied when evpn_multicast is true.
                reload_delay: reload_delay
                tcam_profile: tcam_profile
                lag_hardware_only: lag_hardware_only
                default_interface_mtu:
                   Default interface MTU configured on EOS under "interface defaults".
                   Takes precedence over the root
                   key "default_interface_mtu".
                p2p_uplinks_mtu:
                   Set MTU on point to point uplink interfaces.
                   Takes precedence over the root key "p2p_uplinks_mtu".
                   <node_type>.uplink_mtu -> platform_settings.p2p_uplinks_mtu -> p2p_uplinks_mtu -> 9214.
                feature_support: feature_support
                management_interface: management_interface
                security_entropy_sources: Entropy source improves the randomness of the numbers used to generate MACsec's cryptographic keys.
                structured_config: Custom structured config for eos_cli_config_gen.
                raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PlatformSettingsItem(AvdModel):
        class ReloadDelay(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mlag": {"type": int}, "non_mlag": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mlag: int | None
            """In seconds."""
            non_mlag: int | None
            """In seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mlag: int | None | UndefinedType = Undefined,
                non_mlag: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                ReloadDelay.

                Args:
                -----
                    _custom_data: _custom_data
                    mlag: In seconds.
                    non_mlag: In seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FeatureSupport(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "queue_monitor_length_notify": {"type": bool, "default": True},
                "interface_storm_control": {"type": bool, "default": True},
                "poe": {"type": bool, "default": False},
                "per_interface_mtu": {"type": bool, "default": True},
                "bgp_update_wait_install": {"type": bool, "default": True},
                "bgp_update_wait_for_convergence": {"type": bool, "default": True},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            queue_monitor_length_notify: bool | None
            interface_storm_control: bool | None
            poe: bool | None
            per_interface_mtu: bool | None
            """
            Support for configuration of per interface MTU for p2p links, MLAG SVIs and Network Services.
            Effectively this means that all settings regarding interface MTU will be ignored if this is false.
            Platforms without support for per interface MTU can use a single default interface MTU setting. Set
            this via "default_interface_mtu"
            """
            bgp_update_wait_install: bool | None
            """
            Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
            convergence state is reached.
            Can be overridden by setting "bgp_update_wait_install"
            host/group_vars.
            """
            bgp_update_wait_for_convergence: bool | None
            """
            Do not advertise reachability to a prefix until that prefix has been installed in hardware.
            This
            will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
            that may not yet be installed into the forwarding plane.
            Can be overridden by setting
            "bgp_update_wait_for_convergence" host/group_vars.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                queue_monitor_length_notify: bool | None | UndefinedType = Undefined,
                interface_storm_control: bool | None | UndefinedType = Undefined,
                poe: bool | None | UndefinedType = Undefined,
                per_interface_mtu: bool | None | UndefinedType = Undefined,
                bgp_update_wait_install: bool | None | UndefinedType = Undefined,
                bgp_update_wait_for_convergence: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                FeatureSupport.

                Args:
                -----
                    _custom_data: _custom_data
                    queue_monitor_length_notify: queue_monitor_length_notify
                    interface_storm_control: interface_storm_control
                    poe: poe
                    per_interface_mtu:
                       Support for configuration of per interface MTU for p2p links, MLAG SVIs and Network Services.
                       Effectively this means that all settings regarding interface MTU will be ignored if this is false.
                       Platforms without support for per interface MTU can use a single default interface MTU setting. Set
                       this via "default_interface_mtu"
                    bgp_update_wait_install:
                       Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                       convergence state is reached.
                       Can be overridden by setting "bgp_update_wait_install"
                       host/group_vars.
                    bgp_update_wait_for_convergence:
                       Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                       This
                       will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                       that may not yet be installed into the forwarding plane.
                       Can be overridden by setting
                       "bgp_update_wait_for_convergence" host/group_vars.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SecurityEntropySources(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "hardware": {"type": bool},
                "haveged": {"type": bool},
                "cpu_jitter": {"type": bool},
                "hardware_exclusive": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            hardware: bool | None
            """Use a hardware based source."""
            haveged: bool | None
            """Use the HAVEGE algorithm."""
            cpu_jitter: bool | None
            """Use the Jitter RNG algorithm of a CPU based source."""
            hardware_exclusive: bool | None
            """Only use entropy from the hardware source."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                hardware: bool | None | UndefinedType = Undefined,
                haveged: bool | None | UndefinedType = Undefined,
                cpu_jitter: bool | None | UndefinedType = Undefined,
                hardware_exclusive: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                SecurityEntropySources.

                Args:
                -----
                    _custom_data: _custom_data
                    hardware: Use a hardware based source.
                    haveged: Use the HAVEGE algorithm.
                    cpu_jitter: Use the Jitter RNG algorithm of a CPU based source.
                    hardware_exclusive: Only use entropy from the hardware source.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StructuredConfig(EosCliConfigGen):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "platforms": {"type": list, "items": str},
            "trident_forwarding_table_partition": {"type": str},
            "reload_delay": {"type": ReloadDelay},
            "tcam_profile": {"type": str},
            "lag_hardware_only": {"type": bool},
            "default_interface_mtu": {"type": int},
            "p2p_uplinks_mtu": {"type": int},
            "feature_support": {"type": FeatureSupport},
            "management_interface": {"type": str, "default": "Management1"},
            "security_entropy_sources": {"type": SecurityEntropySources},
            "structured_config": {"type": StructuredConfig},
            "raw_eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        platforms: list[str]
        trident_forwarding_table_partition: str | None
        """Only applied when evpn_multicast is true."""
        reload_delay: ReloadDelay
        tcam_profile: str | None
        lag_hardware_only: bool | None
        default_interface_mtu: int | None
        """
        Default interface MTU configured on EOS under "interface defaults".
        Takes precedence over the root
        key "default_interface_mtu".
        """
        p2p_uplinks_mtu: int | None
        """
        Set MTU on point to point uplink interfaces.
        Takes precedence over the root key "p2p_uplinks_mtu".
        <node_type>.uplink_mtu -> platform_settings.p2p_uplinks_mtu -> p2p_uplinks_mtu -> 9214.
        """
        feature_support: FeatureSupport
        management_interface: str | None
        security_entropy_sources: SecurityEntropySources
        """Entropy source improves the randomness of the numbers used to generate MACsec's cryptographic keys."""
        structured_config: StructuredConfig
        """Custom structured config for eos_cli_config_gen."""
        raw_eos_cli: str | None
        """EOS CLI rendered directly on the root level of the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            platforms: list[str] | UndefinedType = Undefined,
            trident_forwarding_table_partition: str | None | UndefinedType = Undefined,
            reload_delay: ReloadDelay | UndefinedType = Undefined,
            tcam_profile: str | None | UndefinedType = Undefined,
            lag_hardware_only: bool | None | UndefinedType = Undefined,
            default_interface_mtu: int | None | UndefinedType = Undefined,
            p2p_uplinks_mtu: int | None | UndefinedType = Undefined,
            feature_support: FeatureSupport | UndefinedType = Undefined,
            management_interface: str | None | UndefinedType = Undefined,
            security_entropy_sources: SecurityEntropySources | UndefinedType = Undefined,
            structured_config: StructuredConfig | UndefinedType = Undefined,
            raw_eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            PlatformSettingsItem.

            Args:
            -----
                _custom_data: _custom_data
                platforms: platforms
                trident_forwarding_table_partition: Only applied when evpn_multicast is true.
                reload_delay: reload_delay
                tcam_profile: tcam_profile
                lag_hardware_only: lag_hardware_only
                default_interface_mtu:
                   Default interface MTU configured on EOS under "interface defaults".
                   Takes precedence over the root
                   key "default_interface_mtu".
                p2p_uplinks_mtu:
                   Set MTU on point to point uplink interfaces.
                   Takes precedence over the root key "p2p_uplinks_mtu".
                   <node_type>.uplink_mtu -> platform_settings.p2p_uplinks_mtu -> p2p_uplinks_mtu -> 9214.
                feature_support: feature_support
                management_interface: management_interface
                security_entropy_sources: Entropy source improves the randomness of the numbers used to generate MACsec's cryptographic keys.
                structured_config: Custom structured config for eos_cli_config_gen.
                raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PlatformSpeedGroupsItem(AvdModel):
        class SpeedsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "speed": {"type": str}, "speed_groups": {"type": list, "items": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "speed")
            _custom_data: dict[str, Any]
            speed: str
            speed_groups: list[str]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                speed: str | UndefinedType = Undefined,
                speed_groups: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                SpeedsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    speed: speed
                    speed_groups: speed_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Speeds(AvdCollection[str, SpeedsItem]):
            _primary_key: ClassVar[str] = "speed"

        Speeds._item_type = SpeedsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "platform": {"type": str}, "speeds": {"type": Speeds}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "platform")
        _custom_data: dict[str, Any]
        platform: str
        speeds: Speeds

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            platform: str | UndefinedType = Undefined,
            speeds: Speeds | UndefinedType = Undefined,
        ) -> None:
            """
            PlatformSpeedGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                platform: platform
                speeds: speeds

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PlatformSpeedGroups(AvdCollection[str, PlatformSpeedGroupsItem]):
        _primary_key: ClassVar[str] = "platform"

    PlatformSpeedGroups._item_type = PlatformSpeedGroupsItem

    class PortProfilesItem(AvdModel):
        class Flowcontrol(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "received": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            received: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, received: str | None | UndefinedType = Undefined) -> None:
                """
                Flowcontrol.

                Args:
                -----
                    _custom_data: _custom_data
                    received: received

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ptp(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool, "default": False},
                "endpoint_role": {"type": str, "default": "follower"},
                "profile": {"type": str, "default": "aes67-r16-2016"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            endpoint_role: str | None
            profile: str | None
            """
            Default available profiles are:
              - "aes67"
              - "aes67-r16-2016"
              - "smpte2059-2"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                endpoint_role: str | None | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ptp.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    endpoint_role: endpoint_role
                    profile:
                       Default available profiles are:
                         - "aes67"
                         - "aes67-r16-2016"
                         - "smpte2059-2"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FlowTracking(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """Flow tracker name as defined in flow_tracking_settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracking.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name: Flow tracker name as defined in flow_tracking_settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTracking(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            name: str | None
            """
            Tracking group name.
            The default group name is taken from fabric variable of the switch,
            `link_tracking.groups[0].name` with default value being "LT_GROUP1".
            Optional if default
            link_tracking settings are configured on the node.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LinkTracking.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    name:
                       Tracking group name.
                       The default group name is taken from fabric variable of the switch,
                       `link_tracking.groups[0].name` with default value being "LT_GROUP1".
                       Optional if default
                       link_tracking settings are configured on the node.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdModel):
            class Pae(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | None | UndefinedType = Undefined) -> None:
                    """
                    Pae.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AuthenticationFailure(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}, "allow_vlan": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                action: str | None
                allow_vlan: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    action: str | None | UndefinedType = Undefined,
                    allow_vlan: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AuthenticationFailure.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: action
                        allow_vlan: allow_vlan

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HostMode(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multi_host_authenticated": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                multi_host_authenticated: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    multi_host_authenticated: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostMode.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        multi_host_authenticated: multi_host_authenticated

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MacBasedAuthentication(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "always": {"type": bool},
                    "host_mode_common": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always: bool | None
                host_mode_common: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    host_mode_common: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    MacBasedAuthentication.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        host_mode_common: host_mode_common

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timeout(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "idle_host": {"type": int},
                    "quiet_period": {"type": int},
                    "reauth_period": {"type": str},
                    "reauth_timeout_ignore": {"type": bool},
                    "tx_period": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                idle_host: int | None
                quiet_period: int | None
                reauth_period: str | None
                """Range 60-4294967295 or "server"."""
                reauth_timeout_ignore: bool | None
                tx_period: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    idle_host: int | None | UndefinedType = Undefined,
                    quiet_period: int | None | UndefinedType = Undefined,
                    reauth_period: str | None | UndefinedType = Undefined,
                    reauth_timeout_ignore: bool | None | UndefinedType = Undefined,
                    tx_period: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timeout.

                    Args:
                    -----
                        _custom_data: _custom_data
                        idle_host: idle_host
                        quiet_period: quiet_period
                        reauth_period: Range 60-4294967295 or "server".
                        reauth_timeout_ignore: reauth_timeout_ignore
                        tx_period: tx_period

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Unauthorized(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "access_vlan_membership_egress": {"type": bool},
                    "native_vlan_membership_egress": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                access_vlan_membership_egress: bool | None
                native_vlan_membership_egress: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    access_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                    native_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Unauthorized.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_vlan_membership_egress: access_vlan_membership_egress
                        native_vlan_membership_egress: native_vlan_membership_egress

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "port_control": {"type": str},
                "port_control_force_authorized_phone": {"type": bool},
                "reauthentication": {"type": bool},
                "pae": {"type": Pae},
                "authentication_failure": {"type": AuthenticationFailure},
                "host_mode": {"type": HostMode},
                "mac_based_authentication": {"type": MacBasedAuthentication},
                "timeout": {"type": Timeout},
                "reauthorization_request_limit": {"type": int},
                "unauthorized": {"type": Unauthorized},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            port_control: str | None
            port_control_force_authorized_phone: bool | None
            reauthentication: bool | None
            pae: Pae
            authentication_failure: AuthenticationFailure
            host_mode: HostMode
            mac_based_authentication: MacBasedAuthentication
            timeout: Timeout
            reauthorization_request_limit: int | None
            unauthorized: Unauthorized

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                port_control: str | None | UndefinedType = Undefined,
                port_control_force_authorized_phone: bool | None | UndefinedType = Undefined,
                reauthentication: bool | None | UndefinedType = Undefined,
                pae: Pae | UndefinedType = Undefined,
                authentication_failure: AuthenticationFailure | UndefinedType = Undefined,
                host_mode: HostMode | UndefinedType = Undefined,
                mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                timeout: Timeout | UndefinedType = Undefined,
                reauthorization_request_limit: int | None | UndefinedType = Undefined,
                unauthorized: Unauthorized | UndefinedType = Undefined,
            ) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    port_control: port_control
                    port_control_force_authorized_phone: port_control_force_authorized_phone
                    reauthentication: reauthentication
                    pae: pae
                    authentication_failure: authentication_failure
                    host_mode: host_mode
                    mac_based_authentication: mac_based_authentication
                    timeout: timeout
                    reauthorization_request_limit: reauthorization_request_limit
                    unauthorized: unauthorized

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Poe(EosCliConfigGen.EthernetInterfacesItem.Poe):
            pass

        class StormControl(AvdModel):
            class All(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    All.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Broadcast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Broadcast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Multicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class UnknownUnicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional variable and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnknownUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional variable and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            all: All
            broadcast: Broadcast
            multicast: Multicast
            unknown_unicast: UnknownUnicast

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                all: All | UndefinedType = Undefined,
                broadcast: Broadcast | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
            ) -> None:
                """
                StormControl.

                Args:
                -----
                    _custom_data: _custom_data
                    all: all
                    broadcast: broadcast
                    multicast: multicast
                    unknown_unicast: unknown_unicast

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MonitorSessionsItem(AvdModel):
            class SourceSettings(AvdModel):
                class AccessGroup(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}, "priority": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    type: str | None
                    name: str | None
                    """ACL name."""
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        type: str | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessGroup.

                        Args:
                        -----
                            _custom_data: _custom_data
                            type: type
                            name: ACL name.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction": {"type": str}, "access_group": {"type": AccessGroup}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                direction: str | None
                access_group: AccessGroup
                """This can only be set when `session_settings.access_group` is not set."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    direction: str | None | UndefinedType = Undefined,
                    access_group: AccessGroup | UndefinedType = Undefined,
                ) -> None:
                    """
                    SourceSettings.

                    Args:
                    -----
                        _custom_data: _custom_data
                        direction: direction
                        access_group: This can only be set when `session_settings.access_group` is not set.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SessionSettings(AvdModel):
                class AccessGroup(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    type: str | None
                    name: str | None
                    """ACL name."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        type: str | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AccessGroup.

                        Args:
                        -----
                            _custom_data: _custom_data
                            type: type
                            name: ACL name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Truncate(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "size": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    size: int | None
                    """Size in bytes."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        size: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Truncate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            size: Size in bytes.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "encapsulation_gre_metadata_tx": {"type": bool},
                    "header_remove_size": {"type": int},
                    "access_group": {"type": AccessGroup},
                    "rate_limit_per_ingress_chip": {"type": str},
                    "rate_limit_per_egress_chip": {"type": str},
                    "sample": {"type": int},
                    "truncate": {"type": Truncate},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                encapsulation_gre_metadata_tx: bool | None
                header_remove_size: int | None
                """Number of bytes to remove from header."""
                access_group: AccessGroup
                rate_limit_per_ingress_chip: str | None
                """
                Ratelimit and unit as string.
                Examples:
                  "100000 bps"
                  "100 kbps"
                  "10 mbps"
                """
                rate_limit_per_egress_chip: str | None
                """
                Ratelimit and unit as string.
                Examples:
                  "100000 bps"
                  "100 kbps"
                  "10 mbps"
                """
                sample: int | None
                truncate: Truncate

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    encapsulation_gre_metadata_tx: bool | None | UndefinedType = Undefined,
                    header_remove_size: int | None | UndefinedType = Undefined,
                    access_group: AccessGroup | UndefinedType = Undefined,
                    rate_limit_per_ingress_chip: str | None | UndefinedType = Undefined,
                    rate_limit_per_egress_chip: str | None | UndefinedType = Undefined,
                    sample: int | None | UndefinedType = Undefined,
                    truncate: Truncate | UndefinedType = Undefined,
                ) -> None:
                    """
                    SessionSettings.

                    Args:
                    -----
                        _custom_data: _custom_data
                        encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                        header_remove_size: Number of bytes to remove from header.
                        access_group: access_group
                        rate_limit_per_ingress_chip:
                           Ratelimit and unit as string.

                    Examples:
                             "100000 bps"
                             "100 kbps"
                             "10 mbps"
                        rate_limit_per_egress_chip:
                           Ratelimit and unit as string.

                    Examples:
                             "100000 bps"
                             "100 kbps"
                             "10 mbps"
                        sample: sample
                        truncate: truncate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "role": {"type": str},
                "source_settings": {"type": SourceSettings},
                "session_settings": {"type": SessionSettings},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Session name."""
            role: str | None
            source_settings: SourceSettings
            session_settings: SessionSettings
            """
            Session settings are defined per session name.
            Different session_settings for the same session name
            will be combined/merged.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                source_settings: SourceSettings | UndefinedType = Undefined,
                session_settings: SessionSettings | UndefinedType = Undefined,
            ) -> None:
                """
                MonitorSessionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Session name.
                    role: role
                    source_settings: source_settings
                    session_settings:
                       Session settings are defined per session name.
                       Different session_settings for the same session name
                       will be combined/merged.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EthernetSegment(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "short_esi": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_algorithm": {"type": str},
                "designated_forwarder_preferences": {"type": list, "items": int},
                "dont_preempt": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "short_esi")
            _custom_data: dict[str, Any]
            short_esi: str
            """
            In format xxxx:xxxx:xxxx or "auto".
            Define a manual short-esi (be careful using this on profiles) or
            set the value to "auto" to automatically generate the value.
            Please see the notes under "EVPN A/A
            ESI dual and single-attached endpoint scenarios" before setting `short_esi: auto`.
            """
            redundancy: str | None
            """
            If omitted, Port-Channels use the EOS default of all-active.
            If omitted, Ethernet interfaces are
            configured as single-active.
            """
            designated_forwarder_algorithm: str | None
            """
            Configure DF algorithm and preferences.
            - auto: Use preference-based algorithm and assign preference
            based on position of device in the 'switches' list,
              e.g., assuming a list of three switches, this
            would assign a preference of 200 to the first switch, 100 to the 2nd, and 0 to the third.
            -
            preference: Set preference for each switch manually using designated_forwarder_preferences key.
            -
            modulus: Use the default modulus-based algorithm.
            If omitted, Port-Channels use the EOS default of
            modulus.
            If omitted, Ethernet interfaces default to the 'auto' mechanism detailed above.
            """
            designated_forwarder_preferences: list[int]
            """Manual preference as described above, required only for preference algorithm."""
            dont_preempt: bool | None
            """Disable preemption for single-active forwarding when auto/manual DF preference is configured."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                short_esi: str | UndefinedType = Undefined,
                redundancy: str | None | UndefinedType = Undefined,
                designated_forwarder_algorithm: str | None | UndefinedType = Undefined,
                designated_forwarder_preferences: list[int] | UndefinedType = Undefined,
                dont_preempt: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                EthernetSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    short_esi:
                       In format xxxx:xxxx:xxxx or "auto".
                       Define a manual short-esi (be careful using this on profiles) or
                       set the value to "auto" to automatically generate the value.
                       Please see the notes under "EVPN A/A
                       ESI dual and single-attached endpoint scenarios" before setting `short_esi: auto`.
                    redundancy:
                       If omitted, Port-Channels use the EOS default of all-active.
                       If omitted, Ethernet interfaces are
                       configured as single-active.
                    designated_forwarder_algorithm:
                       Configure DF algorithm and preferences.
                       - auto: Use preference-based algorithm and assign preference
                       based on position of device in the 'switches' list,
                         e.g., assuming a list of three switches, this
                       would assign a preference of 200 to the first switch, 100 to the 2nd, and 0 to the third.
                       -
                       preference: Set preference for each switch manually using designated_forwarder_preferences key.
                       -
                       modulus: Use the default modulus-based algorithm.
                       If omitted, Port-Channels use the EOS default of
                       modulus.
                       If omitted, Ethernet interfaces default to the 'auto' mechanism detailed above.
                    designated_forwarder_preferences: Manual preference as described above, required only for preference algorithm.
                    dont_preempt: Disable preemption for single-active forwarding when auto/manual DF preference is configured.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PortChannel(AvdModel):
            class LacpFallback(AvdModel):
                class Individual(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    profile: str | None
                    """Port-profile name to inherit configuration."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined) -> None:
                        """
                        Individual.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: Port-profile name to inherit configuration.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "individual": {"type": Individual}, "timeout": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                """
                Either static or individual mode is supported.
                If the mode is set to "individual" the
                "individual.profile" setting must be defined.
                """
                individual: Individual
                """
                Define parameters for port-channel member interfaces. Applies only if LACP fallback is set to
                "individual".
                """
                timeout: int | None
                """Timeout in seconds. EOS default is 90 seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    individual: Individual | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LacpFallback.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode:
                           Either static or individual mode is supported.
                           If the mode is set to "individual" the
                           "individual.profile" setting must be defined.
                        individual:
                           Define parameters for port-channel member interfaces. Applies only if LACP fallback is set to
                           "individual".
                        timeout: Timeout in seconds. EOS default is 90 seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LacpTimer(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multiplier": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                """LACP mode for interface members."""
                multiplier: int | None
                """Number of LACP BPDUs lost before deeming the peer down. EOS default is 3."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    multiplier: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LacpTimer.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: LACP mode for interface members.
                        multiplier: Number of LACP BPDUs lost before deeming the peer down. EOS default is 3.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SubinterfacesItem(AvdModel):
                class EncapsulationVlan(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "client_dot1q": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    client_dot1q: int | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, client_dot1q: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        EncapsulationVlan.

                        Args:
                        -----
                            _custom_data: _custom_data
                            client_dot1q: client_dot1q

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "number": {"type": int},
                    "short_esi": {"type": str},
                    "vlan_id": {"type": int},
                    "encapsulation_vlan": {"type": EncapsulationVlan},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                number: int | None
                """Subinterface number."""
                short_esi: str | None
                """
                In format xxxx:xxxx:xxxx or "auto".
                Required for multihomed port-channels with subinterfaces.
                """
                vlan_id: int | None
                """
                VLAN ID to bridge.
                Default is subinterface number.
                """
                encapsulation_vlan: EncapsulationVlan
                """
                Client VLAN ID encapsulation.
                Default is subinterface number.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    number: int | None | UndefinedType = Undefined,
                    short_esi: str | None | UndefinedType = Undefined,
                    vlan_id: int | None | UndefinedType = Undefined,
                    encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                ) -> None:
                    """
                    SubinterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        number: Subinterface number.
                        short_esi:
                           In format xxxx:xxxx:xxxx or "auto".
                           Required for multihomed port-channels with subinterfaces.
                        vlan_id:
                           VLAN ID to bridge.
                           Default is subinterface number.
                        encapsulation_vlan:
                           Client VLAN ID encapsulation.
                           Default is subinterface number.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "mode": {"type": str},
                "channel_id": {"type": int},
                "description": {"type": str},
                "endpoint_port_channel": {"type": str},
                "enabled": {"type": bool, "default": True},
                "ptp_mpass": {"type": bool, "default": False},
                "lacp_fallback": {"type": LacpFallback},
                "lacp_timer": {"type": LacpTimer},
                "subinterfaces": {"type": list, "items": SubinterfacesItem},
                "raw_eos_cli": {"type": str},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mode: str | None
            """Port-Channel Mode."""
            channel_id: int | None
            """
            Port-Channel ID.
            If no channel_id is specified, an id is generated from the first switch port in the
            port channel.
            """
            description: str | None
            """
            Description or description template to be used on the port-channel interface.
            This can be a template
            using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
            to/custom-descriptions-names.html#avd-string-formatter-syntax.
            The available template fields are:
            - `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
              -
            `endpoint` - The name of the connected endpoint
              - `endpoint_port_channel` - The value from
            `endpoint_port_channel` if set.
              - `port_channel_id` - The port-channel number for the switch.
              -
            `adapter_description` - The adapter's description if set.
              - `adapter_description_or_endpoint` -
            Helper alias of the adapter_description or endpoint.

            The default description is set by
            `default_connected_endpoints_port_channel_description`.
            By default the description is templated from
            the type, name and port_channel interface of the endpoint if set.
            """
            endpoint_port_channel: str | None
            """
            Name of the port-channel interface on the endpoint.
            Used for the port-channel description template
            with the field name `peer_interface`
            """
            enabled: bool | None
            """
            Port-Channel administrative state.
            Setting to false will set port to 'shutdown' in intended
            configuration.
            """
            ptp_mpass: bool | None
            """
            When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
            logical device.
            Arista PTP enabled devices always place PTP messages on the same physical link
            within the port-channel.
            Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
            devices.
            """
            lacp_fallback: LacpFallback
            """LACP fallback configuration."""
            lacp_timer: LacpTimer
            """LACP timer configuration. Applies only when Port-channel mode is not "on"."""
            subinterfaces: list[SubinterfacesItem]
            """
            Port-Channel L2 Subinterfaces
            Subinterfaces are only supported on routed port-channels, which means
            they cannot be configured on MLAG port-channels.
            Setting short_esi: auto generates the short_esi
            automatically using a hash of configuration elements.
            Please see the notes under "EVPN A/A ESI dual-
            attached endpoint scenario" before setting short_esi: auto.
            """
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""
            structured_config: StructuredConfig
            """
            Custom structured config added under port_channel_interfaces.[name=<interface>] for
            eos_cli_config_gen.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                channel_id: int | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                endpoint_port_channel: str | None | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                ptp_mpass: bool | None | UndefinedType = Undefined,
                lacp_fallback: LacpFallback | UndefinedType = Undefined,
                lacp_timer: LacpTimer | UndefinedType = Undefined,
                subinterfaces: list[SubinterfacesItem] | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                PortChannel.

                Args:
                -----
                    _custom_data: _custom_data
                    mode: Port-Channel Mode.
                    channel_id:
                       Port-Channel ID.
                       If no channel_id is specified, an id is generated from the first switch port in the
                       port channel.
                    description:
                       Description or description template to be used on the port-channel interface.
                       This can be a template
                       using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                       to/custom-descriptions-names.html#avd-string-formatter-syntax.
                       The available template fields are:
                       - `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                         -
                       `endpoint` - The name of the connected endpoint
                         - `endpoint_port_channel` - The value from
                       `endpoint_port_channel` if set.
                         - `port_channel_id` - The port-channel number for the switch.
                         -
                       `adapter_description` - The adapter's description if set.
                         - `adapter_description_or_endpoint` -
                       Helper alias of the adapter_description or endpoint.

                       The default description is set by
                       `default_connected_endpoints_port_channel_description`.
                       By default the description is templated from
                       the type, name and port_channel interface of the endpoint if set.
                    endpoint_port_channel:
                       Name of the port-channel interface on the endpoint.
                       Used for the port-channel description template
                       with the field name `peer_interface`
                    enabled:
                       Port-Channel administrative state.
                       Setting to false will set port to 'shutdown' in intended
                       configuration.
                    ptp_mpass:
                       When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                       logical device.
                       Arista PTP enabled devices always place PTP messages on the same physical link
                       within the port-channel.
                       Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                       devices.
                    lacp_fallback: LACP fallback configuration.
                    lacp_timer: LACP timer configuration. Applies only when Port-channel mode is not "on".
                    subinterfaces:
                       Port-Channel L2 Subinterfaces
                       Subinterfaces are only supported on routed port-channels, which means
                       they cannot be configured on MLAG port-channels.
                       Setting short_esi: auto generates the short_esi
                       automatically using a hash of configuration elements.
                       Please see the notes under "EVPN A/A ESI dual-
                       attached endpoint scenario" before setting short_esi: auto.
                    raw_eos_cli: EOS CLI rendered directly on the port-channel interface in the final EOS configuration.
                    structured_config:
                       Custom structured config added under port_channel_interfaces.[name=<interface>] for
                       eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "profile": {"type": str},
            "parent_profile": {"type": str},
            "speed": {"type": str},
            "description": {"type": str},
            "enabled": {"type": bool, "default": True},
            "mode": {"type": str},
            "mtu": {"type": int},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "phone_vlan": {"type": int},
            "phone_trunk_mode": {"type": str},
            "trunk_groups": {"type": list, "items": str},
            "vlans": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "flowcontrol": {"type": Flowcontrol},
            "qos_profile": {"type": str},
            "ptp": {"type": Ptp},
            "sflow": {"type": bool},
            "flow_tracking": {"type": FlowTracking},
            "link_tracking": {"type": LinkTracking},
            "dot1x": {"type": Dot1x},
            "poe": {"type": Poe},
            "storm_control": {"type": StormControl},
            "monitor_sessions": {"type": list, "items": MonitorSessionsItem},
            "ethernet_segment": {"type": EthernetSegment},
            "port_channel": {"type": PortChannel},
            "validate_state": {"type": bool},
            "raw_eos_cli": {"type": str},
            "structured_config": {"type": StructuredConfig},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "profile")
        _custom_data: dict[str, Any]
        profile: str
        """Port profile name."""
        parent_profile: str | None
        """
        Parent profile is optional.
        Port_profiles can refer to another port_profile to inherit settings in
        up to two levels (adapter->profile->parent_profile).
        """
        speed: str | None
        """
        Set adapter speed in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        If not specified speed will be auto.
        """
        description: str | None
        """
        Description or description template to be used on all ports.
        This can be a template using the AVD
        string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
        descriptions-names.html#avd-string-formatter-syntax.
        The available template fields are:
          -
        `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
          -
        `endpoint` - The name of the connected endpoint
          - `endpoint_port` - The value from
        `endpoint_ports` for this switch port if set.

        The default description is set by
        `default_connected_endpoints_description`.
        By default the description is templated from the type,
        name and port of the endpoint if set.
        """
        enabled: bool | None
        """
        Administrative state, setting to false will set the port to 'shutdown' in the intended
        configuration.
        """
        mode: str | None
        """Interface mode."""
        mtu: int | None
        l2_mtu: int | None
        l2_mru: int | None
        native_vlan: int | None
        """
        Native VLAN for a trunk port.
        If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag`
        takes precedence.
        """
        native_vlan_tag: bool | None
        """If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag` takes precedence."""
        phone_vlan: int | None
        """
        Phone VLAN for a mode `trunk phone` port.
        Requires `mode: trunk phone` to be set.
        """
        phone_trunk_mode: str | None
        """
        Specify if the phone traffic is tagged or untagged.
        If both data and phone traffic are untagged,
        MAC-Based VLAN Assignment (MBVA) is used, if supported by the model of switch.
        """
        trunk_groups: list[str]
        """
        Required with `enable_trunk_groups: true`.
        Trunk Groups are used for limiting VLANs on trunk ports
        to VLANs with the same Trunk Group.
        """
        vlans: str | None
        """
        Interface VLANs - if not set, the EOS default is that all VLANs are allowed for trunk ports, and
        VLAN 1 will be used for access ports.
        """
        spanning_tree_portfast: str | None
        spanning_tree_bpdufilter: str | None
        spanning_tree_bpduguard: str | None
        flowcontrol: Flowcontrol
        qos_profile: str | None
        """QOS profile name."""
        ptp: Ptp
        """
        The global PTP profile parameters will be applied to all connected endpoints where `ptp` is manually
        enabled.
        `ptp role master` is set to ensure control over the PTP topology.
        """
        sflow: bool | None
        """Configures sFlow on the interface. Overrides `fabric_sflow.endpoints` setting."""
        flow_tracking: FlowTracking
        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.endpoints` setting."""
        link_tracking: LinkTracking
        """
        Configure the downstream interfaces of a respective Link Tracking Group.
        If `port_channel` is
        defined in an adapter, then the port-channel interface is configured to be the downstream.
        Else all
        the ethernet interfaces will be configured as downstream -> to configure single-active EVPN
        multihomed networks.
        """
        dot1x: Dot1x
        """802.1x"""
        poe: Poe
        """Power Over Ethernet settings applied on port. Only configured if platform supports PoE."""
        storm_control: StormControl
        """Storm control settings applied on port toward the endpoint."""
        monitor_sessions: list[MonitorSessionsItem]
        """Used to define switchports as source or destination for monitoring sessions."""
        ethernet_segment: EthernetSegment
        """Settings for all or single-active EVPN multihoming."""
        port_channel: PortChannel
        """Used for port-channel adapter."""
        validate_state: bool | None
        """Set to false to disable interface validation by the `eos_validate_state` role."""
        raw_eos_cli: str | None
        """EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""
        structured_config: StructuredConfig
        """Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            profile: str | UndefinedType = Undefined,
            parent_profile: str | None | UndefinedType = Undefined,
            speed: str | None | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            l2_mtu: int | None | UndefinedType = Undefined,
            l2_mru: int | None | UndefinedType = Undefined,
            native_vlan: int | None | UndefinedType = Undefined,
            native_vlan_tag: bool | None | UndefinedType = Undefined,
            phone_vlan: int | None | UndefinedType = Undefined,
            phone_trunk_mode: str | None | UndefinedType = Undefined,
            trunk_groups: list[str] | UndefinedType = Undefined,
            vlans: str | None | UndefinedType = Undefined,
            spanning_tree_portfast: str | None | UndefinedType = Undefined,
            spanning_tree_bpdufilter: str | None | UndefinedType = Undefined,
            spanning_tree_bpduguard: str | None | UndefinedType = Undefined,
            flowcontrol: Flowcontrol | UndefinedType = Undefined,
            qos_profile: str | None | UndefinedType = Undefined,
            ptp: Ptp | UndefinedType = Undefined,
            sflow: bool | None | UndefinedType = Undefined,
            flow_tracking: FlowTracking | UndefinedType = Undefined,
            link_tracking: LinkTracking | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            poe: Poe | UndefinedType = Undefined,
            storm_control: StormControl | UndefinedType = Undefined,
            monitor_sessions: list[MonitorSessionsItem] | UndefinedType = Undefined,
            ethernet_segment: EthernetSegment | UndefinedType = Undefined,
            port_channel: PortChannel | UndefinedType = Undefined,
            validate_state: bool | None | UndefinedType = Undefined,
            raw_eos_cli: str | None | UndefinedType = Undefined,
            structured_config: StructuredConfig | UndefinedType = Undefined,
        ) -> None:
            """
            PortProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                profile: Port profile name.
                parent_profile:
                   Parent profile is optional.
                   Port_profiles can refer to another port_profile to inherit settings in
                   up to two levels (adapter->profile->parent_profile).
                speed:
                   Set adapter speed in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                   If not specified speed will be auto.
                description:
                   Description or description template to be used on all ports.
                   This can be a template using the AVD
                   string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
                   descriptions-names.html#avd-string-formatter-syntax.
                   The available template fields are:
                     -
                   `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                     -
                   `endpoint` - The name of the connected endpoint
                     - `endpoint_port` - The value from
                   `endpoint_ports` for this switch port if set.

                   The default description is set by
                   `default_connected_endpoints_description`.
                   By default the description is templated from the type,
                   name and port of the endpoint if set.
                enabled:
                   Administrative state, setting to false will set the port to 'shutdown' in the intended
                   configuration.
                mode: Interface mode.
                mtu: mtu
                l2_mtu: l2_mtu
                l2_mru: l2_mru
                native_vlan:
                   Native VLAN for a trunk port.
                   If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag`
                   takes precedence.
                native_vlan_tag: If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag` takes precedence.
                phone_vlan:
                   Phone VLAN for a mode `trunk phone` port.
                   Requires `mode: trunk phone` to be set.
                phone_trunk_mode:
                   Specify if the phone traffic is tagged or untagged.
                   If both data and phone traffic are untagged,
                   MAC-Based VLAN Assignment (MBVA) is used, if supported by the model of switch.
                trunk_groups:
                   Required with `enable_trunk_groups: true`.
                   Trunk Groups are used for limiting VLANs on trunk ports
                   to VLANs with the same Trunk Group.
                vlans:
                   Interface VLANs - if not set, the EOS default is that all VLANs are allowed for trunk ports, and
                   VLAN 1 will be used for access ports.
                spanning_tree_portfast: spanning_tree_portfast
                spanning_tree_bpdufilter: spanning_tree_bpdufilter
                spanning_tree_bpduguard: spanning_tree_bpduguard
                flowcontrol: flowcontrol
                qos_profile: QOS profile name.
                ptp:
                   The global PTP profile parameters will be applied to all connected endpoints where `ptp` is manually
                   enabled.
                   `ptp role master` is set to ensure control over the PTP topology.
                sflow: Configures sFlow on the interface. Overrides `fabric_sflow.endpoints` setting.
                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.endpoints` setting.
                link_tracking:
                   Configure the downstream interfaces of a respective Link Tracking Group.
                   If `port_channel` is
                   defined in an adapter, then the port-channel interface is configured to be the downstream.
                   Else all
                   the ethernet interfaces will be configured as downstream -> to configure single-active EVPN
                   multihomed networks.
                dot1x: 802.1x
                poe: Power Over Ethernet settings applied on port. Only configured if platform supports PoE.
                storm_control: Storm control settings applied on port toward the endpoint.
                monitor_sessions: Used to define switchports as source or destination for monitoring sessions.
                ethernet_segment: Settings for all or single-active EVPN multihoming.
                port_channel: Used for port-channel adapter.
                validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                raw_eos_cli: EOS CLI rendered directly on the ethernet interface in the final EOS configuration.
                structured_config: Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PortProfiles(AvdCollection[str, PortProfilesItem]):
        _primary_key: ClassVar[str] = "profile"

    PortProfiles._item_type = PortProfilesItem

    class PtpProfilesItem(AvdModel):
        class Announce(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "timeout": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interval: int | None
            timeout: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                timeout: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Announce.

                Args:
                -----
                    _custom_data: _custom_data
                    interval: interval
                    timeout: timeout

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SyncMessage(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interval: int | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                """
                SyncMessage.

                Args:
                -----
                    _custom_data: _custom_data
                    interval: interval

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "profile": {"type": str},
            "announce": {"type": Announce},
            "delay_req": {"type": int},
            "sync_message": {"type": SyncMessage},
            "transport": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "profile")
        _custom_data: dict[str, Any]
        profile: str
        """PTP profile."""
        announce: Announce
        """PTP announce interval."""
        delay_req: int | None
        sync_message: SyncMessage
        """PTP sync message interval."""
        transport: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            profile: str | UndefinedType = Undefined,
            announce: Announce | UndefinedType = Undefined,
            delay_req: int | None | UndefinedType = Undefined,
            sync_message: SyncMessage | UndefinedType = Undefined,
            transport: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            PtpProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                profile: PTP profile.
                announce: PTP announce interval.
                delay_req: delay_req
                sync_message: PTP sync message interval.
                transport: transport

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PtpProfiles(AvdCollection[str, PtpProfilesItem]):
        _primary_key: ClassVar[str] = "profile"

    PtpProfiles._item_type = PtpProfilesItem

    class PtpSettings(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool},
            "profile": {"type": str, "default": "aes67-r16-2016"},
            "domain": {"type": int},
            "auto_clock_identity": {"type": bool, "default": True},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None
        profile: str | None
        """
        Default available profiles are:
          - "aes67"
          - "aes67-r16-2016"
          - "smpte2059-2"
        """
        domain: int | None
        auto_clock_identity: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            profile: str | None | UndefinedType = Undefined,
            domain: int | None | UndefinedType = Undefined,
            auto_clock_identity: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            PtpSettings.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                profile:
                   Default available profiles are:
                     - "aes67"
                     - "aes67-r16-2016"
                     - "smpte2059-2"
                domain: domain
                auto_clock_identity: auto_clock_identity

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QueueMonitorLength(AvdModel):
        class DefaultThresholds(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "high": {"type": int}, "low": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "high")
            _custom_data: dict[str, Any]
            high: int
            """Default high threshold for Ethernet Interfaces."""
            low: int | None
            """
            Default low threshold for Ethernet Interfaces.
            Low threshold support is platform dependent.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                high: int | UndefinedType = Undefined,
                low: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                DefaultThresholds.

                Args:
                -----
                    _custom_data: _custom_data
                    high: Default high threshold for Ethernet Interfaces.
                    low:
                       Default low threshold for Ethernet Interfaces.
                       Low threshold support is platform dependent.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Cpu(AvdModel):
            class Thresholds(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "high": {"type": int}, "low": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "high")
                _custom_data: dict[str, Any]
                high: int
                low: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    high: int | UndefinedType = Undefined,
                    low: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Thresholds.

                    Args:
                    -----
                        _custom_data: _custom_data
                        high: high
                        low: low

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "thresholds": {"type": Thresholds}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            thresholds: Thresholds

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, thresholds: Thresholds | UndefinedType = Undefined) -> None:
                """
                Cpu.

                Args:
                -----
                    _custom_data: _custom_data
                    thresholds: thresholds

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool},
            "notifying": {"type": bool},
            "default_thresholds": {"type": DefaultThresholds},
            "log": {"type": int},
            "cpu": {"type": Cpu},
            "tx_latency": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
        _custom_data: dict[str, Any]
        enabled: bool
        notifying: bool | None
        """
        If True, `eos_designs` will configure `queue-monitor length notifying` according to the
        `platform_settings.[].feature_support.queue_monitor_length_notify` setting.
        """
        default_thresholds: DefaultThresholds
        log: int | None
        """Logging interval in seconds."""
        cpu: Cpu
        tx_latency: bool | None
        """Enable tx-latency mode."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | UndefinedType = Undefined,
            notifying: bool | None | UndefinedType = Undefined,
            default_thresholds: DefaultThresholds | UndefinedType = Undefined,
            log: int | None | UndefinedType = Undefined,
            cpu: Cpu | UndefinedType = Undefined,
            tx_latency: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            QueueMonitorLength.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                notifying:
                   If True, `eos_designs` will configure `queue-monitor length notifying` according to the
                   `platform_settings.[].feature_support.queue_monitor_length_notify` setting.
                default_thresholds: default_thresholds
                log: Logging interval in seconds.
                cpu: cpu
                tx_latency: Enable tx-latency mode.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Redundancy(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "protocol": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        protocol: str | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, protocol: str | None | UndefinedType = Undefined) -> None:
            """
            Redundancy.

            Args:
            -----
                _custom_data: _custom_data
                protocol: protocol

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SflowSettings(AvdModel):
        class Sample(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            rate: int | None
            """
            Packet sampling rate that defines the average number of ingress packets that pass through an
            interface for every packet that is sampled.
            A rate of 16384 corresponds to an average sample of one
            per 16384 packets.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: int | None | UndefinedType = Undefined) -> None:
                """
                Sample.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Packet sampling rate that defines the average number of ingress packets that pass through an
                       interface for every packet that is sampled.
                       A rate of 16384 corresponds to an average sample of one
                       per 16384 packets.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DestinationsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination": {"type": str}, "port": {"type": int}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "destination")
            _custom_data: dict[str, Any]
            destination: str
            """sFlow destination name or IP address."""
            port: int | None
            """UDP Port number. The default port number for sFlow is 6343."""
            vrf: str | None
            """
            If not set, the VRF is automatically picked up from the global setting `default_mgmt_method`.
            The
            value of `vrf` will be interpreted according to these rules:
            - `use_mgmt_interface_vrf` will
            configure the sFlow destination under the VRF set with `mgmt_interface_vrf` and set the
            `mgmt_interface` as sFlow source-interface.
              An error will be raised if `mgmt_ip` or `ipv6_mgmt_ip`
            are not configured for the device.
            - `use_inband_mgmt_vrf` will configure the sFlow destination
            under the VRF set with `inband_mgmt_vrf` and set the `inband_mgmt_interface` as sFlow source-
            interface.
              An error will be raised if inband management is not configured for the device.
            - Any
            other string will be used directly as the VRF name. Remember to set the
            `sflow_settings.vrfs[].source_interface` if needed.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                destination: str | UndefinedType = Undefined,
                port: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: sFlow destination name or IP address.
                    port: UDP Port number. The default port number for sFlow is 6343.
                    vrf:
                       If not set, the VRF is automatically picked up from the global setting `default_mgmt_method`.
                       The
                       value of `vrf` will be interpreted according to these rules:
                       - `use_mgmt_interface_vrf` will
                       configure the sFlow destination under the VRF set with `mgmt_interface_vrf` and set the
                       `mgmt_interface` as sFlow source-interface.
                         An error will be raised if `mgmt_ip` or `ipv6_mgmt_ip`
                       are not configured for the device.
                       - `use_inband_mgmt_vrf` will configure the sFlow destination
                       under the VRF set with `inband_mgmt_vrf` and set the `inband_mgmt_interface` as sFlow source-
                       interface.
                         An error will be raised if inband management is not configured for the device.
                       - Any
                       other string will be used directly as the VRF name. Remember to set the
                       `sflow_settings.vrfs[].source_interface` if needed.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "source_interface": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            source_interface: str | None
            """
            Source interface to use for sFlow destinations in this VRF.
            If set for the VRFs defined by
            `mgmt_interface_vrf` or `inband_mgmt_vrf`, this setting will take precedence.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    source_interface:
                       Source interface to use for sFlow destinations in this VRF.
                       If set for the VRFs defined by
                       `mgmt_interface_vrf` or `inband_mgmt_vrf`, this setting will take precedence.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "sample": {"type": Sample},
            "destinations": {"type": list, "items": DestinationsItem},
            "vrfs": {"type": Vrfs},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "destinations")
        _custom_data: dict[str, Any]
        sample: Sample
        destinations: list[DestinationsItem]
        vrfs: Vrfs

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            sample: Sample | UndefinedType = Undefined,
            destinations: list[DestinationsItem] | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            SflowSettings.

            Args:
            -----
                _custom_data: _custom_data
                sample: sample
                destinations: destinations
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SnmpSettings(AvdModel):
        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enable": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            enable: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    enable: enable

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class UsersItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "group": {"type": str},
                "version": {"type": str},
                "auth": {"type": str},
                "auth_passphrase": {"type": str},
                "priv": {"type": str},
                "priv_passphrase": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Username."""
            group: str | None
            """Group name."""
            version: str | None
            auth: str | None
            auth_passphrase: str | None
            """Cleartext passphrase so the recommendation is to use vault. Requires 'auth' to be set."""
            priv: str | None
            priv_passphrase: str | None
            """Cleartext passphrase so the recommendation is to use vault. Requires 'priv' to be set."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                group: str | None | UndefinedType = Undefined,
                version: str | None | UndefinedType = Undefined,
                auth: str | None | UndefinedType = Undefined,
                auth_passphrase: str | None | UndefinedType = Undefined,
                priv: str | None | UndefinedType = Undefined,
                priv_passphrase: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                UsersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Username.
                    group: Group name.
                    version: version
                    auth: auth
                    auth_passphrase: Cleartext passphrase so the recommendation is to use vault. Requires 'auth' to be set.
                    priv: priv
                    priv_passphrase: Cleartext passphrase so the recommendation is to use vault. Requires 'priv' to be set.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdModel):
            class UsersItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "username": {"type": str}, "authentication_level": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                username: str | None
                authentication_level: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    username: str | None | UndefinedType = Undefined,
                    authentication_level: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UsersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        username: username
                        authentication_level: authentication_level

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "host": {"type": str},
                "vrf": {"type": str},
                "use_mgmt_interface_vrf": {"type": bool},
                "use_inband_mgmt_vrf": {"type": bool},
                "version": {"type": str},
                "community": {"type": str},
                "users": {"type": list, "items": UsersItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            """
            VRF Name.
            Can be used in combination with "use_mgmt_interface_vrf" and "use_inband_mgmt_vrf" to
            configure the SNMP host under multiple VRFs.
            """
            use_mgmt_interface_vrf: bool | None
            """
            Configure the SNMP host under the VRF set with "mgmt_interface_vrf". Ignored if 'mgmt_ip' or
            'ipv6_mgmt_ip' are not configured for the device, so if the host is only configured with this VRF,
            the host will not be configured at all. Can be used in combination with "vrf" and
            "use_inband_mgmt_vrf" to configure the SNMP host under multiple VRFs.
            """
            use_inband_mgmt_vrf: bool | None
            """
            Configure the SNMP host under the VRF set with "inband_mgmt_vrf". Ignored if inband management is
            not configured for the device, so if the host is only configured with this VRF, the host will not be
            configured at all. Can be used in combination with "vrf" and "use_mgmt_interface_vrf" to configure
            the SNMP host under multiple VRFs.
            """
            version: str | None
            community: str | None
            """Community name."""
            users: list[UsersItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                host: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                use_mgmt_interface_vrf: bool | None | UndefinedType = Undefined,
                use_inband_mgmt_vrf: bool | None | UndefinedType = Undefined,
                version: str | None | UndefinedType = Undefined,
                community: str | None | UndefinedType = Undefined,
                users: list[UsersItem] | UndefinedType = Undefined,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf:
                       VRF Name.
                       Can be used in combination with "use_mgmt_interface_vrf" and "use_inband_mgmt_vrf" to
                       configure the SNMP host under multiple VRFs.
                    use_mgmt_interface_vrf:
                       Configure the SNMP host under the VRF set with "mgmt_interface_vrf". Ignored if 'mgmt_ip' or
                       'ipv6_mgmt_ip' are not configured for the device, so if the host is only configured with this VRF,
                       the host will not be configured at all. Can be used in combination with "vrf" and
                       "use_inband_mgmt_vrf" to configure the SNMP host under multiple VRFs.
                    use_inband_mgmt_vrf:
                       Configure the SNMP host under the VRF set with "inband_mgmt_vrf". Ignored if inband management is
                       not configured for the device, so if the host is only configured with this VRF, the host will not be
                       configured at all. Can be used in combination with "vrf" and "use_mgmt_interface_vrf" to configure
                       the SNMP host under multiple VRFs.
                    version: version
                    community: Community name.
                    users: users

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CommunitiesItem(AvdModel):
            class AccessListIpv4(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """IPv4 access list name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                    """
                    AccessListIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 access list name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessListIpv6(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """IPv6 access list name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                    """
                    AccessListIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv6 access list name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "access": {"type": str},
                "access_list_ipv4": {"type": AccessListIpv4},
                "access_list_ipv6": {"type": AccessListIpv6},
                "view": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Community name."""
            access: str | None
            access_list_ipv4: AccessListIpv4
            access_list_ipv6: AccessListIpv6
            view: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                access: str | None | UndefinedType = Undefined,
                access_list_ipv4: AccessListIpv4 | UndefinedType = Undefined,
                access_list_ipv6: AccessListIpv6 | UndefinedType = Undefined,
                view: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                CommunitiesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Community name.
                    access: access
                    access_list_ipv4: access_list_ipv4
                    access_list_ipv6: access_list_ipv6
                    view: view

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Communities(AvdCollection[str, CommunitiesItem]):
            _primary_key: ClassVar[str] = "name"

        Communities._item_type = CommunitiesItem

        class Ipv4AclsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """IPv4 access list name."""
            vrf: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv4AclsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IPv4 access list name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AclsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """IPv6 access list name."""
            vrf: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6AclsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IPv6 access list name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ViewsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "mib_family_name": {"type": str}, "included": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """SNMP view name."""
            mib_family_name: str | None
            included: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                mib_family_name: str | None | UndefinedType = Undefined,
                included: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                ViewsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: SNMP view name.
                    mib_family_name: mib_family_name
                    included: included

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GroupsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "version": {"type": str},
                "authentication": {"type": str},
                "read": {"type": str},
                "write": {"type": str},
                "notify": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Group name."""
            version: str | None
            authentication: str | None
            read: str | None
            """Read view."""
            write: str | None
            """Write view."""
            notify: str | None
            """Notify view."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                version: str | None | UndefinedType = Undefined,
                authentication: str | None | UndefinedType = Undefined,
                read: str | None | UndefinedType = Undefined,
                write: str | None | UndefinedType = Undefined,
                notify: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                GroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    version: version
                    authentication: authentication
                    read: Read view.
                    write: Write view.
                    notify: Notify view.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Traps(EosCliConfigGen.SnmpServer.Traps):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "contact": {"type": str},
            "location": {"type": bool, "default": False},
            "vrfs": {"type": Vrfs},
            "enable_mgmt_interface_vrf": {"type": bool},
            "enable_inband_mgmt_vrf": {"type": bool},
            "compute_local_engineid": {"type": bool, "default": False},
            "compute_local_engineid_source": {"type": str, "default": "hostname_and_ip"},
            "compute_v3_user_localized_key": {"type": bool, "default": False},
            "users": {"type": list, "items": UsersItem},
            "hosts": {"type": list, "items": HostsItem},
            "communities": {"type": Communities},
            "ipv4_acls": {"type": list, "items": Ipv4AclsItem},
            "ipv6_acls": {"type": list, "items": Ipv6AclsItem},
            "views": {"type": list, "items": ViewsItem},
            "groups": {"type": list, "items": GroupsItem},
            "traps": {"type": Traps},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        contact: str | None
        """SNMP contact."""
        location: bool | None
        """
        Set SNMP location. Formatted as "<fabric_name> <dc_name> <pod_name> <switch_rack>
        <inventory_hostname>".
        """
        vrfs: Vrfs
        """
        Enable/disable SNMP for one or more VRFs.
        Can be used in combination with
        "enable_mgmt_interface_vrf" and "enable_inband_mgmt_vrf".
        """
        enable_mgmt_interface_vrf: bool | None
        """
        Enable/disable SNMP for the VRF set with "mgmt_interface_vrf".
        Ignored if 'mgmt_ip' or
        'ipv6_mgmt_ip' are not configured for the device.
        Can be used in combination with "vrfs" and
        "enable_inband_mgmt_vrf".
        """
        enable_inband_mgmt_vrf: bool | None
        """
        Enable/disable SNMP for the VRF set with "inband_mgmt_vrf".
        Ignored if inband management is not
        configured for the device.
        Can be used in combination with "vrfs" and "enable_mgmt_interface_vrf".
        """
        compute_local_engineid: bool | None
        """Generate a local engineId for SNMP using the 'compute_local_engineid_source' method."""
        compute_local_engineid_source: str | None
        """
        `compute_local_engineid_source` supports:
        - `hostname_and_ip` generate a local engineId for SNMP by
        hashing via SHA1
          the string generated via the concatenation of the hostname plus the management
        IP.
          {{ inventory_hostname }} + {{ switch.mgmt_ip }}.
        - `system_mac` generate the switch default
        engine id for AVD usage.
          To use this, `system_mac_address` MUST be set for the device.
          The
        formula is f5717f + system_mac_address + 00.
        """
        compute_v3_user_localized_key: bool | None
        """
        Requires compute_local_engineid to be `true`.
        If enabled, the SNMPv3 passphrases for auth and priv
        are transformed using RFC 2574, matching the value they would take in EOS CLI.
        The algorithm
        requires a local engineId, which is unknown to AVD, hence the necessity to generate one beforehand.
        """
        users: list[UsersItem]
        """
        Configuration of local SNMP users.
        Configuration of remote SNMP users are currently only possible
        using `structured_config`.
        """
        hosts: list[HostsItem]
        communities: Communities
        ipv4_acls: list[Ipv4AclsItem]
        ipv6_acls: list[Ipv6AclsItem]
        views: list[ViewsItem]
        groups: list[GroupsItem]
        traps: Traps

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            contact: str | None | UndefinedType = Undefined,
            location: bool | None | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            enable_mgmt_interface_vrf: bool | None | UndefinedType = Undefined,
            enable_inband_mgmt_vrf: bool | None | UndefinedType = Undefined,
            compute_local_engineid: bool | None | UndefinedType = Undefined,
            compute_local_engineid_source: str | None | UndefinedType = Undefined,
            compute_v3_user_localized_key: bool | None | UndefinedType = Undefined,
            users: list[UsersItem] | UndefinedType = Undefined,
            hosts: list[HostsItem] | UndefinedType = Undefined,
            communities: Communities | UndefinedType = Undefined,
            ipv4_acls: list[Ipv4AclsItem] | UndefinedType = Undefined,
            ipv6_acls: list[Ipv6AclsItem] | UndefinedType = Undefined,
            views: list[ViewsItem] | UndefinedType = Undefined,
            groups: list[GroupsItem] | UndefinedType = Undefined,
            traps: Traps | UndefinedType = Undefined,
        ) -> None:
            """
            SnmpSettings.

            Args:
            -----
                _custom_data: _custom_data
                contact: SNMP contact.
                location:
                   Set SNMP location. Formatted as "<fabric_name> <dc_name> <pod_name> <switch_rack>
                   <inventory_hostname>".
                vrfs:
                   Enable/disable SNMP for one or more VRFs.
                   Can be used in combination with
                   "enable_mgmt_interface_vrf" and "enable_inband_mgmt_vrf".
                enable_mgmt_interface_vrf:
                   Enable/disable SNMP for the VRF set with "mgmt_interface_vrf".
                   Ignored if 'mgmt_ip' or
                   'ipv6_mgmt_ip' are not configured for the device.
                   Can be used in combination with "vrfs" and
                   "enable_inband_mgmt_vrf".
                enable_inband_mgmt_vrf:
                   Enable/disable SNMP for the VRF set with "inband_mgmt_vrf".
                   Ignored if inband management is not
                   configured for the device.
                   Can be used in combination with "vrfs" and "enable_mgmt_interface_vrf".
                compute_local_engineid: Generate a local engineId for SNMP using the 'compute_local_engineid_source' method.
                compute_local_engineid_source:
                   `compute_local_engineid_source` supports:
                   - `hostname_and_ip` generate a local engineId for SNMP by
                   hashing via SHA1
                     the string generated via the concatenation of the hostname plus the management
                   IP.
                     {{ inventory_hostname }} + {{ switch.mgmt_ip }}.
                   - `system_mac` generate the switch default
                   engine id for AVD usage.
                     To use this, `system_mac_address` MUST be set for the device.
                     The
                   formula is f5717f + system_mac_address + 00.
                compute_v3_user_localized_key:
                   Requires compute_local_engineid to be `true`.
                   If enabled, the SNMPv3 passphrases for auth and priv
                   are transformed using RFC 2574, matching the value they would take in EOS CLI.
                   The algorithm
                   requires a local engineId, which is unknown to AVD, hence the necessity to generate one beforehand.
                users:
                   Configuration of local SNMP users.
                   Configuration of remote SNMP users are currently only possible
                   using `structured_config`.
                hosts: hosts
                communities: communities
                ipv4_acls: ipv4_acls
                ipv6_acls: ipv6_acls
                views: views
                groups: groups
                traps: traps

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SourceInterfaces(AvdModel):
        class DomainLookup(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mgmt_interface": {"type": bool}, "inband_mgmt_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mgmt_interface: bool | None
            """
            Configure an IP Domain Lookup source-interface with the interface set by `mgmt_interface` for the
            VRF set by `mgmt_interface_vrf`.
            `mgmt_interface` is typically the out-of-band Management interface,
            and can be set under the node settings, platform settings or as a group/host var.
            """
            inband_mgmt_interface: bool | None
            """
            Configure an IP Domain Lookup source-interface with the interface set by `inband_mgmt_interface` for
            the VRF set by `inband_mgmt_vrf`.
            `inband_mgmt_interface` is typically a loopback or SVI interface,
            and can be set under the node settings.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mgmt_interface: bool | None | UndefinedType = Undefined,
                inband_mgmt_interface: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                DomainLookup.

                Args:
                -----
                    _custom_data: _custom_data
                    mgmt_interface:
                       Configure an IP Domain Lookup source-interface with the interface set by `mgmt_interface` for the
                       VRF set by `mgmt_interface_vrf`.
                       `mgmt_interface` is typically the out-of-band Management interface,
                       and can be set under the node settings, platform settings or as a group/host var.
                    inband_mgmt_interface:
                       Configure an IP Domain Lookup source-interface with the interface set by `inband_mgmt_interface` for
                       the VRF set by `inband_mgmt_vrf`.
                       `inband_mgmt_interface` is typically a loopback or SVI interface,
                       and can be set under the node settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HttpClient(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mgmt_interface": {"type": bool}, "inband_mgmt_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mgmt_interface: bool | None
            """
            Configure an IP HTTP Client source-interface with the interface set by `mgmt_interface` for the VRF
            set by `mgmt_interface_vrf`.
            `mgmt_interface` is typically the out-of-band Management interface, and
            can be set under the node settings, platform settings or as a group/host var.
            """
            inband_mgmt_interface: bool | None
            """
            Configure an IP HTTP Client source-interface with the interface set by `inband_mgmt_interface` for
            the VRF set by `inband_mgmt_vrf`.
            `inband_mgmt_interface` is typically a loopback or SVI interface,
            and can be set under the node settings.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mgmt_interface: bool | None | UndefinedType = Undefined,
                inband_mgmt_interface: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                HttpClient.

                Args:
                -----
                    _custom_data: _custom_data
                    mgmt_interface:
                       Configure an IP HTTP Client source-interface with the interface set by `mgmt_interface` for the VRF
                       set by `mgmt_interface_vrf`.
                       `mgmt_interface` is typically the out-of-band Management interface, and
                       can be set under the node settings, platform settings or as a group/host var.
                    inband_mgmt_interface:
                       Configure an IP HTTP Client source-interface with the interface set by `inband_mgmt_interface` for
                       the VRF set by `inband_mgmt_vrf`.
                       `inband_mgmt_interface` is typically a loopback or SVI interface,
                       and can be set under the node settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Radius(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mgmt_interface": {"type": bool}, "inband_mgmt_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mgmt_interface: bool | None
            """
            Configure an IP Radius source-interface with the interface set by `mgmt_interface` for the VRF set
            by `mgmt_interface_vrf`.
            `mgmt_interface` is typically the out-of-band Management interface, and can
            be set under the node settings, platform settings or as a group/host var.
            """
            inband_mgmt_interface: bool | None
            """
            Configure an IP Radius source-interface with the interface set by `inband_mgmt_interface` for the
            VRF set by `inband_mgmt_vrf`.
            `inband_mgmt_interface` is typically a loopback or SVI interface, and
            can be set under the node settings.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mgmt_interface: bool | None | UndefinedType = Undefined,
                inband_mgmt_interface: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Radius.

                Args:
                -----
                    _custom_data: _custom_data
                    mgmt_interface:
                       Configure an IP Radius source-interface with the interface set by `mgmt_interface` for the VRF set
                       by `mgmt_interface_vrf`.
                       `mgmt_interface` is typically the out-of-band Management interface, and can
                       be set under the node settings, platform settings or as a group/host var.
                    inband_mgmt_interface:
                       Configure an IP Radius source-interface with the interface set by `inband_mgmt_interface` for the
                       VRF set by `inband_mgmt_vrf`.
                       `inband_mgmt_interface` is typically a loopback or SVI interface, and
                       can be set under the node settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Snmp(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mgmt_interface": {"type": bool}, "inband_mgmt_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mgmt_interface: bool | None
            """
            Configure a SNMP local-interface with the interface set by `mgmt_interface` for the VRF set by
            `mgmt_interface_vrf`.
            `mgmt_interface` is typically the out-of-band Management interface, and can be
            set under the node settings, platform settings or as a group/host var.
            """
            inband_mgmt_interface: bool | None
            """
            Configure a SNMP local-interface with the interface set by `inband_mgmt_interface` for the VRF set
            by `inband_mgmt_vrf`.
            `inband_mgmt_interface` is typically a loopback or SVI interface, and can be
            set under the node settings.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mgmt_interface: bool | None | UndefinedType = Undefined,
                inband_mgmt_interface: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Snmp.

                Args:
                -----
                    _custom_data: _custom_data
                    mgmt_interface:
                       Configure a SNMP local-interface with the interface set by `mgmt_interface` for the VRF set by
                       `mgmt_interface_vrf`.
                       `mgmt_interface` is typically the out-of-band Management interface, and can be
                       set under the node settings, platform settings or as a group/host var.
                    inband_mgmt_interface:
                       Configure a SNMP local-interface with the interface set by `inband_mgmt_interface` for the VRF set
                       by `inband_mgmt_vrf`.
                       `inband_mgmt_interface` is typically a loopback or SVI interface, and can be
                       set under the node settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SshClient(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mgmt_interface": {"type": bool}, "inband_mgmt_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mgmt_interface: bool | None
            """
            Configure an IP SSH Client source-interface with the interface set by `mgmt_interface` for the VRF
            set by `mgmt_interface_vrf`.
            `mgmt_interface` is typically the out-of-band Management interface, and
            can be set under the node settings, platform settings or as a group/host var.
            """
            inband_mgmt_interface: bool | None
            """
            Configure an IP SSH Client source-interface with the interface set by `inband_mgmt_interface` for
            the VRF set by `inband_mgmt_vrf`.
            `inband_mgmt_interface` is typically a loopback or SVI interface,
            and can be set under the node settings.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mgmt_interface: bool | None | UndefinedType = Undefined,
                inband_mgmt_interface: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                SshClient.

                Args:
                -----
                    _custom_data: _custom_data
                    mgmt_interface:
                       Configure an IP SSH Client source-interface with the interface set by `mgmt_interface` for the VRF
                       set by `mgmt_interface_vrf`.
                       `mgmt_interface` is typically the out-of-band Management interface, and
                       can be set under the node settings, platform settings or as a group/host var.
                    inband_mgmt_interface:
                       Configure an IP SSH Client source-interface with the interface set by `inband_mgmt_interface` for
                       the VRF set by `inband_mgmt_vrf`.
                       `inband_mgmt_interface` is typically a loopback or SVI interface,
                       and can be set under the node settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Tacacs(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mgmt_interface": {"type": bool}, "inband_mgmt_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mgmt_interface: bool | None
            """
            Configure an IP Tacacs source-interface with the interface set by `mgmt_interface` for the VRF set
            by `mgmt_interface_vrf`.
            `mgmt_interface` is typically the out-of-band Management interface, and can
            be set under the node settings, platform settings or as a group/host var.
            """
            inband_mgmt_interface: bool | None
            """
            Configure an IP Tacacs source-interface with the interface set by `inband_mgmt_interface` for the
            VRF set by `inband_mgmt_vrf`.
            `inband_mgmt_interface` is typically a loopback or SVI interface, and
            can be set under the node settings.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mgmt_interface: bool | None | UndefinedType = Undefined,
                inband_mgmt_interface: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Tacacs.

                Args:
                -----
                    _custom_data: _custom_data
                    mgmt_interface:
                       Configure an IP Tacacs source-interface with the interface set by `mgmt_interface` for the VRF set
                       by `mgmt_interface_vrf`.
                       `mgmt_interface` is typically the out-of-band Management interface, and can
                       be set under the node settings, platform settings or as a group/host var.
                    inband_mgmt_interface:
                       Configure an IP Tacacs source-interface with the interface set by `inband_mgmt_interface` for the
                       VRF set by `inband_mgmt_vrf`.
                       `inband_mgmt_interface` is typically a loopback or SVI interface, and
                       can be set under the node settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "domain_lookup": {"type": DomainLookup},
            "http_client": {"type": HttpClient},
            "radius": {"type": Radius},
            "snmp": {"type": Snmp},
            "ssh_client": {"type": SshClient},
            "tacacs": {"type": Tacacs},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        domain_lookup: DomainLookup
        """IP Domain Lookup source-interfaces."""
        http_client: HttpClient
        """IP HTTP Client source-interfaces."""
        radius: Radius
        """IP Radius source-interfaces."""
        snmp: Snmp
        """SNMP local-interfaces."""
        ssh_client: SshClient
        """IP SSH Client source-interfaces."""
        tacacs: Tacacs
        """IP Tacacs source-interfaces."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            domain_lookup: DomainLookup | UndefinedType = Undefined,
            http_client: HttpClient | UndefinedType = Undefined,
            radius: Radius | UndefinedType = Undefined,
            snmp: Snmp | UndefinedType = Undefined,
            ssh_client: SshClient | UndefinedType = Undefined,
            tacacs: Tacacs | UndefinedType = Undefined,
        ) -> None:
            """
            SourceInterfaces.

            Args:
            -----
                _custom_data: _custom_data
                domain_lookup: IP Domain Lookup source-interfaces.
                http_client: IP HTTP Client source-interfaces.
                radius: IP Radius source-interfaces.
                snmp: SNMP local-interfaces.
                ssh_client: IP SSH Client source-interfaces.
                tacacs: IP Tacacs source-interfaces.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SviProfilesItem(AvdModel):
        class NodesItem(AvdModel):
            class IpHelpersItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_helper": {"type": str},
                    "source_interface": {"type": str},
                    "source_vrf": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
                _custom_data: dict[str, Any]
                ip_helper: str
                """IPv4 DHCP server IP."""
                source_interface: str | None
                """Interface name to originate DHCP relay packets to DHCP server."""
                source_vrf: str | None
                """VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_helper: str | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    source_vrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IpHelpersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_helper: IPv4 DHCP server IP.
                        source_interface: Interface name to originate DHCP relay packets to DHCP server.
                        source_vrf: VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class IpHelpers(AvdCollection[str, IpHelpersItem]):
                _primary_key: ClassVar[str] = "ip_helper"

            IpHelpers._item_type = IpHelpersItem

            class EvpnL2Multicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always_redistribute_igmp": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always_redistribute_igmp: bool | None
                """
                Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                By default `redistribute
                igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                False.
                Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                additional control-plane and data-plane resources,
                but it is required to support forwarding of TTL=1
                multicast traffic within the VLAN.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always_redistribute_igmp: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnL2Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always_redistribute_igmp:
                           Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                           `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                           By default `redistribute
                           igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                           False.
                           Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                           additional control-plane and data-plane resources,
                           but it is required to support forwarding of TTL=1
                           multicast traffic within the VLAN.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class EvpnL3Multicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                    """
                    EvpnL3Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class IgmpSnoopingQuerier(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "source_address": {"type": str},
                    "version": {"type": int},
                    "fast_leave": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Will be enabled automatically if evpn_l2_multicast is enabled."""
                source_address: str | None
                """
                IPv4_address
                If not set, IP address of "Loopback0" will be used.
                """
                version: int | None
                """IGMP Version (By default EOS uses IGMP version 2 for IGMP querier)."""
                fast_leave: bool | None
                """Enable IGMP snooping fast-leave feature."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    source_address: str | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                    fast_leave: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    IgmpSnoopingQuerier.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Will be enabled automatically if evpn_l2_multicast is enabled.
                        source_address:
                           IPv4_address
                           If not set, IP address of "Loopback0" will be used.
                        version: IGMP Version (By default EOS uses IGMP version 2 for IGMP querier).
                        fast_leave: Enable IGMP snooping fast-leave feature.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ospf(AvdModel):
                class MessageDigestKeysItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "hash_algorithm": {"type": str, "default": "sha512"},
                        "key": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    id: int | None
                    hash_algorithm: str | None
                    key: str | None
                    """Type 7 encrypted key."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        hash_algorithm: str | None | UndefinedType = Undefined,
                        key: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MessageDigestKeysItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: id
                            hash_algorithm: hash_algorithm
                            key: Type 7 encrypted key.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "point_to_point": {"type": bool, "default": True},
                    "area": {"type": str, "default": "0.0.0.0"},
                    "cost": {"type": int},
                    "authentication": {"type": str},
                    "simple_auth_key": {"type": str},
                    "message_digest_keys": {"type": list, "items": MessageDigestKeysItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                point_to_point: bool | None
                area: str | None
                """OSPF area ID."""
                cost: int | None
                """OSPF link cost."""
                authentication: str | None
                simple_auth_key: str | None
                """Password used with simple authentication."""
                message_digest_keys: list[MessageDigestKeysItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    point_to_point: bool | None | UndefinedType = Undefined,
                    area: str | None | UndefinedType = Undefined,
                    cost: int | None | UndefinedType = Undefined,
                    authentication: str | None | UndefinedType = Undefined,
                    simple_auth_key: str | None | UndefinedType = Undefined,
                    message_digest_keys: list[MessageDigestKeysItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ospf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        point_to_point: point_to_point
                        area: OSPF area ID.
                        cost: OSPF link cost.
                        authentication: authentication
                        simple_auth_key: Password used with simple authentication.
                        message_digest_keys: message_digest_keys

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdModel):
                class StructuredConfig(EosCliConfigGen.RouterBgp.VlansItem):
                    pass

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "structured_config": {"type": StructuredConfig}, "raw_eos_cli": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                structured_config: StructuredConfig
                """
                Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                This
                configuration will not be applied to vlan aware bundles.
                """
                raw_eos_cli: str | None
                """EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    structured_config: StructuredConfig | UndefinedType = Undefined,
                    raw_eos_cli: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        structured_config:
                           Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                           This
                           configuration will not be applied to vlan aware bundles.
                        raw_eos_cli: EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                pass

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "node": {"type": str},
                "name": {"type": str},
                "enabled": {"type": bool},
                "description": {"type": str},
                "ip_address": {"type": str},
                "ipv6_address": {"type": str},
                "ipv6_enable": {"type": bool},
                "ip_address_virtual": {"type": str},
                "ipv6_address_virtuals": {"type": list, "items": str},
                "ip_address_virtual_secondaries": {"type": list, "items": str},
                "ip_virtual_router_addresses": {"type": list, "items": str},
                "ipv6_virtual_router_addresses": {"type": list, "items": str},
                "ipv4_acl_in": {"type": str},
                "ipv4_acl_out": {"type": str},
                "ip_helpers": {"type": IpHelpers},
                "vni_override": {"type": int},
                "rt_override": {"type": str},
                "rd_override": {"type": str},
                "trunk_groups": {"type": list, "items": str},
                "evpn_l2_multicast": {"type": EvpnL2Multicast},
                "evpn_l3_multicast": {"type": EvpnL3Multicast},
                "igmp_snooping_enabled": {"type": bool},
                "igmp_snooping_querier": {"type": IgmpSnoopingQuerier},
                "vxlan": {"type": bool, "default": True},
                "spanning_tree_priority": {"type": int},
                "mtu": {"type": int},
                "ospf": {"type": Ospf},
                "bgp": {"type": Bgp},
                "raw_eos_cli": {"type": str},
                "structured_config": {"type": StructuredConfig},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "node")
            _custom_data: dict[str, Any]
            node: str
            """l3_leaf inventory hostname."""
            name: str | None
            """VLAN name."""
            enabled: bool | None
            """Enable or disable interface."""
            description: str | None
            """SVI description. By default set to VLAN name."""
            ip_address: str | None
            """IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node."""
            ipv6_address: str | None
            """IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node."""
            ipv6_enable: bool | None
            """Explicitly enable/disable link-local IPv6 addressing."""
            ip_address_virtual: str | None
            """
            IPv4_address/Mask.
            IPv4 VXLAN Anycast IP address.
            Conserves IP addresses in VXLAN deployments as it
            doesn't require unique IP addresses on each node.
            """
            ipv6_address_virtuals: list[str]
            """
            IPv6 VXLAN Anycast IP addresses.
            Conserves IPv6 addresses in VXLAN deployments as it doesn't require
            unique IPv6 addresses on each node.
            """
            ip_address_virtual_secondaries: list[str]
            """Secondary IPv4 VXLAN Anycast IP addresses."""
            ip_virtual_router_addresses: list[str]
            """
            IPv4 VARP addresses.
            Requires an IP address to be configured on the SVI.
            If ip_address_virtual is
            also set, ip_virtual_router_addresses will take precedence
            _if_ there is an ip_address configured
            for the node.
            """
            ipv6_virtual_router_addresses: list[str]
            """
            IPv6 VARP addresses.
            Requires an IPv6 address to be configured on the SVI.
            If ipv6_address_virtuals
            is also set, ipv6_virtual_router_addresses will take precedence
            _if_ there is an ipv6_address
            configured for the node.
            """
            ipv4_acl_in: str | None
            """
            Name of the IPv4 access-list to be assigned in the ingress direction.
            The access-list must be
            defined under `ipv4_acls` and supports substitution of the field "interface_ip".
            """
            ipv4_acl_out: str | None
            """
            Name of the IPv4 Access-list to be assigned in the egress direction.
            The access-list must be defined
            under `ipv4_acls` and supports substitution of the field "interface_ip".
            """
            ip_helpers: IpHelpers
            """IP helper for DHCP relay."""
            vni_override: int | None
            """
            By default the VNI will be derived from "mac_vrf_vni_base".
            The vni_override allows us to override
            this value and statically define it (optional).
            """
            rt_override: str | None
            """
            By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
            The rt_override allows us
            to override this value and statically define it.
            rt_override will default to vni_override if set.
            rt_override supports two formats:
              - A single number which will be used in the RT fields instead of
            mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
              - A full RT string with colon
            separator which will override the full RT.
            """
            rd_override: str | None
            """
            By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
            The rt_override allows us
            to override this value and statically define it.
            rd_override will default to rt_override or
            vni_override if set.

            rd_override supports two formats:
              - A single number which will be used in
            the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
            - A full RD string with colon separator which will override the full RD.
            """
            trunk_groups: list[str]
            evpn_l2_multicast: EvpnL2Multicast
            """
            Explicitly enable or disable evpn_l2_multicast to override setting of
            `<network_services_key>.[].evpn_l2_multicast.enabled`.
            When evpn_l2_multicast.enabled is set to true
            for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
            overriding those individual settings.
            Requires `evpn_multicast` to also be set to `true`.
            """
            evpn_l3_multicast: EvpnL3Multicast
            """
            Explicitly enable or disable evpn_l3_multicast to override setting of
            `<network_services_key>.[].evpn_l3_multicast.enabled` and
            `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
            Requires `evpn_multicast` to also be
            set to `true`.
            """
            igmp_snooping_enabled: bool | None
            """Enable IGMP Snooping (Enabled by default on EOS)."""
            igmp_snooping_querier: IgmpSnoopingQuerier
            vxlan: bool | None
            """Extend this SVI over VXLAN."""
            spanning_tree_priority: int | None
            """
            Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
            under node type settings.
            The default priority for rapid-PVST is set under the node type settings
            with `spanning_tree_priority` (default=32768).
            """
            mtu: int | None
            """Interface MTU."""
            ospf: Ospf
            """OSPF interface configuration."""
            bgp: Bgp
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""
            structured_config: StructuredConfig
            """Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                node: str | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                ip_address: str | None | UndefinedType = Undefined,
                ipv6_address: str | None | UndefinedType = Undefined,
                ipv6_enable: bool | None | UndefinedType = Undefined,
                ip_address_virtual: str | None | UndefinedType = Undefined,
                ipv6_address_virtuals: list[str] | UndefinedType = Undefined,
                ip_address_virtual_secondaries: list[str] | UndefinedType = Undefined,
                ip_virtual_router_addresses: list[str] | UndefinedType = Undefined,
                ipv6_virtual_router_addresses: list[str] | UndefinedType = Undefined,
                ipv4_acl_in: str | None | UndefinedType = Undefined,
                ipv4_acl_out: str | None | UndefinedType = Undefined,
                ip_helpers: IpHelpers | UndefinedType = Undefined,
                vni_override: int | None | UndefinedType = Undefined,
                rt_override: str | None | UndefinedType = Undefined,
                rd_override: str | None | UndefinedType = Undefined,
                trunk_groups: list[str] | UndefinedType = Undefined,
                evpn_l2_multicast: EvpnL2Multicast | UndefinedType = Undefined,
                evpn_l3_multicast: EvpnL3Multicast | UndefinedType = Undefined,
                igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                igmp_snooping_querier: IgmpSnoopingQuerier | UndefinedType = Undefined,
                vxlan: bool | None | UndefinedType = Undefined,
                spanning_tree_priority: int | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                ospf: Ospf | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
            ) -> None:
                """
                NodesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    node: l3_leaf inventory hostname.
                    name: VLAN name.
                    enabled: Enable or disable interface.
                    description: SVI description. By default set to VLAN name.
                    ip_address: IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node.
                    ipv6_address: IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node.
                    ipv6_enable: Explicitly enable/disable link-local IPv6 addressing.
                    ip_address_virtual:
                       IPv4_address/Mask.
                       IPv4 VXLAN Anycast IP address.
                       Conserves IP addresses in VXLAN deployments as it
                       doesn't require unique IP addresses on each node.
                    ipv6_address_virtuals:
                       IPv6 VXLAN Anycast IP addresses.
                       Conserves IPv6 addresses in VXLAN deployments as it doesn't require
                       unique IPv6 addresses on each node.
                    ip_address_virtual_secondaries: Secondary IPv4 VXLAN Anycast IP addresses.
                    ip_virtual_router_addresses:
                       IPv4 VARP addresses.
                       Requires an IP address to be configured on the SVI.
                       If ip_address_virtual is
                       also set, ip_virtual_router_addresses will take precedence
                       _if_ there is an ip_address configured
                       for the node.
                    ipv6_virtual_router_addresses:
                       IPv6 VARP addresses.
                       Requires an IPv6 address to be configured on the SVI.
                       If ipv6_address_virtuals
                       is also set, ipv6_virtual_router_addresses will take precedence
                       _if_ there is an ipv6_address
                       configured for the node.
                    ipv4_acl_in:
                       Name of the IPv4 access-list to be assigned in the ingress direction.
                       The access-list must be
                       defined under `ipv4_acls` and supports substitution of the field "interface_ip".
                    ipv4_acl_out:
                       Name of the IPv4 Access-list to be assigned in the egress direction.
                       The access-list must be defined
                       under `ipv4_acls` and supports substitution of the field "interface_ip".
                    ip_helpers: IP helper for DHCP relay.
                    vni_override:
                       By default the VNI will be derived from "mac_vrf_vni_base".
                       The vni_override allows us to override
                       this value and statically define it (optional).
                    rt_override:
                       By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                       The rt_override allows us
                       to override this value and statically define it.
                       rt_override will default to vni_override if set.
                       rt_override supports two formats:
                         - A single number which will be used in the RT fields instead of
                       mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                         - A full RT string with colon
                       separator which will override the full RT.
                    rd_override:
                       By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                       The rt_override allows us
                       to override this value and statically define it.
                       rd_override will default to rt_override or
                       vni_override if set.

                       rd_override supports two formats:
                         - A single number which will be used in
                       the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                       - A full RD string with colon separator which will override the full RD.
                    trunk_groups: trunk_groups
                    evpn_l2_multicast:
                       Explicitly enable or disable evpn_l2_multicast to override setting of
                       `<network_services_key>.[].evpn_l2_multicast.enabled`.
                       When evpn_l2_multicast.enabled is set to true
                       for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
                       overriding those individual settings.
                       Requires `evpn_multicast` to also be set to `true`.
                    evpn_l3_multicast:
                       Explicitly enable or disable evpn_l3_multicast to override setting of
                       `<network_services_key>.[].evpn_l3_multicast.enabled` and
                       `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
                       Requires `evpn_multicast` to also be
                       set to `true`.
                    igmp_snooping_enabled: Enable IGMP Snooping (Enabled by default on EOS).
                    igmp_snooping_querier: igmp_snooping_querier
                    vxlan: Extend this SVI over VXLAN.
                    spanning_tree_priority:
                       Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                       under node type settings.
                       The default priority for rapid-PVST is set under the node type settings
                       with `spanning_tree_priority` (default=32768).
                    mtu: Interface MTU.
                    ospf: OSPF interface configuration.
                    bgp: bgp
                    raw_eos_cli: EOS CLI rendered directly on the VLAN interface in the final EOS configuration.
                    structured_config: Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Nodes(AvdCollection[str, NodesItem]):
            _primary_key: ClassVar[str] = "node"

        Nodes._item_type = NodesItem

        class IpHelpersItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ip_helper": {"type": str},
                "source_interface": {"type": str},
                "source_vrf": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
            _custom_data: dict[str, Any]
            ip_helper: str
            """IPv4 DHCP server IP."""
            source_interface: str | None
            """Interface name to originate DHCP relay packets to DHCP server."""
            source_vrf: str | None
            """VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_helper: str | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                source_vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpHelpersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_helper: IPv4 DHCP server IP.
                    source_interface: Interface name to originate DHCP relay packets to DHCP server.
                    source_vrf: VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpers(AvdCollection[str, IpHelpersItem]):
            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class EvpnL2Multicast(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always_redistribute_igmp": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            always_redistribute_igmp: bool | None
            """
            Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
            `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
            By default `redistribute
            igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
            False.
            Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
            additional control-plane and data-plane resources,
            but it is required to support forwarding of TTL=1
            multicast traffic within the VLAN.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                always_redistribute_igmp: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                EvpnL2Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    always_redistribute_igmp:
                       Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                       `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                       By default `redistribute
                       igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                       False.
                       Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                       additional control-plane and data-plane resources,
                       but it is required to support forwarding of TTL=1
                       multicast traffic within the VLAN.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EvpnL3Multicast(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                """
                EvpnL3Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IgmpSnoopingQuerier(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "source_address": {"type": str},
                "version": {"type": int},
                "fast_leave": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            """Will be enabled automatically if evpn_l2_multicast is enabled."""
            source_address: str | None
            """
            IPv4_address
            If not set, IP address of "Loopback0" will be used.
            """
            version: int | None
            """IGMP Version (By default EOS uses IGMP version 2 for IGMP querier)."""
            fast_leave: bool | None
            """Enable IGMP snooping fast-leave feature."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                source_address: str | None | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
                fast_leave: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                IgmpSnoopingQuerier.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Will be enabled automatically if evpn_l2_multicast is enabled.
                    source_address:
                       IPv4_address
                       If not set, IP address of "Loopback0" will be used.
                    version: IGMP Version (By default EOS uses IGMP version 2 for IGMP querier).
                    fast_leave: Enable IGMP snooping fast-leave feature.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ospf(AvdModel):
            class MessageDigestKeysItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "id": {"type": int},
                    "hash_algorithm": {"type": str, "default": "sha512"},
                    "key": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                id: int | None
                hash_algorithm: str | None
                key: str | None
                """Type 7 encrypted key."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: int | None | UndefinedType = Undefined,
                    hash_algorithm: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    MessageDigestKeysItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        hash_algorithm: hash_algorithm
                        key: Type 7 encrypted key.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "point_to_point": {"type": bool, "default": True},
                "area": {"type": str, "default": "0.0.0.0"},
                "cost": {"type": int},
                "authentication": {"type": str},
                "simple_auth_key": {"type": str},
                "message_digest_keys": {"type": list, "items": MessageDigestKeysItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            point_to_point: bool | None
            area: str | None
            """OSPF area ID."""
            cost: int | None
            """OSPF link cost."""
            authentication: str | None
            simple_auth_key: str | None
            """Password used with simple authentication."""
            message_digest_keys: list[MessageDigestKeysItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                point_to_point: bool | None | UndefinedType = Undefined,
                area: str | None | UndefinedType = Undefined,
                cost: int | None | UndefinedType = Undefined,
                authentication: str | None | UndefinedType = Undefined,
                simple_auth_key: str | None | UndefinedType = Undefined,
                message_digest_keys: list[MessageDigestKeysItem] | UndefinedType = Undefined,
            ) -> None:
                """
                Ospf.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    point_to_point: point_to_point
                    area: OSPF area ID.
                    cost: OSPF link cost.
                    authentication: authentication
                    simple_auth_key: Password used with simple authentication.
                    message_digest_keys: message_digest_keys

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdModel):
            class StructuredConfig(EosCliConfigGen.RouterBgp.VlansItem):
                pass

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "structured_config": {"type": StructuredConfig}, "raw_eos_cli": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            structured_config: StructuredConfig
            """
            Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
            This
            configuration will not be applied to vlan aware bundles.
            """
            raw_eos_cli: str | None
            """EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                structured_config: StructuredConfig | UndefinedType = Undefined,
                raw_eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    structured_config:
                       Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                       This
                       configuration will not be applied to vlan aware bundles.
                    raw_eos_cli: EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StructuredConfig(EosCliConfigGen.VlanInterfacesItem):
            pass

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "profile": {"type": str},
            "parent_profile": {"type": str},
            "nodes": {"type": Nodes},
            "name": {"type": str},
            "enabled": {"type": bool},
            "description": {"type": str},
            "ip_address": {"type": str},
            "ipv6_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ip_address_virtual": {"type": str},
            "ipv6_address_virtuals": {"type": list, "items": str},
            "ip_address_virtual_secondaries": {"type": list, "items": str},
            "ip_virtual_router_addresses": {"type": list, "items": str},
            "ipv6_virtual_router_addresses": {"type": list, "items": str},
            "ipv4_acl_in": {"type": str},
            "ipv4_acl_out": {"type": str},
            "ip_helpers": {"type": IpHelpers},
            "vni_override": {"type": int},
            "rt_override": {"type": str},
            "rd_override": {"type": str},
            "trunk_groups": {"type": list, "items": str},
            "evpn_l2_multicast": {"type": EvpnL2Multicast},
            "evpn_l3_multicast": {"type": EvpnL3Multicast},
            "igmp_snooping_enabled": {"type": bool},
            "igmp_snooping_querier": {"type": IgmpSnoopingQuerier},
            "vxlan": {"type": bool, "default": True},
            "spanning_tree_priority": {"type": int},
            "mtu": {"type": int},
            "ospf": {"type": Ospf},
            "bgp": {"type": Bgp},
            "raw_eos_cli": {"type": str},
            "structured_config": {"type": StructuredConfig},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "profile")
        _custom_data: dict[str, Any]
        profile: str
        """Profile name."""
        parent_profile: str | None
        """
        Parent SVI profile name to apply.
        svi_profiles can refer to another svi_profile to inherit settings
        in up to two levels (svi -> svi_profile -> svi_parent_profile).
        """
        nodes: Nodes
        """
        Define node specific configuration, such as unique IP addresses.
        Any keys set here will be merged
        onto the SVI config, except `structured_config` keys which will replace the `structured_config` set
        on SVI level.
        """
        name: str | None
        """VLAN name."""
        enabled: bool | None
        """Enable or disable interface."""
        description: str | None
        """SVI description. By default set to VLAN name."""
        ip_address: str | None
        """IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node."""
        ipv6_address: str | None
        """IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node."""
        ipv6_enable: bool | None
        """Explicitly enable/disable link-local IPv6 addressing."""
        ip_address_virtual: str | None
        """
        IPv4_address/Mask.
        IPv4 VXLAN Anycast IP address.
        Conserves IP addresses in VXLAN deployments as it
        doesn't require unique IP addresses on each node.
        """
        ipv6_address_virtuals: list[str]
        """
        IPv6 VXLAN Anycast IP addresses.
        Conserves IPv6 addresses in VXLAN deployments as it doesn't require
        unique IPv6 addresses on each node.
        """
        ip_address_virtual_secondaries: list[str]
        """Secondary IPv4 VXLAN Anycast IP addresses."""
        ip_virtual_router_addresses: list[str]
        """
        IPv4 VARP addresses.
        Requires an IP address to be configured on the SVI.
        If ip_address_virtual is
        also set, ip_virtual_router_addresses will take precedence
        _if_ there is an ip_address configured
        for the node.
        """
        ipv6_virtual_router_addresses: list[str]
        """
        IPv6 VARP addresses.
        Requires an IPv6 address to be configured on the SVI.
        If ipv6_address_virtuals
        is also set, ipv6_virtual_router_addresses will take precedence
        _if_ there is an ipv6_address
        configured for the node.
        """
        ipv4_acl_in: str | None
        """
        Name of the IPv4 access-list to be assigned in the ingress direction.
        The access-list must be
        defined under `ipv4_acls` and supports substitution of the field "interface_ip".
        """
        ipv4_acl_out: str | None
        """
        Name of the IPv4 Access-list to be assigned in the egress direction.
        The access-list must be defined
        under `ipv4_acls` and supports substitution of the field "interface_ip".
        """
        ip_helpers: IpHelpers
        """IP helper for DHCP relay."""
        vni_override: int | None
        """
        By default the VNI will be derived from "mac_vrf_vni_base".
        The vni_override allows us to override
        this value and statically define it (optional).
        """
        rt_override: str | None
        """
        By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
        The rt_override allows us
        to override this value and statically define it.
        rt_override will default to vni_override if set.
        rt_override supports two formats:
          - A single number which will be used in the RT fields instead of
        mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
          - A full RT string with colon
        separator which will override the full RT.
        """
        rd_override: str | None
        """
        By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
        The rt_override allows us
        to override this value and statically define it.
        rd_override will default to rt_override or
        vni_override if set.

        rd_override supports two formats:
          - A single number which will be used in
        the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
        - A full RD string with colon separator which will override the full RD.
        """
        trunk_groups: list[str]
        evpn_l2_multicast: EvpnL2Multicast
        """
        Explicitly enable or disable evpn_l2_multicast to override setting of
        `<network_services_key>.[].evpn_l2_multicast.enabled`.
        When evpn_l2_multicast.enabled is set to true
        for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
        overriding those individual settings.
        Requires `evpn_multicast` to also be set to `true`.
        """
        evpn_l3_multicast: EvpnL3Multicast
        """
        Explicitly enable or disable evpn_l3_multicast to override setting of
        `<network_services_key>.[].evpn_l3_multicast.enabled` and
        `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
        Requires `evpn_multicast` to also be
        set to `true`.
        """
        igmp_snooping_enabled: bool | None
        """Enable IGMP Snooping (Enabled by default on EOS)."""
        igmp_snooping_querier: IgmpSnoopingQuerier
        vxlan: bool | None
        """Extend this SVI over VXLAN."""
        spanning_tree_priority: int | None
        """
        Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
        under node type settings.
        The default priority for rapid-PVST is set under the node type settings
        with `spanning_tree_priority` (default=32768).
        """
        mtu: int | None
        """Interface MTU."""
        ospf: Ospf
        """OSPF interface configuration."""
        bgp: Bgp
        raw_eos_cli: str | None
        """EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""
        structured_config: StructuredConfig
        """Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            profile: str | UndefinedType = Undefined,
            parent_profile: str | None | UndefinedType = Undefined,
            nodes: Nodes | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ip_address_virtual: str | None | UndefinedType = Undefined,
            ipv6_address_virtuals: list[str] | UndefinedType = Undefined,
            ip_address_virtual_secondaries: list[str] | UndefinedType = Undefined,
            ip_virtual_router_addresses: list[str] | UndefinedType = Undefined,
            ipv6_virtual_router_addresses: list[str] | UndefinedType = Undefined,
            ipv4_acl_in: str | None | UndefinedType = Undefined,
            ipv4_acl_out: str | None | UndefinedType = Undefined,
            ip_helpers: IpHelpers | UndefinedType = Undefined,
            vni_override: int | None | UndefinedType = Undefined,
            rt_override: str | None | UndefinedType = Undefined,
            rd_override: str | None | UndefinedType = Undefined,
            trunk_groups: list[str] | UndefinedType = Undefined,
            evpn_l2_multicast: EvpnL2Multicast | UndefinedType = Undefined,
            evpn_l3_multicast: EvpnL3Multicast | UndefinedType = Undefined,
            igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
            igmp_snooping_querier: IgmpSnoopingQuerier | UndefinedType = Undefined,
            vxlan: bool | None | UndefinedType = Undefined,
            spanning_tree_priority: int | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            ospf: Ospf | UndefinedType = Undefined,
            bgp: Bgp | UndefinedType = Undefined,
            raw_eos_cli: str | None | UndefinedType = Undefined,
            structured_config: StructuredConfig | UndefinedType = Undefined,
        ) -> None:
            """
            SviProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                profile: Profile name.
                parent_profile:
                   Parent SVI profile name to apply.
                   svi_profiles can refer to another svi_profile to inherit settings
                   in up to two levels (svi -> svi_profile -> svi_parent_profile).
                nodes:
                   Define node specific configuration, such as unique IP addresses.
                   Any keys set here will be merged
                   onto the SVI config, except `structured_config` keys which will replace the `structured_config` set
                   on SVI level.
                name: VLAN name.
                enabled: Enable or disable interface.
                description: SVI description. By default set to VLAN name.
                ip_address: IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node.
                ipv6_address: IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node.
                ipv6_enable: Explicitly enable/disable link-local IPv6 addressing.
                ip_address_virtual:
                   IPv4_address/Mask.
                   IPv4 VXLAN Anycast IP address.
                   Conserves IP addresses in VXLAN deployments as it
                   doesn't require unique IP addresses on each node.
                ipv6_address_virtuals:
                   IPv6 VXLAN Anycast IP addresses.
                   Conserves IPv6 addresses in VXLAN deployments as it doesn't require
                   unique IPv6 addresses on each node.
                ip_address_virtual_secondaries: Secondary IPv4 VXLAN Anycast IP addresses.
                ip_virtual_router_addresses:
                   IPv4 VARP addresses.
                   Requires an IP address to be configured on the SVI.
                   If ip_address_virtual is
                   also set, ip_virtual_router_addresses will take precedence
                   _if_ there is an ip_address configured
                   for the node.
                ipv6_virtual_router_addresses:
                   IPv6 VARP addresses.
                   Requires an IPv6 address to be configured on the SVI.
                   If ipv6_address_virtuals
                   is also set, ipv6_virtual_router_addresses will take precedence
                   _if_ there is an ipv6_address
                   configured for the node.
                ipv4_acl_in:
                   Name of the IPv4 access-list to be assigned in the ingress direction.
                   The access-list must be
                   defined under `ipv4_acls` and supports substitution of the field "interface_ip".
                ipv4_acl_out:
                   Name of the IPv4 Access-list to be assigned in the egress direction.
                   The access-list must be defined
                   under `ipv4_acls` and supports substitution of the field "interface_ip".
                ip_helpers: IP helper for DHCP relay.
                vni_override:
                   By default the VNI will be derived from "mac_vrf_vni_base".
                   The vni_override allows us to override
                   this value and statically define it (optional).
                rt_override:
                   By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                   The rt_override allows us
                   to override this value and statically define it.
                   rt_override will default to vni_override if set.
                   rt_override supports two formats:
                     - A single number which will be used in the RT fields instead of
                   mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                     - A full RT string with colon
                   separator which will override the full RT.
                rd_override:
                   By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                   The rt_override allows us
                   to override this value and statically define it.
                   rd_override will default to rt_override or
                   vni_override if set.

                   rd_override supports two formats:
                     - A single number which will be used in
                   the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                   - A full RD string with colon separator which will override the full RD.
                trunk_groups: trunk_groups
                evpn_l2_multicast:
                   Explicitly enable or disable evpn_l2_multicast to override setting of
                   `<network_services_key>.[].evpn_l2_multicast.enabled`.
                   When evpn_l2_multicast.enabled is set to true
                   for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
                   overriding those individual settings.
                   Requires `evpn_multicast` to also be set to `true`.
                evpn_l3_multicast:
                   Explicitly enable or disable evpn_l3_multicast to override setting of
                   `<network_services_key>.[].evpn_l3_multicast.enabled` and
                   `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
                   Requires `evpn_multicast` to also be
                   set to `true`.
                igmp_snooping_enabled: Enable IGMP Snooping (Enabled by default on EOS).
                igmp_snooping_querier: igmp_snooping_querier
                vxlan: Extend this SVI over VXLAN.
                spanning_tree_priority:
                   Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                   under node type settings.
                   The default priority for rapid-PVST is set under the node type settings
                   with `spanning_tree_priority` (default=32768).
                mtu: Interface MTU.
                ospf: OSPF interface configuration.
                bgp: bgp
                raw_eos_cli: EOS CLI rendered directly on the VLAN interface in the final EOS configuration.
                structured_config: Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SviProfiles(AvdCollection[str, SviProfilesItem]):
        _primary_key: ClassVar[str] = "profile"

    SviProfiles._item_type = SviProfilesItem

    class TrunkGroups(AvdModel):
        class Mlag(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str, "default": "MLAG"}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                """
                Mlag.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MlagL3(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str, "default": "MLAG"}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                """
                MlagL3.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Uplink(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str, "default": "UPLINK"}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                """
                Uplink.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mlag": {"type": Mlag}, "mlag_l3": {"type": MlagL3}, "uplink": {"type": Uplink}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mlag: Mlag
        """Trunk Group used for MLAG VLAN (Typically VLAN 4094)."""
        mlag_l3: MlagL3
        """Trunk Group used for MLAG L3 peering VLAN and for VRF L3 peering VLANs (Typically VLAN 4093)."""
        uplink: Uplink
        """Trunk Group used on L2 Leaf switches when "enable_trunk_groups" is set."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            mlag: Mlag | UndefinedType = Undefined,
            mlag_l3: MlagL3 | UndefinedType = Undefined,
            uplink: Uplink | UndefinedType = Undefined,
        ) -> None:
            """
            TrunkGroups.

            Args:
            -----
                _custom_data: _custom_data
                mlag: Trunk Group used for MLAG VLAN (Typically VLAN 4094).
                mlag_l3: Trunk Group used for MLAG L3 peering VLAN and for VRF L3 peering VLANs (Typically VLAN 4093).
                uplink: Trunk Group used on L2 Leaf switches when "enable_trunk_groups" is set.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class UnderlayMulticastAnycastRp(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str, "default": "pim"}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mode: str | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | None | UndefinedType = Undefined) -> None:
            """
            UnderlayMulticastAnycastRp.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class UnderlayMulticastRpsItem(AvdModel):
        class NodesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "loopback_number": {"type": int},
                "description": {"type": str, "default": "PIM RP"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "loopback_number")
            _custom_data: dict[str, Any]
            name: str
            """Hostname."""
            loopback_number: int
            description: str | None
            """Interface description."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                loopback_number: int | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                NodesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Hostname.
                    loopback_number: loopback_number
                    description: Interface description.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Nodes(AvdCollection[str, NodesItem]):
            _primary_key: ClassVar[str] = "name"

        Nodes._item_type = NodesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "rp": {"type": str},
            "nodes": {"type": Nodes},
            "groups": {"type": list, "items": str},
            "access_list_name": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "rp")
        _custom_data: dict[str, Any]
        rp: str
        """RP IPv4 address."""
        nodes: Nodes
        """List of nodes where a Loopback interface with the RP address will be configured."""
        groups: list[str]
        """
        List of groups to associate with the RP address set in 'rp'.
        If access_list_name is set, a standard
        access-list will be configured matching these groups.
        Otherwise the groups are configured directly
        on the RP command.
        """
        access_list_name: str | None
        """Name of standard Access-List."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            rp: str | UndefinedType = Undefined,
            nodes: Nodes | UndefinedType = Undefined,
            groups: list[str] | UndefinedType = Undefined,
            access_list_name: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            UnderlayMulticastRpsItem.

            Args:
            -----
                _custom_data: _custom_data
                rp: RP IPv4 address.
                nodes: List of nodes where a Loopback interface with the RP address will be configured.
                groups:
                   List of groups to associate with the RP address set in 'rp'.
                   If access_list_name is set, a standard
                   access-list will be configured matching these groups.
                   Otherwise the groups are configured directly
                   on the RP command.
                access_list_name: Name of standard Access-List.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class UnderlayMulticastRps(AvdCollection[str, UnderlayMulticastRpsItem]):
        _primary_key: ClassVar[str] = "rp"

    UnderlayMulticastRps._item_type = UnderlayMulticastRpsItem

    class UnderlayOspfAuthentication(AvdModel):
        class MessageDigestKeysItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "hash_algorithm": {"type": str, "default": "sha512"},
                "key": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id", "key")
            _custom_data: dict[str, Any]
            id: int
            hash_algorithm: str | None
            key: str
            """
            Key password.
            Only plaintext passwords are supported here as `eos_designs` will encrypt the password
            for each individual underlay interface.
            To protect the password at rest it is strongly recommended
            to make use of Ansible Vault or similar.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | UndefinedType = Undefined,
            ) -> None:
                """
                MessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key:
                       Key password.
                       Only plaintext passwords are supported here as `eos_designs` will encrypt the password
                       for each individual underlay interface.
                       To protect the password at rest it is strongly recommended
                       to make use of Ansible Vault or similar.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MessageDigestKeys(AvdCollection[int, MessageDigestKeysItem]):
            _primary_key: ClassVar[str] = "id"

        MessageDigestKeys._item_type = MessageDigestKeysItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool, "default": False},
            "message_digest_keys": {"type": MessageDigestKeys},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "message_digest_keys")
        _custom_data: dict[str, Any]
        enabled: bool
        message_digest_keys: MessageDigestKeys

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | UndefinedType = Undefined,
            message_digest_keys: MessageDigestKeys | UndefinedType = Undefined,
        ) -> None:
            """
            UnderlayOspfAuthentication.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                message_digest_keys: message_digest_keys

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class UplinkPtp(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable: bool | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined) -> None:
            """
            UplinkPtp.

            Args:
            -----
                _custom_data: _custom_data
                enable: enable

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class WanCarriersItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "path_group": {"type": str},
            "trusted": {"type": bool, "default": False},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "path_group")
        _custom_data: dict[str, Any]
        name: str
        """Carrier name."""
        description: str | None
        """Additional information about the carrier for documentation purposes."""
        path_group: str
        """The path-group to which this carrier belongs."""
        trusted: bool | None
        """
        Set this to `true` to mark this carrier as "trusted".
        WAN interfaces require an inbound access-list
        to be set unless the carrier is "trusted".
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            path_group: str | UndefinedType = Undefined,
            trusted: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            WanCarriersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Carrier name.
                description: Additional information about the carrier for documentation purposes.
                path_group: The path-group to which this carrier belongs.
                trusted:
                   Set this to `true` to mark this carrier as "trusted".
                   WAN interfaces require an inbound access-list
                   to be set unless the carrier is "trusted".

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class WanCarriers(AvdCollection[str, WanCarriersItem]):
        _primary_key: ClassVar[str] = "name"

    WanCarriers._item_type = WanCarriersItem

    class WanHa(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "lan_ha_path_group_name": {"type": str, "default": "LAN_HA"}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        lan_ha_path_group_name: str | None
        """
        When WAN HA is enabled for a site if `wan_mode: cv-pathfinder`, a default path-group is injected to
        form DPS tunnels over LAN.
        This key allows to overwrite the default LAN HA path-group name.
        """

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, lan_ha_path_group_name: str | None | UndefinedType = Undefined) -> None:
            """
            WanHa.

            Args:
            -----
                _custom_data: _custom_data
                lan_ha_path_group_name:
                   When WAN HA is enabled for a site if `wan_mode: cv-pathfinder`, a default path-group is injected to
                   form DPS tunnels over LAN.
                   This key allows to overwrite the default LAN HA path-group name.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class WanIpsecProfiles(AvdModel):
        class ControlPlane(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ike_policy_name": {"type": str, "default": "CP-IKE-POLICY"},
                "sa_policy_name": {"type": str, "default": "CP-SA-POLICY"},
                "profile_name": {"type": str, "default": "CP-PROFILE"},
                "shared_key": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "shared_key")
            _custom_data: dict[str, Any]
            ike_policy_name: str | None
            """Name of the IKE policy."""
            sa_policy_name: str | None
            """Name of the SA policy."""
            profile_name: str | None
            """Name of the IPSec profile."""
            shared_key: str
            """
            The IPSec shared key.
            This variable is sensitive and SHOULD be configured using some vault
            mechanism.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ike_policy_name: str | None | UndefinedType = Undefined,
                sa_policy_name: str | None | UndefinedType = Undefined,
                profile_name: str | None | UndefinedType = Undefined,
                shared_key: str | UndefinedType = Undefined,
            ) -> None:
                """
                ControlPlane.

                Args:
                -----
                    _custom_data: _custom_data
                    ike_policy_name: Name of the IKE policy.
                    sa_policy_name: Name of the SA policy.
                    profile_name: Name of the IPSec profile.
                    shared_key:
                       The IPSec shared key.
                       This variable is sensitive and SHOULD be configured using some vault
                       mechanism.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DataPlane(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ike_policy_name": {"type": str, "default": "DP-IKE-POLICY"},
                "sa_policy_name": {"type": str, "default": "DP-SA-POLICY"},
                "profile_name": {"type": str, "default": "DP-PROFILE"},
                "shared_key": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "shared_key")
            _custom_data: dict[str, Any]
            ike_policy_name: str | None
            """Name of the IKE policy."""
            sa_policy_name: str | None
            """Name of the SA policy."""
            profile_name: str | None
            """Name of the IPSec profile."""
            shared_key: str
            """
            The type 7 encrypted IPSec shared key.
            This variable is sensitive and should be configured using
            some vault mechanism.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ike_policy_name: str | None | UndefinedType = Undefined,
                sa_policy_name: str | None | UndefinedType = Undefined,
                profile_name: str | None | UndefinedType = Undefined,
                shared_key: str | UndefinedType = Undefined,
            ) -> None:
                """
                DataPlane.

                Args:
                -----
                    _custom_data: _custom_data
                    ike_policy_name: Name of the IKE policy.
                    sa_policy_name: Name of the SA policy.
                    profile_name: Name of the IPSec profile.
                    shared_key:
                       The type 7 encrypted IPSec shared key.
                       This variable is sensitive and should be configured using
                       some vault mechanism.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "control_plane": {"type": ControlPlane}, "data_plane": {"type": DataPlane}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "control_plane")
        _custom_data: dict[str, Any]
        control_plane: ControlPlane
        data_plane: DataPlane
        """If `data_plane` is not defined, `control_plane` information is used for both."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            control_plane: ControlPlane | UndefinedType = Undefined,
            data_plane: DataPlane | UndefinedType = Undefined,
        ) -> None:
            """
            WanIpsecProfiles.

            Args:
            -----
                _custom_data: _custom_data
                control_plane: control_plane
                data_plane: If `data_plane` is not defined, `control_plane` information is used for both.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class WanPathGroupsItem(AvdModel):
        class Ipsec(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "dynamic_peers": {"type": bool, "default": True},
                "static_peers": {"type": bool, "default": True},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            dynamic_peers: bool | None
            """Enable IPSec for dynamic peers."""
            static_peers: bool | None
            """Enable IPSec for static peers."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                dynamic_peers: bool | None | UndefinedType = Undefined,
                static_peers: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipsec.

                Args:
                -----
                    _custom_data: _custom_data
                    dynamic_peers: Enable IPSec for dynamic peers.
                    static_peers: Enable IPSec for static peers.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ImportPathGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "remote": {"type": str}, "local": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            remote: str | None
            """Remote path-group to import."""
            local: str | None
            """Optional, if not set, the path-group `name` is used as local."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                remote: str | None | UndefinedType = Undefined,
                local: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ImportPathGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    remote: Remote path-group to import.
                    local: Optional, if not set, the path-group `name` is used as local.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DpsKeepalive(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": str}, "failure_threshold": {"type": int, "default": 5}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interval: str | None
            """
            Interval in milliseconds. Valid values are 50-60000 | "auto".

            When auto, the interval and
            failure_threshold are automatically determined based on
            path state.
            """
            failure_threshold: int | None
            """Failure threshold in number of lost keep-alive messages."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interval: str | None | UndefinedType = Undefined,
                failure_threshold: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                DpsKeepalive.

                Args:
                -----
                    _custom_data: _custom_data
                    interval:
                       Interval in milliseconds. Valid values are 50-60000 | "auto".

                       When auto, the interval and
                       failure_threshold are automatically determined based on
                       path state.
                    failure_threshold: Failure threshold in number of lost keep-alive messages.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "id": {"type": int},
            "description": {"type": str},
            "ipsec": {"type": Ipsec},
            "import_path_groups": {"type": list, "items": ImportPathGroupsItem},
            "default_preference": {"type": str, "default": "preferred"},
            "excluded_from_default_policy": {"type": bool, "default": False},
            "dps_keepalive": {"type": DpsKeepalive},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
        _custom_data: dict[str, Any]
        name: str
        """Path-group name."""
        id: int
        """
        Path-group id.
        Required until an auto ID algorithm is implemented.
        """
        description: str | None
        """Additional information about the path-group for documentation purposes."""
        ipsec: Ipsec
        """Configuration of IPSec at the path-group level."""
        import_path_groups: list[ImportPathGroupsItem]
        """List of path-groups to import in this path-group."""
        default_preference: str | None
        """
        Preference value used when a preference is not given for a path-group in the
        `wan_virtual_topologies.policies` input or when
        the path-group is used in an auto generated policy
        except if `excluded_from_default_policy` is set to `true.

        Valid values are 1-65535 | "preferred" |
        "alternate".

        `preferred` is converted to priority 1.
        `alternate` is converted to priority 2.
        """
        excluded_from_default_policy: bool | None
        """When set to `true`, the path-group is excluded from AVD auto generated policies."""
        dps_keepalive: DpsKeepalive
        """Period between the transmission of consecutive keepalive messages, and failure threshold."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            id: int | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            ipsec: Ipsec | UndefinedType = Undefined,
            import_path_groups: list[ImportPathGroupsItem] | UndefinedType = Undefined,
            default_preference: str | None | UndefinedType = Undefined,
            excluded_from_default_policy: bool | None | UndefinedType = Undefined,
            dps_keepalive: DpsKeepalive | UndefinedType = Undefined,
        ) -> None:
            """
            WanPathGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Path-group name.
                id:
                   Path-group id.
                   Required until an auto ID algorithm is implemented.
                description: Additional information about the path-group for documentation purposes.
                ipsec: Configuration of IPSec at the path-group level.
                import_path_groups: List of path-groups to import in this path-group.
                default_preference:
                   Preference value used when a preference is not given for a path-group in the
                   `wan_virtual_topologies.policies` input or when
                   the path-group is used in an auto generated policy
                   except if `excluded_from_default_policy` is set to `true.

                   Valid values are 1-65535 | "preferred" |
                   "alternate".

                   `preferred` is converted to priority 1.
                   `alternate` is converted to priority 2.
                excluded_from_default_policy: When set to `true`, the path-group is excluded from AVD auto generated policies.
                dps_keepalive: Period between the transmission of consecutive keepalive messages, and failure threshold.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class WanPathGroups(AvdCollection[str, WanPathGroupsItem]):
        _primary_key: ClassVar[str] = "name"

    WanPathGroups._item_type = WanPathGroupsItem

    class WanRouteServersItem(AvdModel):
        class PathGroupsItem(AvdModel):
            class InterfacesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "public_ip": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Interface name."""
                public_ip: str | None
                """The public IPv4 address (without mask) of the Route Reflector for this path-group."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    public_ip: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Interface name.
                        public_ip: The public IPv4 address (without mask) of the Route Reflector for this path-group.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Interfaces(AvdCollection[str, InterfacesItem]):
                _primary_key: ClassVar[str] = "name"

            Interfaces._item_type = InterfacesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "interfaces": {"type": Interfaces}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "interfaces")
            _custom_data: dict[str, Any]
            name: str
            """Path-group name."""
            interfaces: Interfaces

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                interfaces: Interfaces | UndefinedType = Undefined,
            ) -> None:
                """
                PathGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Path-group name.
                    interfaces: interfaces

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PathGroups(AvdCollection[str, PathGroupsItem]):
            _primary_key: ClassVar[str] = "name"

        PathGroups._item_type = PathGroupsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "hostname": {"type": str}, "vtep_ip": {"type": str}, "path_groups": {"type": PathGroups}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "hostname")
        _custom_data: dict[str, Any]
        hostname: str
        """Route-Reflector hostname."""
        vtep_ip: str | None
        """Route-Reflector VTEP IP Address. This is usually the IP address under `interface Dps1`."""
        path_groups: PathGroups
        """Path-groups through which the Route Reflector/Pathfinder is reached."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            hostname: str | UndefinedType = Undefined,
            vtep_ip: str | None | UndefinedType = Undefined,
            path_groups: PathGroups | UndefinedType = Undefined,
        ) -> None:
            """
            WanRouteServersItem.

            Args:
            -----
                _custom_data: _custom_data
                hostname: Route-Reflector hostname.
                vtep_ip: Route-Reflector VTEP IP Address. This is usually the IP address under `interface Dps1`.
                path_groups: Path-groups through which the Route Reflector/Pathfinder is reached.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class WanRouteServers(AvdCollection[str, WanRouteServersItem]):
        _primary_key: ClassVar[str] = "hostname"

    WanRouteServers._item_type = WanRouteServersItem

    class WanVirtualTopologies(AvdModel):
        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "policy": {"type": str, "default": "DEFAULT-POLICY"},
                "wan_vni": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "wan_vni")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            policy: str | None
            """
            Name of the policy to apply to this VRF.
            AVD will auto generate a default policy DEFAULT-POLICY and
            apply it to the VRF(s)
            where the `policy` key is not set.
            It is possible to overwrite the default
            policy for all VRFs using it
            by redefining it in the `wan_virtual_topologies.policies` list using
            the
            default name `DEFAULT-POLICY`.
            """
            wan_vni: int
            """
            Required for VRFs carried over AutoVPN or CV Pathfinder WAN.

            A VRF can have different VNIs between
            the Datacenters and the WAN.
            Note that if no VRF default is configured for WAN, AVD will
            automatically inject the VRF default with
            `wan_vni` set to `1`.
            In addition either `vrf_id` or
            `vrf_vni` must be set to enforce consistent route-targets across domains.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                policy: str | None | UndefinedType = Undefined,
                wan_vni: int | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    policy:
                       Name of the policy to apply to this VRF.
                       AVD will auto generate a default policy DEFAULT-POLICY and
                       apply it to the VRF(s)
                       where the `policy` key is not set.
                       It is possible to overwrite the default
                       policy for all VRFs using it
                       by redefining it in the `wan_virtual_topologies.policies` list using
                       the
                       default name `DEFAULT-POLICY`.
                    wan_vni:
                       Required for VRFs carried over AutoVPN or CV Pathfinder WAN.

                       A VRF can have different VNIs between
                       the Datacenters and the WAN.
                       Note that if no VRF default is configured for WAN, AVD will
                       automatically inject the VRF default with
                       `wan_vni` set to `1`.
                       In addition either `vrf_id` or
                       `vrf_vni` must be set to enforce consistent route-targets across domains.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ControlPlaneVirtualTopology(AvdModel):
            class Constraints(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "jitter": {"type": int}, "latency": {"type": int}, "loss_rate": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                jitter: int | None
                latency: int | None
                loss_rate: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    jitter: int | None | UndefinedType = Undefined,
                    latency: int | None | UndefinedType = Undefined,
                    loss_rate: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Constraints.

                    Args:
                    -----
                        _custom_data: _custom_data
                        jitter: jitter
                        latency: latency
                        loss_rate: loss_rate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PathGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "names": {"type": list, "items": str}, "preference": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "names")
                _custom_data: dict[str, Any]
                names: list[str]
                """List of path-group names."""
                preference: str | None
                """
                Valid values are 1-65535 | "preferred" | "alternate".

                "preferred" is converted to priority 1.
                "alternate" is converted to priority 2.

                If not set, each path-group in `names` will be attributed
                its `default_preference`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    names: list[str] | UndefinedType = Undefined,
                    preference: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PathGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        names: List of path-group names.
                        preference:
                           Valid values are 1-65535 | "preferred" | "alternate".

                           "preferred" is converted to priority 1.
                           "alternate" is converted to priority 2.

                           If not set, each path-group in `names` will be attributed
                           its `default_preference`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InternetExit(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policy": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                policy: str | None
                """
                PREVIEW: This key is in preview mode.

                Internet-exit policy name associated with this
                virtual_topology.
                The policy must be defined under `cv_pathfinder_internet_exit_policies`.
                """

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policy: str | None | UndefinedType = Undefined) -> None:
                    """
                    InternetExit.

                    Args:
                    -----
                        _custom_data: _custom_data
                        policy:
                           PREVIEW: This key is in preview mode.

                           Internet-exit policy name associated with this
                           virtual_topology.
                           The policy must be defined under `cv_pathfinder_internet_exit_policies`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "application_profile": {"type": str, "default": "APP-PROFILE-CONTROL-PLANE"},
                "traffic_class": {"type": int},
                "dscp": {"type": int},
                "lowest_hop_count": {"type": bool, "default": False},
                "constraints": {"type": Constraints},
                "path_groups": {"type": list, "items": PathGroupsItem},
                "internet_exit": {"type": InternetExit},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Optional name, if not set `CONTROL-PLANE-PROFILE` is used."""
            application_profile: str | None
            """
            The application profile to use for control plane traffic.

            The application profile should be defined
            under `application_classification.application_profiles`.
            If not defined AVD will auto generate an
            application profile using the provided name or the default value.

            If not overwritten elsewhere, the
            application profile is generated matching one application matching the control plane traffic either
            sourced from or destined to the WAN route servers.
            """
            traffic_class: int | None
            dscp: int | None
            lowest_hop_count: bool | None
            """
            Prefer paths with lowest hop-count.
            Only applicable for `wan_mode: "cv-pathfinder"`.
            """
            constraints: Constraints
            path_groups: list[PathGroupsItem]
            internet_exit: InternetExit

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                application_profile: str | None | UndefinedType = Undefined,
                traffic_class: int | None | UndefinedType = Undefined,
                dscp: int | None | UndefinedType = Undefined,
                lowest_hop_count: bool | None | UndefinedType = Undefined,
                constraints: Constraints | UndefinedType = Undefined,
                path_groups: list[PathGroupsItem] | UndefinedType = Undefined,
                internet_exit: InternetExit | UndefinedType = Undefined,
            ) -> None:
                """
                ControlPlaneVirtualTopology.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Optional name, if not set `CONTROL-PLANE-PROFILE` is used.
                    application_profile:
                       The application profile to use for control plane traffic.

                       The application profile should be defined
                       under `application_classification.application_profiles`.
                       If not defined AVD will auto generate an
                       application profile using the provided name or the default value.

                       If not overwritten elsewhere, the
                       application profile is generated matching one application matching the control plane traffic either
                       sourced from or destined to the WAN route servers.
                    traffic_class: traffic_class
                    dscp: dscp
                    lowest_hop_count:
                       Prefer paths with lowest hop-count.
                       Only applicable for `wan_mode: "cv-pathfinder"`.
                    constraints: constraints
                    path_groups: path_groups
                    internet_exit: internet_exit

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PoliciesItem(AvdModel):
            class ApplicationVirtualTopologiesItem(AvdModel):
                class Constraints(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "jitter": {"type": int}, "latency": {"type": int}, "loss_rate": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    jitter: int | None
                    latency: int | None
                    loss_rate: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        jitter: int | None | UndefinedType = Undefined,
                        latency: int | None | UndefinedType = Undefined,
                        loss_rate: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Constraints.

                        Args:
                        -----
                            _custom_data: _custom_data
                            jitter: jitter
                            latency: latency
                            loss_rate: loss_rate

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PathGroupsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "names": {"type": list, "items": str}, "preference": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "names")
                    _custom_data: dict[str, Any]
                    names: list[str]
                    """List of path-group names."""
                    preference: str | None
                    """
                    Valid values are 1-65535 | "preferred" | "alternate".

                    "preferred" is converted to priority 1.
                    "alternate" is converted to priority 2.

                    If not set, each path-group in `names` will be attributed
                    its `default_preference`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        names: list[str] | UndefinedType = Undefined,
                        preference: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PathGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            names: List of path-group names.
                            preference:
                               Valid values are 1-65535 | "preferred" | "alternate".

                               "preferred" is converted to priority 1.
                               "alternate" is converted to priority 2.

                               If not set, each path-group in `names` will be attributed
                               its `default_preference`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class InternetExit(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policy": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    policy: str | None
                    """
                    PREVIEW: This key is in preview mode.

                    Internet-exit policy name associated with this
                    virtual_topology.
                    The policy must be defined under `cv_pathfinder_internet_exit_policies`.
                    """

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policy: str | None | UndefinedType = Undefined) -> None:
                        """
                        InternetExit.

                        Args:
                        -----
                            _custom_data: _custom_data
                            policy:
                               PREVIEW: This key is in preview mode.

                               Internet-exit policy name associated with this
                               virtual_topology.
                               The policy must be defined under `cv_pathfinder_internet_exit_policies`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "application_profile": {"type": str},
                    "name": {"type": str},
                    "id": {"type": int},
                    "traffic_class": {"type": int},
                    "dscp": {"type": int},
                    "lowest_hop_count": {"type": bool, "default": False},
                    "constraints": {"type": Constraints},
                    "path_groups": {"type": list, "items": PathGroupsItem},
                    "internet_exit": {"type": InternetExit},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "application_profile")
                _custom_data: dict[str, Any]
                application_profile: str
                """
                The application profile to use for this virtual topology. It must be a defined
                `application_classification.application_profile`.
                """
                name: str | None
                """Optional name, if not set `<policy_name>-<application_profile>` is used."""
                id: int | None
                """
                ID of the AVT in each VRFs. ID must be unique across all virtual topologies in a policy.
                ID 1 is
                reserved for the default_virtual_toplogy.
                ID 254 is reserved for the control_plane_virtual_topology.
                `id` is required when `wan_mode` is 'cv-pathfinder'.
                """
                traffic_class: int | None
                dscp: int | None
                lowest_hop_count: bool | None
                """
                Prefer paths with lowest hop-count.
                Only applicable for `wan_mode: "cv-pathfinder"`.
                """
                constraints: Constraints
                path_groups: list[PathGroupsItem]
                internet_exit: InternetExit

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    application_profile: str | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    id: int | None | UndefinedType = Undefined,
                    traffic_class: int | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    lowest_hop_count: bool | None | UndefinedType = Undefined,
                    constraints: Constraints | UndefinedType = Undefined,
                    path_groups: list[PathGroupsItem] | UndefinedType = Undefined,
                    internet_exit: InternetExit | UndefinedType = Undefined,
                ) -> None:
                    """
                    ApplicationVirtualTopologiesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        application_profile:
                           The application profile to use for this virtual topology. It must be a defined
                           `application_classification.application_profile`.
                        name: Optional name, if not set `<policy_name>-<application_profile>` is used.
                        id:
                           ID of the AVT in each VRFs. ID must be unique across all virtual topologies in a policy.
                           ID 1 is
                           reserved for the default_virtual_toplogy.
                           ID 254 is reserved for the control_plane_virtual_topology.
                           `id` is required when `wan_mode` is 'cv-pathfinder'.
                        traffic_class: traffic_class
                        dscp: dscp
                        lowest_hop_count:
                           Prefer paths with lowest hop-count.
                           Only applicable for `wan_mode: "cv-pathfinder"`.
                        constraints: constraints
                        path_groups: path_groups
                        internet_exit: internet_exit

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ApplicationVirtualTopologies(AvdCollection[str, ApplicationVirtualTopologiesItem]):
                _primary_key: ClassVar[str] = "application_profile"

            ApplicationVirtualTopologies._item_type = ApplicationVirtualTopologiesItem

            class DefaultVirtualTopology(AvdModel):
                class Constraints(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "jitter": {"type": int}, "latency": {"type": int}, "loss_rate": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    jitter: int | None
                    latency: int | None
                    loss_rate: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        jitter: int | None | UndefinedType = Undefined,
                        latency: int | None | UndefinedType = Undefined,
                        loss_rate: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Constraints.

                        Args:
                        -----
                            _custom_data: _custom_data
                            jitter: jitter
                            latency: latency
                            loss_rate: loss_rate

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PathGroupsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "names": {"type": list, "items": str}, "preference": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "names")
                    _custom_data: dict[str, Any]
                    names: list[str]
                    """List of path-group names."""
                    preference: str | None
                    """
                    Valid values are 1-65535 | "preferred" | "alternate".

                    "preferred" is converted to priority 1.
                    "alternate" is converted to priority 2.

                    If not set, each path-group in `names` will be attributed
                    its `default_preference`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        names: list[str] | UndefinedType = Undefined,
                        preference: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PathGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            names: List of path-group names.
                            preference:
                               Valid values are 1-65535 | "preferred" | "alternate".

                               "preferred" is converted to priority 1.
                               "alternate" is converted to priority 2.

                               If not set, each path-group in `names` will be attributed
                               its `default_preference`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class InternetExit(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policy": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    policy: str | None
                    """
                    PREVIEW: This key is in preview mode.

                    Internet-exit policy name associated with this
                    virtual_topology.
                    The policy must be defined under `cv_pathfinder_internet_exit_policies`.
                    """

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policy: str | None | UndefinedType = Undefined) -> None:
                        """
                        InternetExit.

                        Args:
                        -----
                            _custom_data: _custom_data
                            policy:
                               PREVIEW: This key is in preview mode.

                               Internet-exit policy name associated with this
                               virtual_topology.
                               The policy must be defined under `cv_pathfinder_internet_exit_policies`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "drop_unmatched": {"type": bool, "default": False},
                    "traffic_class": {"type": int},
                    "dscp": {"type": int},
                    "lowest_hop_count": {"type": bool, "default": False},
                    "constraints": {"type": Constraints},
                    "path_groups": {"type": list, "items": PathGroupsItem},
                    "internet_exit": {"type": InternetExit},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """Optional name, if not set `<policy_name>-DEFAULT` is used."""
                drop_unmatched: bool | None
                """When set, no `catch-all` match is configured for the policy and unmatched traffic is dropped."""
                traffic_class: int | None
                dscp: int | None
                lowest_hop_count: bool | None
                """
                Prefer paths with lowest hop-count.
                Only applicable for `wan_mode: "cv-pathfinder"`.
                """
                constraints: Constraints
                path_groups: list[PathGroupsItem]
                internet_exit: InternetExit

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    drop_unmatched: bool | None | UndefinedType = Undefined,
                    traffic_class: int | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    lowest_hop_count: bool | None | UndefinedType = Undefined,
                    constraints: Constraints | UndefinedType = Undefined,
                    path_groups: list[PathGroupsItem] | UndefinedType = Undefined,
                    internet_exit: InternetExit | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultVirtualTopology.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Optional name, if not set `<policy_name>-DEFAULT` is used.
                        drop_unmatched: When set, no `catch-all` match is configured for the policy and unmatched traffic is dropped.
                        traffic_class: traffic_class
                        dscp: dscp
                        lowest_hop_count:
                           Prefer paths with lowest hop-count.
                           Only applicable for `wan_mode: "cv-pathfinder"`.
                        constraints: constraints
                        path_groups: path_groups
                        internet_exit: internet_exit

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "application_virtual_topologies": {"type": ApplicationVirtualTopologies},
                "default_virtual_topology": {"type": DefaultVirtualTopology},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "default_virtual_topology")
            _custom_data: dict[str, Any]
            name: str
            """Name of the AVT policy."""
            application_virtual_topologies: ApplicationVirtualTopologies
            """List of application specific virtual topologies."""
            default_virtual_topology: DefaultVirtualTopology
            """
            Default match for the policy.
            If no default match should be configured, set `drop_unmatched` to
            `true`.
            Otherwise, in CV Pathfinder mode, a default AVT profile will be configured with ID 1.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                application_virtual_topologies: ApplicationVirtualTopologies | UndefinedType = Undefined,
                default_virtual_topology: DefaultVirtualTopology | UndefinedType = Undefined,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of the AVT policy.
                    application_virtual_topologies: List of application specific virtual topologies.
                    default_virtual_topology:
                       Default match for the policy.
                       If no default match should be configured, set `drop_unmatched` to
                       `true`.
                       Otherwise, in CV Pathfinder mode, a default AVT profile will be configured with ID 1.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdCollection[str, PoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "vrfs": {"type": Vrfs},
            "control_plane_virtual_topology": {"type": ControlPlaneVirtualTopology},
            "policies": {"type": Policies},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        vrfs: Vrfs
        """Map a VRF that exists in network_services to an AVT policy."""
        control_plane_virtual_topology: ControlPlaneVirtualTopology
        """
        Always injected into the default VRF policy as the first entry.

        By default, if no path-groups are
        specified, all locally available path-groups
        are used in the generated load-balance policy.
        ID is
        hardcoded to 254 for the AVT profile in CV Pathfinder mode.
        """
        policies: Policies
        """
        List of virtual topologies policies.

        For Legacy AutoVPN, each item in the list creates:
          * one
        policy with:
              * one `match` entry per `application_virtual_topologies` item
                they are
        indexed using `10 * <list_index>` where `list_index` starts at `1`.
              * one `default-match`
          *
        one load-balance policy per `application_virtual_topologies` and one for the
        `default_virtual_topology`.
          * if the policy is associated with the default VRF, a special control-
        plane rule is injected
            in the policy with index `1` referring to a control-plane load-balance
        policy as defined under
            `control_plane_virtual_topology` or if not set, the default one.

        For CV
        Pathfinder, each item in the list creates:
          * one policy with:
              * one `match` entry per
        `application_virtual_topologies` item ordered as in the data.
              * one last match entry for the
        `default` application-profile using `default_virtual_topology` information.
          * one profile per
        `application_virtual_topologies` item.
          * one profile for the `default_virtual_topology`.
          * one
        load-balance policy per `application_virtual_topologies`.
          * one load_balance policy for the
        `default_virtual_topology`.
          * if the policy is associated with the default VRF, a special control-
        plane profile is configured
            and injected first in the policy assigned to the `default` VRF. This
        profile points to a
            control-plane load-balance policy as defined under
        `control_plane_virtual_topology` or if not set, the default one.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            control_plane_virtual_topology: ControlPlaneVirtualTopology | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
        ) -> None:
            """
            WanVirtualTopologies.

            Args:
            -----
                _custom_data: _custom_data
                vrfs: Map a VRF that exists in network_services to an AVT policy.
                control_plane_virtual_topology:
                   Always injected into the default VRF policy as the first entry.

                   By default, if no path-groups are
                   specified, all locally available path-groups
                   are used in the generated load-balance policy.
                   ID is
                   hardcoded to 254 for the AVT profile in CV Pathfinder mode.
                policies:
                   List of virtual topologies policies.

                   For Legacy AutoVPN, each item in the list creates:
                     * one
                   policy with:
                         * one `match` entry per `application_virtual_topologies` item
                           they are
                   indexed using `10 * <list_index>` where `list_index` starts at `1`.
                         * one `default-match`
                     *
                   one load-balance policy per `application_virtual_topologies` and one for the
                   `default_virtual_topology`.
                     * if the policy is associated with the default VRF, a special control-
                   plane rule is injected
                       in the policy with index `1` referring to a control-plane load-balance
                   policy as defined under
                       `control_plane_virtual_topology` or if not set, the default one.

                   For CV
                   Pathfinder, each item in the list creates:
                     * one policy with:
                         * one `match` entry per
                   `application_virtual_topologies` item ordered as in the data.
                         * one last match entry for the
                   `default` application-profile using `default_virtual_topology` information.
                     * one profile per
                   `application_virtual_topologies` item.
                     * one profile for the `default_virtual_topology`.
                     * one
                   load-balance policy per `application_virtual_topologies`.
                     * one load_balance policy for the
                   `default_virtual_topology`.
                     * if the policy is associated with the default VRF, a special control-
                   plane profile is configured
                       and injected first in the policy assigned to the `default` VRF. This
                   profile points to a
                       control-plane load-balance policy as defined under
                   `control_plane_virtual_topology` or if not set, the default one.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ZscalerEndpoints(AvdModel):
        class Primary(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ip_address": {"type": str},
                "datacenter": {"type": str},
                "city": {"type": str},
                "country": {"type": str},
                "latitude": {"type": str},
                "longitude": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address", "datacenter", "city", "country", "latitude", "longitude")
            _custom_data: dict[str, Any]
            ip_address: str
            datacenter: str
            city: str
            country: str
            latitude: str
            longitude: str

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_address: str | UndefinedType = Undefined,
                datacenter: str | UndefinedType = Undefined,
                city: str | UndefinedType = Undefined,
                country: str | UndefinedType = Undefined,
                latitude: str | UndefinedType = Undefined,
                longitude: str | UndefinedType = Undefined,
            ) -> None:
                """
                Primary.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_address: ip_address
                    datacenter: datacenter
                    city: city
                    country: country
                    latitude: latitude
                    longitude: longitude

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Secondary(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ip_address": {"type": str},
                "datacenter": {"type": str},
                "city": {"type": str},
                "country": {"type": str},
                "latitude": {"type": str},
                "longitude": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address", "datacenter", "city", "country", "latitude", "longitude")
            _custom_data: dict[str, Any]
            ip_address: str
            datacenter: str
            city: str
            country: str
            latitude: str
            longitude: str

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_address: str | UndefinedType = Undefined,
                datacenter: str | UndefinedType = Undefined,
                city: str | UndefinedType = Undefined,
                country: str | UndefinedType = Undefined,
                latitude: str | UndefinedType = Undefined,
                longitude: str | UndefinedType = Undefined,
            ) -> None:
                """
                Secondary.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_address: ip_address
                    datacenter: datacenter
                    city: city
                    country: country
                    latitude: latitude
                    longitude: longitude

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Tertiary(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ip_address": {"type": str},
                "datacenter": {"type": str},
                "city": {"type": str},
                "country": {"type": str},
                "latitude": {"type": str},
                "longitude": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address", "datacenter", "city", "country", "latitude", "longitude")
            _custom_data: dict[str, Any]
            ip_address: str
            datacenter: str
            city: str
            country: str
            latitude: str
            longitude: str

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_address: str | UndefinedType = Undefined,
                datacenter: str | UndefinedType = Undefined,
                city: str | UndefinedType = Undefined,
                country: str | UndefinedType = Undefined,
                latitude: str | UndefinedType = Undefined,
                longitude: str | UndefinedType = Undefined,
            ) -> None:
                """
                Tertiary.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_address: ip_address
                    datacenter: datacenter
                    city: city
                    country: country
                    latitude: latitude
                    longitude: longitude

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DeviceLocation(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "city": {"type": str}, "country": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "city", "country")
            _custom_data: dict[str, Any]
            city: str
            country: str

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                city: str | UndefinedType = Undefined,
                country: str | UndefinedType = Undefined,
            ) -> None:
                """
                DeviceLocation.

                Args:
                -----
                    _custom_data: _custom_data
                    city: city
                    country: country

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "primary": {"type": Primary},
            "secondary": {"type": Secondary},
            "tertiary": {"type": Tertiary},
            "cloud_name": {"type": str},
            "device_location": {"type": DeviceLocation},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "primary", "cloud_name", "device_location")
        _custom_data: dict[str, Any]
        primary: Primary
        secondary: Secondary
        tertiary: Tertiary
        cloud_name: str
        """
        The name of the Zscaler cloud the CloudVision cluster is integrated with like 'zscaler1' or
        'zscalerbeta'.
        """
        device_location: DeviceLocation
        """
        The location of the calling device after being resolved by Zscaler location APIs. This is required
        since Zscaler only accepts their own variants of City and Country.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            primary: Primary | UndefinedType = Undefined,
            secondary: Secondary | UndefinedType = Undefined,
            tertiary: Tertiary | UndefinedType = Undefined,
            cloud_name: str | UndefinedType = Undefined,
            device_location: DeviceLocation | UndefinedType = Undefined,
        ) -> None:
            """
            ZscalerEndpoints.

            Args:
            -----
                _custom_data: _custom_data
                primary: primary
                secondary: secondary
                tertiary: tertiary
                cloud_name:
                   The name of the Zscaler cloud the CloudVision cluster is integrated with like 'zscaler1' or
                   'zscalerbeta'.
                device_location:
                   The location of the calling device after being resolved by Zscaler location APIs. This is required
                   since Zscaler only accepts their own variants of City and Country.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class _CustomStructuredConfigurationsItem(AvdModel):
        _fields: ClassVar[dict] = {"key": {"type": str}, "value": {"type": EosCliConfigGen}}
        _required_fields: ClassVar[tuple] = ("key", "value")
        key: str
        """Complete key including prefix"""
        value: EosCliConfigGen
        """Structured config including the suffix part of the key."""

        def __init__(self, *, key: str | UndefinedType = Undefined, value: EosCliConfigGen | UndefinedType = Undefined) -> None:
            """
            _CustomStructuredConfigurationsItem.

            Args:
            -----
                key: Complete key including prefix
                value: Structured config including the suffix part of the key.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class _DynamicKeys(AvdModel):
        """Data models for dynamic keys."""

        class DynamicConnectedEndpointsKeys(AvdModel):
            class ConnectedEndpointsKeysKeyItem(AvdModel):
                class AdaptersItem(AvdModel):
                    class Flowcontrol(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "received": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        received: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, received: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Flowcontrol.

                            Args:
                            -----
                                _custom_data: _custom_data
                                received: received

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "endpoint_role": {"type": str, "default": "follower"},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        endpoint_role: str | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            endpoint_role: str | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                endpoint_role: endpoint_role
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class FlowTracking(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        name: str | None
                        """Flow tracker name as defined in flow_tracking_settings."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            FlowTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                name: Flow tracker name as defined in flow_tracking_settings.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LinkTracking(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        name: str | None
                        """
                        Tracking group name.
                        The default group name is taken from fabric variable of the switch,
                        `link_tracking.groups[0].name` with default value being "LT_GROUP1".
                        Optional if default
                        link_tracking settings are configured on the node.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                name:
                                   Tracking group name.
                                   The default group name is taken from fabric variable of the switch,
                                   `link_tracking.groups[0].name` with default value being "LT_GROUP1".
                                   Optional if default
                                   link_tracking settings are configured on the node.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Dot1x(AvdModel):
                        class Pae(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            mode: str | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                Pae.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    mode: mode

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class AuthenticationFailure(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}, "allow_vlan": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            action: str | None
                            allow_vlan: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                action: str | None | UndefinedType = Undefined,
                                allow_vlan: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AuthenticationFailure.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    action: action
                                    allow_vlan: allow_vlan

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class HostMode(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multi_host_authenticated": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            mode: str | None
                            multi_host_authenticated: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                mode: str | None | UndefinedType = Undefined,
                                multi_host_authenticated: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                HostMode.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    mode: mode
                                    multi_host_authenticated: multi_host_authenticated

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MacBasedAuthentication(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "always": {"type": bool},
                                "host_mode_common": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            always: bool | None
                            host_mode_common: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                always: bool | None | UndefinedType = Undefined,
                                host_mode_common: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MacBasedAuthentication.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    always: always
                                    host_mode_common: host_mode_common

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Timeout(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "idle_host": {"type": int},
                                "quiet_period": {"type": int},
                                "reauth_period": {"type": str},
                                "reauth_timeout_ignore": {"type": bool},
                                "tx_period": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            idle_host: int | None
                            quiet_period: int | None
                            reauth_period: str | None
                            """Range 60-4294967295 or "server"."""
                            reauth_timeout_ignore: bool | None
                            tx_period: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                idle_host: int | None | UndefinedType = Undefined,
                                quiet_period: int | None | UndefinedType = Undefined,
                                reauth_period: str | None | UndefinedType = Undefined,
                                reauth_timeout_ignore: bool | None | UndefinedType = Undefined,
                                tx_period: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Timeout.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    idle_host: idle_host
                                    quiet_period: quiet_period
                                    reauth_period: Range 60-4294967295 or "server".
                                    reauth_timeout_ignore: reauth_timeout_ignore
                                    tx_period: tx_period

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Unauthorized(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "access_vlan_membership_egress": {"type": bool},
                                "native_vlan_membership_egress": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            access_vlan_membership_egress: bool | None
                            native_vlan_membership_egress: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                access_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                                native_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Unauthorized.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    access_vlan_membership_egress: access_vlan_membership_egress
                                    native_vlan_membership_egress: native_vlan_membership_egress

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "port_control": {"type": str},
                            "port_control_force_authorized_phone": {"type": bool},
                            "reauthentication": {"type": bool},
                            "pae": {"type": Pae},
                            "authentication_failure": {"type": AuthenticationFailure},
                            "host_mode": {"type": HostMode},
                            "mac_based_authentication": {"type": MacBasedAuthentication},
                            "timeout": {"type": Timeout},
                            "reauthorization_request_limit": {"type": int},
                            "unauthorized": {"type": Unauthorized},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        port_control: str | None
                        port_control_force_authorized_phone: bool | None
                        reauthentication: bool | None
                        pae: Pae
                        authentication_failure: AuthenticationFailure
                        host_mode: HostMode
                        mac_based_authentication: MacBasedAuthentication
                        timeout: Timeout
                        reauthorization_request_limit: int | None
                        unauthorized: Unauthorized

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            port_control: str | None | UndefinedType = Undefined,
                            port_control_force_authorized_phone: bool | None | UndefinedType = Undefined,
                            reauthentication: bool | None | UndefinedType = Undefined,
                            pae: Pae | UndefinedType = Undefined,
                            authentication_failure: AuthenticationFailure | UndefinedType = Undefined,
                            host_mode: HostMode | UndefinedType = Undefined,
                            mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                            timeout: Timeout | UndefinedType = Undefined,
                            reauthorization_request_limit: int | None | UndefinedType = Undefined,
                            unauthorized: Unauthorized | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dot1x.

                            Args:
                            -----
                                _custom_data: _custom_data
                                port_control: port_control
                                port_control_force_authorized_phone: port_control_force_authorized_phone
                                reauthentication: reauthentication
                                pae: pae
                                authentication_failure: authentication_failure
                                host_mode: host_mode
                                mac_based_authentication: mac_based_authentication
                                timeout: timeout
                                reauthorization_request_limit: reauthorization_request_limit
                                unauthorized: unauthorized

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Poe(EosCliConfigGen.EthernetInterfacesItem.Poe):
                        pass

                    class StormControl(AvdModel):
                        class All(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            level: str | None
                            """Configure maximum storm-control level."""
                            unit: str | None
                            """Optional variable and is hardware dependent."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                level: str | None | UndefinedType = Undefined,
                                unit: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                All.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    level: Configure maximum storm-control level.
                                    unit: Optional variable and is hardware dependent.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Broadcast(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            level: str | None
                            """Configure maximum storm-control level."""
                            unit: str | None
                            """Optional variable and is hardware dependent."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                level: str | None | UndefinedType = Undefined,
                                unit: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Broadcast.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    level: Configure maximum storm-control level.
                                    unit: Optional variable and is hardware dependent.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Multicast(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            level: str | None
                            """Configure maximum storm-control level."""
                            unit: str | None
                            """Optional variable and is hardware dependent."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                level: str | None | UndefinedType = Undefined,
                                unit: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Multicast.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    level: Configure maximum storm-control level.
                                    unit: Optional variable and is hardware dependent.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class UnknownUnicast(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            level: str | None
                            """Configure maximum storm-control level."""
                            unit: str | None
                            """Optional variable and is hardware dependent."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                level: str | None | UndefinedType = Undefined,
                                unit: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                UnknownUnicast.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    level: Configure maximum storm-control level.
                                    unit: Optional variable and is hardware dependent.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "all": {"type": All},
                            "broadcast": {"type": Broadcast},
                            "multicast": {"type": Multicast},
                            "unknown_unicast": {"type": UnknownUnicast},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        all: All
                        broadcast: Broadcast
                        multicast: Multicast
                        unknown_unicast: UnknownUnicast

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            all: All | UndefinedType = Undefined,
                            broadcast: Broadcast | UndefinedType = Undefined,
                            multicast: Multicast | UndefinedType = Undefined,
                            unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StormControl.

                            Args:
                            -----
                                _custom_data: _custom_data
                                all: all
                                broadcast: broadcast
                                multicast: multicast
                                unknown_unicast: unknown_unicast

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MonitorSessionsItem(AvdModel):
                        class SourceSettings(AvdModel):
                            class AccessGroup(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "type": {"type": str},
                                    "name": {"type": str},
                                    "priority": {"type": int},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                type: str | None
                                name: str | None
                                """ACL name."""
                                priority: int | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    type: str | None | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                    priority: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    AccessGroup.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        type: type
                                        name: ACL name.
                                        priority: priority

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction": {"type": str}, "access_group": {"type": AccessGroup}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            direction: str | None
                            access_group: AccessGroup
                            """This can only be set when `session_settings.access_group` is not set."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                direction: str | None | UndefinedType = Undefined,
                                access_group: AccessGroup | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SourceSettings.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    direction: direction
                                    access_group: This can only be set when `session_settings.access_group` is not set.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class SessionSettings(AvdModel):
                            class AccessGroup(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                type: str | None
                                name: str | None
                                """ACL name."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    type: str | None | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    AccessGroup.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        type: type
                                        name: ACL name.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Truncate(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "size": {"type": int}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                size: int | None
                                """Size in bytes."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    size: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Truncate.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        size: Size in bytes.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "encapsulation_gre_metadata_tx": {"type": bool},
                                "header_remove_size": {"type": int},
                                "access_group": {"type": AccessGroup},
                                "rate_limit_per_ingress_chip": {"type": str},
                                "rate_limit_per_egress_chip": {"type": str},
                                "sample": {"type": int},
                                "truncate": {"type": Truncate},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            encapsulation_gre_metadata_tx: bool | None
                            header_remove_size: int | None
                            """Number of bytes to remove from header."""
                            access_group: AccessGroup
                            rate_limit_per_ingress_chip: str | None
                            """
                            Ratelimit and unit as string.
                            Examples:
                              "100000 bps"
                              "100 kbps"
                              "10 mbps"
                            """
                            rate_limit_per_egress_chip: str | None
                            """
                            Ratelimit and unit as string.
                            Examples:
                              "100000 bps"
                              "100 kbps"
                              "10 mbps"
                            """
                            sample: int | None
                            truncate: Truncate

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                encapsulation_gre_metadata_tx: bool | None | UndefinedType = Undefined,
                                header_remove_size: int | None | UndefinedType = Undefined,
                                access_group: AccessGroup | UndefinedType = Undefined,
                                rate_limit_per_ingress_chip: str | None | UndefinedType = Undefined,
                                rate_limit_per_egress_chip: str | None | UndefinedType = Undefined,
                                sample: int | None | UndefinedType = Undefined,
                                truncate: Truncate | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SessionSettings.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                                    header_remove_size: Number of bytes to remove from header.
                                    access_group: access_group
                                    rate_limit_per_ingress_chip:
                                       Ratelimit and unit as string.

                                Examples:
                                         "100000 bps"
                                         "100 kbps"
                                         "10 mbps"
                                    rate_limit_per_egress_chip:
                                       Ratelimit and unit as string.

                                Examples:
                                         "100000 bps"
                                         "100 kbps"
                                         "10 mbps"
                                    sample: sample
                                    truncate: truncate

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "name": {"type": str},
                            "role": {"type": str},
                            "source_settings": {"type": SourceSettings},
                            "session_settings": {"type": SessionSettings},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        name: str
                        """Session name."""
                        role: str | None
                        source_settings: SourceSettings
                        session_settings: SessionSettings
                        """
                        Session settings are defined per session name.
                        Different session_settings for the same session name
                        will be combined/merged.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            role: str | None | UndefinedType = Undefined,
                            source_settings: SourceSettings | UndefinedType = Undefined,
                            session_settings: SessionSettings | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MonitorSessionsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: Session name.
                                role: role
                                source_settings: source_settings
                                session_settings:
                                   Session settings are defined per session name.
                                   Different session_settings for the same session name
                                   will be combined/merged.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EthernetSegment(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "short_esi": {"type": str},
                            "redundancy": {"type": str},
                            "designated_forwarder_algorithm": {"type": str},
                            "designated_forwarder_preferences": {"type": list, "items": int},
                            "dont_preempt": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "short_esi")
                        _custom_data: dict[str, Any]
                        short_esi: str
                        """
                        In format xxxx:xxxx:xxxx or "auto".
                        Define a manual short-esi (be careful using this on profiles) or
                        set the value to "auto" to automatically generate the value.
                        Please see the notes under "EVPN A/A
                        ESI dual and single-attached endpoint scenarios" before setting `short_esi: auto`.
                        """
                        redundancy: str | None
                        """
                        If omitted, Port-Channels use the EOS default of all-active.
                        If omitted, Ethernet interfaces are
                        configured as single-active.
                        """
                        designated_forwarder_algorithm: str | None
                        """
                        Configure DF algorithm and preferences.
                        - auto: Use preference-based algorithm and assign preference
                        based on position of device in the 'switches' list,
                          e.g., assuming a list of three switches, this
                        would assign a preference of 200 to the first switch, 100 to the 2nd, and 0 to the third.
                        -
                        preference: Set preference for each switch manually using designated_forwarder_preferences key.
                        -
                        modulus: Use the default modulus-based algorithm.
                        If omitted, Port-Channels use the EOS default of
                        modulus.
                        If omitted, Ethernet interfaces default to the 'auto' mechanism detailed above.
                        """
                        designated_forwarder_preferences: list[int]
                        """Manual preference as described above, required only for preference algorithm."""
                        dont_preempt: bool | None
                        """Disable preemption for single-active forwarding when auto/manual DF preference is configured."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            short_esi: str | UndefinedType = Undefined,
                            redundancy: str | None | UndefinedType = Undefined,
                            designated_forwarder_algorithm: str | None | UndefinedType = Undefined,
                            designated_forwarder_preferences: list[int] | UndefinedType = Undefined,
                            dont_preempt: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EthernetSegment.

                            Args:
                            -----
                                _custom_data: _custom_data
                                short_esi:
                                   In format xxxx:xxxx:xxxx or "auto".
                                   Define a manual short-esi (be careful using this on profiles) or
                                   set the value to "auto" to automatically generate the value.
                                   Please see the notes under "EVPN A/A
                                   ESI dual and single-attached endpoint scenarios" before setting `short_esi: auto`.
                                redundancy:
                                   If omitted, Port-Channels use the EOS default of all-active.
                                   If omitted, Ethernet interfaces are
                                   configured as single-active.
                                designated_forwarder_algorithm:
                                   Configure DF algorithm and preferences.
                                   - auto: Use preference-based algorithm and assign preference
                                   based on position of device in the 'switches' list,
                                     e.g., assuming a list of three switches, this
                                   would assign a preference of 200 to the first switch, 100 to the 2nd, and 0 to the third.
                                   -
                                   preference: Set preference for each switch manually using designated_forwarder_preferences key.
                                   -
                                   modulus: Use the default modulus-based algorithm.
                                   If omitted, Port-Channels use the EOS default of
                                   modulus.
                                   If omitted, Ethernet interfaces default to the 'auto' mechanism detailed above.
                                designated_forwarder_preferences: Manual preference as described above, required only for preference algorithm.
                                dont_preempt: Disable preemption for single-active forwarding when auto/manual DF preference is configured.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class PortChannel(AvdModel):
                        class LacpFallback(AvdModel):
                            class Individual(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                profile: str | None
                                """Port-profile name to inherit configuration."""

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    Individual.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        profile: Port-profile name to inherit configuration.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "mode": {"type": str},
                                "individual": {"type": Individual},
                                "timeout": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            mode: str | None
                            """
                            Either static or individual mode is supported.
                            If the mode is set to "individual" the
                            "individual.profile" setting must be defined.
                            """
                            individual: Individual
                            """
                            Define parameters for port-channel member interfaces. Applies only if LACP fallback is set to
                            "individual".
                            """
                            timeout: int | None
                            """Timeout in seconds. EOS default is 90 seconds."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                mode: str | None | UndefinedType = Undefined,
                                individual: Individual | UndefinedType = Undefined,
                                timeout: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LacpFallback.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    mode:
                                       Either static or individual mode is supported.
                                       If the mode is set to "individual" the
                                       "individual.profile" setting must be defined.
                                    individual:
                                       Define parameters for port-channel member interfaces. Applies only if LACP fallback is set to
                                       "individual".
                                    timeout: Timeout in seconds. EOS default is 90 seconds.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class LacpTimer(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multiplier": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            mode: str | None
                            """LACP mode for interface members."""
                            multiplier: int | None
                            """Number of LACP BPDUs lost before deeming the peer down. EOS default is 3."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                mode: str | None | UndefinedType = Undefined,
                                multiplier: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LacpTimer.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    mode: LACP mode for interface members.
                                    multiplier: Number of LACP BPDUs lost before deeming the peer down. EOS default is 3.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class SubinterfacesItem(AvdModel):
                            class EncapsulationVlan(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "client_dot1q": {"type": int}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                client_dot1q: int | None

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, client_dot1q: int | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    EncapsulationVlan.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        client_dot1q: client_dot1q

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "number": {"type": int},
                                "short_esi": {"type": str},
                                "vlan_id": {"type": int},
                                "encapsulation_vlan": {"type": EncapsulationVlan},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            number: int | None
                            """Subinterface number."""
                            short_esi: str | None
                            """
                            In format xxxx:xxxx:xxxx or "auto".
                            Required for multihomed port-channels with subinterfaces.
                            """
                            vlan_id: int | None
                            """
                            VLAN ID to bridge.
                            Default is subinterface number.
                            """
                            encapsulation_vlan: EncapsulationVlan
                            """
                            Client VLAN ID encapsulation.
                            Default is subinterface number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                number: int | None | UndefinedType = Undefined,
                                short_esi: str | None | UndefinedType = Undefined,
                                vlan_id: int | None | UndefinedType = Undefined,
                                encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SubinterfacesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    number: Subinterface number.
                                    short_esi:
                                       In format xxxx:xxxx:xxxx or "auto".
                                       Required for multihomed port-channels with subinterfaces.
                                    vlan_id:
                                       VLAN ID to bridge.
                                       Default is subinterface number.
                                    encapsulation_vlan:
                                       Client VLAN ID encapsulation.
                                       Default is subinterface number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "mode": {"type": str},
                            "channel_id": {"type": int},
                            "description": {"type": str},
                            "endpoint_port_channel": {"type": str},
                            "enabled": {"type": bool, "default": True},
                            "ptp_mpass": {"type": bool, "default": False},
                            "lacp_fallback": {"type": LacpFallback},
                            "lacp_timer": {"type": LacpTimer},
                            "subinterfaces": {"type": list, "items": SubinterfacesItem},
                            "raw_eos_cli": {"type": str},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        mode: str | None
                        """Port-Channel Mode."""
                        channel_id: int | None
                        """
                        Port-Channel ID.
                        If no channel_id is specified, an id is generated from the first switch port in the
                        port channel.
                        """
                        description: str | None
                        """
                        Description or description template to be used on the port-channel interface.
                        This can be a template
                        using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                        to/custom-descriptions-names.html#avd-string-formatter-syntax.
                        The available template fields are:
                        - `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                          -
                        `endpoint` - The name of the connected endpoint
                          - `endpoint_port_channel` - The value from
                        `endpoint_port_channel` if set.
                          - `port_channel_id` - The port-channel number for the switch.
                          -
                        `adapter_description` - The adapter's description if set.
                          - `adapter_description_or_endpoint` -
                        Helper alias of the adapter_description or endpoint.

                        The default description is set by
                        `default_connected_endpoints_port_channel_description`.
                        By default the description is templated from
                        the type, name and port_channel interface of the endpoint if set.
                        """
                        endpoint_port_channel: str | None
                        """
                        Name of the port-channel interface on the endpoint.
                        Used for the port-channel description template
                        with the field name `peer_interface`
                        """
                        enabled: bool | None
                        """
                        Port-Channel administrative state.
                        Setting to false will set port to 'shutdown' in intended
                        configuration.
                        """
                        ptp_mpass: bool | None
                        """
                        When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                        logical device.
                        Arista PTP enabled devices always place PTP messages on the same physical link
                        within the port-channel.
                        Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                        devices.
                        """
                        lacp_fallback: LacpFallback
                        """LACP fallback configuration."""
                        lacp_timer: LacpTimer
                        """LACP timer configuration. Applies only when Port-channel mode is not "on"."""
                        subinterfaces: list[SubinterfacesItem]
                        """
                        Port-Channel L2 Subinterfaces
                        Subinterfaces are only supported on routed port-channels, which means
                        they cannot be configured on MLAG port-channels.
                        Setting short_esi: auto generates the short_esi
                        automatically using a hash of configuration elements.
                        Please see the notes under "EVPN A/A ESI dual-
                        attached endpoint scenario" before setting short_esi: auto.
                        """
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""
                        structured_config: StructuredConfig
                        """
                        Custom structured config added under port_channel_interfaces.[name=<interface>] for
                        eos_cli_config_gen.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            channel_id: int | None | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            endpoint_port_channel: str | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ptp_mpass: bool | None | UndefinedType = Undefined,
                            lacp_fallback: LacpFallback | UndefinedType = Undefined,
                            lacp_timer: LacpTimer | UndefinedType = Undefined,
                            subinterfaces: list[SubinterfacesItem] | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PortChannel.

                            Args:
                            -----
                                _custom_data: _custom_data
                                mode: Port-Channel Mode.
                                channel_id:
                                   Port-Channel ID.
                                   If no channel_id is specified, an id is generated from the first switch port in the
                                   port channel.
                                description:
                                   Description or description template to be used on the port-channel interface.
                                   This can be a template
                                   using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
                                   to/custom-descriptions-names.html#avd-string-formatter-syntax.
                                   The available template fields are:
                                   - `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                                     -
                                   `endpoint` - The name of the connected endpoint
                                     - `endpoint_port_channel` - The value from
                                   `endpoint_port_channel` if set.
                                     - `port_channel_id` - The port-channel number for the switch.
                                     -
                                   `adapter_description` - The adapter's description if set.
                                     - `adapter_description_or_endpoint` -
                                   Helper alias of the adapter_description or endpoint.

                                   The default description is set by
                                   `default_connected_endpoints_port_channel_description`.
                                   By default the description is templated from
                                   the type, name and port_channel interface of the endpoint if set.
                                endpoint_port_channel:
                                   Name of the port-channel interface on the endpoint.
                                   Used for the port-channel description template
                                   with the field name `peer_interface`
                                enabled:
                                   Port-Channel administrative state.
                                   Setting to false will set port to 'shutdown' in intended
                                   configuration.
                                ptp_mpass:
                                   When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                                   logical device.
                                   Arista PTP enabled devices always place PTP messages on the same physical link
                                   within the port-channel.
                                   Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                                   devices.
                                lacp_fallback: LACP fallback configuration.
                                lacp_timer: LACP timer configuration. Applies only when Port-channel mode is not "on".
                                subinterfaces:
                                   Port-Channel L2 Subinterfaces
                                   Subinterfaces are only supported on routed port-channels, which means
                                   they cannot be configured on MLAG port-channels.
                                   Setting short_esi: auto generates the short_esi
                                   automatically using a hash of configuration elements.
                                   Please see the notes under "EVPN A/A ESI dual-
                                   attached endpoint scenario" before setting short_esi: auto.
                                raw_eos_cli: EOS CLI rendered directly on the port-channel interface in the final EOS configuration.
                                structured_config:
                                   Custom structured config added under port_channel_interfaces.[name=<interface>] for
                                   eos_cli_config_gen.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                        pass

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "switch_ports": {"type": list, "items": str},
                        "switches": {"type": list, "items": str},
                        "endpoint_ports": {"type": list, "items": str},
                        "descriptions": {"type": list, "items": Any},
                        "speed": {"type": str},
                        "description": {"type": str},
                        "profile": {"type": str},
                        "enabled": {"type": bool, "default": True},
                        "mode": {"type": str},
                        "mtu": {"type": int},
                        "l2_mtu": {"type": int},
                        "l2_mru": {"type": int},
                        "native_vlan": {"type": int},
                        "native_vlan_tag": {"type": bool},
                        "phone_vlan": {"type": int},
                        "phone_trunk_mode": {"type": str},
                        "trunk_groups": {"type": list, "items": str},
                        "vlans": {"type": str},
                        "spanning_tree_portfast": {"type": str},
                        "spanning_tree_bpdufilter": {"type": str},
                        "spanning_tree_bpduguard": {"type": str},
                        "flowcontrol": {"type": Flowcontrol},
                        "qos_profile": {"type": str},
                        "ptp": {"type": Ptp},
                        "sflow": {"type": bool},
                        "flow_tracking": {"type": FlowTracking},
                        "link_tracking": {"type": LinkTracking},
                        "dot1x": {"type": Dot1x},
                        "poe": {"type": Poe},
                        "storm_control": {"type": StormControl},
                        "monitor_sessions": {"type": list, "items": MonitorSessionsItem},
                        "ethernet_segment": {"type": EthernetSegment},
                        "port_channel": {"type": PortChannel},
                        "validate_state": {"type": bool},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "switch_ports", "switches")
                    _custom_data: dict[str, Any]
                    switch_ports: list[str]
                    """
                    List of switch interfaces.
                    The lists `endpoint_ports`, `switch_ports`, and `switches` must have the
                    same length.
                    """
                    switches: list[str]
                    """
                    List of switches.
                    The lists `endpoint_ports`, `switch_ports`, and `switches` must have the same
                    length.
                    """
                    endpoint_ports: list[str]
                    """
                    Endpoint ports is used for description, required unless `description` or `descriptions` is set.
                    The
                    lists `endpoint_ports`, `switch_ports`, `descriptions` and `switches` must have the same length.
                    Each list item is one switchport.
                    """
                    descriptions: list[Any]
                    """
                    Unique description per port. When set, takes priority over description.
                    This can be a template using
                    the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
                    descriptions-names.html#avd-string-formatter-syntax.
                    The available template fields are:
                      -
                    `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                      -
                    `endpoint` - The name of the connected endpoint
                      - `endpoint_port` - The value from
                    `endpoint_ports` for this switch port if set.
                    """
                    speed: str | None
                    """
                    Set adapter speed in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                    <interface_speed>`.
                    If not specified speed will be auto.
                    """
                    description: str | None
                    """
                    Description or description template to be used on all ports.
                    This can be a template using the AVD
                    string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
                    descriptions-names.html#avd-string-formatter-syntax.
                    The available template fields are:
                      -
                    `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                      -
                    `endpoint` - The name of the connected endpoint
                      - `endpoint_port` - The value from
                    `endpoint_ports` for this switch port if set.

                    The default description is set by
                    `default_connected_endpoints_description`.
                    By default the description is templated from the type,
                    name and port of the endpoint if set.
                    """
                    profile: str | None
                    """Port-profile name to inherit configuration."""
                    enabled: bool | None
                    """
                    Administrative state, setting to false will set the port to 'shutdown' in the intended
                    configuration.
                    """
                    mode: str | None
                    """Interface mode."""
                    mtu: int | None
                    l2_mtu: int | None
                    l2_mru: int | None
                    native_vlan: int | None
                    """
                    Native VLAN for a trunk port.
                    If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag`
                    takes precedence.
                    """
                    native_vlan_tag: bool | None
                    """If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag` takes precedence."""
                    phone_vlan: int | None
                    """
                    Phone VLAN for a mode `trunk phone` port.
                    Requires `mode: trunk phone` to be set.
                    """
                    phone_trunk_mode: str | None
                    """
                    Specify if the phone traffic is tagged or untagged.
                    If both data and phone traffic are untagged,
                    MAC-Based VLAN Assignment (MBVA) is used, if supported by the model of switch.
                    """
                    trunk_groups: list[str]
                    """
                    Required with `enable_trunk_groups: true`.
                    Trunk Groups are used for limiting VLANs on trunk ports
                    to VLANs with the same Trunk Group.
                    """
                    vlans: str | None
                    """
                    Interface VLANs - if not set, the EOS default is that all VLANs are allowed for trunk ports, and
                    VLAN 1 will be used for access ports.
                    """
                    spanning_tree_portfast: str | None
                    spanning_tree_bpdufilter: str | None
                    spanning_tree_bpduguard: str | None
                    flowcontrol: Flowcontrol
                    qos_profile: str | None
                    """QOS profile name."""
                    ptp: Ptp
                    """
                    The global PTP profile parameters will be applied to all connected endpoints where `ptp` is manually
                    enabled.
                    `ptp role master` is set to ensure control over the PTP topology.
                    """
                    sflow: bool | None
                    """Configures sFlow on the interface. Overrides `fabric_sflow.endpoints` setting."""
                    flow_tracking: FlowTracking
                    """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.endpoints` setting."""
                    link_tracking: LinkTracking
                    """
                    Configure the downstream interfaces of a respective Link Tracking Group.
                    If `port_channel` is
                    defined in an adapter, then the port-channel interface is configured to be the downstream.
                    Else all
                    the ethernet interfaces will be configured as downstream -> to configure single-active EVPN
                    multihomed networks.
                    """
                    dot1x: Dot1x
                    """802.1x"""
                    poe: Poe
                    """Power Over Ethernet settings applied on port. Only configured if platform supports PoE."""
                    storm_control: StormControl
                    """Storm control settings applied on port toward the endpoint."""
                    monitor_sessions: list[MonitorSessionsItem]
                    """Used to define switchports as source or destination for monitoring sessions."""
                    ethernet_segment: EthernetSegment
                    """Settings for all or single-active EVPN multihoming."""
                    port_channel: PortChannel
                    """Used for port-channel adapter."""
                    validate_state: bool | None
                    """Set to false to disable interface validation by the `eos_validate_state` role."""
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        switch_ports: list[str] | UndefinedType = Undefined,
                        switches: list[str] | UndefinedType = Undefined,
                        endpoint_ports: list[str] | UndefinedType = Undefined,
                        descriptions: list[Any] | UndefinedType = Undefined,
                        speed: str | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        profile: str | None | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        mode: str | None | UndefinedType = Undefined,
                        mtu: int | None | UndefinedType = Undefined,
                        l2_mtu: int | None | UndefinedType = Undefined,
                        l2_mru: int | None | UndefinedType = Undefined,
                        native_vlan: int | None | UndefinedType = Undefined,
                        native_vlan_tag: bool | None | UndefinedType = Undefined,
                        phone_vlan: int | None | UndefinedType = Undefined,
                        phone_trunk_mode: str | None | UndefinedType = Undefined,
                        trunk_groups: list[str] | UndefinedType = Undefined,
                        vlans: str | None | UndefinedType = Undefined,
                        spanning_tree_portfast: str | None | UndefinedType = Undefined,
                        spanning_tree_bpdufilter: str | None | UndefinedType = Undefined,
                        spanning_tree_bpduguard: str | None | UndefinedType = Undefined,
                        flowcontrol: Flowcontrol | UndefinedType = Undefined,
                        qos_profile: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        sflow: bool | None | UndefinedType = Undefined,
                        flow_tracking: FlowTracking | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        dot1x: Dot1x | UndefinedType = Undefined,
                        poe: Poe | UndefinedType = Undefined,
                        storm_control: StormControl | UndefinedType = Undefined,
                        monitor_sessions: list[MonitorSessionsItem] | UndefinedType = Undefined,
                        ethernet_segment: EthernetSegment | UndefinedType = Undefined,
                        port_channel: PortChannel | UndefinedType = Undefined,
                        validate_state: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdaptersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            switch_ports:
                               List of switch interfaces.
                               The lists `endpoint_ports`, `switch_ports`, and `switches` must have the
                               same length.
                            switches:
                               List of switches.
                               The lists `endpoint_ports`, `switch_ports`, and `switches` must have the same
                               length.
                            endpoint_ports:
                               Endpoint ports is used for description, required unless `description` or `descriptions` is set.
                               The
                               lists `endpoint_ports`, `switch_ports`, `descriptions` and `switches` must have the same length.
                               Each list item is one switchport.
                            descriptions:
                               Unique description per port. When set, takes priority over description.
                               This can be a template using
                               the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
                               descriptions-names.html#avd-string-formatter-syntax.
                               The available template fields are:
                                 -
                               `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                                 -
                               `endpoint` - The name of the connected endpoint
                                 - `endpoint_port` - The value from
                               `endpoint_ports` for this switch port if set.
                            speed:
                               Set adapter speed in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                               <interface_speed>`.
                               If not specified speed will be auto.
                            description:
                               Description or description template to be used on all ports.
                               This can be a template using the AVD
                               string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
                               descriptions-names.html#avd-string-formatter-syntax.
                               The available template fields are:
                                 -
                               `endpoint_type` - the `type` from `connected_endpoints_keys` like `server`, `router` etc.
                                 -
                               `endpoint` - The name of the connected endpoint
                                 - `endpoint_port` - The value from
                               `endpoint_ports` for this switch port if set.

                               The default description is set by
                               `default_connected_endpoints_description`.
                               By default the description is templated from the type,
                               name and port of the endpoint if set.
                            profile: Port-profile name to inherit configuration.
                            enabled:
                               Administrative state, setting to false will set the port to 'shutdown' in the intended
                               configuration.
                            mode: Interface mode.
                            mtu: mtu
                            l2_mtu: l2_mtu
                            l2_mru: l2_mru
                            native_vlan:
                               Native VLAN for a trunk port.
                               If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag`
                               takes precedence.
                            native_vlan_tag: If both `native_vlan` and `native_vlan_tag` are set, `native_vlan_tag` takes precedence.
                            phone_vlan:
                               Phone VLAN for a mode `trunk phone` port.
                               Requires `mode: trunk phone` to be set.
                            phone_trunk_mode:
                               Specify if the phone traffic is tagged or untagged.
                               If both data and phone traffic are untagged,
                               MAC-Based VLAN Assignment (MBVA) is used, if supported by the model of switch.
                            trunk_groups:
                               Required with `enable_trunk_groups: true`.
                               Trunk Groups are used for limiting VLANs on trunk ports
                               to VLANs with the same Trunk Group.
                            vlans:
                               Interface VLANs - if not set, the EOS default is that all VLANs are allowed for trunk ports, and
                               VLAN 1 will be used for access ports.
                            spanning_tree_portfast: spanning_tree_portfast
                            spanning_tree_bpdufilter: spanning_tree_bpdufilter
                            spanning_tree_bpduguard: spanning_tree_bpduguard
                            flowcontrol: flowcontrol
                            qos_profile: QOS profile name.
                            ptp:
                               The global PTP profile parameters will be applied to all connected endpoints where `ptp` is manually
                               enabled.
                               `ptp role master` is set to ensure control over the PTP topology.
                            sflow: Configures sFlow on the interface. Overrides `fabric_sflow.endpoints` setting.
                            flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.endpoints` setting.
                            link_tracking:
                               Configure the downstream interfaces of a respective Link Tracking Group.
                               If `port_channel` is
                               defined in an adapter, then the port-channel interface is configured to be the downstream.
                               Else all
                               the ethernet interfaces will be configured as downstream -> to configure single-active EVPN
                               multihomed networks.
                            dot1x: 802.1x
                            poe: Power Over Ethernet settings applied on port. Only configured if platform supports PoE.
                            storm_control: Storm control settings applied on port toward the endpoint.
                            monitor_sessions: Used to define switchports as source or destination for monitoring sessions.
                            ethernet_segment: Settings for all or single-active EVPN multihoming.
                            port_channel: Used for port-channel adapter.
                            validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                            raw_eos_cli: EOS CLI rendered directly on the ethernet interface in the final EOS configuration.
                            structured_config: Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "rack": {"type": str},
                    "adapters": {"type": list, "items": AdaptersItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Endpoint name will be used in the switchport description."""
                rack: str | None
                """Rack is used for documentation purposes only."""
                adapters: list[AdaptersItem]
                """A list of adapters, group by adapters leveraging the same port-profile."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    rack: str | None | UndefinedType = Undefined,
                    adapters: list[AdaptersItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    ConnectedEndpointsKeysKeyItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Endpoint name will be used in the switchport description.
                        rack: Rack is used for documentation purposes only.
                        adapters: A list of adapters, group by adapters leveraging the same port-profile.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ConnectedEndpointsKeysKey(AvdCollection[str, ConnectedEndpointsKeysKeyItem]):
                _primary_key: ClassVar[str] = "name"

            ConnectedEndpointsKeysKey._item_type = ConnectedEndpointsKeysKeyItem

            _fields: ClassVar[dict] = {"key": {"type": str}, "value": {"type": ConnectedEndpointsKeysKey, "key": "connected_endpoints_keys_key"}}
            _required_fields: ClassVar[tuple] = ("key",)
            key: str
            """Key used as dynamic key"""
            value: ConnectedEndpointsKeysKey
            """Value of dynamic key"""

            def __init__(self, *, key: str | UndefinedType = Undefined, value: ConnectedEndpointsKeysKey | UndefinedType = Undefined) -> None:
                """
                DynamicConnectedEndpointsKeys.

                Args:
                -----
                    key: Key used as dynamic key
                    value: Value of dynamic key

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DynamicCustomNodeTypeKeys(AvdModel):
            class CustomNodeTypeKeysKey(AvdModel):
                class Defaults(AvdModel):
                    class LinkTracking(AvdModel):
                        class GroupsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "name": {"type": str},
                                "recovery_delay": {"type": int},
                                "links_minimum": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            name: str | None
                            """Tracking group name."""
                            recovery_delay: int | None
                            """default -> platform_settings_mlag_reload_delay -> 300."""
                            links_minimum: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                recovery_delay: int | None | UndefinedType = Undefined,
                                links_minimum: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                GroupsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    name: Tracking group name.
                                    recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                    links_minimum: links_minimum

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "groups": {
                                "type": list,
                                "items": GroupsItem,
                                "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                            },
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        groups: list[GroupsItem]
                        """
                        Link Tracking Groups.
                        By default a single group named "LT_GROUP1" is defined with default values.
                        Any groups defined under "groups" will replace the default.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            groups: list[GroupsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                groups:
                                   Link Tracking Groups.
                                   By default a single group named "LT_GROUP1" is defined with default values.
                                   Any groups defined under "groups" will replace the default.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LacpPortIdRange(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "size": {"type": int, "default": 128},
                            "offset": {"type": int, "default": 0},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        size: int | None
                        """Recommended size > = number of ports in the switch."""
                        offset: int | None
                        """
                        Offset is used to avoid overlapping port-id ranges of different switches.
                        Useful when a "connected-
                        endpoint" is connected to switches in different "node_groups".
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            offset: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LacpPortIdRange.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                size: Recommended size > = number of ports in the switch.
                                offset:
                                   Offset is used to avoid overlapping port-id ranges of different switches.
                                   Useful when a "connected-
                                   endpoint" is connected to switches in different "node_groups".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    class UplinkPtp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enable: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkPtp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enable: enable

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UplinkMacsec(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        profile: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkMacsec.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: profile

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                        pass

                    class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class Filter(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "tenants": {"type": list, "items": str, "default": ["all"]},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "always_include_vrfs_in_tenants": {"type": list, "items": str},
                            "only_vlans_in_use": {"type": bool, "default": False},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        tenants: list[str]
                        """
                        Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                        Tenants (default).
                        This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                        """
                        tags: list[str]
                        """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                        allow_vrfs: list[str]
                        """
                        Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                        (default).
                        This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                        """
                        deny_vrfs: list[str]
                        """
                        Prevent configuration of Network Services defined under these VRFs.
                        This list prevents the given
                        VRFs to be included by any other filtering mechanism.
                        """
                        always_include_vrfs_in_tenants: list[str]
                        """
                        List of tenants where VRFs will be configured even if VLANs are not included in tags.
                        Useful for L3
                        "border" leaf.
                        """
                        only_vlans_in_use: bool | None
                        """
                        Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                        Note! This
                        feature only considers configuration managed by eos_designs.
                        This excludes structured_config,
                        custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            tenants: list[str] | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            allow_vrfs: list[str] | UndefinedType = Undefined,
                            deny_vrfs: list[str] | UndefinedType = Undefined,
                            always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                            only_vlans_in_use: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.

                            Args:
                            -----
                                _custom_data: _custom_data
                                tenants:
                                   Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                   Tenants (default).
                                   This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                allow_vrfs:
                                   Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                   (default).
                                   This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                deny_vrfs:
                                   Prevent configuration of Network Services defined under these VRFs.
                                   This list prevents the given
                                   VRFs to be included by any other filtering mechanism.
                                always_include_vrfs_in_tenants:
                                   List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                   Useful for L3
                                   "border" leaf.
                                only_vlans_in_use:
                                   Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                   Note! This
                                   feature only considers configuration managed by eos_designs.
                                   This excludes structured_config,
                                   custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            hostname: str | None
                            """Hostname of remote EVPN GW server."""
                            ip_address: str | None
                            """Peering IP of remote Route Server."""
                            bgp_as: str | None
                            """
                            Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                            interpreted as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                bgp_as: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote EVPN GW server.
                                    ip_address: Peering IP of remote Route Server.
                                    bgp_as:
                                       Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                       interpreted as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL2(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL2.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "inter_domain": {"type": bool, "default": True},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            inter_domain: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                inter_domain: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL3.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    inter_domain: inter_domain

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                            "evpn_l2": {"type": EvpnL2},
                            "evpn_l3": {"type": EvpnL3},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_peers: list[RemotePeersItem]
                        """
                        Define remote peers of the EVPN VXLAN Gateway.
                        If the hostname can be found in the inventory,
                        ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                        If the
                        peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                        """
                        evpn_l2: EvpnL2
                        """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                        evpn_l3: EvpnL3
                        """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            evpn_l2: EvpnL2 | UndefinedType = Undefined,
                            evpn_l3: EvpnL3 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_peers:
                                   Define remote peers of the EVPN VXLAN Gateway.
                                   If the hostname can be found in the inventory,
                                   ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                   If the
                                   peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                            _custom_data: dict[str, Any]
                            hostname: str
                            """Hostname of remote IPVPN Peer."""
                            ip_address: str
                            """Peering IP of remote IPVPN Peer."""
                            bgp_as: str
                            """
                            Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For
                            asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                            as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | UndefinedType = Undefined,
                                ip_address: str | UndefinedType = Undefined,
                                bgp_as: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote IPVPN Peer.
                                    ip_address: Peering IP of remote IPVPN Peer.
                                    bgp_as:
                                       Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For
                                       asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                       as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_domain_id": {"type": str, "default": "65535:1"},
                            "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                            "enable_d_path": {"type": bool, "default": True},
                            "maximum_routes": {"type": int, "default": 0},
                            "local_as": {"type": str, "default": "none"},
                            "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        evpn_domain_id: str | None
                        """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                        ipvpn_domain_id: str | None
                        """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                        enable_d_path: bool | None
                        """Enable D-path for use with BGP bestpath selection algorithm."""
                        maximum_routes: int | None
                        """Maximum routes to accept from IPVPN remote peers."""
                        local_as: str | None
                        """
                        Local BGP AS applied to peering with IPVPN remote peers.
                        BGP AS <1-4294967295> or AS number in asdot
                        notation "<1-65535>.<0-65535>".
                        For asdot notation in YAML inputs, the value must be put in quotes,
                        to prevent it from being interpreted as a float number.
                        """
                        address_families: list[str]
                        """IPVPN address families to enable for remote peers."""
                        remote_peers: list[RemotePeersItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            evpn_domain_id: str | None | UndefinedType = Undefined,
                            ipvpn_domain_id: str | None | UndefinedType = Undefined,
                            enable_d_path: bool | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            address_families: list[str] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                local_as:
                                   Local BGP AS applied to peering with IPVPN remote peers.
                                   BGP AS <1-4294967295> or AS number in asdot
                                   notation "<1-65535>.<0-65535>".
                                   For asdot notation in YAML inputs, the value must be put in quotes,
                                   to prevent it from being interpreted as a float number.
                                address_families: IPVPN address families to enable for remote peers.
                                remote_peers: remote_peers

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        class Dscp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            general_messages: int | None
                            event_messages: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                general_messages: int | None | UndefinedType = Undefined,
                                event_messages: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dscp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    general_messages: general_messages
                                    event_messages: event_messages

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Monitor(AvdModel):
                            class Threshold(AvdModel):
                                class Drop(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int},
                                        "mean_path_delay": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Drop.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "offset_from_master": {"type": int, "default": 250},
                                    "mean_path_delay": {"type": int, "default": 1500},
                                    "drop": {"type": Drop},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                offset_from_master: int | None
                                mean_path_delay: int | None
                                drop: Drop

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    offset_from_master: int | None | UndefinedType = Undefined,
                                    mean_path_delay: int | None | UndefinedType = Undefined,
                                    drop: Drop | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Threshold.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        offset_from_master: offset_from_master
                                        mean_path_delay: mean_path_delay
                                        drop: drop

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class MissingMessage(AvdModel):
                                class Intervals(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "announce": {"type": int},
                                        "follow_up": {"type": int},
                                        "sync": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    announce: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Intervals.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            announce: announce
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class SequenceIds(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "enabled": {"type": bool, "default": True},
                                        "announce": {"type": int, "default": 3},
                                        "delay_resp": {"type": int, "default": 3},
                                        "follow_up": {"type": int, "default": 3},
                                        "sync": {"type": int, "default": 3},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    enabled: bool | None
                                    announce: int | None
                                    delay_resp: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        enabled: bool | None | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        delay_resp: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        SequenceIds.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            enabled: enabled
                                            announce: announce
                                            delay_resp: delay_resp
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "intervals": {"type": Intervals},
                                    "sequence_ids": {"type": SequenceIds},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                intervals: Intervals
                                sequence_ids: SequenceIds

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    intervals: Intervals | UndefinedType = Undefined,
                                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MissingMessage.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        intervals: intervals
                                        sequence_ids: sequence_ids

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "threshold": {"type": Threshold},
                                "missing_message": {"type": MissingMessage},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            threshold: Threshold
                            missing_message: MissingMessage

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                threshold: Threshold | UndefinedType = Undefined,
                                missing_message: MissingMessage | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Monitor.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    threshold: threshold
                                    missing_message: missing_message

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                            "mlag": {"type": bool, "default": False},
                            "domain": {"type": int, "default": 127},
                            "priority1": {"type": int},
                            "priority2": {"type": int},
                            "auto_clock_identity": {"type": bool, "default": True},
                            "clock_identity_prefix": {"type": str},
                            "clock_identity": {"type": str},
                            "source_ip": {"type": str},
                            "mode": {"type": str, "default": "boundary"},
                            "mode_one_step": {"type": bool, "default": False},
                            "ttl": {"type": int},
                            "forward_unicast": {"type": bool, "default": False},
                            "dscp": {"type": Dscp},
                            "monitor": {"type": Monitor},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """
                        mlag: bool | None
                        """
                        Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                        configured on the MLAG peer-link port-channel.
                        """
                        domain: int | None
                        priority1: int | None
                        """default -> automatically set based on node_type."""
                        priority2: int | None
                        """default -> (node_id modulus 256)."""
                        auto_clock_identity: bool | None
                        """
                        If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                        default EOS behaviour, simply disable the automatic PTP clock identity.
                        default ->
                        (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                        HEX).
                        """
                        clock_identity_prefix: str | None
                        """
                        PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                        By default the 3-byte prefix is "00:1C:73".
                        This
                        can be overridden if auto_clock_identity is set to true (which is the default).
                        """
                        clock_identity: str | None
                        """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                        source_ip: str | None
                        """
                        By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                        relevant SVI, which is the recommended behaviour.
                        This can be set manually if required, for example,
                        to a value of "10.1.2.3".
                        """
                        mode: str | None
                        mode_one_step: bool | None
                        ttl: int | None
                        forward_unicast: bool | None
                        """Enable PTP unicast forwarding."""
                        dscp: Dscp
                        monitor: Monitor

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            domain: int | None | UndefinedType = Undefined,
                            priority1: int | None | UndefinedType = Undefined,
                            priority2: int | None | UndefinedType = Undefined,
                            auto_clock_identity: bool | None | UndefinedType = Undefined,
                            clock_identity_prefix: str | None | UndefinedType = Undefined,
                            clock_identity: str | None | UndefinedType = Undefined,
                            source_ip: str | None | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            mode_one_step: bool | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            forward_unicast: bool | None | UndefinedType = Undefined,
                            dscp: Dscp | UndefinedType = Undefined,
                            monitor: Monitor | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"
                                mlag:
                                   Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                   configured on the MLAG peer-link port-channel.
                                domain: domain
                                priority1: default -> automatically set based on node_type.
                                priority2: default -> (node_id modulus 256).
                                auto_clock_identity:
                                   If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                   default EOS behaviour, simply disable the automatic PTP clock identity.
                                   default ->
                                   (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                   HEX).
                                clock_identity_prefix:
                                   PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                   By default the 3-byte prefix is "00:1C:73".
                                   This
                                   can be overridden if auto_clock_identity is set to true (which is the default).
                                clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                source_ip:
                                   By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                   relevant SVI, which is the recommended behaviour.
                                   This can be set manually if required, for example,
                                   to a value of "10.1.2.3".
                                mode: mode
                                mode_one_step: mode_one_step
                                ttl: ttl
                                forward_unicast: Enable PTP unicast forwarding.
                                dscp: dscp
                                monitor: monitor

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class WanHa(AvdModel):
                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": True},
                            "ipsec": {"type": bool, "default": True},
                            "mtu": {"type": int, "default": 9194},
                            "ha_interfaces": {"type": list, "items": str},
                            "ha_ipv4_pool": {"type": str},
                            "max_ha_interfaces": {"type": int},
                            "port_channel_id": {"type": int},
                            "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                            "flow_tracking": {"type": FlowTracking},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                        ipsec: bool | None
                        """Enable / Disable IPsec over HA path-group when HA is enabled."""
                        mtu: int | None
                        """Set MTU on WAN HA interfaces."""
                        ha_interfaces: list[str]
                        """
                        Local WAN HA interfaces
                        Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                        Can be used to filter uplink interfaces when there are multiple uplinks.
                        Limitations:
                          Either all
                        interfaces must be uplinks or all interfaces must not be uplinks.
                          Only one interface is supported
                        for non uplinks.
                        """
                        ha_ipv4_pool: str | None
                        """
                        IP address pool used for WAN HA connectivity.
                        IP is derived from the node ID.
                        Not used for uplink
                        interfaces.
                        """
                        max_ha_interfaces: int | None
                        """
                        Number of parallel links towards HA switches.
                        Can be used to reserve IP addresses for future
                        parallel HA links.
                        """
                        port_channel_id: int | None
                        """Port-channel ID to use for direct HA."""
                        use_port_channel_for_direct_ha: bool | None
                        """
                        Enable or disable using a port-channel interface for direct HA when there is only one interface.
                        This feature was introduced in EOS 4.33.0F.
                        """
                        flow_tracking: FlowTracking
                        """
                        Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                        setting.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ipsec: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ha_interfaces: list[str] | UndefinedType = Undefined,
                            ha_ipv4_pool: str | None | UndefinedType = Undefined,
                            max_ha_interfaces: int | None | UndefinedType = Undefined,
                            port_channel_id: int | None | UndefinedType = Undefined,
                            use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WanHa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                mtu: Set MTU on WAN HA interfaces.
                                ha_interfaces:
                                   Local WAN HA interfaces
                                   Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                   Can be used to filter uplink interfaces when there are multiple uplinks.
                                   Limitations:
                                     Either all
                                   interfaces must be uplinks or all interfaces must not be uplinks.
                                     Only one interface is supported
                                   for non uplinks.
                                ha_ipv4_pool:
                                   IP address pool used for WAN HA connectivity.
                                   IP is derived from the node ID.
                                   Not used for uplink
                                   interfaces.
                                max_ha_interfaces:
                                   Number of parallel links towards HA switches.
                                   Can be used to reserve IP addresses for future
                                   parallel HA links.
                                port_channel_id: Port-channel ID to use for direct HA.
                                use_port_channel_for_direct_ha:
                                   Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                   This feature was introduced in EOS 4.33.0F.
                                flow_tracking:
                                   Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                   setting.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Bgp(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "peer_as": {"type": str},
                                "ipv4_prefix_list_in": {"type": str},
                                "ipv4_prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                            _custom_data: dict[str, Any]
                            peer_as: str
                            """
                            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in
                            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                            number.
                            """
                            ipv4_prefix_list_in: str | None
                            """
                            Prefix List Name. Accept routes for only these prefixes from the peer.
                            Required for wan interfaces.
                            """
                            ipv4_prefix_list_out: str | None
                            """
                            Prefix List Name. Advertise routes for only these prefixes.
                            If not specified, nothing would be
                            advertised.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                peer_as: str | UndefinedType = Undefined,
                                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    peer_as:
                                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in
                                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                       number.
                                    ipv4_prefix_list_in:
                                       Prefix List Name. Accept routes for only these prefixes from the peer.
                                       Required for wan interfaces.
                                    ipv4_prefix_list_out:
                                       Prefix List Name. Advertise routes for only these prefixes.
                                       If not specified, nothing would be
                                       advertised.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StaticRoutesItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                            _custom_data: dict[str, Any]
                            prefix: str
                            """IPv4_network/Mask."""

                            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                                """
                                StaticRoutesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    prefix: IPv4_network/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class CvPathfinderInternetExit(AvdModel):
                            class PoliciesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                _custom_data: dict[str, Any]
                                name: str
                                """Internet-exit policy name."""
                                tunnel_interface_numbers: str | None
                                """
                                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                interface.
                                Examples: '1-3' or '100,200,300'
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | UndefinedType = Undefined,
                                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PoliciesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Internet-exit policy name.
                                        tunnel_interface_numbers:
                                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                           interface.
                                           Examples: '1-3' or '100,200,300'

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Policies(AvdCollection[str, PoliciesItem]):
                                _primary_key: ClassVar[str] = "name"

                            Policies._item_type = PoliciesItem

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            policies: Policies
                            """List of Internet-exit policies using this interface as exit."""

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                            ) -> None:
                                """
                                CvPathfinderInternetExit.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    policies: List of Internet-exit policies using this interface as exit.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "profile": {"type": str},
                            "name": {"type": str},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "dhcp_ip": {"type": str},
                            "public_ip": {"type": str},
                            "encapsulation_dot1q_vlan": {"type": int},
                            "dhcp_accept_default_route": {"type": bool, "default": True},
                            "enabled": {"type": bool, "default": True},
                            "speed": {"type": str},
                            "peer": {"type": str},
                            "peer_interface": {"type": str},
                            "peer_ip": {"type": str},
                            "bgp": {"type": Bgp},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "static_routes": {"type": list, "items": StaticRoutesItem},
                            "qos_profile": {"type": str},
                            "wan_carrier": {"type": str},
                            "wan_circuit_id": {"type": str},
                            "connected_to_pathfinder": {"type": bool, "default": True},
                            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                            "raw_eos_cli": {"type": str},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        profile: str | None
                        """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                        name: str
                        """
                        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                        For a
                        subinterface, the parent physical interface is automatically created.
                        """
                        description: str | None
                        """
                        Interface description.
                        If not set a default description will be configured with '[<peer>[
                        <peer_interface>]]'.
                        """
                        ip_address: str | None
                        """Node IPv4 address/Mask or 'dhcp'."""
                        dhcp_ip: str | None
                        """
                        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                        IPv4 address
                        (without mask) to be allocated on the interface if known.
                        This is not rendered in the configuration
                        but can be used for substitution of 'interface_ip' in the Access-list
                        set under `ipv4_acl_in` and
                        `ipv4_acl_out`.
                        """
                        public_ip: str | None
                        """
                        Node IPv4 address (no mask).

                        This is used to get the public IP (if known) when the device is behind
                        NAT.
                        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                        with the following preference:
                          `wan_route_servers.path_groups.interfaces.ip_address`
                              ->
                        `l3_interfaces.public_ip`
                                  -> `l3_interfaces.ip_address`

                        The determined Public IP is used
                        by WAN routers when peering with this interface.
                        """
                        encapsulation_dot1q_vlan: int | None
                        """
                        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        dhcp_accept_default_route: bool | None
                        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                        enabled: bool | None
                        """Enable or Shutdown the interface."""
                        speed: str | None
                        """
                        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                        <interface_speed>`.
                        """
                        peer: str | None
                        """The peer device name. Used for description and documentation."""
                        peer_interface: str | None
                        """The peer device interface. Used for description and documentation."""
                        peer_ip: str | None
                        """
                        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                        and `ip` is an IP address.
                        """
                        bgp: Bgp
                        """Enforce IPv4 BGP peering for the peer"""
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        Required
                        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                        `wan_carriers`.
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        """
                        static_routes: list[StaticRoutesItem]
                        """Configure IPv4 static routes pointing to `peer_ip`."""
                        qos_profile: str | None
                        """QOS service profile."""
                        wan_carrier: str | None
                        """
                        The WAN carrier this interface is connected to.
                        This is used to infer the path-groups in which this
                        interface should be configured.
                        Unless the carrier is marked as 'trusted' under `wan_carriers`,
                        `ipv4_acl_in` is also required on all WAN interfaces.
                        """
                        wan_circuit_id: str | None
                        """
                        The WAN circuit ID for this interface.
                        This is not rendered in the configuration but used for WAN
                        designs.
                        """
                        connected_to_pathfinder: bool | None
                        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                        cv_pathfinder_internet_exit: CvPathfinderInternetExit
                        """PREVIEW: This key is in preview mode"""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the interface in the final EOS configuration."""
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config for the Ethernet interface."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            dhcp_ip: str | None | UndefinedType = Undefined,
                            public_ip: str | None | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            speed: str | None | UndefinedType = Undefined,
                            peer: str | None | UndefinedType = Undefined,
                            peer_interface: str | None | UndefinedType = Undefined,
                            peer_ip: str | None | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                            qos_profile: str | None | UndefinedType = Undefined,
                            wan_carrier: str | None | UndefinedType = Undefined,
                            wan_circuit_id: str | None | UndefinedType = Undefined,
                            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                name:
                                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                   For a
                                   subinterface, the parent physical interface is automatically created.
                                description:
                                   Interface description.
                                   If not set a default description will be configured with '[<peer>[
                                   <peer_interface>]]'.
                                ip_address: Node IPv4 address/Mask or 'dhcp'.
                                dhcp_ip:
                                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                   IPv4 address
                                   (without mask) to be allocated on the interface if known.
                                   This is not rendered in the configuration
                                   but can be used for substitution of 'interface_ip' in the Access-list
                                   set under `ipv4_acl_in` and
                                   `ipv4_acl_out`.
                                public_ip:
                                   Node IPv4 address (no mask).

                                   This is used to get the public IP (if known) when the device is behind
                                   NAT.
                                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                   with the following preference:
                                     `wan_route_servers.path_groups.interfaces.ip_address`
                                         ->
                                   `l3_interfaces.public_ip`
                                             -> `l3_interfaces.ip_address`

                                   The determined Public IP is used
                                   by WAN routers when peering with this interface.
                                encapsulation_dot1q_vlan:
                                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                enabled: Enable or Shutdown the interface.
                                speed:
                                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                   <interface_speed>`.
                                peer: The peer device name. Used for description and documentation.
                                peer_interface: The peer device interface. Used for description and documentation.
                                peer_ip:
                                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                   and `ip` is an IP address.
                                bgp: Enforce IPv4 BGP peering for the peer
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                   Required
                                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                   `wan_carriers`.
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                qos_profile: QOS service profile.
                                wan_carrier:
                                   The WAN carrier this interface is connected to.
                                   This is used to infer the path-groups in which this
                                   interface should be configured.
                                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                   `ipv4_acl_in` is also required on all WAN interfaces.
                                wan_circuit_id:
                                   The WAN circuit ID for this interface.
                                   This is not rendered in the configuration but used for WAN
                                   designs.
                                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config for the Ethernet interface.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                        _primary_key: ClassVar[str] = "name"

                    L3Interfaces._item_type = L3InterfacesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "platform": {"type": str},
                        "mac_address": {"type": str},
                        "system_mac_address": {"type": str},
                        "serial_number": {"type": str},
                        "rack": {"type": str},
                        "mgmt_ip": {"type": str},
                        "mgmt_gateway": {"type": str},
                        "ipv6_mgmt_ip": {"type": str},
                        "ipv6_mgmt_gateway": {"type": str},
                        "mgmt_interface": {"type": str},
                        "link_tracking": {"type": LinkTracking},
                        "lacp_port_id_range": {"type": LacpPortIdRange},
                        "always_configure_ip_routing": {"type": bool, "default": False},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                        "uplink_type": {"type": str, "default": "p2p"},
                        "uplink_ipv4_pool": {"type": str},
                        "uplink_interfaces": {"type": list, "items": str},
                        "uplink_switch_interfaces": {"type": list, "items": str},
                        "uplink_switches": {"type": list, "items": str},
                        "uplink_interface_speed": {"type": str},
                        "uplink_switch_interface_speed": {"type": str},
                        "uplink_mtu": {"type": int},
                        "max_uplink_switches": {"type": int},
                        "max_parallel_uplinks": {"type": int},
                        "uplink_bfd": {"type": bool, "default": False},
                        "uplink_native_vlan": {"type": int},
                        "uplink_ptp": {"type": UplinkPtp},
                        "uplink_macsec": {"type": UplinkMacsec},
                        "uplink_port_channel_id": {"type": int},
                        "uplink_switch_port_channel_id": {"type": int},
                        "uplink_structured_config": {"type": dict},
                        "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                        "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                        "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                        "short_esi": {"type": str},
                        "isis_system_id_prefix": {"type": str},
                        "isis_maximum_paths": {"type": int},
                        "is_type": {"type": str, "default": "level-2"},
                        "node_sid_base": {"type": int, "default": 0},
                        "loopback_ipv4_pool": {"type": str},
                        "loopback_ipv4_address": {"type": str},
                        "vtep_loopback_ipv4_pool": {"type": str},
                        "vtep_loopback_ipv4_address": {"type": str},
                        "loopback_ipv4_offset": {"type": int, "default": 0},
                        "loopback_ipv6_pool": {"type": str},
                        "loopback_ipv6_offset": {"type": int, "default": 0},
                        "vtep": {"type": bool},
                        "vtep_loopback": {"type": str},
                        "bgp_as": {"type": str},
                        "bgp_defaults": {"type": list, "items": str},
                        "evpn_role": {"type": str},
                        "evpn_route_servers": {"type": list, "items": str},
                        "evpn_services_l2_only": {"type": bool, "default": False},
                        "filter": {"type": Filter},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "evpn_gateway": {"type": EvpnGateway},
                        "ipvpn_gateway": {"type": IpvpnGateway},
                        "mlag": {"type": bool, "default": True},
                        "mlag_dual_primary_detection": {"type": bool, "default": False},
                        "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                        "mlag_interfaces": {"type": list, "items": str},
                        "mlag_interfaces_speed": {"type": str},
                        "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                        "mlag_peer_l3_ipv4_pool": {"type": str},
                        "mlag_peer_vlan": {"type": int, "default": 4094},
                        "mlag_peer_link_allowed_vlans": {"type": str},
                        "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                        "mlag_peer_ipv4_pool": {"type": str},
                        "mlag_peer_ipv6_pool": {"type": str},
                        "mlag_port_channel_id": {"type": int},
                        "mlag_domain_id": {"type": str},
                        "spanning_tree_mode": {"type": str},
                        "spanning_tree_priority": {"type": int, "default": 32768},
                        "spanning_tree_root_super": {"type": bool, "default": False},
                        "virtual_router_mac_address": {"type": str},
                        "inband_mgmt_interface": {"type": str},
                        "inband_mgmt_vlan": {"type": int, "default": 4092},
                        "inband_mgmt_subnet": {"type": str},
                        "inband_mgmt_ip": {"type": str},
                        "inband_mgmt_gateway": {"type": str},
                        "inband_mgmt_ipv6_address": {"type": str},
                        "inband_mgmt_ipv6_subnet": {"type": str},
                        "inband_mgmt_ipv6_gateway": {"type": str},
                        "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vrf": {"type": str, "default": "default"},
                        "inband_mgmt_mtu": {"type": int, "default": 1500},
                        "inband_ztp": {"type": bool, "default": False},
                        "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                        "mpls_overlay_role": {"type": str},
                        "overlay_address_families": {"type": list, "items": str},
                        "mpls_route_reflectors": {"type": list, "items": str},
                        "bgp_cluster_id": {"type": str},
                        "ptp": {"type": Ptp},
                        "wan_role": {"type": str},
                        "cv_pathfinder_transit_mode": {"type": str},
                        "cv_pathfinder_region": {"type": str},
                        "cv_pathfinder_site": {"type": str},
                        "wan_ha": {"type": WanHa},
                        "dps_mss_ipv4": {"type": str, "default": "auto"},
                        "l3_interfaces": {"type": L3Interfaces},
                        "data_plane_cpu_allocation_max": {"type": int},
                        "flow_tracker_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    id: int | None
                    """Unique identifier used for IP addressing and other algorithms."""
                    platform: str | None
                    """Arista platform family."""
                    mac_address: str | None
                    """Leverage to document management interface mac address."""
                    system_mac_address: str | None
                    """
                    System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                    Set to the same MAC address as
                    available in "show version" on the device.
                    "system_mac_address" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    serial_number: str | None
                    """
                    Set to the Serial Number of the device.
                    Only used for documentation purpose in the fabric
                    documentation and part of the structured_config.
                    "serial_number" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    rack: str | None
                    """Rack that the switch is located in (only used in snmp_settings location)."""
                    mgmt_ip: str | None
                    """Node management interface IPv4 address."""
                    mgmt_gateway: str | None
                    """
                    This key sets the management gateway for the device. It takes precedence over the global
                    `mgmt_gateway`.
                    """
                    ipv6_mgmt_ip: str | None
                    """Node management interface IPv6 address."""
                    ipv6_mgmt_gateway: str | None
                    """
                    This key sets the ipv6 management gateway for the device. It takes precedence over the global
                    `ipv6_mgmt_gateway`.
                    """
                    mgmt_interface: str | None
                    """
                    Management Interface Name.
                    Default -> platform_management_interface -> mgmt_interface ->
                    "Management1".
                    """
                    link_tracking: LinkTracking
                    """
                    This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                    the upstream interfaces.
                    Useful in EVPN multhoming designs.
                    """
                    lacp_port_id_range: LacpPortIdRange
                    """
                    This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                    number of nodes in the "node_group".
                    Unique LACP port-id ranges are recommended for EVPN Multihoming
                    designs.
                    """
                    always_configure_ip_routing: bool | None
                    """
                    Force configuration of "ip routing" even on L2 devices.
                    Use this to retain behavior of AVD versions
                    below 4.0.0.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""
                    uplink_type: str | None
                    """
                    Override the default `uplink_type` set at the `node_type_key` level.
                    `uplink_type` must be "p2p" if
                    `vtep` or `underlay_router` is true for the `node_type_key` definition.
                    """
                    uplink_ipv4_pool: str | None
                    """IPv4 subnet to use to connect to uplink switches."""
                    uplink_interfaces: list[str]
                    """
                    Local uplink interfaces.
                    Each list item supports range syntax that can be expanded into a list of
                    interfaces.
                    If uplink_interfaces is not defined, platform-specific defaults (defined under
                    default_interfaces) will be used instead.
                    Please note that default_interfaces are not defined by
                    default, you should define these yourself.
                    """
                    uplink_switch_interfaces: list[str]
                    """Interfaces located on uplink switches."""
                    uplink_switches: list[str]
                    uplink_interface_speed: str | None
                    """
                    Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                    (Uplink switch
                    interface speed can be overridden with `uplink_switch_interface_speed`).
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_switch_interface_speed: str | None
                    """
                    Set point-to-Point interface speed for the uplink switch interface only.
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_mtu: int | None
                    """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                    max_uplink_switches: int | None
                    """
                    Maximum number of uplink switches.
                    Changing this value may change IP Addressing on uplinks.
                    Can be
                    used to reserve IP space for future expansions.
                    """
                    max_parallel_uplinks: int | None
                    """
                    Number of parallel links towards uplink switches.
                    Changing this value may change interface naming on
                    uplinks (and corresponding downlinks).
                    Can be used to reserve interfaces for future parallel
                    uplinks.
                    """
                    uplink_bfd: bool | None
                    """Enable bfd on uplink interfaces."""
                    uplink_native_vlan: int | None
                    """
                    Only applicable to switches with layer-2 port-channel uplinks.
                    A suspended (disabled) vlan will be
                    created in both ends of the link unless the vlan is defined under network services.
                    By default the
                    uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                    """
                    uplink_ptp: UplinkPtp
                    """Enable PTP on all infrastructure links."""
                    uplink_macsec: UplinkMacsec
                    """Enable MacSec on all uplinks."""
                    uplink_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink Port-channel
                    ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                    For
                    example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [ Eth11/1, Eth22/1 ] -> ID 111
                    For
                    MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                    This
                    option overrides the default behavior and statically sets the local Port-channel ID.
                    Note! Make sure
                    the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                    value.
                    """
                    uplink_switch_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink switch Port-
                    channel ID will be set to the number of the first interface defined under
                    `uplink_switch_interfaces`.
                    For example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [
                    Eth11/1, Eth22/1 ] -> ID 111
                    For MLAG port-channels ID will be based on the lowest member interface
                    on the first MLAG switch.
                    This option overrides the default behavior and statically sets the Port-
                    channel ID on the uplink switch.
                    Note! Make sure the ID is unique and does not overlap with
                    autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between
                    1 and 2000 and both MLAG switches must have the same value.
                    """
                    uplink_structured_config: dict
                    """
                    Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                    When
                    uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                    for eos_cli_config_gen overrides the settings on the ethernet interface level.
                    When uplink_type ==
                    "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                    eos_cli_config_gen overrides the settings on the port-channel interface level.
                    "uplink_structured_config" is applied after "structured_config", so it can override
                    "structured_config" defined on node-level.
                    Note! The content of this dictionary is _not_ validated
                    by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                    """
                    mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                    """
                    Custom structured config applied to MLAG peer link port-channel id.
                    Added under
                    port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the
                    port-channel interface level.
                    "mlag_port_channel_structured_config" is applied after
                    "structured_config", so it can override "structured_config" defined on node-level.
                    """
                    mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                    """
                    Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                    override "structured_config" defined on node-level.
                    """
                    mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                    """
                    Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                    can override "structured_config" defined on node-level.
                    """
                    short_esi: str | None
                    """
                    short_esi only valid for l2leaf devices using port-channel uplink.
                    Setting short_esi to "auto"
                    generates the short_esi automatically using a hash of configuration elements.
                    < 0000:0000:0000 |
                    auto >.
                    """
                    isis_system_id_prefix: str | None
                    """(4.4 hexadecimal)."""
                    isis_maximum_paths: int | None
                    """Number of path to configure in ECMP for ISIS."""
                    is_type: str | None
                    node_sid_base: int | None
                    """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                    loopback_ipv4_pool: str | None
                    """IPv4 subnet for Loopback0 allocation."""
                    loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for Loopback0.
                    When set, it takes precedence over `loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                    """
                    vtep_loopback_ipv4_pool: str | None
                    """IPv4 subnet for VTEP-Loopback allocation."""
                    vtep_loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for VTEP-Loopback.
                    When set, it takes precedence over
                    `vtep_loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not
                    catch duplicates.
                    """
                    loopback_ipv4_offset: int | None
                    """
                    Offset all assigned loopback IP addresses.
                    Required when the < loopback_ipv4_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                    """
                    loopback_ipv6_pool: str | None
                    """IPv6 subnet for Loopback0 allocation."""
                    loopback_ipv6_offset: int | None
                    """
                    Offset all assigned loopback IPv6 addresses.
                    Required when the < loopback_ipv6_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid overlapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                    """
                    vtep: bool | None
                    """
                    Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                    Overrides VTEP
                    setting inherited from node_type_keys.
                    """
                    vtep_loopback: str | None
                    """Set VXLAN source interface."""
                    bgp_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    Required with eBGP.
                    """
                    bgp_defaults: list[str]
                    """List of EOS commands to apply to BGP daemon."""
                    evpn_role: str | None
                    """
                    Acting role in EVPN control plane.
                    Default is set in node_type definition from node_type_keys.
                    """
                    evpn_route_servers: list[str]
                    """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                    evpn_services_l2_only: bool | None
                    """
                    Possibility to prevent configuration of Tenant VRFs and SVIs.
                    Override node definition
                    "network_services_l3" from node_type_keys.
                    This allows support for centralized routing.
                    """
                    filter: Filter
                    """
                    Filter L3 and L2 network services based on tenant and tags (and operation filter).
                    If filter is not
                    defined it will default to all.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping on device level."""
                    evpn_gateway: EvpnGateway
                    """
                    Node is acting as EVPN Multi-Domain Gateway.
                    New BGP peer-group is generated between EVPN GWs in
                    different domains or between GWs and Route Servers.
                    Name can be changed under
                    "bgp_peer_groups.evpn_overlay_core" variable.
                    L3 rechability for different EVPN GWs must be already
                    in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                    same Ansible inventory.
                    """
                    ipvpn_gateway: IpvpnGateway
                    """
                    Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                    this is "bgp_peer_groups.ipvpn_gateway_peers".
                    L3 Reachability is required for this to work, the
                    preferred method to establish underlay connectivity is to use core_interfaces.
                    """
                    mlag: bool | None
                    """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                    mlag_dual_primary_detection: bool | None
                    """Enable / Disable MLAG dual primary detection."""
                    mlag_ibgp_origin_incomplete: bool | None
                    """
                    Set origin of routes received from MLAG iBGP peer to incomplete.
                    The purpose is to optimize routing
                    for leaf loopbacks from spine perspective and
                    avoid suboptimal routing via peerlink for control
                    plane traffic.
                    """
                    mlag_interfaces: list[str]
                    """
                    Each list item supports range syntax that can be expanded into a list of interfaces.
                    Required when
                    MLAG leafs are present in the topology.
                    """
                    mlag_interfaces_speed: str | None
                    """
                    Set MLAG interface speed.
                    Speed should be set in the format `<interface_speed>` or `forced
                    <interface_speed>` or `auto <interface_speed>`.
                    """
                    mlag_peer_l3_vlan: int | None
                    """
                    Underlay L3 peering SVI interface id.
                    If set to 0 or the same vlan as mlag_peer_vlan, the
                    mlag_peer_vlan will be used for L3 peering.
                    """
                    mlag_peer_l3_ipv4_pool: str | None
                    """
                    IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                    Required when
                    MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                    """
                    mlag_peer_vlan: int | None
                    """MLAG Peer Link (control link) SVI interface id."""
                    mlag_peer_link_allowed_vlans: str | None
                    mlag_peer_address_family: str | None
                    """
                    IP address family used to establish MLAG Peer Link (control link).
                    `ipv6` requires EOS version
                    4.31.1F or higher.
                    Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                    (ex. `mlag_peer_l3_vlan` set to 4094).
                    """
                    mlag_peer_ipv4_pool: str | None
                    """
                    IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                    """
                    mlag_peer_ipv6_pool: str | None
                    """
                    IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                    """
                    mlag_port_channel_id: int | None
                    """
                    If not set, the mlag port-channel id is generated based on the digits of the first interface present
                    in 'mlag_interfaces'.
                    Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                    999999 > for EOS >= 4.25.0F.
                    """
                    mlag_domain_id: str | None
                    """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                    spanning_tree_mode: str | None
                    spanning_tree_priority: int | None
                    """
                    Spanning-tree priority configured for the selected mode.
                    For `rapid-pvst` the priority can also be
                    set per VLAN under network services.
                    """
                    spanning_tree_root_super: bool | None
                    virtual_router_mac_address: str | None
                    """Virtual router mac address for anycast gateway."""
                    inband_mgmt_interface: str | None
                    """
                    Pointer to interface used for inband management.
                    All configuration must be done using other data
                    models like network services or structured_config.
                    'inband_mgmt_interface' is only used to refer to
                    this interface as source in various management protocol settings (future feature).

                    On L2 switches,
                    this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                    """
                    inband_mgmt_vlan: int | None
                    """
                    VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                    uplinks).
                    When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                    switch as well as all 'uplink_switches'.
                    When using 'inband_mgmt_ip' the VLAN and SVI will only be
                    created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                    created using network services data models.
                    """
                    inband_mgmt_subnet: str | None
                    """
                    Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                    ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      : <subnet> +
                    2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       :
                    <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than total l2leafs + 5
                    Setting is ignored if 'inband_mgmt_ip' is set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ip: str | None
                    """
                    IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                    If this is set the
                    VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN and SVI on
                    the parent switches must be created using network services data models.

                    This setting is applicable
                    to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                    is derived from 'inband_mgmt_subnet' if set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_address: str | None
                    """
                    IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                    If this
                    is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN
                    and SVI on the parent switches must be created using network services data models.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_subnet: str | None
                    """
                    Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                    on ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                    extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      :
                    <subnet> + 2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       : <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than
                    total l2leafs + 5

                    Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf'.
                    Used when `inband_mgmt_ipv6_address` is set.
                    Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_description: str | None
                    """
                    Description configured on the Inband Management SVI.

                    This setting is only applied on the devices
                    where it is set, it does not automatically affect any parent/child devices configuration, so it must
                    be set on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vlan_name: str | None
                    """
                    Name configured on the Inband Management VLAN.
                    This setting is only applied on the devices where it
                    is set, it does not automatically affect any parent/child devices configuration, so it must be set
                    on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vrf: str | None
                    """
                    VRF configured on the Inband Management Interface.
                    The VRF is created if not already created by
                    other means.
                    This setting is only applied on the devices where it is set, it does not automatically
                    affect any parent/child devices configuration, so it must be set on each applicable node/node-
                    group/node-type as needed.
                    """
                    inband_mgmt_mtu: int | None
                    """
                    MTU configured on the Inband Management Interface.
                    This setting is only applied on the devices where
                    it is set, it does not automatically affect any parent/child devices configuration, so it must be
                    set on each applicable node/node-group/node-type as needed.
                    """
                    inband_ztp: bool | None
                    """
                    Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                    inband.
                    This setting also requires that the `inband_mgmt_vlan` is set for the node.
                    """
                    inband_ztp_lacp_fallback_delay: int | None
                    """
                    Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                    ZTP node.
                    This setting also requires that `inband_ztp` is set for the node.
                    """
                    mpls_overlay_role: str | None
                    """
                    Set the default mpls overlay role.
                    Acting role in overlay control plane.
                    """
                    overlay_address_families: list[str]
                    """Set the default overlay address families."""
                    mpls_route_reflectors: list[str]
                    """List of inventory hostname acting as MPLS route-reflectors."""
                    bgp_cluster_id: str | None
                    """Set BGP cluster id."""
                    ptp: Ptp
                    wan_role: str | None
                    """
                    Override the default WAN role.

                    This is used both for AutoVPN and Pathfinder designs.
                    That means if
                    `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                    `server` indicates that the
                    router is a route-reflector.

                    Only supported if `overlay_routing_protocol` is set to `ibgp`.
                    """
                    cv_pathfinder_transit_mode: str | None
                    """
                    Configure the transit mode for a WAN client for CV Pathfinder designs
                    only when the `wan_mode` root
                    key is set to `cv_pathfinder`.

                    'zone' is currently not supported.
                    """
                    cv_pathfinder_region: str | None
                    """
                    The CV Pathfinder region name.
                    This key is required for WAN routers but optional for pathfinders.
                    The region name must be defined under 'cv_pathfinder_regions'.
                    """
                    cv_pathfinder_site: str | None
                    """
                    The CV Pathfinder site name.
                    This key is required for WAN routers but optional for pathfinders.
                    For
                    WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                    relevant region under 'cv_pathfinder_regions'.
                    For pathfinders without `cv_pathfinder_region` set,
                    the site must be defined under `cv_pathfinder_global_sites`.
                    """
                    wan_ha: WanHa
                    """
                    PREVIEW: This key is currently not supported

                    The key is supported only if `wan_mode` == `cv-
                    pathfinder`.
                    AutoVPN support is still to be determined.

                    Maximum 2 devices supported by group for
                    HA.
                    """
                    dps_mss_ipv4: str | None
                    """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                    l3_interfaces: L3Interfaces
                    """
                    L3 Interfaces to configure on the node.
                    Used to define the node for WAN interfaces when
                    `wan_carrier` is set.
                    """
                    data_plane_cpu_allocation_max: int | None
                    """
                    Set the maximum number of CPU used for the data plane.
                    This setting is useful on virtual Route
                    Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                    """
                    flow_tracker_type: str | None
                    """
                    Set the flow tracker type.
                    Override the `default_flow_tracker_type`` set at the `node_type_key`
                    level.
                    `default_flow_tracker_type` default value is `sampled`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        platform: str | None | UndefinedType = Undefined,
                        mac_address: str | None | UndefinedType = Undefined,
                        system_mac_address: str | None | UndefinedType = Undefined,
                        serial_number: str | None | UndefinedType = Undefined,
                        rack: str | None | UndefinedType = Undefined,
                        mgmt_ip: str | None | UndefinedType = Undefined,
                        mgmt_gateway: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                        mgmt_interface: str | None | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                        always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                        uplink_type: str | None | UndefinedType = Undefined,
                        uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                        uplink_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switches: list[str] | UndefinedType = Undefined,
                        uplink_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_mtu: int | None | UndefinedType = Undefined,
                        max_uplink_switches: int | None | UndefinedType = Undefined,
                        max_parallel_uplinks: int | None | UndefinedType = Undefined,
                        uplink_bfd: bool | None | UndefinedType = Undefined,
                        uplink_native_vlan: int | None | UndefinedType = Undefined,
                        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                        uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                        uplink_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_structured_config: dict | UndefinedType = Undefined,
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                        short_esi: str | None | UndefinedType = Undefined,
                        isis_system_id_prefix: str | None | UndefinedType = Undefined,
                        isis_maximum_paths: int | None | UndefinedType = Undefined,
                        is_type: str | None | UndefinedType = Undefined,
                        node_sid_base: int | None | UndefinedType = Undefined,
                        loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                        loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                        vtep: bool | None | UndefinedType = Undefined,
                        vtep_loopback: str | None | UndefinedType = Undefined,
                        bgp_as: str | None | UndefinedType = Undefined,
                        bgp_defaults: list[str] | UndefinedType = Undefined,
                        evpn_role: str | None | UndefinedType = Undefined,
                        evpn_route_servers: list[str] | UndefinedType = Undefined,
                        evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                        ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                        mlag: bool | None | UndefinedType = Undefined,
                        mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                        mlag_interfaces: list[str] | UndefinedType = Undefined,
                        mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                        mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                        mlag_peer_address_family: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                        mlag_port_channel_id: int | None | UndefinedType = Undefined,
                        mlag_domain_id: str | None | UndefinedType = Undefined,
                        spanning_tree_mode: str | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                        virtual_router_mac_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_interface: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                        inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ip: str | None | UndefinedType = Undefined,
                        inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_description: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                        inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                        inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                        inband_ztp: bool | None | UndefinedType = Undefined,
                        inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                        mpls_overlay_role: str | None | UndefinedType = Undefined,
                        overlay_address_families: list[str] | UndefinedType = Undefined,
                        mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                        bgp_cluster_id: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        wan_role: str | None | UndefinedType = Undefined,
                        cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                        cv_pathfinder_region: str | None | UndefinedType = Undefined,
                        cv_pathfinder_site: str | None | UndefinedType = Undefined,
                        wan_ha: WanHa | UndefinedType = Undefined,
                        dps_mss_ipv4: str | None | UndefinedType = Undefined,
                        l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                        data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                        flow_tracker_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Defaults.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Unique identifier used for IP addressing and other algorithms.
                            platform: Arista platform family.
                            mac_address: Leverage to document management interface mac address.
                            system_mac_address:
                               System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                               Set to the same MAC address as
                               available in "show version" on the device.
                               "system_mac_address" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            serial_number:
                               Set to the Serial Number of the device.
                               Only used for documentation purpose in the fabric
                               documentation and part of the structured_config.
                               "serial_number" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            rack: Rack that the switch is located in (only used in snmp_settings location).
                            mgmt_ip: Node management interface IPv4 address.
                            mgmt_gateway:
                               This key sets the management gateway for the device. It takes precedence over the global
                               `mgmt_gateway`.
                            ipv6_mgmt_ip: Node management interface IPv6 address.
                            ipv6_mgmt_gateway:
                               This key sets the ipv6 management gateway for the device. It takes precedence over the global
                               `ipv6_mgmt_gateway`.
                            mgmt_interface:
                               Management Interface Name.
                               Default -> platform_management_interface -> mgmt_interface ->
                               "Management1".
                            link_tracking:
                               This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                               the upstream interfaces.
                               Useful in EVPN multhoming designs.
                            lacp_port_id_range:
                               This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                               number of nodes in the "node_group".
                               Unique LACP port-id ranges are recommended for EVPN Multihoming
                               designs.
                            always_configure_ip_routing:
                               Force configuration of "ip routing" even on L2 devices.
                               Use this to retain behavior of AVD versions
                               below 4.0.0.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.
                            uplink_type:
                               Override the default `uplink_type` set at the `node_type_key` level.
                               `uplink_type` must be "p2p" if
                               `vtep` or `underlay_router` is true for the `node_type_key` definition.
                            uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                            uplink_interfaces:
                               Local uplink interfaces.
                               Each list item supports range syntax that can be expanded into a list of
                               interfaces.
                               If uplink_interfaces is not defined, platform-specific defaults (defined under
                               default_interfaces) will be used instead.
                               Please note that default_interfaces are not defined by
                               default, you should define these yourself.
                            uplink_switch_interfaces: Interfaces located on uplink switches.
                            uplink_switches: uplink_switches
                            uplink_interface_speed:
                               Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                               (Uplink switch
                               interface speed can be overridden with `uplink_switch_interface_speed`).
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_switch_interface_speed:
                               Set point-to-Point interface speed for the uplink switch interface only.
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                            max_uplink_switches:
                               Maximum number of uplink switches.
                               Changing this value may change IP Addressing on uplinks.
                               Can be
                               used to reserve IP space for future expansions.
                            max_parallel_uplinks:
                               Number of parallel links towards uplink switches.
                               Changing this value may change interface naming on
                               uplinks (and corresponding downlinks).
                               Can be used to reserve interfaces for future parallel
                               uplinks.
                            uplink_bfd: Enable bfd on uplink interfaces.
                            uplink_native_vlan:
                               Only applicable to switches with layer-2 port-channel uplinks.
                               A suspended (disabled) vlan will be
                               created in both ends of the link unless the vlan is defined under network services.
                               By default the
                               uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                            uplink_ptp: Enable PTP on all infrastructure links.
                            uplink_macsec: Enable MacSec on all uplinks.
                            uplink_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink Port-channel
                               ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                               For
                               example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [ Eth11/1, Eth22/1 ] -> ID 111
                               For
                               MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                               This
                               option overrides the default behavior and statically sets the local Port-channel ID.
                               Note! Make sure
                               the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                               value.
                            uplink_switch_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink switch Port-
                               channel ID will be set to the number of the first interface defined under
                               `uplink_switch_interfaces`.
                               For example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [
                               Eth11/1, Eth22/1 ] -> ID 111
                               For MLAG port-channels ID will be based on the lowest member interface
                               on the first MLAG switch.
                               This option overrides the default behavior and statically sets the Port-
                               channel ID on the uplink switch.
                               Note! Make sure the ID is unique and does not overlap with
                               autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between
                               1 and 2000 and both MLAG switches must have the same value.
                            uplink_structured_config:
                               Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                               When
                               uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                               for eos_cli_config_gen overrides the settings on the ethernet interface level.
                               When uplink_type ==
                               "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                               eos_cli_config_gen overrides the settings on the port-channel interface level.
                               "uplink_structured_config" is applied after "structured_config", so it can override
                               "structured_config" defined on node-level.
                               Note! The content of this dictionary is _not_ validated
                               by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                            mlag_port_channel_structured_config:
                               Custom structured config applied to MLAG peer link port-channel id.
                               Added under
                               port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the
                               port-channel interface level.
                               "mlag_port_channel_structured_config" is applied after
                               "structured_config", so it can override "structured_config" defined on node-level.
                            mlag_peer_vlan_structured_config:
                               Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                               override "structured_config" defined on node-level.
                            mlag_peer_l3_vlan_structured_config:
                               Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                               can override "structured_config" defined on node-level.
                            short_esi:
                               short_esi only valid for l2leaf devices using port-channel uplink.
                               Setting short_esi to "auto"
                               generates the short_esi automatically using a hash of configuration elements.
                               < 0000:0000:0000 |
                               auto >.
                            isis_system_id_prefix: (4.4 hexadecimal).
                            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                            is_type: is_type
                            node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                            loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                            loopback_ipv4_address:
                               IPv4 address without mask for Loopback0.
                               When set, it takes precedence over `loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                            vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                            vtep_loopback_ipv4_address:
                               IPv4 address without mask for VTEP-Loopback.
                               When set, it takes precedence over
                               `vtep_loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not
                               catch duplicates.
                            loopback_ipv4_offset:
                               Offset all assigned loopback IP addresses.
                               Required when the < loopback_ipv4_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                            loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                            loopback_ipv6_offset:
                               Offset all assigned loopback IPv6 addresses.
                               Required when the < loopback_ipv6_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid overlapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                            vtep:
                               Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                               Overrides VTEP
                               setting inherited from node_type_keys.
                            vtep_loopback: Set VXLAN source interface.
                            bgp_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                               Required with eBGP.
                            bgp_defaults: List of EOS commands to apply to BGP daemon.
                            evpn_role:
                               Acting role in EVPN control plane.
                               Default is set in node_type definition from node_type_keys.
                            evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                            evpn_services_l2_only:
                               Possibility to prevent configuration of Tenant VRFs and SVIs.
                               Override node definition
                               "network_services_l3" from node_type_keys.
                               This allows support for centralized routing.
                            filter:
                               Filter L3 and L2 network services based on tenant and tags (and operation filter).
                               If filter is not
                               defined it will default to all.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                            evpn_gateway:
                               Node is acting as EVPN Multi-Domain Gateway.
                               New BGP peer-group is generated between EVPN GWs in
                               different domains or between GWs and Route Servers.
                               Name can be changed under
                               "bgp_peer_groups.evpn_overlay_core" variable.
                               L3 rechability for different EVPN GWs must be already
                               in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                               same Ansible inventory.
                            ipvpn_gateway:
                               Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                               this is "bgp_peer_groups.ipvpn_gateway_peers".
                               L3 Reachability is required for this to work, the
                               preferred method to establish underlay connectivity is to use core_interfaces.
                            mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                            mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                            mlag_ibgp_origin_incomplete:
                               Set origin of routes received from MLAG iBGP peer to incomplete.
                               The purpose is to optimize routing
                               for leaf loopbacks from spine perspective and
                               avoid suboptimal routing via peerlink for control
                               plane traffic.
                            mlag_interfaces:
                               Each list item supports range syntax that can be expanded into a list of interfaces.
                               Required when
                               MLAG leafs are present in the topology.
                            mlag_interfaces_speed:
                               Set MLAG interface speed.
                               Speed should be set in the format `<interface_speed>` or `forced
                               <interface_speed>` or `auto <interface_speed>`.
                            mlag_peer_l3_vlan:
                               Underlay L3 peering SVI interface id.
                               If set to 0 or the same vlan as mlag_peer_vlan, the
                               mlag_peer_vlan will be used for L3 peering.
                            mlag_peer_l3_ipv4_pool:
                               IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                               Required when
                               MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                            mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                            mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                            mlag_peer_address_family:
                               IP address family used to establish MLAG Peer Link (control link).
                               `ipv6` requires EOS version
                               4.31.1F or higher.
                               Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                               (ex. `mlag_peer_l3_vlan` set to 4094).
                            mlag_peer_ipv4_pool:
                               IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                            mlag_peer_ipv6_pool:
                               IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                            mlag_port_channel_id:
                               If not set, the mlag port-channel id is generated based on the digits of the first interface present
                               in 'mlag_interfaces'.
                               Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                               999999 > for EOS >= 4.25.0F.
                            mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                            spanning_tree_mode: spanning_tree_mode
                            spanning_tree_priority:
                               Spanning-tree priority configured for the selected mode.
                               For `rapid-pvst` the priority can also be
                               set per VLAN under network services.
                            spanning_tree_root_super: spanning_tree_root_super
                            virtual_router_mac_address: Virtual router mac address for anycast gateway.
                            inband_mgmt_interface:
                               Pointer to interface used for inband management.
                               All configuration must be done using other data
                               models like network services or structured_config.
                               'inband_mgmt_interface' is only used to refer to
                               this interface as source in various management protocol settings (future feature).

                               On L2 switches,
                               this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                            inband_mgmt_vlan:
                               VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                               uplinks).
                               When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                               switch as well as all 'uplink_switches'.
                               When using 'inband_mgmt_ip' the VLAN and SVI will only be
                               created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                               created using network services data models.
                            inband_mgmt_subnet:
                               Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                               ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      : <subnet> +
                               2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       :
                               <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than total l2leafs + 5
                               Setting is ignored if 'inband_mgmt_ip' is set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ip:
                               IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                               If this is set the
                               VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN and SVI on
                               the parent switches must be created using network services data models.

                               This setting is applicable
                               to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                               is derived from 'inband_mgmt_subnet' if set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_address:
                               IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                               If this
                               is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN
                               and SVI on the parent switches must be created using network services data models.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_subnet:
                               Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                               on ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                               extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      :
                               <subnet> + 2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       : <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than
                               total l2leafs + 5

                               Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf'.
                               Used when `inband_mgmt_ipv6_address` is set.
                               Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_description:
                               Description configured on the Inband Management SVI.

                               This setting is only applied on the devices
                               where it is set, it does not automatically affect any parent/child devices configuration, so it must
                               be set on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vlan_name:
                               Name configured on the Inband Management VLAN.
                               This setting is only applied on the devices where it
                               is set, it does not automatically affect any parent/child devices configuration, so it must be set
                               on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vrf:
                               VRF configured on the Inband Management Interface.
                               The VRF is created if not already created by
                               other means.
                               This setting is only applied on the devices where it is set, it does not automatically
                               affect any parent/child devices configuration, so it must be set on each applicable node/node-
                               group/node-type as needed.
                            inband_mgmt_mtu:
                               MTU configured on the Inband Management Interface.
                               This setting is only applied on the devices where
                               it is set, it does not automatically affect any parent/child devices configuration, so it must be
                               set on each applicable node/node-group/node-type as needed.
                            inband_ztp:
                               Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                               inband.
                               This setting also requires that the `inband_mgmt_vlan` is set for the node.
                            inband_ztp_lacp_fallback_delay:
                               Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                               ZTP node.
                               This setting also requires that `inband_ztp` is set for the node.
                            mpls_overlay_role:
                               Set the default mpls overlay role.
                               Acting role in overlay control plane.
                            overlay_address_families: Set the default overlay address families.
                            mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                            bgp_cluster_id: Set BGP cluster id.
                            ptp: ptp
                            wan_role:
                               Override the default WAN role.

                               This is used both for AutoVPN and Pathfinder designs.
                               That means if
                               `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                               `server` indicates that the
                               router is a route-reflector.

                               Only supported if `overlay_routing_protocol` is set to `ibgp`.
                            cv_pathfinder_transit_mode:
                               Configure the transit mode for a WAN client for CV Pathfinder designs
                               only when the `wan_mode` root
                               key is set to `cv_pathfinder`.

                               'zone' is currently not supported.
                            cv_pathfinder_region:
                               The CV Pathfinder region name.
                               This key is required for WAN routers but optional for pathfinders.
                               The region name must be defined under 'cv_pathfinder_regions'.
                            cv_pathfinder_site:
                               The CV Pathfinder site name.
                               This key is required for WAN routers but optional for pathfinders.
                               For
                               WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                               relevant region under 'cv_pathfinder_regions'.
                               For pathfinders without `cv_pathfinder_region` set,
                               the site must be defined under `cv_pathfinder_global_sites`.
                            wan_ha:
                               PREVIEW: This key is currently not supported

                               The key is supported only if `wan_mode` == `cv-
                               pathfinder`.
                               AutoVPN support is still to be determined.

                               Maximum 2 devices supported by group for
                               HA.
                            dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                            l3_interfaces:
                               L3 Interfaces to configure on the node.
                               Used to define the node for WAN interfaces when
                               `wan_carrier` is set.
                            data_plane_cpu_allocation_max:
                               Set the maximum number of CPU used for the data plane.
                               This setting is useful on virtual Route
                               Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                            flow_tracker_type:
                               Set the flow tracker type.
                               Override the `default_flow_tracker_type`` set at the `node_type_key`
                               level.
                               `default_flow_tracker_type` default value is `sampled`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodeGroupsItem(AvdModel):
                    class NodesItem(AvdModel):
                        class DownlinkPoolsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "ipv4_pool": {"type": str},
                                "downlink_interfaces": {"type": list, "items": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            ipv4_pool: str | None
                            """IPv4 pool from which subnets will be allocated for links to downlink switches."""
                            downlink_interfaces: list[str]
                            """
                            List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                            this list will determine which subnet will be taken from the pool.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ipv4_pool: str | None | UndefinedType = Undefined,
                                downlink_interfaces: list[str] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DownlinkPoolsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    ipv4_pool: IPv4 pool from which subnets will be allocated for links to downlink switches.
                                    downlink_interfaces:
                                       List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                                       this list will determine which subnet will be taken from the pool.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class LinkTracking(AvdModel):
                            class GroupsItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "name": {"type": str},
                                    "recovery_delay": {"type": int},
                                    "links_minimum": {"type": int},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                name: str | None
                                """Tracking group name."""
                                recovery_delay: int | None
                                """default -> platform_settings_mlag_reload_delay -> 300."""
                                links_minimum: int | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                    recovery_delay: int | None | UndefinedType = Undefined,
                                    links_minimum: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    GroupsItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Tracking group name.
                                        recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                        links_minimum: links_minimum

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "groups": {
                                    "type": list,
                                    "items": GroupsItem,
                                    "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                                },
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            groups: list[GroupsItem]
                            """
                            Link Tracking Groups.
                            By default a single group named "LT_GROUP1" is defined with default values.
                            Any groups defined under "groups" will replace the default.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                groups: list[GroupsItem] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LinkTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    groups:
                                       Link Tracking Groups.
                                       By default a single group named "LT_GROUP1" is defined with default values.
                                       Any groups defined under "groups" will replace the default.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class LacpPortIdRange(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "size": {"type": int, "default": 128},
                                "offset": {"type": int, "default": 0},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            size: int | None
                            """Recommended size > = number of ports in the switch."""
                            offset: int | None
                            """
                            Offset is used to avoid overlapping port-id ranges of different switches.
                            Useful when a "connected-
                            endpoint" is connected to switches in different "node_groups".
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                size: int | None | UndefinedType = Undefined,
                                offset: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LacpPortIdRange.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    size: Recommended size > = number of ports in the switch.
                                    offset:
                                       Offset is used to avoid overlapping port-id ranges of different switches.
                                       Useful when a "connected-
                                       endpoint" is connected to switches in different "node_groups".

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen):
                            pass

                        class UplinkPtp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enable: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                UplinkPtp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enable: enable

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class UplinkMacsec(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            profile: str | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                UplinkMacsec.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    profile: profile

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                            pass

                        class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                            pass

                        class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                            pass

                        class Filter(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "tenants": {"type": list, "items": str, "default": ["all"]},
                                "tags": {"type": list, "items": str, "default": ["all"]},
                                "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                                "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                                "always_include_vrfs_in_tenants": {"type": list, "items": str},
                                "only_vlans_in_use": {"type": bool, "default": False},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            tenants: list[str]
                            """
                            Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                            Tenants (default).
                            This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                            """
                            tags: list[str]
                            """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                            allow_vrfs: list[str]
                            """
                            Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                            (default).
                            This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                            """
                            deny_vrfs: list[str]
                            """
                            Prevent configuration of Network Services defined under these VRFs.
                            This list prevents the given
                            VRFs to be included by any other filtering mechanism.
                            """
                            always_include_vrfs_in_tenants: list[str]
                            """
                            List of tenants where VRFs will be configured even if VLANs are not included in tags.
                            Useful for L3
                            "border" leaf.
                            """
                            only_vlans_in_use: bool | None
                            """
                            Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                            Note! This
                            feature only considers configuration managed by eos_designs.
                            This excludes structured_config,
                            custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                tenants: list[str] | UndefinedType = Undefined,
                                tags: list[str] | UndefinedType = Undefined,
                                allow_vrfs: list[str] | UndefinedType = Undefined,
                                deny_vrfs: list[str] | UndefinedType = Undefined,
                                always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                                only_vlans_in_use: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Filter.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    tenants:
                                       Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                       Tenants (default).
                                       This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                    tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                    allow_vrfs:
                                       Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                       (default).
                                       This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                    deny_vrfs:
                                       Prevent configuration of Network Services defined under these VRFs.
                                       This list prevents the given
                                       VRFs to be included by any other filtering mechanism.
                                    always_include_vrfs_in_tenants:
                                       List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                       Useful for L3
                                       "border" leaf.
                                    only_vlans_in_use:
                                       Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                       Note! This
                                       feature only considers configuration managed by eos_designs.
                                       This excludes structured_config,
                                       custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnGateway(AvdModel):
                            class RemotePeersItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "hostname": {"type": str},
                                    "ip_address": {"type": str},
                                    "bgp_as": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                hostname: str | None
                                """Hostname of remote EVPN GW server."""
                                ip_address: str | None
                                """Peering IP of remote Route Server."""
                                bgp_as: str | None
                                """
                                Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                interpreted as a float number.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    hostname: str | None | UndefinedType = Undefined,
                                    ip_address: str | None | UndefinedType = Undefined,
                                    bgp_as: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    RemotePeersItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        hostname: Hostname of remote EVPN GW server.
                                        ip_address: Peering IP of remote Route Server.
                                        bgp_as:
                                           Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                           For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                           interpreted as a float number.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class EvpnL2(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    EvpnL2.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class EvpnL3(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool, "default": False},
                                    "inter_domain": {"type": bool, "default": True},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                inter_domain: bool | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    inter_domain: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    EvpnL3.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        inter_domain: inter_domain

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "remote_peers": {"type": list, "items": RemotePeersItem},
                                "evpn_l2": {"type": EvpnL2},
                                "evpn_l3": {"type": EvpnL3},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            remote_peers: list[RemotePeersItem]
                            """
                            Define remote peers of the EVPN VXLAN Gateway.
                            If the hostname can be found in the inventory,
                            ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                            If the
                            peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                            """
                            evpn_l2: EvpnL2
                            """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                            evpn_l3: EvpnL3
                            """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                                evpn_l2: EvpnL2 | UndefinedType = Undefined,
                                evpn_l3: EvpnL3 | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnGateway.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    remote_peers:
                                       Define remote peers of the EVPN VXLAN Gateway.
                                       If the hostname can be found in the inventory,
                                       ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                       If the
                                       peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                    evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                    evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class IpvpnGateway(AvdModel):
                            class RemotePeersItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "hostname": {"type": str},
                                    "ip_address": {"type": str},
                                    "bgp_as": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                                _custom_data: dict[str, Any]
                                hostname: str
                                """Hostname of remote IPVPN Peer."""
                                ip_address: str
                                """Peering IP of remote IPVPN Peer."""
                                bgp_as: str
                                """
                                Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                For
                                asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                as a float number.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    hostname: str | UndefinedType = Undefined,
                                    ip_address: str | UndefinedType = Undefined,
                                    bgp_as: str | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    RemotePeersItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        hostname: Hostname of remote IPVPN Peer.
                                        ip_address: Peering IP of remote IPVPN Peer.
                                        bgp_as:
                                           Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                           For
                                           asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                           as a float number.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "evpn_domain_id": {"type": str, "default": "65535:1"},
                                "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                                "enable_d_path": {"type": bool, "default": True},
                                "maximum_routes": {"type": int, "default": 0},
                                "local_as": {"type": str, "default": "none"},
                                "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                                "remote_peers": {"type": list, "items": RemotePeersItem},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            evpn_domain_id: str | None
                            """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                            ipvpn_domain_id: str | None
                            """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                            enable_d_path: bool | None
                            """Enable D-path for use with BGP bestpath selection algorithm."""
                            maximum_routes: int | None
                            """Maximum routes to accept from IPVPN remote peers."""
                            local_as: str | None
                            """
                            Local BGP AS applied to peering with IPVPN remote peers.
                            BGP AS <1-4294967295> or AS number in asdot
                            notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes,
                            to prevent it from being interpreted as a float number.
                            """
                            address_families: list[str]
                            """IPVPN address families to enable for remote peers."""
                            remote_peers: list[RemotePeersItem]

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                evpn_domain_id: str | None | UndefinedType = Undefined,
                                ipvpn_domain_id: str | None | UndefinedType = Undefined,
                                enable_d_path: bool | None | UndefinedType = Undefined,
                                maximum_routes: int | None | UndefinedType = Undefined,
                                local_as: str | None | UndefinedType = Undefined,
                                address_families: list[str] | UndefinedType = Undefined,
                                remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                IpvpnGateway.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                    ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                    enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                    maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                    local_as:
                                       Local BGP AS applied to peering with IPVPN remote peers.
                                       BGP AS <1-4294967295> or AS number in asdot
                                       notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes,
                                       to prevent it from being interpreted as a float number.
                                    address_families: IPVPN address families to enable for remote peers.
                                    remote_peers: remote_peers

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Ptp(AvdModel):
                            class Dscp(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                general_messages: int | None
                                event_messages: int | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    general_messages: int | None | UndefinedType = Undefined,
                                    event_messages: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Dscp.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        general_messages: general_messages
                                        event_messages: event_messages

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Monitor(AvdModel):
                                class Threshold(AvdModel):
                                    class Drop(AvdModel):
                                        _fields: ClassVar[dict] = {
                                            "_custom_data": {"type": dict},
                                            "offset_from_master": {"type": int},
                                            "mean_path_delay": {"type": int},
                                        }
                                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                                        _custom_data: dict[str, Any]
                                        offset_from_master: int | None
                                        mean_path_delay: int | None

                                        def __init__(
                                            self,
                                            *,
                                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                            offset_from_master: int | None | UndefinedType = Undefined,
                                            mean_path_delay: int | None | UndefinedType = Undefined,
                                        ) -> None:
                                            """
                                            Drop.

                                            Args:
                                            -----
                                                _custom_data: _custom_data
                                                offset_from_master: offset_from_master
                                                mean_path_delay: mean_path_delay

                                            """
                                            for arg, arg_value in locals().items():
                                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                                    continue
                                                setattr(self, arg, arg_value)

                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int, "default": 250},
                                        "mean_path_delay": {"type": int, "default": 1500},
                                        "drop": {"type": Drop},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None
                                    drop: Drop

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                        drop: Drop | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Threshold.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay
                                            drop: drop

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class MissingMessage(AvdModel):
                                    class Intervals(AvdModel):
                                        _fields: ClassVar[dict] = {
                                            "_custom_data": {"type": dict},
                                            "announce": {"type": int},
                                            "follow_up": {"type": int},
                                            "sync": {"type": int},
                                        }
                                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                                        _custom_data: dict[str, Any]
                                        announce: int | None
                                        follow_up: int | None
                                        sync: int | None

                                        def __init__(
                                            self,
                                            *,
                                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                            announce: int | None | UndefinedType = Undefined,
                                            follow_up: int | None | UndefinedType = Undefined,
                                            sync: int | None | UndefinedType = Undefined,
                                        ) -> None:
                                            """
                                            Intervals.

                                            Args:
                                            -----
                                                _custom_data: _custom_data
                                                announce: announce
                                                follow_up: follow_up
                                                sync: sync

                                            """
                                            for arg, arg_value in locals().items():
                                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                                    continue
                                                setattr(self, arg, arg_value)

                                    class SequenceIds(AvdModel):
                                        _fields: ClassVar[dict] = {
                                            "_custom_data": {"type": dict},
                                            "enabled": {"type": bool, "default": True},
                                            "announce": {"type": int, "default": 3},
                                            "delay_resp": {"type": int, "default": 3},
                                            "follow_up": {"type": int, "default": 3},
                                            "sync": {"type": int, "default": 3},
                                        }
                                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                                        _custom_data: dict[str, Any]
                                        enabled: bool | None
                                        announce: int | None
                                        delay_resp: int | None
                                        follow_up: int | None
                                        sync: int | None

                                        def __init__(
                                            self,
                                            *,
                                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                            enabled: bool | None | UndefinedType = Undefined,
                                            announce: int | None | UndefinedType = Undefined,
                                            delay_resp: int | None | UndefinedType = Undefined,
                                            follow_up: int | None | UndefinedType = Undefined,
                                            sync: int | None | UndefinedType = Undefined,
                                        ) -> None:
                                            """
                                            SequenceIds.

                                            Args:
                                            -----
                                                _custom_data: _custom_data
                                                enabled: enabled
                                                announce: announce
                                                delay_resp: delay_resp
                                                follow_up: follow_up
                                                sync: sync

                                            """
                                            for arg, arg_value in locals().items():
                                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                                    continue
                                                setattr(self, arg, arg_value)

                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "intervals": {"type": Intervals},
                                        "sequence_ids": {"type": SequenceIds},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    intervals: Intervals
                                    sequence_ids: SequenceIds

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        intervals: Intervals | UndefinedType = Undefined,
                                        sequence_ids: SequenceIds | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        MissingMessage.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            intervals: intervals
                                            sequence_ids: sequence_ids

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool, "default": True},
                                    "threshold": {"type": Threshold},
                                    "missing_message": {"type": MissingMessage},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                threshold: Threshold
                                missing_message: MissingMessage

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    threshold: Threshold | UndefinedType = Undefined,
                                    missing_message: MissingMessage | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Monitor.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        threshold: threshold
                                        missing_message: missing_message

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "profile": {"type": str, "default": "aes67-r16-2016"},
                                "mlag": {"type": bool, "default": False},
                                "domain": {"type": int, "default": 127},
                                "priority1": {"type": int},
                                "priority2": {"type": int},
                                "auto_clock_identity": {"type": bool, "default": True},
                                "clock_identity_prefix": {"type": str},
                                "clock_identity": {"type": str},
                                "source_ip": {"type": str},
                                "mode": {"type": str, "default": "boundary"},
                                "mode_one_step": {"type": bool, "default": False},
                                "ttl": {"type": int},
                                "forward_unicast": {"type": bool, "default": False},
                                "dscp": {"type": Dscp},
                                "monitor": {"type": Monitor},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            profile: str | None
                            """
                            Default available profiles are:
                              - "aes67"
                              - "aes67-r16-2016"
                              - "smpte2059-2"
                            """
                            mlag: bool | None
                            """
                            Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                            configured on the MLAG peer-link port-channel.
                            """
                            domain: int | None
                            priority1: int | None
                            """default -> automatically set based on node_type."""
                            priority2: int | None
                            """default -> (node_id modulus 256)."""
                            auto_clock_identity: bool | None
                            """
                            If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                            default EOS behaviour, simply disable the automatic PTP clock identity.
                            default ->
                            (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                            HEX).
                            """
                            clock_identity_prefix: str | None
                            """
                            PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                            By default the 3-byte prefix is "00:1C:73".
                            This
                            can be overridden if auto_clock_identity is set to true (which is the default).
                            """
                            clock_identity: str | None
                            """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                            source_ip: str | None
                            """
                            By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                            relevant SVI, which is the recommended behaviour.
                            This can be set manually if required, for example,
                            to a value of "10.1.2.3".
                            """
                            mode: str | None
                            mode_one_step: bool | None
                            ttl: int | None
                            forward_unicast: bool | None
                            """Enable PTP unicast forwarding."""
                            dscp: Dscp
                            monitor: Monitor

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                profile: str | None | UndefinedType = Undefined,
                                mlag: bool | None | UndefinedType = Undefined,
                                domain: int | None | UndefinedType = Undefined,
                                priority1: int | None | UndefinedType = Undefined,
                                priority2: int | None | UndefinedType = Undefined,
                                auto_clock_identity: bool | None | UndefinedType = Undefined,
                                clock_identity_prefix: str | None | UndefinedType = Undefined,
                                clock_identity: str | None | UndefinedType = Undefined,
                                source_ip: str | None | UndefinedType = Undefined,
                                mode: str | None | UndefinedType = Undefined,
                                mode_one_step: bool | None | UndefinedType = Undefined,
                                ttl: int | None | UndefinedType = Undefined,
                                forward_unicast: bool | None | UndefinedType = Undefined,
                                dscp: Dscp | UndefinedType = Undefined,
                                monitor: Monitor | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ptp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    profile:
                                       Default available profiles are:
                                         - "aes67"
                                         - "aes67-r16-2016"
                                         - "smpte2059-2"
                                    mlag:
                                       Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                       configured on the MLAG peer-link port-channel.
                                    domain: domain
                                    priority1: default -> automatically set based on node_type.
                                    priority2: default -> (node_id modulus 256).
                                    auto_clock_identity:
                                       If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                       default EOS behaviour, simply disable the automatic PTP clock identity.
                                       default ->
                                       (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                       HEX).
                                    clock_identity_prefix:
                                       PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                       By default the 3-byte prefix is "00:1C:73".
                                       This
                                       can be overridden if auto_clock_identity is set to true (which is the default).
                                    clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                    source_ip:
                                       By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                       relevant SVI, which is the recommended behaviour.
                                       This can be set manually if required, for example,
                                       to a value of "10.1.2.3".
                                    mode: mode
                                    mode_one_step: mode_one_step
                                    ttl: ttl
                                    forward_unicast: Enable PTP unicast forwarding.
                                    dscp: dscp
                                    monitor: monitor

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class WanHa(AvdModel):
                            class FlowTracking(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                name: str | None
                                """Flow tracker name as defined in flow_tracking_settings."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    FlowTracking.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        name: Flow tracker name as defined in flow_tracking_settings.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "ipsec": {"type": bool, "default": True},
                                "mtu": {"type": int, "default": 9194},
                                "ha_interfaces": {"type": list, "items": str},
                                "ha_ipv4_pool": {"type": str},
                                "max_ha_interfaces": {"type": int},
                                "port_channel_id": {"type": int},
                                "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                                "flow_tracking": {"type": FlowTracking},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                            ipsec: bool | None
                            """Enable / Disable IPsec over HA path-group when HA is enabled."""
                            mtu: int | None
                            """Set MTU on WAN HA interfaces."""
                            ha_interfaces: list[str]
                            """
                            Local WAN HA interfaces
                            Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                            Can be used to filter uplink interfaces when there are multiple uplinks.
                            Limitations:
                              Either all
                            interfaces must be uplinks or all interfaces must not be uplinks.
                              Only one interface is supported
                            for non uplinks.
                            """
                            ha_ipv4_pool: str | None
                            """
                            IP address pool used for WAN HA connectivity.
                            IP is derived from the node ID.
                            Not used for uplink
                            interfaces.
                            """
                            max_ha_interfaces: int | None
                            """
                            Number of parallel links towards HA switches.
                            Can be used to reserve IP addresses for future
                            parallel HA links.
                            """
                            port_channel_id: int | None
                            """Port-channel ID to use for direct HA."""
                            use_port_channel_for_direct_ha: bool | None
                            """
                            Enable or disable using a port-channel interface for direct HA when there is only one interface.
                            This feature was introduced in EOS 4.33.0F.
                            """
                            flow_tracking: FlowTracking
                            """
                            Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                            setting.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                ipsec: bool | None | UndefinedType = Undefined,
                                mtu: int | None | UndefinedType = Undefined,
                                ha_interfaces: list[str] | UndefinedType = Undefined,
                                ha_ipv4_pool: str | None | UndefinedType = Undefined,
                                max_ha_interfaces: int | None | UndefinedType = Undefined,
                                port_channel_id: int | None | UndefinedType = Undefined,
                                use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                                flow_tracking: FlowTracking | UndefinedType = Undefined,
                            ) -> None:
                                """
                                WanHa.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                    ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                    mtu: Set MTU on WAN HA interfaces.
                                    ha_interfaces:
                                       Local WAN HA interfaces
                                       Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                       Can be used to filter uplink interfaces when there are multiple uplinks.
                                       Limitations:
                                         Either all
                                       interfaces must be uplinks or all interfaces must not be uplinks.
                                         Only one interface is supported
                                       for non uplinks.
                                    ha_ipv4_pool:
                                       IP address pool used for WAN HA connectivity.
                                       IP is derived from the node ID.
                                       Not used for uplink
                                       interfaces.
                                    max_ha_interfaces:
                                       Number of parallel links towards HA switches.
                                       Can be used to reserve IP addresses for future
                                       parallel HA links.
                                    port_channel_id: Port-channel ID to use for direct HA.
                                    use_port_channel_for_direct_ha:
                                       Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                       This feature was introduced in EOS 4.33.0F.
                                    flow_tracking:
                                       Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                       setting.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class L3InterfacesItem(AvdModel):
                            class Bgp(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "peer_as": {"type": str},
                                    "ipv4_prefix_list_in": {"type": str},
                                    "ipv4_prefix_list_out": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                                _custom_data: dict[str, Any]
                                peer_as: str
                                """
                                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                For asdot notation in
                                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                number.
                                """
                                ipv4_prefix_list_in: str | None
                                """
                                Prefix List Name. Accept routes for only these prefixes from the peer.
                                Required for wan interfaces.
                                """
                                ipv4_prefix_list_out: str | None
                                """
                                Prefix List Name. Advertise routes for only these prefixes.
                                If not specified, nothing would be
                                advertised.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    peer_as: str | UndefinedType = Undefined,
                                    ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                    ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Bgp.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        peer_as:
                                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                           For asdot notation in
                                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                           number.
                                        ipv4_prefix_list_in:
                                           Prefix List Name. Accept routes for only these prefixes from the peer.
                                           Required for wan interfaces.
                                        ipv4_prefix_list_out:
                                           Prefix List Name. Advertise routes for only these prefixes.
                                           If not specified, nothing would be
                                           advertised.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class StaticRoutesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                                _custom_data: dict[str, Any]
                                prefix: str
                                """IPv4_network/Mask."""

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    StaticRoutesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        prefix: IPv4_network/Mask.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class CvPathfinderInternetExit(AvdModel):
                                class PoliciesItem(AvdModel):
                                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                    _custom_data: dict[str, Any]
                                    name: str
                                    """Internet-exit policy name."""
                                    tunnel_interface_numbers: str | None
                                    """
                                    Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                    interface.
                                    Examples: '1-3' or '100,200,300'
                                    """

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        name: str | UndefinedType = Undefined,
                                        tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        PoliciesItem.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            name: Internet-exit policy name.
                                            tunnel_interface_numbers:
                                               Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                               interface.
                                               Examples: '1-3' or '100,200,300'

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class Policies(AvdCollection[str, PoliciesItem]):
                                    _primary_key: ClassVar[str] = "name"

                                Policies._item_type = PoliciesItem

                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                policies: Policies
                                """List of Internet-exit policies using this interface as exit."""

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    CvPathfinderInternetExit.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        policies: List of Internet-exit policies using this interface as exit.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class FlowTracking(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                name: str | None
                                """Flow tracker name as defined in flow_tracking_settings."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    FlowTracking.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        name: Flow tracker name as defined in flow_tracking_settings.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                                pass

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "profile": {"type": str},
                                "name": {"type": str},
                                "description": {"type": str},
                                "ip_address": {"type": str},
                                "dhcp_ip": {"type": str},
                                "public_ip": {"type": str},
                                "encapsulation_dot1q_vlan": {"type": int},
                                "dhcp_accept_default_route": {"type": bool, "default": True},
                                "enabled": {"type": bool, "default": True},
                                "speed": {"type": str},
                                "peer": {"type": str},
                                "peer_interface": {"type": str},
                                "peer_ip": {"type": str},
                                "bgp": {"type": Bgp},
                                "ipv4_acl_in": {"type": str},
                                "ipv4_acl_out": {"type": str},
                                "static_routes": {"type": list, "items": StaticRoutesItem},
                                "qos_profile": {"type": str},
                                "wan_carrier": {"type": str},
                                "wan_circuit_id": {"type": str},
                                "connected_to_pathfinder": {"type": bool, "default": True},
                                "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                                "raw_eos_cli": {"type": str},
                                "flow_tracking": {"type": FlowTracking},
                                "structured_config": {"type": StructuredConfig},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                            _custom_data: dict[str, Any]
                            profile: str | None
                            """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                            name: str
                            """
                            Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                            For a
                            subinterface, the parent physical interface is automatically created.
                            """
                            description: str | None
                            """
                            Interface description.
                            If not set a default description will be configured with '[<peer>[
                            <peer_interface>]]'.
                            """
                            ip_address: str | None
                            """Node IPv4 address/Mask or 'dhcp'."""
                            dhcp_ip: str | None
                            """
                            When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                            IPv4 address
                            (without mask) to be allocated on the interface if known.
                            This is not rendered in the configuration
                            but can be used for substitution of 'interface_ip' in the Access-list
                            set under `ipv4_acl_in` and
                            `ipv4_acl_out`.
                            """
                            public_ip: str | None
                            """
                            Node IPv4 address (no mask).

                            This is used to get the public IP (if known) when the device is behind
                            NAT.
                            This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                            with the following preference:
                              `wan_route_servers.path_groups.interfaces.ip_address`
                                  ->
                            `l3_interfaces.public_ip`
                                      -> `l3_interfaces.ip_address`

                            The determined Public IP is used
                            by WAN routers when peering with this interface.
                            """
                            encapsulation_dot1q_vlan: int | None
                            """
                            For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                            specified.
                            """
                            dhcp_accept_default_route: bool | None
                            """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                            enabled: bool | None
                            """Enable or Shutdown the interface."""
                            speed: str | None
                            """
                            Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                            <interface_speed>`.
                            """
                            peer: str | None
                            """The peer device name. Used for description and documentation."""
                            peer_interface: str | None
                            """The peer device interface. Used for description and documentation."""
                            peer_ip: str | None
                            """
                            The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                            and `ip` is an IP address.
                            """
                            bgp: Bgp
                            """Enforce IPv4 BGP peering for the peer"""
                            ipv4_acl_in: str | None
                            """
                            Name of the IPv4 access-list to be assigned in the ingress direction.
                            The access-list must be
                            defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                            Required
                            for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                            `wan_carriers`.
                            """
                            ipv4_acl_out: str | None
                            """
                            Name of the IPv4 Access-list to be assigned in the egress direction.
                            The access-list must be defined
                            under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                            """
                            static_routes: list[StaticRoutesItem]
                            """Configure IPv4 static routes pointing to `peer_ip`."""
                            qos_profile: str | None
                            """QOS service profile."""
                            wan_carrier: str | None
                            """
                            The WAN carrier this interface is connected to.
                            This is used to infer the path-groups in which this
                            interface should be configured.
                            Unless the carrier is marked as 'trusted' under `wan_carriers`,
                            `ipv4_acl_in` is also required on all WAN interfaces.
                            """
                            wan_circuit_id: str | None
                            """
                            The WAN circuit ID for this interface.
                            This is not rendered in the configuration but used for WAN
                            designs.
                            """
                            connected_to_pathfinder: bool | None
                            """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit
                            """PREVIEW: This key is in preview mode"""
                            raw_eos_cli: str | None
                            """EOS CLI rendered directly on the interface in the final EOS configuration."""
                            flow_tracking: FlowTracking
                            """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                            structured_config: StructuredConfig
                            """Custom structured config for the Ethernet interface."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                profile: str | None | UndefinedType = Undefined,
                                name: str | UndefinedType = Undefined,
                                description: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                dhcp_ip: str | None | UndefinedType = Undefined,
                                public_ip: str | None | UndefinedType = Undefined,
                                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                                dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                speed: str | None | UndefinedType = Undefined,
                                peer: str | None | UndefinedType = Undefined,
                                peer_interface: str | None | UndefinedType = Undefined,
                                peer_ip: str | None | UndefinedType = Undefined,
                                bgp: Bgp | UndefinedType = Undefined,
                                ipv4_acl_in: str | None | UndefinedType = Undefined,
                                ipv4_acl_out: str | None | UndefinedType = Undefined,
                                static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                                qos_profile: str | None | UndefinedType = Undefined,
                                wan_carrier: str | None | UndefinedType = Undefined,
                                wan_circuit_id: str | None | UndefinedType = Undefined,
                                connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                                cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                                raw_eos_cli: str | None | UndefinedType = Undefined,
                                flow_tracking: FlowTracking | UndefinedType = Undefined,
                                structured_config: StructuredConfig | UndefinedType = Undefined,
                            ) -> None:
                                """
                                L3InterfacesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                    name:
                                       Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                       For a
                                       subinterface, the parent physical interface is automatically created.
                                    description:
                                       Interface description.
                                       If not set a default description will be configured with '[<peer>[
                                       <peer_interface>]]'.
                                    ip_address: Node IPv4 address/Mask or 'dhcp'.
                                    dhcp_ip:
                                       When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                       IPv4 address
                                       (without mask) to be allocated on the interface if known.
                                       This is not rendered in the configuration
                                       but can be used for substitution of 'interface_ip' in the Access-list
                                       set under `ipv4_acl_in` and
                                       `ipv4_acl_out`.
                                    public_ip:
                                       Node IPv4 address (no mask).

                                       This is used to get the public IP (if known) when the device is behind
                                       NAT.
                                       This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                       with the following preference:
                                         `wan_route_servers.path_groups.interfaces.ip_address`
                                             ->
                                       `l3_interfaces.public_ip`
                                                 -> `l3_interfaces.ip_address`

                                       The determined Public IP is used
                                       by WAN routers when peering with this interface.
                                    encapsulation_dot1q_vlan:
                                       For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                       specified.
                                    dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                    enabled: Enable or Shutdown the interface.
                                    speed:
                                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                       <interface_speed>`.
                                    peer: The peer device name. Used for description and documentation.
                                    peer_interface: The peer device interface. Used for description and documentation.
                                    peer_ip:
                                       The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                       and `ip` is an IP address.
                                    bgp: Enforce IPv4 BGP peering for the peer
                                    ipv4_acl_in:
                                       Name of the IPv4 access-list to be assigned in the ingress direction.
                                       The access-list must be
                                       defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                       Required
                                       for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                       `wan_carriers`.
                                    ipv4_acl_out:
                                       Name of the IPv4 Access-list to be assigned in the egress direction.
                                       The access-list must be defined
                                       under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                    static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                    qos_profile: QOS service profile.
                                    wan_carrier:
                                       The WAN carrier this interface is connected to.
                                       This is used to infer the path-groups in which this
                                       interface should be configured.
                                       Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                       `ipv4_acl_in` is also required on all WAN interfaces.
                                    wan_circuit_id:
                                       The WAN circuit ID for this interface.
                                       This is not rendered in the configuration but used for WAN
                                       designs.
                                    connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                    cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                    raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                    flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                    structured_config: Custom structured config for the Ethernet interface.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                            _primary_key: ClassVar[str] = "name"

                        L3Interfaces._item_type = L3InterfacesItem

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "name": {"type": str},
                            "downlink_pools": {"type": list, "items": DownlinkPoolsItem},
                            "id": {"type": int},
                            "platform": {"type": str},
                            "mac_address": {"type": str},
                            "system_mac_address": {"type": str},
                            "serial_number": {"type": str},
                            "rack": {"type": str},
                            "mgmt_ip": {"type": str},
                            "mgmt_gateway": {"type": str},
                            "ipv6_mgmt_ip": {"type": str},
                            "ipv6_mgmt_gateway": {"type": str},
                            "mgmt_interface": {"type": str},
                            "link_tracking": {"type": LinkTracking},
                            "lacp_port_id_range": {"type": LacpPortIdRange},
                            "always_configure_ip_routing": {"type": bool, "default": False},
                            "raw_eos_cli": {"type": str},
                            "structured_config": {"type": StructuredConfig},
                            "uplink_type": {"type": str, "default": "p2p"},
                            "uplink_ipv4_pool": {"type": str},
                            "uplink_interfaces": {"type": list, "items": str},
                            "uplink_switch_interfaces": {"type": list, "items": str},
                            "uplink_switches": {"type": list, "items": str},
                            "uplink_interface_speed": {"type": str},
                            "uplink_switch_interface_speed": {"type": str},
                            "uplink_mtu": {"type": int},
                            "max_uplink_switches": {"type": int},
                            "max_parallel_uplinks": {"type": int},
                            "uplink_bfd": {"type": bool, "default": False},
                            "uplink_native_vlan": {"type": int},
                            "uplink_ptp": {"type": UplinkPtp},
                            "uplink_macsec": {"type": UplinkMacsec},
                            "uplink_port_channel_id": {"type": int},
                            "uplink_switch_port_channel_id": {"type": int},
                            "uplink_structured_config": {"type": dict},
                            "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                            "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                            "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                            "short_esi": {"type": str},
                            "isis_system_id_prefix": {"type": str},
                            "isis_maximum_paths": {"type": int},
                            "is_type": {"type": str, "default": "level-2"},
                            "node_sid_base": {"type": int, "default": 0},
                            "loopback_ipv4_pool": {"type": str},
                            "loopback_ipv4_address": {"type": str},
                            "vtep_loopback_ipv4_pool": {"type": str},
                            "vtep_loopback_ipv4_address": {"type": str},
                            "loopback_ipv4_offset": {"type": int, "default": 0},
                            "loopback_ipv6_pool": {"type": str},
                            "loopback_ipv6_offset": {"type": int, "default": 0},
                            "vtep": {"type": bool},
                            "vtep_loopback": {"type": str},
                            "bgp_as": {"type": str},
                            "bgp_defaults": {"type": list, "items": str},
                            "evpn_role": {"type": str},
                            "evpn_route_servers": {"type": list, "items": str},
                            "evpn_services_l2_only": {"type": bool, "default": False},
                            "filter": {"type": Filter},
                            "igmp_snooping_enabled": {"type": bool, "default": True},
                            "evpn_gateway": {"type": EvpnGateway},
                            "ipvpn_gateway": {"type": IpvpnGateway},
                            "mlag": {"type": bool, "default": True},
                            "mlag_dual_primary_detection": {"type": bool, "default": False},
                            "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                            "mlag_interfaces": {"type": list, "items": str},
                            "mlag_interfaces_speed": {"type": str},
                            "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                            "mlag_peer_l3_ipv4_pool": {"type": str},
                            "mlag_peer_vlan": {"type": int, "default": 4094},
                            "mlag_peer_link_allowed_vlans": {"type": str},
                            "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                            "mlag_peer_ipv4_pool": {"type": str},
                            "mlag_peer_ipv6_pool": {"type": str},
                            "mlag_port_channel_id": {"type": int},
                            "mlag_domain_id": {"type": str},
                            "spanning_tree_mode": {"type": str},
                            "spanning_tree_priority": {"type": int, "default": 32768},
                            "spanning_tree_root_super": {"type": bool, "default": False},
                            "virtual_router_mac_address": {"type": str},
                            "inband_mgmt_interface": {"type": str},
                            "inband_mgmt_vlan": {"type": int, "default": 4092},
                            "inband_mgmt_subnet": {"type": str},
                            "inband_mgmt_ip": {"type": str},
                            "inband_mgmt_gateway": {"type": str},
                            "inband_mgmt_ipv6_address": {"type": str},
                            "inband_mgmt_ipv6_subnet": {"type": str},
                            "inband_mgmt_ipv6_gateway": {"type": str},
                            "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                            "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                            "inband_mgmt_vrf": {"type": str, "default": "default"},
                            "inband_mgmt_mtu": {"type": int, "default": 1500},
                            "inband_ztp": {"type": bool, "default": False},
                            "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                            "mpls_overlay_role": {"type": str},
                            "overlay_address_families": {"type": list, "items": str},
                            "mpls_route_reflectors": {"type": list, "items": str},
                            "bgp_cluster_id": {"type": str},
                            "ptp": {"type": Ptp},
                            "wan_role": {"type": str},
                            "cv_pathfinder_transit_mode": {"type": str},
                            "cv_pathfinder_region": {"type": str},
                            "cv_pathfinder_site": {"type": str},
                            "wan_ha": {"type": WanHa},
                            "dps_mss_ipv4": {"type": str, "default": "auto"},
                            "l3_interfaces": {"type": L3Interfaces},
                            "data_plane_cpu_allocation_max": {"type": int},
                            "flow_tracker_type": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        name: str
                        """The Node Name is used as "hostname"."""
                        downlink_pools: list[DownlinkPoolsItem]
                        """
                        IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                        with `uplink_ipv4_pool` set on the downlink switch.
                        """
                        id: int | None
                        """Unique identifier used for IP addressing and other algorithms."""
                        platform: str | None
                        """Arista platform family."""
                        mac_address: str | None
                        """Leverage to document management interface mac address."""
                        system_mac_address: str | None
                        """
                        System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                        Set to the same MAC address as
                        available in "show version" on the device.
                        "system_mac_address" can also be set directly as a
                        hostvar.
                        If both are set, the setting under node type settings takes precedence.
                        """
                        serial_number: str | None
                        """
                        Set to the Serial Number of the device.
                        Only used for documentation purpose in the fabric
                        documentation and part of the structured_config.
                        "serial_number" can also be set directly as a
                        hostvar.
                        If both are set, the setting under node type settings takes precedence.
                        """
                        rack: str | None
                        """Rack that the switch is located in (only used in snmp_settings location)."""
                        mgmt_ip: str | None
                        """Node management interface IPv4 address."""
                        mgmt_gateway: str | None
                        """
                        This key sets the management gateway for the device. It takes precedence over the global
                        `mgmt_gateway`.
                        """
                        ipv6_mgmt_ip: str | None
                        """Node management interface IPv6 address."""
                        ipv6_mgmt_gateway: str | None
                        """
                        This key sets the ipv6 management gateway for the device. It takes precedence over the global
                        `ipv6_mgmt_gateway`.
                        """
                        mgmt_interface: str | None
                        """
                        Management Interface Name.
                        Default -> platform_management_interface -> mgmt_interface ->
                        "Management1".
                        """
                        link_tracking: LinkTracking
                        """
                        This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                        the upstream interfaces.
                        Useful in EVPN multhoming designs.
                        """
                        lacp_port_id_range: LacpPortIdRange
                        """
                        This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                        number of nodes in the "node_group".
                        Unique LACP port-id ranges are recommended for EVPN Multihoming
                        designs.
                        """
                        always_configure_ip_routing: bool | None
                        """
                        Force configuration of "ip routing" even on L2 devices.
                        Use this to retain behavior of AVD versions
                        below 4.0.0.
                        """
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the root level of the final EOS configuration."""
                        structured_config: StructuredConfig
                        """Custom structured config for eos_cli_config_gen."""
                        uplink_type: str | None
                        """
                        Override the default `uplink_type` set at the `node_type_key` level.
                        `uplink_type` must be "p2p" if
                        `vtep` or `underlay_router` is true for the `node_type_key` definition.
                        """
                        uplink_ipv4_pool: str | None
                        """IPv4 subnet to use to connect to uplink switches."""
                        uplink_interfaces: list[str]
                        """
                        Local uplink interfaces.
                        Each list item supports range syntax that can be expanded into a list of
                        interfaces.
                        If uplink_interfaces is not defined, platform-specific defaults (defined under
                        default_interfaces) will be used instead.
                        Please note that default_interfaces are not defined by
                        default, you should define these yourself.
                        """
                        uplink_switch_interfaces: list[str]
                        """Interfaces located on uplink switches."""
                        uplink_switches: list[str]
                        uplink_interface_speed: str | None
                        """
                        Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                        (Uplink switch
                        interface speed can be overridden with `uplink_switch_interface_speed`).
                        Speed should be set in the
                        format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                        """
                        uplink_switch_interface_speed: str | None
                        """
                        Set point-to-Point interface speed for the uplink switch interface only.
                        Speed should be set in the
                        format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                        """
                        uplink_mtu: int | None
                        """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                        max_uplink_switches: int | None
                        """
                        Maximum number of uplink switches.
                        Changing this value may change IP Addressing on uplinks.
                        Can be
                        used to reserve IP space for future expansions.
                        """
                        max_parallel_uplinks: int | None
                        """
                        Number of parallel links towards uplink switches.
                        Changing this value may change interface naming on
                        uplinks (and corresponding downlinks).
                        Can be used to reserve interfaces for future parallel
                        uplinks.
                        """
                        uplink_bfd: bool | None
                        """Enable bfd on uplink interfaces."""
                        uplink_native_vlan: int | None
                        """
                        Only applicable to switches with layer-2 port-channel uplinks.
                        A suspended (disabled) vlan will be
                        created in both ends of the link unless the vlan is defined under network services.
                        By default the
                        uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                        """
                        uplink_ptp: UplinkPtp
                        """Enable PTP on all infrastructure links."""
                        uplink_macsec: UplinkMacsec
                        """Enable MacSec on all uplinks."""
                        uplink_port_channel_id: int | None
                        """
                        Only applicable for L2 switches with `uplink_type: port-channel`.
                        By default the uplink Port-channel
                        ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                        For
                        example:
                          member ports [ Eth22, Eth23 ] -> ID 22
                          member ports [ Eth11/1, Eth22/1 ] -> ID 111
                        For
                        MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                        This
                        option overrides the default behavior and statically sets the local Port-channel ID.
                        Note! Make sure
                        the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                        Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                        value.
                        """
                        uplink_switch_port_channel_id: int | None
                        """
                        Only applicable for L2 switches with `uplink_type: port-channel`.
                        By default the uplink switch Port-
                        channel ID will be set to the number of the first interface defined under
                        `uplink_switch_interfaces`.
                        For example:
                          member ports [ Eth22, Eth23 ] -> ID 22
                          member ports [
                        Eth11/1, Eth22/1 ] -> ID 111
                        For MLAG port-channels ID will be based on the lowest member interface
                        on the first MLAG switch.
                        This option overrides the default behavior and statically sets the Port-
                        channel ID on the uplink switch.
                        Note! Make sure the ID is unique and does not overlap with
                        autogenerated Port-channel IDs in the Network Services.
                        Note! For MLAG pairs the ID must be between
                        1 and 2000 and both MLAG switches must have the same value.
                        """
                        uplink_structured_config: dict
                        """
                        Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                        When
                        uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                        for eos_cli_config_gen overrides the settings on the ethernet interface level.
                        When uplink_type ==
                        "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                        eos_cli_config_gen overrides the settings on the port-channel interface level.
                        "uplink_structured_config" is applied after "structured_config", so it can override
                        "structured_config" defined on node-level.
                        Note! The content of this dictionary is _not_ validated
                        by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                        """
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                        """
                        Custom structured config applied to MLAG peer link port-channel id.
                        Added under
                        port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                        Overrides the settings on the
                        port-channel interface level.
                        "mlag_port_channel_structured_config" is applied after
                        "structured_config", so it can override "structured_config" defined on node-level.
                        """
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                        """
                        Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                        Added under
                        vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                        Overrides the settings on the vlan
                        interface level.
                        "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                        override "structured_config" defined on node-level.
                        """
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                        """
                        Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                        Added under
                        vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                        Overrides the settings on the vlan
                        interface level.
                        "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                        can override "structured_config" defined on node-level.
                        """
                        short_esi: str | None
                        """
                        short_esi only valid for l2leaf devices using port-channel uplink.
                        Setting short_esi to "auto"
                        generates the short_esi automatically using a hash of configuration elements.
                        < 0000:0000:0000 |
                        auto >.
                        """
                        isis_system_id_prefix: str | None
                        """(4.4 hexadecimal)."""
                        isis_maximum_paths: int | None
                        """Number of path to configure in ECMP for ISIS."""
                        is_type: str | None
                        node_sid_base: int | None
                        """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                        loopback_ipv4_pool: str | None
                        """IPv4 subnet for Loopback0 allocation."""
                        loopback_ipv4_address: str | None
                        """
                        IPv4 address without mask for Loopback0.
                        When set, it takes precedence over `loopback_ipv4_pool`.
                        Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                        """
                        vtep_loopback_ipv4_pool: str | None
                        """IPv4 subnet for VTEP-Loopback allocation."""
                        vtep_loopback_ipv4_address: str | None
                        """
                        IPv4 address without mask for VTEP-Loopback.
                        When set, it takes precedence over
                        `vtep_loopback_ipv4_pool`.
                        Note: AVD does not check for validity of the IPv4 address and does not
                        catch duplicates.
                        """
                        loopback_ipv4_offset: int | None
                        """
                        Offset all assigned loopback IP addresses.
                        Required when the < loopback_ipv4_pool > is same for 2
                        different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                        For example, set the minimum
                        offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                        """
                        loopback_ipv6_pool: str | None
                        """IPv6 subnet for Loopback0 allocation."""
                        loopback_ipv6_offset: int | None
                        """
                        Offset all assigned loopback IPv6 addresses.
                        Required when the < loopback_ipv6_pool > is same for 2
                        different node_types (like spine and l3leaf) to avoid overlapping IPs.
                        For example, set the minimum
                        offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                        """
                        vtep: bool | None
                        """
                        Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                        Overrides VTEP
                        setting inherited from node_type_keys.
                        """
                        vtep_loopback: str | None
                        """Set VXLAN source interface."""
                        bgp_as: str | None
                        """
                        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                        For asdot notation in
                        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                        number.
                        Required with eBGP.
                        """
                        bgp_defaults: list[str]
                        """List of EOS commands to apply to BGP daemon."""
                        evpn_role: str | None
                        """
                        Acting role in EVPN control plane.
                        Default is set in node_type definition from node_type_keys.
                        """
                        evpn_route_servers: list[str]
                        """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                        evpn_services_l2_only: bool | None
                        """
                        Possibility to prevent configuration of Tenant VRFs and SVIs.
                        Override node definition
                        "network_services_l3" from node_type_keys.
                        This allows support for centralized routing.
                        """
                        filter: Filter
                        """
                        Filter L3 and L2 network services based on tenant and tags (and operation filter).
                        If filter is not
                        defined it will default to all.
                        """
                        igmp_snooping_enabled: bool | None
                        """Activate or deactivate IGMP snooping on device level."""
                        evpn_gateway: EvpnGateway
                        """
                        Node is acting as EVPN Multi-Domain Gateway.
                        New BGP peer-group is generated between EVPN GWs in
                        different domains or between GWs and Route Servers.
                        Name can be changed under
                        "bgp_peer_groups.evpn_overlay_core" variable.
                        L3 rechability for different EVPN GWs must be already
                        in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                        same Ansible inventory.
                        """
                        ipvpn_gateway: IpvpnGateway
                        """
                        Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                        this is "bgp_peer_groups.ipvpn_gateway_peers".
                        L3 Reachability is required for this to work, the
                        preferred method to establish underlay connectivity is to use core_interfaces.
                        """
                        mlag: bool | None
                        """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                        mlag_dual_primary_detection: bool | None
                        """Enable / Disable MLAG dual primary detection."""
                        mlag_ibgp_origin_incomplete: bool | None
                        """
                        Set origin of routes received from MLAG iBGP peer to incomplete.
                        The purpose is to optimize routing
                        for leaf loopbacks from spine perspective and
                        avoid suboptimal routing via peerlink for control
                        plane traffic.
                        """
                        mlag_interfaces: list[str]
                        """
                        Each list item supports range syntax that can be expanded into a list of interfaces.
                        Required when
                        MLAG leafs are present in the topology.
                        """
                        mlag_interfaces_speed: str | None
                        """
                        Set MLAG interface speed.
                        Speed should be set in the format `<interface_speed>` or `forced
                        <interface_speed>` or `auto <interface_speed>`.
                        """
                        mlag_peer_l3_vlan: int | None
                        """
                        Underlay L3 peering SVI interface id.
                        If set to 0 or the same vlan as mlag_peer_vlan, the
                        mlag_peer_vlan will be used for L3 peering.
                        """
                        mlag_peer_l3_ipv4_pool: str | None
                        """
                        IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                        Required when
                        MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                        """
                        mlag_peer_vlan: int | None
                        """MLAG Peer Link (control link) SVI interface id."""
                        mlag_peer_link_allowed_vlans: str | None
                        mlag_peer_address_family: str | None
                        """
                        IP address family used to establish MLAG Peer Link (control link).
                        `ipv6` requires EOS version
                        4.31.1F or higher.
                        Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                        (ex. `mlag_peer_l3_vlan` set to 4094).
                        """
                        mlag_peer_ipv4_pool: str | None
                        """
                        IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                        Required
                        for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                        """
                        mlag_peer_ipv6_pool: str | None
                        """
                        IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                        Required
                        for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                        """
                        mlag_port_channel_id: int | None
                        """
                        If not set, the mlag port-channel id is generated based on the digits of the first interface present
                        in 'mlag_interfaces'.
                        Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                        999999 > for EOS >= 4.25.0F.
                        """
                        mlag_domain_id: str | None
                        """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                        spanning_tree_mode: str | None
                        spanning_tree_priority: int | None
                        """
                        Spanning-tree priority configured for the selected mode.
                        For `rapid-pvst` the priority can also be
                        set per VLAN under network services.
                        """
                        spanning_tree_root_super: bool | None
                        virtual_router_mac_address: str | None
                        """Virtual router mac address for anycast gateway."""
                        inband_mgmt_interface: str | None
                        """
                        Pointer to interface used for inband management.
                        All configuration must be done using other data
                        models like network services or structured_config.
                        'inband_mgmt_interface' is only used to refer to
                        this interface as source in various management protocol settings (future feature).

                        On L2 switches,
                        this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                        """
                        inband_mgmt_vlan: int | None
                        """
                        VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                        uplinks).
                        When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                        switch as well as all 'uplink_switches'.
                        When using 'inband_mgmt_ip' the VLAN and SVI will only be
                        created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                        created using network services data models.
                        """
                        inband_mgmt_subnet: str | None
                        """
                        Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                        as uplinks).
                        Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                        ARP.
                        This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                        SVI IP address will be assigned as follows:
                        virtual-router: <subnet> + 1
                        l3leaf A      : <subnet> +
                        2 (same IP on all l3leaf A)
                        l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                        l2leafs       :
                        <subnet> + 3 + <l2leaf id>
                        GW on l2leafs : <subnet> + 1
                        Assign range larger than total l2leafs + 5
                        Setting is ignored if 'inband_mgmt_ip' is set.

                        This setting is applicable to L2 switches (switches
                        using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ip: str | None
                        """
                        IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                        This overrides
                        'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                        If this is set the
                        VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                        The VLAN and SVI on
                        the parent switches must be created using network services data models.

                        This setting is applicable
                        to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_gateway: str | None
                        """
                        Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                        is derived from 'inband_mgmt_subnet' if set.

                        This setting is applicable to L2 switches (switches
                        using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ipv6_address: str | None
                        """
                        IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                        This overrides
                        'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                        If this
                        is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                        The VLAN
                        and SVI on the parent switches must be created using network services data models.

                        This setting is
                        applicable to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ipv6_subnet: str | None
                        """
                        Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                        as uplinks).
                        Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                        on ARP.
                        This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                        extension.
                        SVI IP address will be assigned as follows:
                        virtual-router: <subnet> + 1
                        l3leaf A      :
                        <subnet> + 2 (same IP on all l3leaf A)
                        l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                        l2leafs       : <subnet> + 3 + <l2leaf id>
                        GW on l2leafs : <subnet> + 1
                        Assign range larger than
                        total l2leafs + 5

                        Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                        This setting is
                        applicable to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ipv6_gateway: str | None
                        """
                        Default gateway configured in the 'inband_mgmt_vrf'.
                        Used when `inband_mgmt_ipv6_address` is set.
                        Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                        This setting is
                        applicable to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_description: str | None
                        """
                        Description configured on the Inband Management SVI.

                        This setting is only applied on the devices
                        where it is set, it does not automatically affect any parent/child devices configuration, so it must
                        be set on each applicable node/node-group/node-type as needed.
                        """
                        inband_mgmt_vlan_name: str | None
                        """
                        Name configured on the Inband Management VLAN.
                        This setting is only applied on the devices where it
                        is set, it does not automatically affect any parent/child devices configuration, so it must be set
                        on each applicable node/node-group/node-type as needed.
                        """
                        inband_mgmt_vrf: str | None
                        """
                        VRF configured on the Inband Management Interface.
                        The VRF is created if not already created by
                        other means.
                        This setting is only applied on the devices where it is set, it does not automatically
                        affect any parent/child devices configuration, so it must be set on each applicable node/node-
                        group/node-type as needed.
                        """
                        inband_mgmt_mtu: int | None
                        """
                        MTU configured on the Inband Management Interface.
                        This setting is only applied on the devices where
                        it is set, it does not automatically affect any parent/child devices configuration, so it must be
                        set on each applicable node/node-group/node-type as needed.
                        """
                        inband_ztp: bool | None
                        """
                        Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                        inband.
                        This setting also requires that the `inband_mgmt_vlan` is set for the node.
                        """
                        inband_ztp_lacp_fallback_delay: int | None
                        """
                        Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                        ZTP node.
                        This setting also requires that `inband_ztp` is set for the node.
                        """
                        mpls_overlay_role: str | None
                        """
                        Set the default mpls overlay role.
                        Acting role in overlay control plane.
                        """
                        overlay_address_families: list[str]
                        """Set the default overlay address families."""
                        mpls_route_reflectors: list[str]
                        """List of inventory hostname acting as MPLS route-reflectors."""
                        bgp_cluster_id: str | None
                        """Set BGP cluster id."""
                        ptp: Ptp
                        wan_role: str | None
                        """
                        Override the default WAN role.

                        This is used both for AutoVPN and Pathfinder designs.
                        That means if
                        `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                        `server` indicates that the
                        router is a route-reflector.

                        Only supported if `overlay_routing_protocol` is set to `ibgp`.
                        """
                        cv_pathfinder_transit_mode: str | None
                        """
                        Configure the transit mode for a WAN client for CV Pathfinder designs
                        only when the `wan_mode` root
                        key is set to `cv_pathfinder`.

                        'zone' is currently not supported.
                        """
                        cv_pathfinder_region: str | None
                        """
                        The CV Pathfinder region name.
                        This key is required for WAN routers but optional for pathfinders.
                        The region name must be defined under 'cv_pathfinder_regions'.
                        """
                        cv_pathfinder_site: str | None
                        """
                        The CV Pathfinder site name.
                        This key is required for WAN routers but optional for pathfinders.
                        For
                        WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                        relevant region under 'cv_pathfinder_regions'.
                        For pathfinders without `cv_pathfinder_region` set,
                        the site must be defined under `cv_pathfinder_global_sites`.
                        """
                        wan_ha: WanHa
                        """
                        PREVIEW: This key is currently not supported

                        The key is supported only if `wan_mode` == `cv-
                        pathfinder`.
                        AutoVPN support is still to be determined.

                        Maximum 2 devices supported by group for
                        HA.
                        """
                        dps_mss_ipv4: str | None
                        """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                        l3_interfaces: L3Interfaces
                        """
                        L3 Interfaces to configure on the node.
                        Used to define the node for WAN interfaces when
                        `wan_carrier` is set.
                        """
                        data_plane_cpu_allocation_max: int | None
                        """
                        Set the maximum number of CPU used for the data plane.
                        This setting is useful on virtual Route
                        Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                        """
                        flow_tracker_type: str | None
                        """
                        Set the flow tracker type.
                        Override the `default_flow_tracker_type`` set at the `node_type_key`
                        level.
                        `default_flow_tracker_type` default value is `sampled`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            downlink_pools: list[DownlinkPoolsItem] | UndefinedType = Undefined,
                            id: int | None | UndefinedType = Undefined,
                            platform: str | None | UndefinedType = Undefined,
                            mac_address: str | None | UndefinedType = Undefined,
                            system_mac_address: str | None | UndefinedType = Undefined,
                            serial_number: str | None | UndefinedType = Undefined,
                            rack: str | None | UndefinedType = Undefined,
                            mgmt_ip: str | None | UndefinedType = Undefined,
                            mgmt_gateway: str | None | UndefinedType = Undefined,
                            ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                            ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                            mgmt_interface: str | None | UndefinedType = Undefined,
                            link_tracking: LinkTracking | UndefinedType = Undefined,
                            lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                            always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                            uplink_type: str | None | UndefinedType = Undefined,
                            uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                            uplink_interfaces: list[str] | UndefinedType = Undefined,
                            uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                            uplink_switches: list[str] | UndefinedType = Undefined,
                            uplink_interface_speed: str | None | UndefinedType = Undefined,
                            uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                            uplink_mtu: int | None | UndefinedType = Undefined,
                            max_uplink_switches: int | None | UndefinedType = Undefined,
                            max_parallel_uplinks: int | None | UndefinedType = Undefined,
                            uplink_bfd: bool | None | UndefinedType = Undefined,
                            uplink_native_vlan: int | None | UndefinedType = Undefined,
                            uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                            uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                            uplink_port_channel_id: int | None | UndefinedType = Undefined,
                            uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                            uplink_structured_config: dict | UndefinedType = Undefined,
                            mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                            mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                            mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                            short_esi: str | None | UndefinedType = Undefined,
                            isis_system_id_prefix: str | None | UndefinedType = Undefined,
                            isis_maximum_paths: int | None | UndefinedType = Undefined,
                            is_type: str | None | UndefinedType = Undefined,
                            node_sid_base: int | None | UndefinedType = Undefined,
                            loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                            loopback_ipv4_address: str | None | UndefinedType = Undefined,
                            vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                            vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                            loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                            loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                            loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                            vtep: bool | None | UndefinedType = Undefined,
                            vtep_loopback: str | None | UndefinedType = Undefined,
                            bgp_as: str | None | UndefinedType = Undefined,
                            bgp_defaults: list[str] | UndefinedType = Undefined,
                            evpn_role: str | None | UndefinedType = Undefined,
                            evpn_route_servers: list[str] | UndefinedType = Undefined,
                            evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                            filter: Filter | UndefinedType = Undefined,
                            igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                            evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                            ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                            mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                            mlag_interfaces: list[str] | UndefinedType = Undefined,
                            mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                            mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                            mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                            mlag_peer_vlan: int | None | UndefinedType = Undefined,
                            mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                            mlag_peer_address_family: str | None | UndefinedType = Undefined,
                            mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                            mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                            mlag_port_channel_id: int | None | UndefinedType = Undefined,
                            mlag_domain_id: str | None | UndefinedType = Undefined,
                            spanning_tree_mode: str | None | UndefinedType = Undefined,
                            spanning_tree_priority: int | None | UndefinedType = Undefined,
                            spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                            virtual_router_mac_address: str | None | UndefinedType = Undefined,
                            inband_mgmt_interface: str | None | UndefinedType = Undefined,
                            inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                            inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                            inband_mgmt_ip: str | None | UndefinedType = Undefined,
                            inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                            inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                            inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                            inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                            inband_mgmt_description: str | None | UndefinedType = Undefined,
                            inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                            inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                            inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                            inband_ztp: bool | None | UndefinedType = Undefined,
                            inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                            mpls_overlay_role: str | None | UndefinedType = Undefined,
                            overlay_address_families: list[str] | UndefinedType = Undefined,
                            mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                            bgp_cluster_id: str | None | UndefinedType = Undefined,
                            ptp: Ptp | UndefinedType = Undefined,
                            wan_role: str | None | UndefinedType = Undefined,
                            cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                            cv_pathfinder_region: str | None | UndefinedType = Undefined,
                            cv_pathfinder_site: str | None | UndefinedType = Undefined,
                            wan_ha: WanHa | UndefinedType = Undefined,
                            dps_mss_ipv4: str | None | UndefinedType = Undefined,
                            l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                            data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                            flow_tracker_type: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NodesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: The Node Name is used as "hostname".
                                downlink_pools:
                                   IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                                   with `uplink_ipv4_pool` set on the downlink switch.
                                id: Unique identifier used for IP addressing and other algorithms.
                                platform: Arista platform family.
                                mac_address: Leverage to document management interface mac address.
                                system_mac_address:
                                   System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                                   Set to the same MAC address as
                                   available in "show version" on the device.
                                   "system_mac_address" can also be set directly as a
                                   hostvar.
                                   If both are set, the setting under node type settings takes precedence.
                                serial_number:
                                   Set to the Serial Number of the device.
                                   Only used for documentation purpose in the fabric
                                   documentation and part of the structured_config.
                                   "serial_number" can also be set directly as a
                                   hostvar.
                                   If both are set, the setting under node type settings takes precedence.
                                rack: Rack that the switch is located in (only used in snmp_settings location).
                                mgmt_ip: Node management interface IPv4 address.
                                mgmt_gateway:
                                   This key sets the management gateway for the device. It takes precedence over the global
                                   `mgmt_gateway`.
                                ipv6_mgmt_ip: Node management interface IPv6 address.
                                ipv6_mgmt_gateway:
                                   This key sets the ipv6 management gateway for the device. It takes precedence over the global
                                   `ipv6_mgmt_gateway`.
                                mgmt_interface:
                                   Management Interface Name.
                                   Default -> platform_management_interface -> mgmt_interface ->
                                   "Management1".
                                link_tracking:
                                   This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                                   the upstream interfaces.
                                   Useful in EVPN multhoming designs.
                                lacp_port_id_range:
                                   This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                                   number of nodes in the "node_group".
                                   Unique LACP port-id ranges are recommended for EVPN Multihoming
                                   designs.
                                always_configure_ip_routing:
                                   Force configuration of "ip routing" even on L2 devices.
                                   Use this to retain behavior of AVD versions
                                   below 4.0.0.
                                raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                                structured_config: Custom structured config for eos_cli_config_gen.
                                uplink_type:
                                   Override the default `uplink_type` set at the `node_type_key` level.
                                   `uplink_type` must be "p2p" if
                                   `vtep` or `underlay_router` is true for the `node_type_key` definition.
                                uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                                uplink_interfaces:
                                   Local uplink interfaces.
                                   Each list item supports range syntax that can be expanded into a list of
                                   interfaces.
                                   If uplink_interfaces is not defined, platform-specific defaults (defined under
                                   default_interfaces) will be used instead.
                                   Please note that default_interfaces are not defined by
                                   default, you should define these yourself.
                                uplink_switch_interfaces: Interfaces located on uplink switches.
                                uplink_switches: uplink_switches
                                uplink_interface_speed:
                                   Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                                   (Uplink switch
                                   interface speed can be overridden with `uplink_switch_interface_speed`).
                                   Speed should be set in the
                                   format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                                uplink_switch_interface_speed:
                                   Set point-to-Point interface speed for the uplink switch interface only.
                                   Speed should be set in the
                                   format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                                uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                                max_uplink_switches:
                                   Maximum number of uplink switches.
                                   Changing this value may change IP Addressing on uplinks.
                                   Can be
                                   used to reserve IP space for future expansions.
                                max_parallel_uplinks:
                                   Number of parallel links towards uplink switches.
                                   Changing this value may change interface naming on
                                   uplinks (and corresponding downlinks).
                                   Can be used to reserve interfaces for future parallel
                                   uplinks.
                                uplink_bfd: Enable bfd on uplink interfaces.
                                uplink_native_vlan:
                                   Only applicable to switches with layer-2 port-channel uplinks.
                                   A suspended (disabled) vlan will be
                                   created in both ends of the link unless the vlan is defined under network services.
                                   By default the
                                   uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                                uplink_ptp: Enable PTP on all infrastructure links.
                                uplink_macsec: Enable MacSec on all uplinks.
                                uplink_port_channel_id:
                                   Only applicable for L2 switches with `uplink_type: port-channel`.
                                   By default the uplink Port-channel
                                   ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                                   For
                                   example:
                                     member ports [ Eth22, Eth23 ] -> ID 22
                                     member ports [ Eth11/1, Eth22/1 ] -> ID 111
                                   For
                                   MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                                   This
                                   option overrides the default behavior and statically sets the local Port-channel ID.
                                   Note! Make sure
                                   the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                                   Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                                   value.
                                uplink_switch_port_channel_id:
                                   Only applicable for L2 switches with `uplink_type: port-channel`.
                                   By default the uplink switch Port-
                                   channel ID will be set to the number of the first interface defined under
                                   `uplink_switch_interfaces`.
                                   For example:
                                     member ports [ Eth22, Eth23 ] -> ID 22
                                     member ports [
                                   Eth11/1, Eth22/1 ] -> ID 111
                                   For MLAG port-channels ID will be based on the lowest member interface
                                   on the first MLAG switch.
                                   This option overrides the default behavior and statically sets the Port-
                                   channel ID on the uplink switch.
                                   Note! Make sure the ID is unique and does not overlap with
                                   autogenerated Port-channel IDs in the Network Services.
                                   Note! For MLAG pairs the ID must be between
                                   1 and 2000 and both MLAG switches must have the same value.
                                uplink_structured_config:
                                   Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                                   When
                                   uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                                   for eos_cli_config_gen overrides the settings on the ethernet interface level.
                                   When uplink_type ==
                                   "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                                   eos_cli_config_gen overrides the settings on the port-channel interface level.
                                   "uplink_structured_config" is applied after "structured_config", so it can override
                                   "structured_config" defined on node-level.
                                   Note! The content of this dictionary is _not_ validated
                                   by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                                mlag_port_channel_structured_config:
                                   Custom structured config applied to MLAG peer link port-channel id.
                                   Added under
                                   port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                                   Overrides the settings on the
                                   port-channel interface level.
                                   "mlag_port_channel_structured_config" is applied after
                                   "structured_config", so it can override "structured_config" defined on node-level.
                                mlag_peer_vlan_structured_config:
                                   Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                                   Added under
                                   vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                                   Overrides the settings on the vlan
                                   interface level.
                                   "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                                   override "structured_config" defined on node-level.
                                mlag_peer_l3_vlan_structured_config:
                                   Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                                   Added under
                                   vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                                   Overrides the settings on the vlan
                                   interface level.
                                   "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                                   can override "structured_config" defined on node-level.
                                short_esi:
                                   short_esi only valid for l2leaf devices using port-channel uplink.
                                   Setting short_esi to "auto"
                                   generates the short_esi automatically using a hash of configuration elements.
                                   < 0000:0000:0000 |
                                   auto >.
                                isis_system_id_prefix: (4.4 hexadecimal).
                                isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                                is_type: is_type
                                node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                                loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                                loopback_ipv4_address:
                                   IPv4 address without mask for Loopback0.
                                   When set, it takes precedence over `loopback_ipv4_pool`.
                                   Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                                vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                                vtep_loopback_ipv4_address:
                                   IPv4 address without mask for VTEP-Loopback.
                                   When set, it takes precedence over
                                   `vtep_loopback_ipv4_pool`.
                                   Note: AVD does not check for validity of the IPv4 address and does not
                                   catch duplicates.
                                loopback_ipv4_offset:
                                   Offset all assigned loopback IP addresses.
                                   Required when the < loopback_ipv4_pool > is same for 2
                                   different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                                   For example, set the minimum
                                   offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                                loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                                loopback_ipv6_offset:
                                   Offset all assigned loopback IPv6 addresses.
                                   Required when the < loopback_ipv6_pool > is same for 2
                                   different node_types (like spine and l3leaf) to avoid overlapping IPs.
                                   For example, set the minimum
                                   offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                                vtep:
                                   Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                                   Overrides VTEP
                                   setting inherited from node_type_keys.
                                vtep_loopback: Set VXLAN source interface.
                                bgp_as:
                                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                   For asdot notation in
                                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                   number.
                                   Required with eBGP.
                                bgp_defaults: List of EOS commands to apply to BGP daemon.
                                evpn_role:
                                   Acting role in EVPN control plane.
                                   Default is set in node_type definition from node_type_keys.
                                evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                                evpn_services_l2_only:
                                   Possibility to prevent configuration of Tenant VRFs and SVIs.
                                   Override node definition
                                   "network_services_l3" from node_type_keys.
                                   This allows support for centralized routing.
                                filter:
                                   Filter L3 and L2 network services based on tenant and tags (and operation filter).
                                   If filter is not
                                   defined it will default to all.
                                igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                                evpn_gateway:
                                   Node is acting as EVPN Multi-Domain Gateway.
                                   New BGP peer-group is generated between EVPN GWs in
                                   different domains or between GWs and Route Servers.
                                   Name can be changed under
                                   "bgp_peer_groups.evpn_overlay_core" variable.
                                   L3 rechability for different EVPN GWs must be already
                                   in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                                   same Ansible inventory.
                                ipvpn_gateway:
                                   Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                                   this is "bgp_peer_groups.ipvpn_gateway_peers".
                                   L3 Reachability is required for this to work, the
                                   preferred method to establish underlay connectivity is to use core_interfaces.
                                mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                                mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                                mlag_ibgp_origin_incomplete:
                                   Set origin of routes received from MLAG iBGP peer to incomplete.
                                   The purpose is to optimize routing
                                   for leaf loopbacks from spine perspective and
                                   avoid suboptimal routing via peerlink for control
                                   plane traffic.
                                mlag_interfaces:
                                   Each list item supports range syntax that can be expanded into a list of interfaces.
                                   Required when
                                   MLAG leafs are present in the topology.
                                mlag_interfaces_speed:
                                   Set MLAG interface speed.
                                   Speed should be set in the format `<interface_speed>` or `forced
                                   <interface_speed>` or `auto <interface_speed>`.
                                mlag_peer_l3_vlan:
                                   Underlay L3 peering SVI interface id.
                                   If set to 0 or the same vlan as mlag_peer_vlan, the
                                   mlag_peer_vlan will be used for L3 peering.
                                mlag_peer_l3_ipv4_pool:
                                   IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                                   Required when
                                   MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                                mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                                mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                                mlag_peer_address_family:
                                   IP address family used to establish MLAG Peer Link (control link).
                                   `ipv6` requires EOS version
                                   4.31.1F or higher.
                                   Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                                   (ex. `mlag_peer_l3_vlan` set to 4094).
                                mlag_peer_ipv4_pool:
                                   IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                                   Required
                                   for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                                mlag_peer_ipv6_pool:
                                   IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                                   Required
                                   for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                                mlag_port_channel_id:
                                   If not set, the mlag port-channel id is generated based on the digits of the first interface present
                                   in 'mlag_interfaces'.
                                   Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                                   999999 > for EOS >= 4.25.0F.
                                mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                                spanning_tree_mode: spanning_tree_mode
                                spanning_tree_priority:
                                   Spanning-tree priority configured for the selected mode.
                                   For `rapid-pvst` the priority can also be
                                   set per VLAN under network services.
                                spanning_tree_root_super: spanning_tree_root_super
                                virtual_router_mac_address: Virtual router mac address for anycast gateway.
                                inband_mgmt_interface:
                                   Pointer to interface used for inband management.
                                   All configuration must be done using other data
                                   models like network services or structured_config.
                                   'inband_mgmt_interface' is only used to refer to
                                   this interface as source in various management protocol settings (future feature).

                                   On L2 switches,
                                   this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                                inband_mgmt_vlan:
                                   VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                                   uplinks).
                                   When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                                   switch as well as all 'uplink_switches'.
                                   When using 'inband_mgmt_ip' the VLAN and SVI will only be
                                   created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                                   created using network services data models.
                                inband_mgmt_subnet:
                                   Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                                   as uplinks).
                                   Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                                   ARP.
                                   This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                                   SVI IP address will be assigned as follows:
                                   virtual-router: <subnet> + 1
                                   l3leaf A      : <subnet> +
                                   2 (same IP on all l3leaf A)
                                   l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                                   l2leafs       :
                                   <subnet> + 3 + <l2leaf id>
                                   GW on l2leafs : <subnet> + 1
                                   Assign range larger than total l2leafs + 5
                                   Setting is ignored if 'inband_mgmt_ip' is set.

                                   This setting is applicable to L2 switches (switches
                                   using port-channel trunks as uplinks).
                                inband_mgmt_ip:
                                   IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                                   This overrides
                                   'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                                   If this is set the
                                   VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                                   The VLAN and SVI on
                                   the parent switches must be created using network services data models.

                                   This setting is applicable
                                   to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_gateway:
                                   Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                                   is derived from 'inband_mgmt_subnet' if set.

                                   This setting is applicable to L2 switches (switches
                                   using port-channel trunks as uplinks).
                                inband_mgmt_ipv6_address:
                                   IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                                   This overrides
                                   'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                                   If this
                                   is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                                   The VLAN
                                   and SVI on the parent switches must be created using network services data models.

                                   This setting is
                                   applicable to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_ipv6_subnet:
                                   Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                                   as uplinks).
                                   Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                                   on ARP.
                                   This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                                   extension.
                                   SVI IP address will be assigned as follows:
                                   virtual-router: <subnet> + 1
                                   l3leaf A      :
                                   <subnet> + 2 (same IP on all l3leaf A)
                                   l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                                   l2leafs       : <subnet> + 3 + <l2leaf id>
                                   GW on l2leafs : <subnet> + 1
                                   Assign range larger than
                                   total l2leafs + 5

                                   Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                                   This setting is
                                   applicable to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_ipv6_gateway:
                                   Default gateway configured in the 'inband_mgmt_vrf'.
                                   Used when `inband_mgmt_ipv6_address` is set.
                                   Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                                   This setting is
                                   applicable to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_description:
                                   Description configured on the Inband Management SVI.

                                   This setting is only applied on the devices
                                   where it is set, it does not automatically affect any parent/child devices configuration, so it must
                                   be set on each applicable node/node-group/node-type as needed.
                                inband_mgmt_vlan_name:
                                   Name configured on the Inband Management VLAN.
                                   This setting is only applied on the devices where it
                                   is set, it does not automatically affect any parent/child devices configuration, so it must be set
                                   on each applicable node/node-group/node-type as needed.
                                inband_mgmt_vrf:
                                   VRF configured on the Inband Management Interface.
                                   The VRF is created if not already created by
                                   other means.
                                   This setting is only applied on the devices where it is set, it does not automatically
                                   affect any parent/child devices configuration, so it must be set on each applicable node/node-
                                   group/node-type as needed.
                                inband_mgmt_mtu:
                                   MTU configured on the Inband Management Interface.
                                   This setting is only applied on the devices where
                                   it is set, it does not automatically affect any parent/child devices configuration, so it must be
                                   set on each applicable node/node-group/node-type as needed.
                                inband_ztp:
                                   Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                                   inband.
                                   This setting also requires that the `inband_mgmt_vlan` is set for the node.
                                inband_ztp_lacp_fallback_delay:
                                   Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                                   ZTP node.
                                   This setting also requires that `inband_ztp` is set for the node.
                                mpls_overlay_role:
                                   Set the default mpls overlay role.
                                   Acting role in overlay control plane.
                                overlay_address_families: Set the default overlay address families.
                                mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                                bgp_cluster_id: Set BGP cluster id.
                                ptp: ptp
                                wan_role:
                                   Override the default WAN role.

                                   This is used both for AutoVPN and Pathfinder designs.
                                   That means if
                                   `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                                   `server` indicates that the
                                   router is a route-reflector.

                                   Only supported if `overlay_routing_protocol` is set to `ibgp`.
                                cv_pathfinder_transit_mode:
                                   Configure the transit mode for a WAN client for CV Pathfinder designs
                                   only when the `wan_mode` root
                                   key is set to `cv_pathfinder`.

                                   'zone' is currently not supported.
                                cv_pathfinder_region:
                                   The CV Pathfinder region name.
                                   This key is required for WAN routers but optional for pathfinders.
                                   The region name must be defined under 'cv_pathfinder_regions'.
                                cv_pathfinder_site:
                                   The CV Pathfinder site name.
                                   This key is required for WAN routers but optional for pathfinders.
                                   For
                                   WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                                   relevant region under 'cv_pathfinder_regions'.
                                   For pathfinders without `cv_pathfinder_region` set,
                                   the site must be defined under `cv_pathfinder_global_sites`.
                                wan_ha:
                                   PREVIEW: This key is currently not supported

                                   The key is supported only if `wan_mode` == `cv-
                                   pathfinder`.
                                   AutoVPN support is still to be determined.

                                   Maximum 2 devices supported by group for
                                   HA.
                                dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                                l3_interfaces:
                                   L3 Interfaces to configure on the node.
                                   Used to define the node for WAN interfaces when
                                   `wan_carrier` is set.
                                data_plane_cpu_allocation_max:
                                   Set the maximum number of CPU used for the data plane.
                                   This setting is useful on virtual Route
                                   Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                                flow_tracker_type:
                                   Set the flow tracker type.
                                   Override the `default_flow_tracker_type`` set at the `node_type_key`
                                   level.
                                   `default_flow_tracker_type` default value is `sampled`.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Nodes(AvdCollection[str, NodesItem]):
                        _primary_key: ClassVar[str] = "name"

                    Nodes._item_type = NodesItem

                    class LinkTracking(AvdModel):
                        class GroupsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "name": {"type": str},
                                "recovery_delay": {"type": int},
                                "links_minimum": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            name: str | None
                            """Tracking group name."""
                            recovery_delay: int | None
                            """default -> platform_settings_mlag_reload_delay -> 300."""
                            links_minimum: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                recovery_delay: int | None | UndefinedType = Undefined,
                                links_minimum: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                GroupsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    name: Tracking group name.
                                    recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                    links_minimum: links_minimum

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "groups": {
                                "type": list,
                                "items": GroupsItem,
                                "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                            },
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        groups: list[GroupsItem]
                        """
                        Link Tracking Groups.
                        By default a single group named "LT_GROUP1" is defined with default values.
                        Any groups defined under "groups" will replace the default.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            groups: list[GroupsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                groups:
                                   Link Tracking Groups.
                                   By default a single group named "LT_GROUP1" is defined with default values.
                                   Any groups defined under "groups" will replace the default.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LacpPortIdRange(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "size": {"type": int, "default": 128},
                            "offset": {"type": int, "default": 0},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        size: int | None
                        """Recommended size > = number of ports in the switch."""
                        offset: int | None
                        """
                        Offset is used to avoid overlapping port-id ranges of different switches.
                        Useful when a "connected-
                        endpoint" is connected to switches in different "node_groups".
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            offset: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LacpPortIdRange.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                size: Recommended size > = number of ports in the switch.
                                offset:
                                   Offset is used to avoid overlapping port-id ranges of different switches.
                                   Useful when a "connected-
                                   endpoint" is connected to switches in different "node_groups".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    class UplinkPtp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enable: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkPtp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enable: enable

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UplinkMacsec(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        profile: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkMacsec.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: profile

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                        pass

                    class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class Filter(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "tenants": {"type": list, "items": str, "default": ["all"]},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "always_include_vrfs_in_tenants": {"type": list, "items": str},
                            "only_vlans_in_use": {"type": bool, "default": False},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        tenants: list[str]
                        """
                        Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                        Tenants (default).
                        This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                        """
                        tags: list[str]
                        """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                        allow_vrfs: list[str]
                        """
                        Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                        (default).
                        This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                        """
                        deny_vrfs: list[str]
                        """
                        Prevent configuration of Network Services defined under these VRFs.
                        This list prevents the given
                        VRFs to be included by any other filtering mechanism.
                        """
                        always_include_vrfs_in_tenants: list[str]
                        """
                        List of tenants where VRFs will be configured even if VLANs are not included in tags.
                        Useful for L3
                        "border" leaf.
                        """
                        only_vlans_in_use: bool | None
                        """
                        Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                        Note! This
                        feature only considers configuration managed by eos_designs.
                        This excludes structured_config,
                        custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            tenants: list[str] | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            allow_vrfs: list[str] | UndefinedType = Undefined,
                            deny_vrfs: list[str] | UndefinedType = Undefined,
                            always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                            only_vlans_in_use: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.

                            Args:
                            -----
                                _custom_data: _custom_data
                                tenants:
                                   Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                   Tenants (default).
                                   This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                allow_vrfs:
                                   Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                   (default).
                                   This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                deny_vrfs:
                                   Prevent configuration of Network Services defined under these VRFs.
                                   This list prevents the given
                                   VRFs to be included by any other filtering mechanism.
                                always_include_vrfs_in_tenants:
                                   List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                   Useful for L3
                                   "border" leaf.
                                only_vlans_in_use:
                                   Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                   Note! This
                                   feature only considers configuration managed by eos_designs.
                                   This excludes structured_config,
                                   custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            hostname: str | None
                            """Hostname of remote EVPN GW server."""
                            ip_address: str | None
                            """Peering IP of remote Route Server."""
                            bgp_as: str | None
                            """
                            Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                            interpreted as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                bgp_as: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote EVPN GW server.
                                    ip_address: Peering IP of remote Route Server.
                                    bgp_as:
                                       Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                       interpreted as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL2(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL2.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "inter_domain": {"type": bool, "default": True},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            inter_domain: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                inter_domain: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL3.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    inter_domain: inter_domain

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                            "evpn_l2": {"type": EvpnL2},
                            "evpn_l3": {"type": EvpnL3},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_peers: list[RemotePeersItem]
                        """
                        Define remote peers of the EVPN VXLAN Gateway.
                        If the hostname can be found in the inventory,
                        ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                        If the
                        peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                        """
                        evpn_l2: EvpnL2
                        """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                        evpn_l3: EvpnL3
                        """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            evpn_l2: EvpnL2 | UndefinedType = Undefined,
                            evpn_l3: EvpnL3 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_peers:
                                   Define remote peers of the EVPN VXLAN Gateway.
                                   If the hostname can be found in the inventory,
                                   ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                   If the
                                   peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                            _custom_data: dict[str, Any]
                            hostname: str
                            """Hostname of remote IPVPN Peer."""
                            ip_address: str
                            """Peering IP of remote IPVPN Peer."""
                            bgp_as: str
                            """
                            Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For
                            asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                            as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | UndefinedType = Undefined,
                                ip_address: str | UndefinedType = Undefined,
                                bgp_as: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote IPVPN Peer.
                                    ip_address: Peering IP of remote IPVPN Peer.
                                    bgp_as:
                                       Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For
                                       asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                       as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_domain_id": {"type": str, "default": "65535:1"},
                            "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                            "enable_d_path": {"type": bool, "default": True},
                            "maximum_routes": {"type": int, "default": 0},
                            "local_as": {"type": str, "default": "none"},
                            "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        evpn_domain_id: str | None
                        """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                        ipvpn_domain_id: str | None
                        """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                        enable_d_path: bool | None
                        """Enable D-path for use with BGP bestpath selection algorithm."""
                        maximum_routes: int | None
                        """Maximum routes to accept from IPVPN remote peers."""
                        local_as: str | None
                        """
                        Local BGP AS applied to peering with IPVPN remote peers.
                        BGP AS <1-4294967295> or AS number in asdot
                        notation "<1-65535>.<0-65535>".
                        For asdot notation in YAML inputs, the value must be put in quotes,
                        to prevent it from being interpreted as a float number.
                        """
                        address_families: list[str]
                        """IPVPN address families to enable for remote peers."""
                        remote_peers: list[RemotePeersItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            evpn_domain_id: str | None | UndefinedType = Undefined,
                            ipvpn_domain_id: str | None | UndefinedType = Undefined,
                            enable_d_path: bool | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            address_families: list[str] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                local_as:
                                   Local BGP AS applied to peering with IPVPN remote peers.
                                   BGP AS <1-4294967295> or AS number in asdot
                                   notation "<1-65535>.<0-65535>".
                                   For asdot notation in YAML inputs, the value must be put in quotes,
                                   to prevent it from being interpreted as a float number.
                                address_families: IPVPN address families to enable for remote peers.
                                remote_peers: remote_peers

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        class Dscp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            general_messages: int | None
                            event_messages: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                general_messages: int | None | UndefinedType = Undefined,
                                event_messages: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dscp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    general_messages: general_messages
                                    event_messages: event_messages

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Monitor(AvdModel):
                            class Threshold(AvdModel):
                                class Drop(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int},
                                        "mean_path_delay": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Drop.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "offset_from_master": {"type": int, "default": 250},
                                    "mean_path_delay": {"type": int, "default": 1500},
                                    "drop": {"type": Drop},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                offset_from_master: int | None
                                mean_path_delay: int | None
                                drop: Drop

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    offset_from_master: int | None | UndefinedType = Undefined,
                                    mean_path_delay: int | None | UndefinedType = Undefined,
                                    drop: Drop | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Threshold.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        offset_from_master: offset_from_master
                                        mean_path_delay: mean_path_delay
                                        drop: drop

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class MissingMessage(AvdModel):
                                class Intervals(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "announce": {"type": int},
                                        "follow_up": {"type": int},
                                        "sync": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    announce: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Intervals.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            announce: announce
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class SequenceIds(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "enabled": {"type": bool, "default": True},
                                        "announce": {"type": int, "default": 3},
                                        "delay_resp": {"type": int, "default": 3},
                                        "follow_up": {"type": int, "default": 3},
                                        "sync": {"type": int, "default": 3},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    enabled: bool | None
                                    announce: int | None
                                    delay_resp: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        enabled: bool | None | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        delay_resp: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        SequenceIds.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            enabled: enabled
                                            announce: announce
                                            delay_resp: delay_resp
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "intervals": {"type": Intervals},
                                    "sequence_ids": {"type": SequenceIds},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                intervals: Intervals
                                sequence_ids: SequenceIds

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    intervals: Intervals | UndefinedType = Undefined,
                                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MissingMessage.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        intervals: intervals
                                        sequence_ids: sequence_ids

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "threshold": {"type": Threshold},
                                "missing_message": {"type": MissingMessage},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            threshold: Threshold
                            missing_message: MissingMessage

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                threshold: Threshold | UndefinedType = Undefined,
                                missing_message: MissingMessage | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Monitor.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    threshold: threshold
                                    missing_message: missing_message

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                            "mlag": {"type": bool, "default": False},
                            "domain": {"type": int, "default": 127},
                            "priority1": {"type": int},
                            "priority2": {"type": int},
                            "auto_clock_identity": {"type": bool, "default": True},
                            "clock_identity_prefix": {"type": str},
                            "clock_identity": {"type": str},
                            "source_ip": {"type": str},
                            "mode": {"type": str, "default": "boundary"},
                            "mode_one_step": {"type": bool, "default": False},
                            "ttl": {"type": int},
                            "forward_unicast": {"type": bool, "default": False},
                            "dscp": {"type": Dscp},
                            "monitor": {"type": Monitor},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """
                        mlag: bool | None
                        """
                        Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                        configured on the MLAG peer-link port-channel.
                        """
                        domain: int | None
                        priority1: int | None
                        """default -> automatically set based on node_type."""
                        priority2: int | None
                        """default -> (node_id modulus 256)."""
                        auto_clock_identity: bool | None
                        """
                        If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                        default EOS behaviour, simply disable the automatic PTP clock identity.
                        default ->
                        (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                        HEX).
                        """
                        clock_identity_prefix: str | None
                        """
                        PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                        By default the 3-byte prefix is "00:1C:73".
                        This
                        can be overridden if auto_clock_identity is set to true (which is the default).
                        """
                        clock_identity: str | None
                        """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                        source_ip: str | None
                        """
                        By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                        relevant SVI, which is the recommended behaviour.
                        This can be set manually if required, for example,
                        to a value of "10.1.2.3".
                        """
                        mode: str | None
                        mode_one_step: bool | None
                        ttl: int | None
                        forward_unicast: bool | None
                        """Enable PTP unicast forwarding."""
                        dscp: Dscp
                        monitor: Monitor

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            domain: int | None | UndefinedType = Undefined,
                            priority1: int | None | UndefinedType = Undefined,
                            priority2: int | None | UndefinedType = Undefined,
                            auto_clock_identity: bool | None | UndefinedType = Undefined,
                            clock_identity_prefix: str | None | UndefinedType = Undefined,
                            clock_identity: str | None | UndefinedType = Undefined,
                            source_ip: str | None | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            mode_one_step: bool | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            forward_unicast: bool | None | UndefinedType = Undefined,
                            dscp: Dscp | UndefinedType = Undefined,
                            monitor: Monitor | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"
                                mlag:
                                   Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                   configured on the MLAG peer-link port-channel.
                                domain: domain
                                priority1: default -> automatically set based on node_type.
                                priority2: default -> (node_id modulus 256).
                                auto_clock_identity:
                                   If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                   default EOS behaviour, simply disable the automatic PTP clock identity.
                                   default ->
                                   (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                   HEX).
                                clock_identity_prefix:
                                   PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                   By default the 3-byte prefix is "00:1C:73".
                                   This
                                   can be overridden if auto_clock_identity is set to true (which is the default).
                                clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                source_ip:
                                   By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                   relevant SVI, which is the recommended behaviour.
                                   This can be set manually if required, for example,
                                   to a value of "10.1.2.3".
                                mode: mode
                                mode_one_step: mode_one_step
                                ttl: ttl
                                forward_unicast: Enable PTP unicast forwarding.
                                dscp: dscp
                                monitor: monitor

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class WanHa(AvdModel):
                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": True},
                            "ipsec": {"type": bool, "default": True},
                            "mtu": {"type": int, "default": 9194},
                            "ha_interfaces": {"type": list, "items": str},
                            "ha_ipv4_pool": {"type": str},
                            "max_ha_interfaces": {"type": int},
                            "port_channel_id": {"type": int},
                            "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                            "flow_tracking": {"type": FlowTracking},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                        ipsec: bool | None
                        """Enable / Disable IPsec over HA path-group when HA is enabled."""
                        mtu: int | None
                        """Set MTU on WAN HA interfaces."""
                        ha_interfaces: list[str]
                        """
                        Local WAN HA interfaces
                        Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                        Can be used to filter uplink interfaces when there are multiple uplinks.
                        Limitations:
                          Either all
                        interfaces must be uplinks or all interfaces must not be uplinks.
                          Only one interface is supported
                        for non uplinks.
                        """
                        ha_ipv4_pool: str | None
                        """
                        IP address pool used for WAN HA connectivity.
                        IP is derived from the node ID.
                        Not used for uplink
                        interfaces.
                        """
                        max_ha_interfaces: int | None
                        """
                        Number of parallel links towards HA switches.
                        Can be used to reserve IP addresses for future
                        parallel HA links.
                        """
                        port_channel_id: int | None
                        """Port-channel ID to use for direct HA."""
                        use_port_channel_for_direct_ha: bool | None
                        """
                        Enable or disable using a port-channel interface for direct HA when there is only one interface.
                        This feature was introduced in EOS 4.33.0F.
                        """
                        flow_tracking: FlowTracking
                        """
                        Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                        setting.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ipsec: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ha_interfaces: list[str] | UndefinedType = Undefined,
                            ha_ipv4_pool: str | None | UndefinedType = Undefined,
                            max_ha_interfaces: int | None | UndefinedType = Undefined,
                            port_channel_id: int | None | UndefinedType = Undefined,
                            use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WanHa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                mtu: Set MTU on WAN HA interfaces.
                                ha_interfaces:
                                   Local WAN HA interfaces
                                   Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                   Can be used to filter uplink interfaces when there are multiple uplinks.
                                   Limitations:
                                     Either all
                                   interfaces must be uplinks or all interfaces must not be uplinks.
                                     Only one interface is supported
                                   for non uplinks.
                                ha_ipv4_pool:
                                   IP address pool used for WAN HA connectivity.
                                   IP is derived from the node ID.
                                   Not used for uplink
                                   interfaces.
                                max_ha_interfaces:
                                   Number of parallel links towards HA switches.
                                   Can be used to reserve IP addresses for future
                                   parallel HA links.
                                port_channel_id: Port-channel ID to use for direct HA.
                                use_port_channel_for_direct_ha:
                                   Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                   This feature was introduced in EOS 4.33.0F.
                                flow_tracking:
                                   Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                   setting.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Bgp(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "peer_as": {"type": str},
                                "ipv4_prefix_list_in": {"type": str},
                                "ipv4_prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                            _custom_data: dict[str, Any]
                            peer_as: str
                            """
                            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in
                            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                            number.
                            """
                            ipv4_prefix_list_in: str | None
                            """
                            Prefix List Name. Accept routes for only these prefixes from the peer.
                            Required for wan interfaces.
                            """
                            ipv4_prefix_list_out: str | None
                            """
                            Prefix List Name. Advertise routes for only these prefixes.
                            If not specified, nothing would be
                            advertised.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                peer_as: str | UndefinedType = Undefined,
                                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    peer_as:
                                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in
                                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                       number.
                                    ipv4_prefix_list_in:
                                       Prefix List Name. Accept routes for only these prefixes from the peer.
                                       Required for wan interfaces.
                                    ipv4_prefix_list_out:
                                       Prefix List Name. Advertise routes for only these prefixes.
                                       If not specified, nothing would be
                                       advertised.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StaticRoutesItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                            _custom_data: dict[str, Any]
                            prefix: str
                            """IPv4_network/Mask."""

                            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                                """
                                StaticRoutesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    prefix: IPv4_network/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class CvPathfinderInternetExit(AvdModel):
                            class PoliciesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                _custom_data: dict[str, Any]
                                name: str
                                """Internet-exit policy name."""
                                tunnel_interface_numbers: str | None
                                """
                                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                interface.
                                Examples: '1-3' or '100,200,300'
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | UndefinedType = Undefined,
                                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PoliciesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Internet-exit policy name.
                                        tunnel_interface_numbers:
                                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                           interface.
                                           Examples: '1-3' or '100,200,300'

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Policies(AvdCollection[str, PoliciesItem]):
                                _primary_key: ClassVar[str] = "name"

                            Policies._item_type = PoliciesItem

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            policies: Policies
                            """List of Internet-exit policies using this interface as exit."""

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                            ) -> None:
                                """
                                CvPathfinderInternetExit.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    policies: List of Internet-exit policies using this interface as exit.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "profile": {"type": str},
                            "name": {"type": str},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "dhcp_ip": {"type": str},
                            "public_ip": {"type": str},
                            "encapsulation_dot1q_vlan": {"type": int},
                            "dhcp_accept_default_route": {"type": bool, "default": True},
                            "enabled": {"type": bool, "default": True},
                            "speed": {"type": str},
                            "peer": {"type": str},
                            "peer_interface": {"type": str},
                            "peer_ip": {"type": str},
                            "bgp": {"type": Bgp},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "static_routes": {"type": list, "items": StaticRoutesItem},
                            "qos_profile": {"type": str},
                            "wan_carrier": {"type": str},
                            "wan_circuit_id": {"type": str},
                            "connected_to_pathfinder": {"type": bool, "default": True},
                            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                            "raw_eos_cli": {"type": str},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        profile: str | None
                        """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                        name: str
                        """
                        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                        For a
                        subinterface, the parent physical interface is automatically created.
                        """
                        description: str | None
                        """
                        Interface description.
                        If not set a default description will be configured with '[<peer>[
                        <peer_interface>]]'.
                        """
                        ip_address: str | None
                        """Node IPv4 address/Mask or 'dhcp'."""
                        dhcp_ip: str | None
                        """
                        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                        IPv4 address
                        (without mask) to be allocated on the interface if known.
                        This is not rendered in the configuration
                        but can be used for substitution of 'interface_ip' in the Access-list
                        set under `ipv4_acl_in` and
                        `ipv4_acl_out`.
                        """
                        public_ip: str | None
                        """
                        Node IPv4 address (no mask).

                        This is used to get the public IP (if known) when the device is behind
                        NAT.
                        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                        with the following preference:
                          `wan_route_servers.path_groups.interfaces.ip_address`
                              ->
                        `l3_interfaces.public_ip`
                                  -> `l3_interfaces.ip_address`

                        The determined Public IP is used
                        by WAN routers when peering with this interface.
                        """
                        encapsulation_dot1q_vlan: int | None
                        """
                        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        dhcp_accept_default_route: bool | None
                        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                        enabled: bool | None
                        """Enable or Shutdown the interface."""
                        speed: str | None
                        """
                        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                        <interface_speed>`.
                        """
                        peer: str | None
                        """The peer device name. Used for description and documentation."""
                        peer_interface: str | None
                        """The peer device interface. Used for description and documentation."""
                        peer_ip: str | None
                        """
                        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                        and `ip` is an IP address.
                        """
                        bgp: Bgp
                        """Enforce IPv4 BGP peering for the peer"""
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        Required
                        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                        `wan_carriers`.
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        """
                        static_routes: list[StaticRoutesItem]
                        """Configure IPv4 static routes pointing to `peer_ip`."""
                        qos_profile: str | None
                        """QOS service profile."""
                        wan_carrier: str | None
                        """
                        The WAN carrier this interface is connected to.
                        This is used to infer the path-groups in which this
                        interface should be configured.
                        Unless the carrier is marked as 'trusted' under `wan_carriers`,
                        `ipv4_acl_in` is also required on all WAN interfaces.
                        """
                        wan_circuit_id: str | None
                        """
                        The WAN circuit ID for this interface.
                        This is not rendered in the configuration but used for WAN
                        designs.
                        """
                        connected_to_pathfinder: bool | None
                        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                        cv_pathfinder_internet_exit: CvPathfinderInternetExit
                        """PREVIEW: This key is in preview mode"""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the interface in the final EOS configuration."""
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config for the Ethernet interface."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            dhcp_ip: str | None | UndefinedType = Undefined,
                            public_ip: str | None | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            speed: str | None | UndefinedType = Undefined,
                            peer: str | None | UndefinedType = Undefined,
                            peer_interface: str | None | UndefinedType = Undefined,
                            peer_ip: str | None | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                            qos_profile: str | None | UndefinedType = Undefined,
                            wan_carrier: str | None | UndefinedType = Undefined,
                            wan_circuit_id: str | None | UndefinedType = Undefined,
                            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                name:
                                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                   For a
                                   subinterface, the parent physical interface is automatically created.
                                description:
                                   Interface description.
                                   If not set a default description will be configured with '[<peer>[
                                   <peer_interface>]]'.
                                ip_address: Node IPv4 address/Mask or 'dhcp'.
                                dhcp_ip:
                                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                   IPv4 address
                                   (without mask) to be allocated on the interface if known.
                                   This is not rendered in the configuration
                                   but can be used for substitution of 'interface_ip' in the Access-list
                                   set under `ipv4_acl_in` and
                                   `ipv4_acl_out`.
                                public_ip:
                                   Node IPv4 address (no mask).

                                   This is used to get the public IP (if known) when the device is behind
                                   NAT.
                                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                   with the following preference:
                                     `wan_route_servers.path_groups.interfaces.ip_address`
                                         ->
                                   `l3_interfaces.public_ip`
                                             -> `l3_interfaces.ip_address`

                                   The determined Public IP is used
                                   by WAN routers when peering with this interface.
                                encapsulation_dot1q_vlan:
                                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                enabled: Enable or Shutdown the interface.
                                speed:
                                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                   <interface_speed>`.
                                peer: The peer device name. Used for description and documentation.
                                peer_interface: The peer device interface. Used for description and documentation.
                                peer_ip:
                                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                   and `ip` is an IP address.
                                bgp: Enforce IPv4 BGP peering for the peer
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                   Required
                                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                   `wan_carriers`.
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                qos_profile: QOS service profile.
                                wan_carrier:
                                   The WAN carrier this interface is connected to.
                                   This is used to infer the path-groups in which this
                                   interface should be configured.
                                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                   `ipv4_acl_in` is also required on all WAN interfaces.
                                wan_circuit_id:
                                   The WAN circuit ID for this interface.
                                   This is not rendered in the configuration but used for WAN
                                   designs.
                                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config for the Ethernet interface.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                        _primary_key: ClassVar[str] = "name"

                    L3Interfaces._item_type = L3InterfacesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "group": {"type": str},
                        "nodes": {"type": Nodes},
                        "id": {"type": int},
                        "platform": {"type": str},
                        "mac_address": {"type": str},
                        "system_mac_address": {"type": str},
                        "serial_number": {"type": str},
                        "rack": {"type": str},
                        "mgmt_ip": {"type": str},
                        "mgmt_gateway": {"type": str},
                        "ipv6_mgmt_ip": {"type": str},
                        "ipv6_mgmt_gateway": {"type": str},
                        "mgmt_interface": {"type": str},
                        "link_tracking": {"type": LinkTracking},
                        "lacp_port_id_range": {"type": LacpPortIdRange},
                        "always_configure_ip_routing": {"type": bool, "default": False},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                        "uplink_type": {"type": str, "default": "p2p"},
                        "uplink_ipv4_pool": {"type": str},
                        "uplink_interfaces": {"type": list, "items": str},
                        "uplink_switch_interfaces": {"type": list, "items": str},
                        "uplink_switches": {"type": list, "items": str},
                        "uplink_interface_speed": {"type": str},
                        "uplink_switch_interface_speed": {"type": str},
                        "uplink_mtu": {"type": int},
                        "max_uplink_switches": {"type": int},
                        "max_parallel_uplinks": {"type": int},
                        "uplink_bfd": {"type": bool, "default": False},
                        "uplink_native_vlan": {"type": int},
                        "uplink_ptp": {"type": UplinkPtp},
                        "uplink_macsec": {"type": UplinkMacsec},
                        "uplink_port_channel_id": {"type": int},
                        "uplink_switch_port_channel_id": {"type": int},
                        "uplink_structured_config": {"type": dict},
                        "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                        "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                        "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                        "short_esi": {"type": str},
                        "isis_system_id_prefix": {"type": str},
                        "isis_maximum_paths": {"type": int},
                        "is_type": {"type": str, "default": "level-2"},
                        "node_sid_base": {"type": int, "default": 0},
                        "loopback_ipv4_pool": {"type": str},
                        "loopback_ipv4_address": {"type": str},
                        "vtep_loopback_ipv4_pool": {"type": str},
                        "vtep_loopback_ipv4_address": {"type": str},
                        "loopback_ipv4_offset": {"type": int, "default": 0},
                        "loopback_ipv6_pool": {"type": str},
                        "loopback_ipv6_offset": {"type": int, "default": 0},
                        "vtep": {"type": bool},
                        "vtep_loopback": {"type": str},
                        "bgp_as": {"type": str},
                        "bgp_defaults": {"type": list, "items": str},
                        "evpn_role": {"type": str},
                        "evpn_route_servers": {"type": list, "items": str},
                        "evpn_services_l2_only": {"type": bool, "default": False},
                        "filter": {"type": Filter},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "evpn_gateway": {"type": EvpnGateway},
                        "ipvpn_gateway": {"type": IpvpnGateway},
                        "mlag": {"type": bool, "default": True},
                        "mlag_dual_primary_detection": {"type": bool, "default": False},
                        "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                        "mlag_interfaces": {"type": list, "items": str},
                        "mlag_interfaces_speed": {"type": str},
                        "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                        "mlag_peer_l3_ipv4_pool": {"type": str},
                        "mlag_peer_vlan": {"type": int, "default": 4094},
                        "mlag_peer_link_allowed_vlans": {"type": str},
                        "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                        "mlag_peer_ipv4_pool": {"type": str},
                        "mlag_peer_ipv6_pool": {"type": str},
                        "mlag_port_channel_id": {"type": int},
                        "mlag_domain_id": {"type": str},
                        "spanning_tree_mode": {"type": str},
                        "spanning_tree_priority": {"type": int, "default": 32768},
                        "spanning_tree_root_super": {"type": bool, "default": False},
                        "virtual_router_mac_address": {"type": str},
                        "inband_mgmt_interface": {"type": str},
                        "inband_mgmt_vlan": {"type": int, "default": 4092},
                        "inband_mgmt_subnet": {"type": str},
                        "inband_mgmt_ip": {"type": str},
                        "inband_mgmt_gateway": {"type": str},
                        "inband_mgmt_ipv6_address": {"type": str},
                        "inband_mgmt_ipv6_subnet": {"type": str},
                        "inband_mgmt_ipv6_gateway": {"type": str},
                        "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vrf": {"type": str, "default": "default"},
                        "inband_mgmt_mtu": {"type": int, "default": 1500},
                        "inband_ztp": {"type": bool, "default": False},
                        "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                        "mpls_overlay_role": {"type": str},
                        "overlay_address_families": {"type": list, "items": str},
                        "mpls_route_reflectors": {"type": list, "items": str},
                        "bgp_cluster_id": {"type": str},
                        "ptp": {"type": Ptp},
                        "wan_role": {"type": str},
                        "cv_pathfinder_transit_mode": {"type": str},
                        "cv_pathfinder_region": {"type": str},
                        "cv_pathfinder_site": {"type": str},
                        "wan_ha": {"type": WanHa},
                        "dps_mss_ipv4": {"type": str, "default": "auto"},
                        "l3_interfaces": {"type": L3Interfaces},
                        "data_plane_cpu_allocation_max": {"type": int},
                        "flow_tracker_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "group")
                    _custom_data: dict[str, Any]
                    group: str
                    """
                    The Node Group Name is used for MLAG domain unless set with 'mlag_domain_id'.
                    The Node Group Name is
                    also used for peer description on downstream switches' uplinks.
                    """
                    nodes: Nodes
                    """Define variables per node."""
                    id: int | None
                    """Unique identifier used for IP addressing and other algorithms."""
                    platform: str | None
                    """Arista platform family."""
                    mac_address: str | None
                    """Leverage to document management interface mac address."""
                    system_mac_address: str | None
                    """
                    System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                    Set to the same MAC address as
                    available in "show version" on the device.
                    "system_mac_address" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    serial_number: str | None
                    """
                    Set to the Serial Number of the device.
                    Only used for documentation purpose in the fabric
                    documentation and part of the structured_config.
                    "serial_number" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    rack: str | None
                    """Rack that the switch is located in (only used in snmp_settings location)."""
                    mgmt_ip: str | None
                    """Node management interface IPv4 address."""
                    mgmt_gateway: str | None
                    """
                    This key sets the management gateway for the device. It takes precedence over the global
                    `mgmt_gateway`.
                    """
                    ipv6_mgmt_ip: str | None
                    """Node management interface IPv6 address."""
                    ipv6_mgmt_gateway: str | None
                    """
                    This key sets the ipv6 management gateway for the device. It takes precedence over the global
                    `ipv6_mgmt_gateway`.
                    """
                    mgmt_interface: str | None
                    """
                    Management Interface Name.
                    Default -> platform_management_interface -> mgmt_interface ->
                    "Management1".
                    """
                    link_tracking: LinkTracking
                    """
                    This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                    the upstream interfaces.
                    Useful in EVPN multhoming designs.
                    """
                    lacp_port_id_range: LacpPortIdRange
                    """
                    This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                    number of nodes in the "node_group".
                    Unique LACP port-id ranges are recommended for EVPN Multihoming
                    designs.
                    """
                    always_configure_ip_routing: bool | None
                    """
                    Force configuration of "ip routing" even on L2 devices.
                    Use this to retain behavior of AVD versions
                    below 4.0.0.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""
                    uplink_type: str | None
                    """
                    Override the default `uplink_type` set at the `node_type_key` level.
                    `uplink_type` must be "p2p" if
                    `vtep` or `underlay_router` is true for the `node_type_key` definition.
                    """
                    uplink_ipv4_pool: str | None
                    """IPv4 subnet to use to connect to uplink switches."""
                    uplink_interfaces: list[str]
                    """
                    Local uplink interfaces.
                    Each list item supports range syntax that can be expanded into a list of
                    interfaces.
                    If uplink_interfaces is not defined, platform-specific defaults (defined under
                    default_interfaces) will be used instead.
                    Please note that default_interfaces are not defined by
                    default, you should define these yourself.
                    """
                    uplink_switch_interfaces: list[str]
                    """Interfaces located on uplink switches."""
                    uplink_switches: list[str]
                    uplink_interface_speed: str | None
                    """
                    Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                    (Uplink switch
                    interface speed can be overridden with `uplink_switch_interface_speed`).
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_switch_interface_speed: str | None
                    """
                    Set point-to-Point interface speed for the uplink switch interface only.
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_mtu: int | None
                    """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                    max_uplink_switches: int | None
                    """
                    Maximum number of uplink switches.
                    Changing this value may change IP Addressing on uplinks.
                    Can be
                    used to reserve IP space for future expansions.
                    """
                    max_parallel_uplinks: int | None
                    """
                    Number of parallel links towards uplink switches.
                    Changing this value may change interface naming on
                    uplinks (and corresponding downlinks).
                    Can be used to reserve interfaces for future parallel
                    uplinks.
                    """
                    uplink_bfd: bool | None
                    """Enable bfd on uplink interfaces."""
                    uplink_native_vlan: int | None
                    """
                    Only applicable to switches with layer-2 port-channel uplinks.
                    A suspended (disabled) vlan will be
                    created in both ends of the link unless the vlan is defined under network services.
                    By default the
                    uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                    """
                    uplink_ptp: UplinkPtp
                    """Enable PTP on all infrastructure links."""
                    uplink_macsec: UplinkMacsec
                    """Enable MacSec on all uplinks."""
                    uplink_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink Port-channel
                    ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                    For
                    example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [ Eth11/1, Eth22/1 ] -> ID 111
                    For
                    MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                    This
                    option overrides the default behavior and statically sets the local Port-channel ID.
                    Note! Make sure
                    the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                    value.
                    """
                    uplink_switch_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink switch Port-
                    channel ID will be set to the number of the first interface defined under
                    `uplink_switch_interfaces`.
                    For example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [
                    Eth11/1, Eth22/1 ] -> ID 111
                    For MLAG port-channels ID will be based on the lowest member interface
                    on the first MLAG switch.
                    This option overrides the default behavior and statically sets the Port-
                    channel ID on the uplink switch.
                    Note! Make sure the ID is unique and does not overlap with
                    autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between
                    1 and 2000 and both MLAG switches must have the same value.
                    """
                    uplink_structured_config: dict
                    """
                    Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                    When
                    uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                    for eos_cli_config_gen overrides the settings on the ethernet interface level.
                    When uplink_type ==
                    "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                    eos_cli_config_gen overrides the settings on the port-channel interface level.
                    "uplink_structured_config" is applied after "structured_config", so it can override
                    "structured_config" defined on node-level.
                    Note! The content of this dictionary is _not_ validated
                    by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                    """
                    mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                    """
                    Custom structured config applied to MLAG peer link port-channel id.
                    Added under
                    port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the
                    port-channel interface level.
                    "mlag_port_channel_structured_config" is applied after
                    "structured_config", so it can override "structured_config" defined on node-level.
                    """
                    mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                    """
                    Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                    override "structured_config" defined on node-level.
                    """
                    mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                    """
                    Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                    can override "structured_config" defined on node-level.
                    """
                    short_esi: str | None
                    """
                    short_esi only valid for l2leaf devices using port-channel uplink.
                    Setting short_esi to "auto"
                    generates the short_esi automatically using a hash of configuration elements.
                    < 0000:0000:0000 |
                    auto >.
                    """
                    isis_system_id_prefix: str | None
                    """(4.4 hexadecimal)."""
                    isis_maximum_paths: int | None
                    """Number of path to configure in ECMP for ISIS."""
                    is_type: str | None
                    node_sid_base: int | None
                    """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                    loopback_ipv4_pool: str | None
                    """IPv4 subnet for Loopback0 allocation."""
                    loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for Loopback0.
                    When set, it takes precedence over `loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                    """
                    vtep_loopback_ipv4_pool: str | None
                    """IPv4 subnet for VTEP-Loopback allocation."""
                    vtep_loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for VTEP-Loopback.
                    When set, it takes precedence over
                    `vtep_loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not
                    catch duplicates.
                    """
                    loopback_ipv4_offset: int | None
                    """
                    Offset all assigned loopback IP addresses.
                    Required when the < loopback_ipv4_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                    """
                    loopback_ipv6_pool: str | None
                    """IPv6 subnet for Loopback0 allocation."""
                    loopback_ipv6_offset: int | None
                    """
                    Offset all assigned loopback IPv6 addresses.
                    Required when the < loopback_ipv6_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid overlapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                    """
                    vtep: bool | None
                    """
                    Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                    Overrides VTEP
                    setting inherited from node_type_keys.
                    """
                    vtep_loopback: str | None
                    """Set VXLAN source interface."""
                    bgp_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    Required with eBGP.
                    """
                    bgp_defaults: list[str]
                    """List of EOS commands to apply to BGP daemon."""
                    evpn_role: str | None
                    """
                    Acting role in EVPN control plane.
                    Default is set in node_type definition from node_type_keys.
                    """
                    evpn_route_servers: list[str]
                    """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                    evpn_services_l2_only: bool | None
                    """
                    Possibility to prevent configuration of Tenant VRFs and SVIs.
                    Override node definition
                    "network_services_l3" from node_type_keys.
                    This allows support for centralized routing.
                    """
                    filter: Filter
                    """
                    Filter L3 and L2 network services based on tenant and tags (and operation filter).
                    If filter is not
                    defined it will default to all.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping on device level."""
                    evpn_gateway: EvpnGateway
                    """
                    Node is acting as EVPN Multi-Domain Gateway.
                    New BGP peer-group is generated between EVPN GWs in
                    different domains or between GWs and Route Servers.
                    Name can be changed under
                    "bgp_peer_groups.evpn_overlay_core" variable.
                    L3 rechability for different EVPN GWs must be already
                    in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                    same Ansible inventory.
                    """
                    ipvpn_gateway: IpvpnGateway
                    """
                    Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                    this is "bgp_peer_groups.ipvpn_gateway_peers".
                    L3 Reachability is required for this to work, the
                    preferred method to establish underlay connectivity is to use core_interfaces.
                    """
                    mlag: bool | None
                    """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                    mlag_dual_primary_detection: bool | None
                    """Enable / Disable MLAG dual primary detection."""
                    mlag_ibgp_origin_incomplete: bool | None
                    """
                    Set origin of routes received from MLAG iBGP peer to incomplete.
                    The purpose is to optimize routing
                    for leaf loopbacks from spine perspective and
                    avoid suboptimal routing via peerlink for control
                    plane traffic.
                    """
                    mlag_interfaces: list[str]
                    """
                    Each list item supports range syntax that can be expanded into a list of interfaces.
                    Required when
                    MLAG leafs are present in the topology.
                    """
                    mlag_interfaces_speed: str | None
                    """
                    Set MLAG interface speed.
                    Speed should be set in the format `<interface_speed>` or `forced
                    <interface_speed>` or `auto <interface_speed>`.
                    """
                    mlag_peer_l3_vlan: int | None
                    """
                    Underlay L3 peering SVI interface id.
                    If set to 0 or the same vlan as mlag_peer_vlan, the
                    mlag_peer_vlan will be used for L3 peering.
                    """
                    mlag_peer_l3_ipv4_pool: str | None
                    """
                    IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                    Required when
                    MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                    """
                    mlag_peer_vlan: int | None
                    """MLAG Peer Link (control link) SVI interface id."""
                    mlag_peer_link_allowed_vlans: str | None
                    mlag_peer_address_family: str | None
                    """
                    IP address family used to establish MLAG Peer Link (control link).
                    `ipv6` requires EOS version
                    4.31.1F or higher.
                    Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                    (ex. `mlag_peer_l3_vlan` set to 4094).
                    """
                    mlag_peer_ipv4_pool: str | None
                    """
                    IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                    """
                    mlag_peer_ipv6_pool: str | None
                    """
                    IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                    """
                    mlag_port_channel_id: int | None
                    """
                    If not set, the mlag port-channel id is generated based on the digits of the first interface present
                    in 'mlag_interfaces'.
                    Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                    999999 > for EOS >= 4.25.0F.
                    """
                    mlag_domain_id: str | None
                    """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                    spanning_tree_mode: str | None
                    spanning_tree_priority: int | None
                    """
                    Spanning-tree priority configured for the selected mode.
                    For `rapid-pvst` the priority can also be
                    set per VLAN under network services.
                    """
                    spanning_tree_root_super: bool | None
                    virtual_router_mac_address: str | None
                    """Virtual router mac address for anycast gateway."""
                    inband_mgmt_interface: str | None
                    """
                    Pointer to interface used for inband management.
                    All configuration must be done using other data
                    models like network services or structured_config.
                    'inband_mgmt_interface' is only used to refer to
                    this interface as source in various management protocol settings (future feature).

                    On L2 switches,
                    this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                    """
                    inband_mgmt_vlan: int | None
                    """
                    VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                    uplinks).
                    When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                    switch as well as all 'uplink_switches'.
                    When using 'inband_mgmt_ip' the VLAN and SVI will only be
                    created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                    created using network services data models.
                    """
                    inband_mgmt_subnet: str | None
                    """
                    Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                    ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      : <subnet> +
                    2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       :
                    <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than total l2leafs + 5
                    Setting is ignored if 'inband_mgmt_ip' is set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ip: str | None
                    """
                    IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                    If this is set the
                    VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN and SVI on
                    the parent switches must be created using network services data models.

                    This setting is applicable
                    to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                    is derived from 'inband_mgmt_subnet' if set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_address: str | None
                    """
                    IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                    If this
                    is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN
                    and SVI on the parent switches must be created using network services data models.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_subnet: str | None
                    """
                    Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                    on ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                    extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      :
                    <subnet> + 2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       : <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than
                    total l2leafs + 5

                    Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf'.
                    Used when `inband_mgmt_ipv6_address` is set.
                    Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_description: str | None
                    """
                    Description configured on the Inband Management SVI.

                    This setting is only applied on the devices
                    where it is set, it does not automatically affect any parent/child devices configuration, so it must
                    be set on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vlan_name: str | None
                    """
                    Name configured on the Inband Management VLAN.
                    This setting is only applied on the devices where it
                    is set, it does not automatically affect any parent/child devices configuration, so it must be set
                    on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vrf: str | None
                    """
                    VRF configured on the Inband Management Interface.
                    The VRF is created if not already created by
                    other means.
                    This setting is only applied on the devices where it is set, it does not automatically
                    affect any parent/child devices configuration, so it must be set on each applicable node/node-
                    group/node-type as needed.
                    """
                    inband_mgmt_mtu: int | None
                    """
                    MTU configured on the Inband Management Interface.
                    This setting is only applied on the devices where
                    it is set, it does not automatically affect any parent/child devices configuration, so it must be
                    set on each applicable node/node-group/node-type as needed.
                    """
                    inband_ztp: bool | None
                    """
                    Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                    inband.
                    This setting also requires that the `inband_mgmt_vlan` is set for the node.
                    """
                    inband_ztp_lacp_fallback_delay: int | None
                    """
                    Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                    ZTP node.
                    This setting also requires that `inband_ztp` is set for the node.
                    """
                    mpls_overlay_role: str | None
                    """
                    Set the default mpls overlay role.
                    Acting role in overlay control plane.
                    """
                    overlay_address_families: list[str]
                    """Set the default overlay address families."""
                    mpls_route_reflectors: list[str]
                    """List of inventory hostname acting as MPLS route-reflectors."""
                    bgp_cluster_id: str | None
                    """Set BGP cluster id."""
                    ptp: Ptp
                    wan_role: str | None
                    """
                    Override the default WAN role.

                    This is used both for AutoVPN and Pathfinder designs.
                    That means if
                    `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                    `server` indicates that the
                    router is a route-reflector.

                    Only supported if `overlay_routing_protocol` is set to `ibgp`.
                    """
                    cv_pathfinder_transit_mode: str | None
                    """
                    Configure the transit mode for a WAN client for CV Pathfinder designs
                    only when the `wan_mode` root
                    key is set to `cv_pathfinder`.

                    'zone' is currently not supported.
                    """
                    cv_pathfinder_region: str | None
                    """
                    The CV Pathfinder region name.
                    This key is required for WAN routers but optional for pathfinders.
                    The region name must be defined under 'cv_pathfinder_regions'.
                    """
                    cv_pathfinder_site: str | None
                    """
                    The CV Pathfinder site name.
                    This key is required for WAN routers but optional for pathfinders.
                    For
                    WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                    relevant region under 'cv_pathfinder_regions'.
                    For pathfinders without `cv_pathfinder_region` set,
                    the site must be defined under `cv_pathfinder_global_sites`.
                    """
                    wan_ha: WanHa
                    """
                    PREVIEW: This key is currently not supported

                    The key is supported only if `wan_mode` == `cv-
                    pathfinder`.
                    AutoVPN support is still to be determined.

                    Maximum 2 devices supported by group for
                    HA.
                    """
                    dps_mss_ipv4: str | None
                    """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                    l3_interfaces: L3Interfaces
                    """
                    L3 Interfaces to configure on the node.
                    Used to define the node for WAN interfaces when
                    `wan_carrier` is set.
                    """
                    data_plane_cpu_allocation_max: int | None
                    """
                    Set the maximum number of CPU used for the data plane.
                    This setting is useful on virtual Route
                    Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                    """
                    flow_tracker_type: str | None
                    """
                    Set the flow tracker type.
                    Override the `default_flow_tracker_type`` set at the `node_type_key`
                    level.
                    `default_flow_tracker_type` default value is `sampled`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        group: str | UndefinedType = Undefined,
                        nodes: Nodes | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        platform: str | None | UndefinedType = Undefined,
                        mac_address: str | None | UndefinedType = Undefined,
                        system_mac_address: str | None | UndefinedType = Undefined,
                        serial_number: str | None | UndefinedType = Undefined,
                        rack: str | None | UndefinedType = Undefined,
                        mgmt_ip: str | None | UndefinedType = Undefined,
                        mgmt_gateway: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                        mgmt_interface: str | None | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                        always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                        uplink_type: str | None | UndefinedType = Undefined,
                        uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                        uplink_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switches: list[str] | UndefinedType = Undefined,
                        uplink_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_mtu: int | None | UndefinedType = Undefined,
                        max_uplink_switches: int | None | UndefinedType = Undefined,
                        max_parallel_uplinks: int | None | UndefinedType = Undefined,
                        uplink_bfd: bool | None | UndefinedType = Undefined,
                        uplink_native_vlan: int | None | UndefinedType = Undefined,
                        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                        uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                        uplink_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_structured_config: dict | UndefinedType = Undefined,
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                        short_esi: str | None | UndefinedType = Undefined,
                        isis_system_id_prefix: str | None | UndefinedType = Undefined,
                        isis_maximum_paths: int | None | UndefinedType = Undefined,
                        is_type: str | None | UndefinedType = Undefined,
                        node_sid_base: int | None | UndefinedType = Undefined,
                        loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                        loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                        vtep: bool | None | UndefinedType = Undefined,
                        vtep_loopback: str | None | UndefinedType = Undefined,
                        bgp_as: str | None | UndefinedType = Undefined,
                        bgp_defaults: list[str] | UndefinedType = Undefined,
                        evpn_role: str | None | UndefinedType = Undefined,
                        evpn_route_servers: list[str] | UndefinedType = Undefined,
                        evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                        ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                        mlag: bool | None | UndefinedType = Undefined,
                        mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                        mlag_interfaces: list[str] | UndefinedType = Undefined,
                        mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                        mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                        mlag_peer_address_family: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                        mlag_port_channel_id: int | None | UndefinedType = Undefined,
                        mlag_domain_id: str | None | UndefinedType = Undefined,
                        spanning_tree_mode: str | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                        virtual_router_mac_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_interface: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                        inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ip: str | None | UndefinedType = Undefined,
                        inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_description: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                        inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                        inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                        inband_ztp: bool | None | UndefinedType = Undefined,
                        inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                        mpls_overlay_role: str | None | UndefinedType = Undefined,
                        overlay_address_families: list[str] | UndefinedType = Undefined,
                        mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                        bgp_cluster_id: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        wan_role: str | None | UndefinedType = Undefined,
                        cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                        cv_pathfinder_region: str | None | UndefinedType = Undefined,
                        cv_pathfinder_site: str | None | UndefinedType = Undefined,
                        wan_ha: WanHa | UndefinedType = Undefined,
                        dps_mss_ipv4: str | None | UndefinedType = Undefined,
                        l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                        data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                        flow_tracker_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodeGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            group:
                               The Node Group Name is used for MLAG domain unless set with 'mlag_domain_id'.
                               The Node Group Name is
                               also used for peer description on downstream switches' uplinks.
                            nodes: Define variables per node.
                            id: Unique identifier used for IP addressing and other algorithms.
                            platform: Arista platform family.
                            mac_address: Leverage to document management interface mac address.
                            system_mac_address:
                               System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                               Set to the same MAC address as
                               available in "show version" on the device.
                               "system_mac_address" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            serial_number:
                               Set to the Serial Number of the device.
                               Only used for documentation purpose in the fabric
                               documentation and part of the structured_config.
                               "serial_number" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            rack: Rack that the switch is located in (only used in snmp_settings location).
                            mgmt_ip: Node management interface IPv4 address.
                            mgmt_gateway:
                               This key sets the management gateway for the device. It takes precedence over the global
                               `mgmt_gateway`.
                            ipv6_mgmt_ip: Node management interface IPv6 address.
                            ipv6_mgmt_gateway:
                               This key sets the ipv6 management gateway for the device. It takes precedence over the global
                               `ipv6_mgmt_gateway`.
                            mgmt_interface:
                               Management Interface Name.
                               Default -> platform_management_interface -> mgmt_interface ->
                               "Management1".
                            link_tracking:
                               This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                               the upstream interfaces.
                               Useful in EVPN multhoming designs.
                            lacp_port_id_range:
                               This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                               number of nodes in the "node_group".
                               Unique LACP port-id ranges are recommended for EVPN Multihoming
                               designs.
                            always_configure_ip_routing:
                               Force configuration of "ip routing" even on L2 devices.
                               Use this to retain behavior of AVD versions
                               below 4.0.0.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.
                            uplink_type:
                               Override the default `uplink_type` set at the `node_type_key` level.
                               `uplink_type` must be "p2p" if
                               `vtep` or `underlay_router` is true for the `node_type_key` definition.
                            uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                            uplink_interfaces:
                               Local uplink interfaces.
                               Each list item supports range syntax that can be expanded into a list of
                               interfaces.
                               If uplink_interfaces is not defined, platform-specific defaults (defined under
                               default_interfaces) will be used instead.
                               Please note that default_interfaces are not defined by
                               default, you should define these yourself.
                            uplink_switch_interfaces: Interfaces located on uplink switches.
                            uplink_switches: uplink_switches
                            uplink_interface_speed:
                               Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                               (Uplink switch
                               interface speed can be overridden with `uplink_switch_interface_speed`).
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_switch_interface_speed:
                               Set point-to-Point interface speed for the uplink switch interface only.
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                            max_uplink_switches:
                               Maximum number of uplink switches.
                               Changing this value may change IP Addressing on uplinks.
                               Can be
                               used to reserve IP space for future expansions.
                            max_parallel_uplinks:
                               Number of parallel links towards uplink switches.
                               Changing this value may change interface naming on
                               uplinks (and corresponding downlinks).
                               Can be used to reserve interfaces for future parallel
                               uplinks.
                            uplink_bfd: Enable bfd on uplink interfaces.
                            uplink_native_vlan:
                               Only applicable to switches with layer-2 port-channel uplinks.
                               A suspended (disabled) vlan will be
                               created in both ends of the link unless the vlan is defined under network services.
                               By default the
                               uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                            uplink_ptp: Enable PTP on all infrastructure links.
                            uplink_macsec: Enable MacSec on all uplinks.
                            uplink_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink Port-channel
                               ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                               For
                               example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [ Eth11/1, Eth22/1 ] -> ID 111
                               For
                               MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                               This
                               option overrides the default behavior and statically sets the local Port-channel ID.
                               Note! Make sure
                               the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                               value.
                            uplink_switch_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink switch Port-
                               channel ID will be set to the number of the first interface defined under
                               `uplink_switch_interfaces`.
                               For example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [
                               Eth11/1, Eth22/1 ] -> ID 111
                               For MLAG port-channels ID will be based on the lowest member interface
                               on the first MLAG switch.
                               This option overrides the default behavior and statically sets the Port-
                               channel ID on the uplink switch.
                               Note! Make sure the ID is unique and does not overlap with
                               autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between
                               1 and 2000 and both MLAG switches must have the same value.
                            uplink_structured_config:
                               Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                               When
                               uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                               for eos_cli_config_gen overrides the settings on the ethernet interface level.
                               When uplink_type ==
                               "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                               eos_cli_config_gen overrides the settings on the port-channel interface level.
                               "uplink_structured_config" is applied after "structured_config", so it can override
                               "structured_config" defined on node-level.
                               Note! The content of this dictionary is _not_ validated
                               by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                            mlag_port_channel_structured_config:
                               Custom structured config applied to MLAG peer link port-channel id.
                               Added under
                               port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the
                               port-channel interface level.
                               "mlag_port_channel_structured_config" is applied after
                               "structured_config", so it can override "structured_config" defined on node-level.
                            mlag_peer_vlan_structured_config:
                               Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                               override "structured_config" defined on node-level.
                            mlag_peer_l3_vlan_structured_config:
                               Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                               can override "structured_config" defined on node-level.
                            short_esi:
                               short_esi only valid for l2leaf devices using port-channel uplink.
                               Setting short_esi to "auto"
                               generates the short_esi automatically using a hash of configuration elements.
                               < 0000:0000:0000 |
                               auto >.
                            isis_system_id_prefix: (4.4 hexadecimal).
                            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                            is_type: is_type
                            node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                            loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                            loopback_ipv4_address:
                               IPv4 address without mask for Loopback0.
                               When set, it takes precedence over `loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                            vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                            vtep_loopback_ipv4_address:
                               IPv4 address without mask for VTEP-Loopback.
                               When set, it takes precedence over
                               `vtep_loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not
                               catch duplicates.
                            loopback_ipv4_offset:
                               Offset all assigned loopback IP addresses.
                               Required when the < loopback_ipv4_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                            loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                            loopback_ipv6_offset:
                               Offset all assigned loopback IPv6 addresses.
                               Required when the < loopback_ipv6_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid overlapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                            vtep:
                               Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                               Overrides VTEP
                               setting inherited from node_type_keys.
                            vtep_loopback: Set VXLAN source interface.
                            bgp_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                               Required with eBGP.
                            bgp_defaults: List of EOS commands to apply to BGP daemon.
                            evpn_role:
                               Acting role in EVPN control plane.
                               Default is set in node_type definition from node_type_keys.
                            evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                            evpn_services_l2_only:
                               Possibility to prevent configuration of Tenant VRFs and SVIs.
                               Override node definition
                               "network_services_l3" from node_type_keys.
                               This allows support for centralized routing.
                            filter:
                               Filter L3 and L2 network services based on tenant and tags (and operation filter).
                               If filter is not
                               defined it will default to all.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                            evpn_gateway:
                               Node is acting as EVPN Multi-Domain Gateway.
                               New BGP peer-group is generated between EVPN GWs in
                               different domains or between GWs and Route Servers.
                               Name can be changed under
                               "bgp_peer_groups.evpn_overlay_core" variable.
                               L3 rechability for different EVPN GWs must be already
                               in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                               same Ansible inventory.
                            ipvpn_gateway:
                               Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                               this is "bgp_peer_groups.ipvpn_gateway_peers".
                               L3 Reachability is required for this to work, the
                               preferred method to establish underlay connectivity is to use core_interfaces.
                            mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                            mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                            mlag_ibgp_origin_incomplete:
                               Set origin of routes received from MLAG iBGP peer to incomplete.
                               The purpose is to optimize routing
                               for leaf loopbacks from spine perspective and
                               avoid suboptimal routing via peerlink for control
                               plane traffic.
                            mlag_interfaces:
                               Each list item supports range syntax that can be expanded into a list of interfaces.
                               Required when
                               MLAG leafs are present in the topology.
                            mlag_interfaces_speed:
                               Set MLAG interface speed.
                               Speed should be set in the format `<interface_speed>` or `forced
                               <interface_speed>` or `auto <interface_speed>`.
                            mlag_peer_l3_vlan:
                               Underlay L3 peering SVI interface id.
                               If set to 0 or the same vlan as mlag_peer_vlan, the
                               mlag_peer_vlan will be used for L3 peering.
                            mlag_peer_l3_ipv4_pool:
                               IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                               Required when
                               MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                            mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                            mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                            mlag_peer_address_family:
                               IP address family used to establish MLAG Peer Link (control link).
                               `ipv6` requires EOS version
                               4.31.1F or higher.
                               Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                               (ex. `mlag_peer_l3_vlan` set to 4094).
                            mlag_peer_ipv4_pool:
                               IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                            mlag_peer_ipv6_pool:
                               IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                            mlag_port_channel_id:
                               If not set, the mlag port-channel id is generated based on the digits of the first interface present
                               in 'mlag_interfaces'.
                               Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                               999999 > for EOS >= 4.25.0F.
                            mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                            spanning_tree_mode: spanning_tree_mode
                            spanning_tree_priority:
                               Spanning-tree priority configured for the selected mode.
                               For `rapid-pvst` the priority can also be
                               set per VLAN under network services.
                            spanning_tree_root_super: spanning_tree_root_super
                            virtual_router_mac_address: Virtual router mac address for anycast gateway.
                            inband_mgmt_interface:
                               Pointer to interface used for inband management.
                               All configuration must be done using other data
                               models like network services or structured_config.
                               'inband_mgmt_interface' is only used to refer to
                               this interface as source in various management protocol settings (future feature).

                               On L2 switches,
                               this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                            inband_mgmt_vlan:
                               VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                               uplinks).
                               When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                               switch as well as all 'uplink_switches'.
                               When using 'inband_mgmt_ip' the VLAN and SVI will only be
                               created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                               created using network services data models.
                            inband_mgmt_subnet:
                               Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                               ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      : <subnet> +
                               2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       :
                               <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than total l2leafs + 5
                               Setting is ignored if 'inband_mgmt_ip' is set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ip:
                               IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                               If this is set the
                               VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN and SVI on
                               the parent switches must be created using network services data models.

                               This setting is applicable
                               to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                               is derived from 'inband_mgmt_subnet' if set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_address:
                               IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                               If this
                               is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN
                               and SVI on the parent switches must be created using network services data models.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_subnet:
                               Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                               on ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                               extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      :
                               <subnet> + 2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       : <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than
                               total l2leafs + 5

                               Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf'.
                               Used when `inband_mgmt_ipv6_address` is set.
                               Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_description:
                               Description configured on the Inband Management SVI.

                               This setting is only applied on the devices
                               where it is set, it does not automatically affect any parent/child devices configuration, so it must
                               be set on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vlan_name:
                               Name configured on the Inband Management VLAN.
                               This setting is only applied on the devices where it
                               is set, it does not automatically affect any parent/child devices configuration, so it must be set
                               on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vrf:
                               VRF configured on the Inband Management Interface.
                               The VRF is created if not already created by
                               other means.
                               This setting is only applied on the devices where it is set, it does not automatically
                               affect any parent/child devices configuration, so it must be set on each applicable node/node-
                               group/node-type as needed.
                            inband_mgmt_mtu:
                               MTU configured on the Inband Management Interface.
                               This setting is only applied on the devices where
                               it is set, it does not automatically affect any parent/child devices configuration, so it must be
                               set on each applicable node/node-group/node-type as needed.
                            inband_ztp:
                               Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                               inband.
                               This setting also requires that the `inband_mgmt_vlan` is set for the node.
                            inband_ztp_lacp_fallback_delay:
                               Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                               ZTP node.
                               This setting also requires that `inband_ztp` is set for the node.
                            mpls_overlay_role:
                               Set the default mpls overlay role.
                               Acting role in overlay control plane.
                            overlay_address_families: Set the default overlay address families.
                            mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                            bgp_cluster_id: Set BGP cluster id.
                            ptp: ptp
                            wan_role:
                               Override the default WAN role.

                               This is used both for AutoVPN and Pathfinder designs.
                               That means if
                               `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                               `server` indicates that the
                               router is a route-reflector.

                               Only supported if `overlay_routing_protocol` is set to `ibgp`.
                            cv_pathfinder_transit_mode:
                               Configure the transit mode for a WAN client for CV Pathfinder designs
                               only when the `wan_mode` root
                               key is set to `cv_pathfinder`.

                               'zone' is currently not supported.
                            cv_pathfinder_region:
                               The CV Pathfinder region name.
                               This key is required for WAN routers but optional for pathfinders.
                               The region name must be defined under 'cv_pathfinder_regions'.
                            cv_pathfinder_site:
                               The CV Pathfinder site name.
                               This key is required for WAN routers but optional for pathfinders.
                               For
                               WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                               relevant region under 'cv_pathfinder_regions'.
                               For pathfinders without `cv_pathfinder_region` set,
                               the site must be defined under `cv_pathfinder_global_sites`.
                            wan_ha:
                               PREVIEW: This key is currently not supported

                               The key is supported only if `wan_mode` == `cv-
                               pathfinder`.
                               AutoVPN support is still to be determined.

                               Maximum 2 devices supported by group for
                               HA.
                            dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                            l3_interfaces:
                               L3 Interfaces to configure on the node.
                               Used to define the node for WAN interfaces when
                               `wan_carrier` is set.
                            data_plane_cpu_allocation_max:
                               Set the maximum number of CPU used for the data plane.
                               This setting is useful on virtual Route
                               Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                            flow_tracker_type:
                               Set the flow tracker type.
                               Override the `default_flow_tracker_type`` set at the `node_type_key`
                               level.
                               `default_flow_tracker_type` default value is `sampled`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodeGroups(AvdCollection[str, NodeGroupsItem]):
                    _primary_key: ClassVar[str] = "group"

                NodeGroups._item_type = NodeGroupsItem

                class NodesItem(AvdModel):
                    class DownlinkPoolsItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "ipv4_pool": {"type": str},
                            "downlink_interfaces": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        ipv4_pool: str | None
                        """IPv4 pool from which subnets will be allocated for links to downlink switches."""
                        downlink_interfaces: list[str]
                        """
                        List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                        this list will determine which subnet will be taken from the pool.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ipv4_pool: str | None | UndefinedType = Undefined,
                            downlink_interfaces: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DownlinkPoolsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ipv4_pool: IPv4 pool from which subnets will be allocated for links to downlink switches.
                                downlink_interfaces:
                                   List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                                   this list will determine which subnet will be taken from the pool.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LinkTracking(AvdModel):
                        class GroupsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "name": {"type": str},
                                "recovery_delay": {"type": int},
                                "links_minimum": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            name: str | None
                            """Tracking group name."""
                            recovery_delay: int | None
                            """default -> platform_settings_mlag_reload_delay -> 300."""
                            links_minimum: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                recovery_delay: int | None | UndefinedType = Undefined,
                                links_minimum: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                GroupsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    name: Tracking group name.
                                    recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                    links_minimum: links_minimum

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "groups": {
                                "type": list,
                                "items": GroupsItem,
                                "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                            },
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        groups: list[GroupsItem]
                        """
                        Link Tracking Groups.
                        By default a single group named "LT_GROUP1" is defined with default values.
                        Any groups defined under "groups" will replace the default.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            groups: list[GroupsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                groups:
                                   Link Tracking Groups.
                                   By default a single group named "LT_GROUP1" is defined with default values.
                                   Any groups defined under "groups" will replace the default.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LacpPortIdRange(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "size": {"type": int, "default": 128},
                            "offset": {"type": int, "default": 0},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        size: int | None
                        """Recommended size > = number of ports in the switch."""
                        offset: int | None
                        """
                        Offset is used to avoid overlapping port-id ranges of different switches.
                        Useful when a "connected-
                        endpoint" is connected to switches in different "node_groups".
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            offset: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LacpPortIdRange.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                size: Recommended size > = number of ports in the switch.
                                offset:
                                   Offset is used to avoid overlapping port-id ranges of different switches.
                                   Useful when a "connected-
                                   endpoint" is connected to switches in different "node_groups".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    class UplinkPtp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enable: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkPtp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enable: enable

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UplinkMacsec(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        profile: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkMacsec.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: profile

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                        pass

                    class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class Filter(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "tenants": {"type": list, "items": str, "default": ["all"]},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "always_include_vrfs_in_tenants": {"type": list, "items": str},
                            "only_vlans_in_use": {"type": bool, "default": False},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        tenants: list[str]
                        """
                        Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                        Tenants (default).
                        This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                        """
                        tags: list[str]
                        """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                        allow_vrfs: list[str]
                        """
                        Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                        (default).
                        This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                        """
                        deny_vrfs: list[str]
                        """
                        Prevent configuration of Network Services defined under these VRFs.
                        This list prevents the given
                        VRFs to be included by any other filtering mechanism.
                        """
                        always_include_vrfs_in_tenants: list[str]
                        """
                        List of tenants where VRFs will be configured even if VLANs are not included in tags.
                        Useful for L3
                        "border" leaf.
                        """
                        only_vlans_in_use: bool | None
                        """
                        Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                        Note! This
                        feature only considers configuration managed by eos_designs.
                        This excludes structured_config,
                        custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            tenants: list[str] | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            allow_vrfs: list[str] | UndefinedType = Undefined,
                            deny_vrfs: list[str] | UndefinedType = Undefined,
                            always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                            only_vlans_in_use: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.

                            Args:
                            -----
                                _custom_data: _custom_data
                                tenants:
                                   Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                   Tenants (default).
                                   This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                allow_vrfs:
                                   Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                   (default).
                                   This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                deny_vrfs:
                                   Prevent configuration of Network Services defined under these VRFs.
                                   This list prevents the given
                                   VRFs to be included by any other filtering mechanism.
                                always_include_vrfs_in_tenants:
                                   List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                   Useful for L3
                                   "border" leaf.
                                only_vlans_in_use:
                                   Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                   Note! This
                                   feature only considers configuration managed by eos_designs.
                                   This excludes structured_config,
                                   custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            hostname: str | None
                            """Hostname of remote EVPN GW server."""
                            ip_address: str | None
                            """Peering IP of remote Route Server."""
                            bgp_as: str | None
                            """
                            Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                            interpreted as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                bgp_as: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote EVPN GW server.
                                    ip_address: Peering IP of remote Route Server.
                                    bgp_as:
                                       Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                       interpreted as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL2(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL2.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "inter_domain": {"type": bool, "default": True},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            inter_domain: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                inter_domain: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL3.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    inter_domain: inter_domain

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                            "evpn_l2": {"type": EvpnL2},
                            "evpn_l3": {"type": EvpnL3},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_peers: list[RemotePeersItem]
                        """
                        Define remote peers of the EVPN VXLAN Gateway.
                        If the hostname can be found in the inventory,
                        ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                        If the
                        peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                        """
                        evpn_l2: EvpnL2
                        """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                        evpn_l3: EvpnL3
                        """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            evpn_l2: EvpnL2 | UndefinedType = Undefined,
                            evpn_l3: EvpnL3 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_peers:
                                   Define remote peers of the EVPN VXLAN Gateway.
                                   If the hostname can be found in the inventory,
                                   ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                   If the
                                   peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                            _custom_data: dict[str, Any]
                            hostname: str
                            """Hostname of remote IPVPN Peer."""
                            ip_address: str
                            """Peering IP of remote IPVPN Peer."""
                            bgp_as: str
                            """
                            Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For
                            asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                            as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | UndefinedType = Undefined,
                                ip_address: str | UndefinedType = Undefined,
                                bgp_as: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote IPVPN Peer.
                                    ip_address: Peering IP of remote IPVPN Peer.
                                    bgp_as:
                                       Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For
                                       asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                       as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_domain_id": {"type": str, "default": "65535:1"},
                            "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                            "enable_d_path": {"type": bool, "default": True},
                            "maximum_routes": {"type": int, "default": 0},
                            "local_as": {"type": str, "default": "none"},
                            "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        evpn_domain_id: str | None
                        """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                        ipvpn_domain_id: str | None
                        """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                        enable_d_path: bool | None
                        """Enable D-path for use with BGP bestpath selection algorithm."""
                        maximum_routes: int | None
                        """Maximum routes to accept from IPVPN remote peers."""
                        local_as: str | None
                        """
                        Local BGP AS applied to peering with IPVPN remote peers.
                        BGP AS <1-4294967295> or AS number in asdot
                        notation "<1-65535>.<0-65535>".
                        For asdot notation in YAML inputs, the value must be put in quotes,
                        to prevent it from being interpreted as a float number.
                        """
                        address_families: list[str]
                        """IPVPN address families to enable for remote peers."""
                        remote_peers: list[RemotePeersItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            evpn_domain_id: str | None | UndefinedType = Undefined,
                            ipvpn_domain_id: str | None | UndefinedType = Undefined,
                            enable_d_path: bool | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            address_families: list[str] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                local_as:
                                   Local BGP AS applied to peering with IPVPN remote peers.
                                   BGP AS <1-4294967295> or AS number in asdot
                                   notation "<1-65535>.<0-65535>".
                                   For asdot notation in YAML inputs, the value must be put in quotes,
                                   to prevent it from being interpreted as a float number.
                                address_families: IPVPN address families to enable for remote peers.
                                remote_peers: remote_peers

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        class Dscp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            general_messages: int | None
                            event_messages: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                general_messages: int | None | UndefinedType = Undefined,
                                event_messages: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dscp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    general_messages: general_messages
                                    event_messages: event_messages

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Monitor(AvdModel):
                            class Threshold(AvdModel):
                                class Drop(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int},
                                        "mean_path_delay": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Drop.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "offset_from_master": {"type": int, "default": 250},
                                    "mean_path_delay": {"type": int, "default": 1500},
                                    "drop": {"type": Drop},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                offset_from_master: int | None
                                mean_path_delay: int | None
                                drop: Drop

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    offset_from_master: int | None | UndefinedType = Undefined,
                                    mean_path_delay: int | None | UndefinedType = Undefined,
                                    drop: Drop | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Threshold.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        offset_from_master: offset_from_master
                                        mean_path_delay: mean_path_delay
                                        drop: drop

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class MissingMessage(AvdModel):
                                class Intervals(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "announce": {"type": int},
                                        "follow_up": {"type": int},
                                        "sync": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    announce: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Intervals.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            announce: announce
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class SequenceIds(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "enabled": {"type": bool, "default": True},
                                        "announce": {"type": int, "default": 3},
                                        "delay_resp": {"type": int, "default": 3},
                                        "follow_up": {"type": int, "default": 3},
                                        "sync": {"type": int, "default": 3},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    enabled: bool | None
                                    announce: int | None
                                    delay_resp: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        enabled: bool | None | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        delay_resp: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        SequenceIds.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            enabled: enabled
                                            announce: announce
                                            delay_resp: delay_resp
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "intervals": {"type": Intervals},
                                    "sequence_ids": {"type": SequenceIds},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                intervals: Intervals
                                sequence_ids: SequenceIds

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    intervals: Intervals | UndefinedType = Undefined,
                                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MissingMessage.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        intervals: intervals
                                        sequence_ids: sequence_ids

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "threshold": {"type": Threshold},
                                "missing_message": {"type": MissingMessage},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            threshold: Threshold
                            missing_message: MissingMessage

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                threshold: Threshold | UndefinedType = Undefined,
                                missing_message: MissingMessage | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Monitor.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    threshold: threshold
                                    missing_message: missing_message

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                            "mlag": {"type": bool, "default": False},
                            "domain": {"type": int, "default": 127},
                            "priority1": {"type": int},
                            "priority2": {"type": int},
                            "auto_clock_identity": {"type": bool, "default": True},
                            "clock_identity_prefix": {"type": str},
                            "clock_identity": {"type": str},
                            "source_ip": {"type": str},
                            "mode": {"type": str, "default": "boundary"},
                            "mode_one_step": {"type": bool, "default": False},
                            "ttl": {"type": int},
                            "forward_unicast": {"type": bool, "default": False},
                            "dscp": {"type": Dscp},
                            "monitor": {"type": Monitor},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """
                        mlag: bool | None
                        """
                        Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                        configured on the MLAG peer-link port-channel.
                        """
                        domain: int | None
                        priority1: int | None
                        """default -> automatically set based on node_type."""
                        priority2: int | None
                        """default -> (node_id modulus 256)."""
                        auto_clock_identity: bool | None
                        """
                        If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                        default EOS behaviour, simply disable the automatic PTP clock identity.
                        default ->
                        (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                        HEX).
                        """
                        clock_identity_prefix: str | None
                        """
                        PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                        By default the 3-byte prefix is "00:1C:73".
                        This
                        can be overridden if auto_clock_identity is set to true (which is the default).
                        """
                        clock_identity: str | None
                        """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                        source_ip: str | None
                        """
                        By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                        relevant SVI, which is the recommended behaviour.
                        This can be set manually if required, for example,
                        to a value of "10.1.2.3".
                        """
                        mode: str | None
                        mode_one_step: bool | None
                        ttl: int | None
                        forward_unicast: bool | None
                        """Enable PTP unicast forwarding."""
                        dscp: Dscp
                        monitor: Monitor

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            domain: int | None | UndefinedType = Undefined,
                            priority1: int | None | UndefinedType = Undefined,
                            priority2: int | None | UndefinedType = Undefined,
                            auto_clock_identity: bool | None | UndefinedType = Undefined,
                            clock_identity_prefix: str | None | UndefinedType = Undefined,
                            clock_identity: str | None | UndefinedType = Undefined,
                            source_ip: str | None | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            mode_one_step: bool | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            forward_unicast: bool | None | UndefinedType = Undefined,
                            dscp: Dscp | UndefinedType = Undefined,
                            monitor: Monitor | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"
                                mlag:
                                   Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                   configured on the MLAG peer-link port-channel.
                                domain: domain
                                priority1: default -> automatically set based on node_type.
                                priority2: default -> (node_id modulus 256).
                                auto_clock_identity:
                                   If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                   default EOS behaviour, simply disable the automatic PTP clock identity.
                                   default ->
                                   (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                   HEX).
                                clock_identity_prefix:
                                   PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                   By default the 3-byte prefix is "00:1C:73".
                                   This
                                   can be overridden if auto_clock_identity is set to true (which is the default).
                                clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                source_ip:
                                   By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                   relevant SVI, which is the recommended behaviour.
                                   This can be set manually if required, for example,
                                   to a value of "10.1.2.3".
                                mode: mode
                                mode_one_step: mode_one_step
                                ttl: ttl
                                forward_unicast: Enable PTP unicast forwarding.
                                dscp: dscp
                                monitor: monitor

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class WanHa(AvdModel):
                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": True},
                            "ipsec": {"type": bool, "default": True},
                            "mtu": {"type": int, "default": 9194},
                            "ha_interfaces": {"type": list, "items": str},
                            "ha_ipv4_pool": {"type": str},
                            "max_ha_interfaces": {"type": int},
                            "port_channel_id": {"type": int},
                            "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                            "flow_tracking": {"type": FlowTracking},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                        ipsec: bool | None
                        """Enable / Disable IPsec over HA path-group when HA is enabled."""
                        mtu: int | None
                        """Set MTU on WAN HA interfaces."""
                        ha_interfaces: list[str]
                        """
                        Local WAN HA interfaces
                        Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                        Can be used to filter uplink interfaces when there are multiple uplinks.
                        Limitations:
                          Either all
                        interfaces must be uplinks or all interfaces must not be uplinks.
                          Only one interface is supported
                        for non uplinks.
                        """
                        ha_ipv4_pool: str | None
                        """
                        IP address pool used for WAN HA connectivity.
                        IP is derived from the node ID.
                        Not used for uplink
                        interfaces.
                        """
                        max_ha_interfaces: int | None
                        """
                        Number of parallel links towards HA switches.
                        Can be used to reserve IP addresses for future
                        parallel HA links.
                        """
                        port_channel_id: int | None
                        """Port-channel ID to use for direct HA."""
                        use_port_channel_for_direct_ha: bool | None
                        """
                        Enable or disable using a port-channel interface for direct HA when there is only one interface.
                        This feature was introduced in EOS 4.33.0F.
                        """
                        flow_tracking: FlowTracking
                        """
                        Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                        setting.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ipsec: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ha_interfaces: list[str] | UndefinedType = Undefined,
                            ha_ipv4_pool: str | None | UndefinedType = Undefined,
                            max_ha_interfaces: int | None | UndefinedType = Undefined,
                            port_channel_id: int | None | UndefinedType = Undefined,
                            use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WanHa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                mtu: Set MTU on WAN HA interfaces.
                                ha_interfaces:
                                   Local WAN HA interfaces
                                   Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                   Can be used to filter uplink interfaces when there are multiple uplinks.
                                   Limitations:
                                     Either all
                                   interfaces must be uplinks or all interfaces must not be uplinks.
                                     Only one interface is supported
                                   for non uplinks.
                                ha_ipv4_pool:
                                   IP address pool used for WAN HA connectivity.
                                   IP is derived from the node ID.
                                   Not used for uplink
                                   interfaces.
                                max_ha_interfaces:
                                   Number of parallel links towards HA switches.
                                   Can be used to reserve IP addresses for future
                                   parallel HA links.
                                port_channel_id: Port-channel ID to use for direct HA.
                                use_port_channel_for_direct_ha:
                                   Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                   This feature was introduced in EOS 4.33.0F.
                                flow_tracking:
                                   Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                   setting.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Bgp(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "peer_as": {"type": str},
                                "ipv4_prefix_list_in": {"type": str},
                                "ipv4_prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                            _custom_data: dict[str, Any]
                            peer_as: str
                            """
                            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in
                            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                            number.
                            """
                            ipv4_prefix_list_in: str | None
                            """
                            Prefix List Name. Accept routes for only these prefixes from the peer.
                            Required for wan interfaces.
                            """
                            ipv4_prefix_list_out: str | None
                            """
                            Prefix List Name. Advertise routes for only these prefixes.
                            If not specified, nothing would be
                            advertised.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                peer_as: str | UndefinedType = Undefined,
                                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    peer_as:
                                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in
                                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                       number.
                                    ipv4_prefix_list_in:
                                       Prefix List Name. Accept routes for only these prefixes from the peer.
                                       Required for wan interfaces.
                                    ipv4_prefix_list_out:
                                       Prefix List Name. Advertise routes for only these prefixes.
                                       If not specified, nothing would be
                                       advertised.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StaticRoutesItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                            _custom_data: dict[str, Any]
                            prefix: str
                            """IPv4_network/Mask."""

                            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                                """
                                StaticRoutesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    prefix: IPv4_network/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class CvPathfinderInternetExit(AvdModel):
                            class PoliciesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                _custom_data: dict[str, Any]
                                name: str
                                """Internet-exit policy name."""
                                tunnel_interface_numbers: str | None
                                """
                                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                interface.
                                Examples: '1-3' or '100,200,300'
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | UndefinedType = Undefined,
                                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PoliciesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Internet-exit policy name.
                                        tunnel_interface_numbers:
                                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                           interface.
                                           Examples: '1-3' or '100,200,300'

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Policies(AvdCollection[str, PoliciesItem]):
                                _primary_key: ClassVar[str] = "name"

                            Policies._item_type = PoliciesItem

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            policies: Policies
                            """List of Internet-exit policies using this interface as exit."""

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                            ) -> None:
                                """
                                CvPathfinderInternetExit.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    policies: List of Internet-exit policies using this interface as exit.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "profile": {"type": str},
                            "name": {"type": str},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "dhcp_ip": {"type": str},
                            "public_ip": {"type": str},
                            "encapsulation_dot1q_vlan": {"type": int},
                            "dhcp_accept_default_route": {"type": bool, "default": True},
                            "enabled": {"type": bool, "default": True},
                            "speed": {"type": str},
                            "peer": {"type": str},
                            "peer_interface": {"type": str},
                            "peer_ip": {"type": str},
                            "bgp": {"type": Bgp},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "static_routes": {"type": list, "items": StaticRoutesItem},
                            "qos_profile": {"type": str},
                            "wan_carrier": {"type": str},
                            "wan_circuit_id": {"type": str},
                            "connected_to_pathfinder": {"type": bool, "default": True},
                            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                            "raw_eos_cli": {"type": str},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        profile: str | None
                        """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                        name: str
                        """
                        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                        For a
                        subinterface, the parent physical interface is automatically created.
                        """
                        description: str | None
                        """
                        Interface description.
                        If not set a default description will be configured with '[<peer>[
                        <peer_interface>]]'.
                        """
                        ip_address: str | None
                        """Node IPv4 address/Mask or 'dhcp'."""
                        dhcp_ip: str | None
                        """
                        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                        IPv4 address
                        (without mask) to be allocated on the interface if known.
                        This is not rendered in the configuration
                        but can be used for substitution of 'interface_ip' in the Access-list
                        set under `ipv4_acl_in` and
                        `ipv4_acl_out`.
                        """
                        public_ip: str | None
                        """
                        Node IPv4 address (no mask).

                        This is used to get the public IP (if known) when the device is behind
                        NAT.
                        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                        with the following preference:
                          `wan_route_servers.path_groups.interfaces.ip_address`
                              ->
                        `l3_interfaces.public_ip`
                                  -> `l3_interfaces.ip_address`

                        The determined Public IP is used
                        by WAN routers when peering with this interface.
                        """
                        encapsulation_dot1q_vlan: int | None
                        """
                        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        dhcp_accept_default_route: bool | None
                        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                        enabled: bool | None
                        """Enable or Shutdown the interface."""
                        speed: str | None
                        """
                        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                        <interface_speed>`.
                        """
                        peer: str | None
                        """The peer device name. Used for description and documentation."""
                        peer_interface: str | None
                        """The peer device interface. Used for description and documentation."""
                        peer_ip: str | None
                        """
                        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                        and `ip` is an IP address.
                        """
                        bgp: Bgp
                        """Enforce IPv4 BGP peering for the peer"""
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        Required
                        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                        `wan_carriers`.
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        """
                        static_routes: list[StaticRoutesItem]
                        """Configure IPv4 static routes pointing to `peer_ip`."""
                        qos_profile: str | None
                        """QOS service profile."""
                        wan_carrier: str | None
                        """
                        The WAN carrier this interface is connected to.
                        This is used to infer the path-groups in which this
                        interface should be configured.
                        Unless the carrier is marked as 'trusted' under `wan_carriers`,
                        `ipv4_acl_in` is also required on all WAN interfaces.
                        """
                        wan_circuit_id: str | None
                        """
                        The WAN circuit ID for this interface.
                        This is not rendered in the configuration but used for WAN
                        designs.
                        """
                        connected_to_pathfinder: bool | None
                        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                        cv_pathfinder_internet_exit: CvPathfinderInternetExit
                        """PREVIEW: This key is in preview mode"""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the interface in the final EOS configuration."""
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config for the Ethernet interface."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            dhcp_ip: str | None | UndefinedType = Undefined,
                            public_ip: str | None | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            speed: str | None | UndefinedType = Undefined,
                            peer: str | None | UndefinedType = Undefined,
                            peer_interface: str | None | UndefinedType = Undefined,
                            peer_ip: str | None | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                            qos_profile: str | None | UndefinedType = Undefined,
                            wan_carrier: str | None | UndefinedType = Undefined,
                            wan_circuit_id: str | None | UndefinedType = Undefined,
                            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                name:
                                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                   For a
                                   subinterface, the parent physical interface is automatically created.
                                description:
                                   Interface description.
                                   If not set a default description will be configured with '[<peer>[
                                   <peer_interface>]]'.
                                ip_address: Node IPv4 address/Mask or 'dhcp'.
                                dhcp_ip:
                                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                   IPv4 address
                                   (without mask) to be allocated on the interface if known.
                                   This is not rendered in the configuration
                                   but can be used for substitution of 'interface_ip' in the Access-list
                                   set under `ipv4_acl_in` and
                                   `ipv4_acl_out`.
                                public_ip:
                                   Node IPv4 address (no mask).

                                   This is used to get the public IP (if known) when the device is behind
                                   NAT.
                                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                   with the following preference:
                                     `wan_route_servers.path_groups.interfaces.ip_address`
                                         ->
                                   `l3_interfaces.public_ip`
                                             -> `l3_interfaces.ip_address`

                                   The determined Public IP is used
                                   by WAN routers when peering with this interface.
                                encapsulation_dot1q_vlan:
                                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                enabled: Enable or Shutdown the interface.
                                speed:
                                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                   <interface_speed>`.
                                peer: The peer device name. Used for description and documentation.
                                peer_interface: The peer device interface. Used for description and documentation.
                                peer_ip:
                                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                   and `ip` is an IP address.
                                bgp: Enforce IPv4 BGP peering for the peer
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                   Required
                                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                   `wan_carriers`.
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                qos_profile: QOS service profile.
                                wan_carrier:
                                   The WAN carrier this interface is connected to.
                                   This is used to infer the path-groups in which this
                                   interface should be configured.
                                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                   `ipv4_acl_in` is also required on all WAN interfaces.
                                wan_circuit_id:
                                   The WAN circuit ID for this interface.
                                   This is not rendered in the configuration but used for WAN
                                   designs.
                                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config for the Ethernet interface.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                        _primary_key: ClassVar[str] = "name"

                    L3Interfaces._item_type = L3InterfacesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "downlink_pools": {"type": list, "items": DownlinkPoolsItem},
                        "id": {"type": int},
                        "platform": {"type": str},
                        "mac_address": {"type": str},
                        "system_mac_address": {"type": str},
                        "serial_number": {"type": str},
                        "rack": {"type": str},
                        "mgmt_ip": {"type": str},
                        "mgmt_gateway": {"type": str},
                        "ipv6_mgmt_ip": {"type": str},
                        "ipv6_mgmt_gateway": {"type": str},
                        "mgmt_interface": {"type": str},
                        "link_tracking": {"type": LinkTracking},
                        "lacp_port_id_range": {"type": LacpPortIdRange},
                        "always_configure_ip_routing": {"type": bool, "default": False},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                        "uplink_type": {"type": str, "default": "p2p"},
                        "uplink_ipv4_pool": {"type": str},
                        "uplink_interfaces": {"type": list, "items": str},
                        "uplink_switch_interfaces": {"type": list, "items": str},
                        "uplink_switches": {"type": list, "items": str},
                        "uplink_interface_speed": {"type": str},
                        "uplink_switch_interface_speed": {"type": str},
                        "uplink_mtu": {"type": int},
                        "max_uplink_switches": {"type": int},
                        "max_parallel_uplinks": {"type": int},
                        "uplink_bfd": {"type": bool, "default": False},
                        "uplink_native_vlan": {"type": int},
                        "uplink_ptp": {"type": UplinkPtp},
                        "uplink_macsec": {"type": UplinkMacsec},
                        "uplink_port_channel_id": {"type": int},
                        "uplink_switch_port_channel_id": {"type": int},
                        "uplink_structured_config": {"type": dict},
                        "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                        "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                        "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                        "short_esi": {"type": str},
                        "isis_system_id_prefix": {"type": str},
                        "isis_maximum_paths": {"type": int},
                        "is_type": {"type": str, "default": "level-2"},
                        "node_sid_base": {"type": int, "default": 0},
                        "loopback_ipv4_pool": {"type": str},
                        "loopback_ipv4_address": {"type": str},
                        "vtep_loopback_ipv4_pool": {"type": str},
                        "vtep_loopback_ipv4_address": {"type": str},
                        "loopback_ipv4_offset": {"type": int, "default": 0},
                        "loopback_ipv6_pool": {"type": str},
                        "loopback_ipv6_offset": {"type": int, "default": 0},
                        "vtep": {"type": bool},
                        "vtep_loopback": {"type": str},
                        "bgp_as": {"type": str},
                        "bgp_defaults": {"type": list, "items": str},
                        "evpn_role": {"type": str},
                        "evpn_route_servers": {"type": list, "items": str},
                        "evpn_services_l2_only": {"type": bool, "default": False},
                        "filter": {"type": Filter},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "evpn_gateway": {"type": EvpnGateway},
                        "ipvpn_gateway": {"type": IpvpnGateway},
                        "mlag": {"type": bool, "default": True},
                        "mlag_dual_primary_detection": {"type": bool, "default": False},
                        "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                        "mlag_interfaces": {"type": list, "items": str},
                        "mlag_interfaces_speed": {"type": str},
                        "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                        "mlag_peer_l3_ipv4_pool": {"type": str},
                        "mlag_peer_vlan": {"type": int, "default": 4094},
                        "mlag_peer_link_allowed_vlans": {"type": str},
                        "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                        "mlag_peer_ipv4_pool": {"type": str},
                        "mlag_peer_ipv6_pool": {"type": str},
                        "mlag_port_channel_id": {"type": int},
                        "mlag_domain_id": {"type": str},
                        "spanning_tree_mode": {"type": str},
                        "spanning_tree_priority": {"type": int, "default": 32768},
                        "spanning_tree_root_super": {"type": bool, "default": False},
                        "virtual_router_mac_address": {"type": str},
                        "inband_mgmt_interface": {"type": str},
                        "inband_mgmt_vlan": {"type": int, "default": 4092},
                        "inband_mgmt_subnet": {"type": str},
                        "inband_mgmt_ip": {"type": str},
                        "inband_mgmt_gateway": {"type": str},
                        "inband_mgmt_ipv6_address": {"type": str},
                        "inband_mgmt_ipv6_subnet": {"type": str},
                        "inband_mgmt_ipv6_gateway": {"type": str},
                        "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vrf": {"type": str, "default": "default"},
                        "inband_mgmt_mtu": {"type": int, "default": 1500},
                        "inband_ztp": {"type": bool, "default": False},
                        "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                        "mpls_overlay_role": {"type": str},
                        "overlay_address_families": {"type": list, "items": str},
                        "mpls_route_reflectors": {"type": list, "items": str},
                        "bgp_cluster_id": {"type": str},
                        "ptp": {"type": Ptp},
                        "wan_role": {"type": str},
                        "cv_pathfinder_transit_mode": {"type": str},
                        "cv_pathfinder_region": {"type": str},
                        "cv_pathfinder_site": {"type": str},
                        "wan_ha": {"type": WanHa},
                        "dps_mss_ipv4": {"type": str, "default": "auto"},
                        "l3_interfaces": {"type": L3Interfaces},
                        "data_plane_cpu_allocation_max": {"type": int},
                        "flow_tracker_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """The Node Name is used as "hostname"."""
                    downlink_pools: list[DownlinkPoolsItem]
                    """
                    IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                    with `uplink_ipv4_pool` set on the downlink switch.
                    """
                    id: int | None
                    """Unique identifier used for IP addressing and other algorithms."""
                    platform: str | None
                    """Arista platform family."""
                    mac_address: str | None
                    """Leverage to document management interface mac address."""
                    system_mac_address: str | None
                    """
                    System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                    Set to the same MAC address as
                    available in "show version" on the device.
                    "system_mac_address" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    serial_number: str | None
                    """
                    Set to the Serial Number of the device.
                    Only used for documentation purpose in the fabric
                    documentation and part of the structured_config.
                    "serial_number" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    rack: str | None
                    """Rack that the switch is located in (only used in snmp_settings location)."""
                    mgmt_ip: str | None
                    """Node management interface IPv4 address."""
                    mgmt_gateway: str | None
                    """
                    This key sets the management gateway for the device. It takes precedence over the global
                    `mgmt_gateway`.
                    """
                    ipv6_mgmt_ip: str | None
                    """Node management interface IPv6 address."""
                    ipv6_mgmt_gateway: str | None
                    """
                    This key sets the ipv6 management gateway for the device. It takes precedence over the global
                    `ipv6_mgmt_gateway`.
                    """
                    mgmt_interface: str | None
                    """
                    Management Interface Name.
                    Default -> platform_management_interface -> mgmt_interface ->
                    "Management1".
                    """
                    link_tracking: LinkTracking
                    """
                    This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                    the upstream interfaces.
                    Useful in EVPN multhoming designs.
                    """
                    lacp_port_id_range: LacpPortIdRange
                    """
                    This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                    number of nodes in the "node_group".
                    Unique LACP port-id ranges are recommended for EVPN Multihoming
                    designs.
                    """
                    always_configure_ip_routing: bool | None
                    """
                    Force configuration of "ip routing" even on L2 devices.
                    Use this to retain behavior of AVD versions
                    below 4.0.0.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""
                    uplink_type: str | None
                    """
                    Override the default `uplink_type` set at the `node_type_key` level.
                    `uplink_type` must be "p2p" if
                    `vtep` or `underlay_router` is true for the `node_type_key` definition.
                    """
                    uplink_ipv4_pool: str | None
                    """IPv4 subnet to use to connect to uplink switches."""
                    uplink_interfaces: list[str]
                    """
                    Local uplink interfaces.
                    Each list item supports range syntax that can be expanded into a list of
                    interfaces.
                    If uplink_interfaces is not defined, platform-specific defaults (defined under
                    default_interfaces) will be used instead.
                    Please note that default_interfaces are not defined by
                    default, you should define these yourself.
                    """
                    uplink_switch_interfaces: list[str]
                    """Interfaces located on uplink switches."""
                    uplink_switches: list[str]
                    uplink_interface_speed: str | None
                    """
                    Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                    (Uplink switch
                    interface speed can be overridden with `uplink_switch_interface_speed`).
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_switch_interface_speed: str | None
                    """
                    Set point-to-Point interface speed for the uplink switch interface only.
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_mtu: int | None
                    """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                    max_uplink_switches: int | None
                    """
                    Maximum number of uplink switches.
                    Changing this value may change IP Addressing on uplinks.
                    Can be
                    used to reserve IP space for future expansions.
                    """
                    max_parallel_uplinks: int | None
                    """
                    Number of parallel links towards uplink switches.
                    Changing this value may change interface naming on
                    uplinks (and corresponding downlinks).
                    Can be used to reserve interfaces for future parallel
                    uplinks.
                    """
                    uplink_bfd: bool | None
                    """Enable bfd on uplink interfaces."""
                    uplink_native_vlan: int | None
                    """
                    Only applicable to switches with layer-2 port-channel uplinks.
                    A suspended (disabled) vlan will be
                    created in both ends of the link unless the vlan is defined under network services.
                    By default the
                    uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                    """
                    uplink_ptp: UplinkPtp
                    """Enable PTP on all infrastructure links."""
                    uplink_macsec: UplinkMacsec
                    """Enable MacSec on all uplinks."""
                    uplink_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink Port-channel
                    ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                    For
                    example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [ Eth11/1, Eth22/1 ] -> ID 111
                    For
                    MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                    This
                    option overrides the default behavior and statically sets the local Port-channel ID.
                    Note! Make sure
                    the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                    value.
                    """
                    uplink_switch_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink switch Port-
                    channel ID will be set to the number of the first interface defined under
                    `uplink_switch_interfaces`.
                    For example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [
                    Eth11/1, Eth22/1 ] -> ID 111
                    For MLAG port-channels ID will be based on the lowest member interface
                    on the first MLAG switch.
                    This option overrides the default behavior and statically sets the Port-
                    channel ID on the uplink switch.
                    Note! Make sure the ID is unique and does not overlap with
                    autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between
                    1 and 2000 and both MLAG switches must have the same value.
                    """
                    uplink_structured_config: dict
                    """
                    Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                    When
                    uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                    for eos_cli_config_gen overrides the settings on the ethernet interface level.
                    When uplink_type ==
                    "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                    eos_cli_config_gen overrides the settings on the port-channel interface level.
                    "uplink_structured_config" is applied after "structured_config", so it can override
                    "structured_config" defined on node-level.
                    Note! The content of this dictionary is _not_ validated
                    by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                    """
                    mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                    """
                    Custom structured config applied to MLAG peer link port-channel id.
                    Added under
                    port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the
                    port-channel interface level.
                    "mlag_port_channel_structured_config" is applied after
                    "structured_config", so it can override "structured_config" defined on node-level.
                    """
                    mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                    """
                    Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                    override "structured_config" defined on node-level.
                    """
                    mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                    """
                    Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                    can override "structured_config" defined on node-level.
                    """
                    short_esi: str | None
                    """
                    short_esi only valid for l2leaf devices using port-channel uplink.
                    Setting short_esi to "auto"
                    generates the short_esi automatically using a hash of configuration elements.
                    < 0000:0000:0000 |
                    auto >.
                    """
                    isis_system_id_prefix: str | None
                    """(4.4 hexadecimal)."""
                    isis_maximum_paths: int | None
                    """Number of path to configure in ECMP for ISIS."""
                    is_type: str | None
                    node_sid_base: int | None
                    """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                    loopback_ipv4_pool: str | None
                    """IPv4 subnet for Loopback0 allocation."""
                    loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for Loopback0.
                    When set, it takes precedence over `loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                    """
                    vtep_loopback_ipv4_pool: str | None
                    """IPv4 subnet for VTEP-Loopback allocation."""
                    vtep_loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for VTEP-Loopback.
                    When set, it takes precedence over
                    `vtep_loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not
                    catch duplicates.
                    """
                    loopback_ipv4_offset: int | None
                    """
                    Offset all assigned loopback IP addresses.
                    Required when the < loopback_ipv4_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                    """
                    loopback_ipv6_pool: str | None
                    """IPv6 subnet for Loopback0 allocation."""
                    loopback_ipv6_offset: int | None
                    """
                    Offset all assigned loopback IPv6 addresses.
                    Required when the < loopback_ipv6_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid overlapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                    """
                    vtep: bool | None
                    """
                    Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                    Overrides VTEP
                    setting inherited from node_type_keys.
                    """
                    vtep_loopback: str | None
                    """Set VXLAN source interface."""
                    bgp_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    Required with eBGP.
                    """
                    bgp_defaults: list[str]
                    """List of EOS commands to apply to BGP daemon."""
                    evpn_role: str | None
                    """
                    Acting role in EVPN control plane.
                    Default is set in node_type definition from node_type_keys.
                    """
                    evpn_route_servers: list[str]
                    """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                    evpn_services_l2_only: bool | None
                    """
                    Possibility to prevent configuration of Tenant VRFs and SVIs.
                    Override node definition
                    "network_services_l3" from node_type_keys.
                    This allows support for centralized routing.
                    """
                    filter: Filter
                    """
                    Filter L3 and L2 network services based on tenant and tags (and operation filter).
                    If filter is not
                    defined it will default to all.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping on device level."""
                    evpn_gateway: EvpnGateway
                    """
                    Node is acting as EVPN Multi-Domain Gateway.
                    New BGP peer-group is generated between EVPN GWs in
                    different domains or between GWs and Route Servers.
                    Name can be changed under
                    "bgp_peer_groups.evpn_overlay_core" variable.
                    L3 rechability for different EVPN GWs must be already
                    in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                    same Ansible inventory.
                    """
                    ipvpn_gateway: IpvpnGateway
                    """
                    Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                    this is "bgp_peer_groups.ipvpn_gateway_peers".
                    L3 Reachability is required for this to work, the
                    preferred method to establish underlay connectivity is to use core_interfaces.
                    """
                    mlag: bool | None
                    """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                    mlag_dual_primary_detection: bool | None
                    """Enable / Disable MLAG dual primary detection."""
                    mlag_ibgp_origin_incomplete: bool | None
                    """
                    Set origin of routes received from MLAG iBGP peer to incomplete.
                    The purpose is to optimize routing
                    for leaf loopbacks from spine perspective and
                    avoid suboptimal routing via peerlink for control
                    plane traffic.
                    """
                    mlag_interfaces: list[str]
                    """
                    Each list item supports range syntax that can be expanded into a list of interfaces.
                    Required when
                    MLAG leafs are present in the topology.
                    """
                    mlag_interfaces_speed: str | None
                    """
                    Set MLAG interface speed.
                    Speed should be set in the format `<interface_speed>` or `forced
                    <interface_speed>` or `auto <interface_speed>`.
                    """
                    mlag_peer_l3_vlan: int | None
                    """
                    Underlay L3 peering SVI interface id.
                    If set to 0 or the same vlan as mlag_peer_vlan, the
                    mlag_peer_vlan will be used for L3 peering.
                    """
                    mlag_peer_l3_ipv4_pool: str | None
                    """
                    IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                    Required when
                    MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                    """
                    mlag_peer_vlan: int | None
                    """MLAG Peer Link (control link) SVI interface id."""
                    mlag_peer_link_allowed_vlans: str | None
                    mlag_peer_address_family: str | None
                    """
                    IP address family used to establish MLAG Peer Link (control link).
                    `ipv6` requires EOS version
                    4.31.1F or higher.
                    Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                    (ex. `mlag_peer_l3_vlan` set to 4094).
                    """
                    mlag_peer_ipv4_pool: str | None
                    """
                    IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                    """
                    mlag_peer_ipv6_pool: str | None
                    """
                    IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                    """
                    mlag_port_channel_id: int | None
                    """
                    If not set, the mlag port-channel id is generated based on the digits of the first interface present
                    in 'mlag_interfaces'.
                    Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                    999999 > for EOS >= 4.25.0F.
                    """
                    mlag_domain_id: str | None
                    """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                    spanning_tree_mode: str | None
                    spanning_tree_priority: int | None
                    """
                    Spanning-tree priority configured for the selected mode.
                    For `rapid-pvst` the priority can also be
                    set per VLAN under network services.
                    """
                    spanning_tree_root_super: bool | None
                    virtual_router_mac_address: str | None
                    """Virtual router mac address for anycast gateway."""
                    inband_mgmt_interface: str | None
                    """
                    Pointer to interface used for inband management.
                    All configuration must be done using other data
                    models like network services or structured_config.
                    'inband_mgmt_interface' is only used to refer to
                    this interface as source in various management protocol settings (future feature).

                    On L2 switches,
                    this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                    """
                    inband_mgmt_vlan: int | None
                    """
                    VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                    uplinks).
                    When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                    switch as well as all 'uplink_switches'.
                    When using 'inband_mgmt_ip' the VLAN and SVI will only be
                    created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                    created using network services data models.
                    """
                    inband_mgmt_subnet: str | None
                    """
                    Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                    ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      : <subnet> +
                    2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       :
                    <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than total l2leafs + 5
                    Setting is ignored if 'inband_mgmt_ip' is set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ip: str | None
                    """
                    IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                    If this is set the
                    VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN and SVI on
                    the parent switches must be created using network services data models.

                    This setting is applicable
                    to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                    is derived from 'inband_mgmt_subnet' if set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_address: str | None
                    """
                    IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                    If this
                    is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN
                    and SVI on the parent switches must be created using network services data models.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_subnet: str | None
                    """
                    Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                    on ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                    extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      :
                    <subnet> + 2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       : <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than
                    total l2leafs + 5

                    Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf'.
                    Used when `inband_mgmt_ipv6_address` is set.
                    Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_description: str | None
                    """
                    Description configured on the Inband Management SVI.

                    This setting is only applied on the devices
                    where it is set, it does not automatically affect any parent/child devices configuration, so it must
                    be set on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vlan_name: str | None
                    """
                    Name configured on the Inband Management VLAN.
                    This setting is only applied on the devices where it
                    is set, it does not automatically affect any parent/child devices configuration, so it must be set
                    on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vrf: str | None
                    """
                    VRF configured on the Inband Management Interface.
                    The VRF is created if not already created by
                    other means.
                    This setting is only applied on the devices where it is set, it does not automatically
                    affect any parent/child devices configuration, so it must be set on each applicable node/node-
                    group/node-type as needed.
                    """
                    inband_mgmt_mtu: int | None
                    """
                    MTU configured on the Inband Management Interface.
                    This setting is only applied on the devices where
                    it is set, it does not automatically affect any parent/child devices configuration, so it must be
                    set on each applicable node/node-group/node-type as needed.
                    """
                    inband_ztp: bool | None
                    """
                    Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                    inband.
                    This setting also requires that the `inband_mgmt_vlan` is set for the node.
                    """
                    inband_ztp_lacp_fallback_delay: int | None
                    """
                    Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                    ZTP node.
                    This setting also requires that `inband_ztp` is set for the node.
                    """
                    mpls_overlay_role: str | None
                    """
                    Set the default mpls overlay role.
                    Acting role in overlay control plane.
                    """
                    overlay_address_families: list[str]
                    """Set the default overlay address families."""
                    mpls_route_reflectors: list[str]
                    """List of inventory hostname acting as MPLS route-reflectors."""
                    bgp_cluster_id: str | None
                    """Set BGP cluster id."""
                    ptp: Ptp
                    wan_role: str | None
                    """
                    Override the default WAN role.

                    This is used both for AutoVPN and Pathfinder designs.
                    That means if
                    `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                    `server` indicates that the
                    router is a route-reflector.

                    Only supported if `overlay_routing_protocol` is set to `ibgp`.
                    """
                    cv_pathfinder_transit_mode: str | None
                    """
                    Configure the transit mode for a WAN client for CV Pathfinder designs
                    only when the `wan_mode` root
                    key is set to `cv_pathfinder`.

                    'zone' is currently not supported.
                    """
                    cv_pathfinder_region: str | None
                    """
                    The CV Pathfinder region name.
                    This key is required for WAN routers but optional for pathfinders.
                    The region name must be defined under 'cv_pathfinder_regions'.
                    """
                    cv_pathfinder_site: str | None
                    """
                    The CV Pathfinder site name.
                    This key is required for WAN routers but optional for pathfinders.
                    For
                    WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                    relevant region under 'cv_pathfinder_regions'.
                    For pathfinders without `cv_pathfinder_region` set,
                    the site must be defined under `cv_pathfinder_global_sites`.
                    """
                    wan_ha: WanHa
                    """
                    PREVIEW: This key is currently not supported

                    The key is supported only if `wan_mode` == `cv-
                    pathfinder`.
                    AutoVPN support is still to be determined.

                    Maximum 2 devices supported by group for
                    HA.
                    """
                    dps_mss_ipv4: str | None
                    """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                    l3_interfaces: L3Interfaces
                    """
                    L3 Interfaces to configure on the node.
                    Used to define the node for WAN interfaces when
                    `wan_carrier` is set.
                    """
                    data_plane_cpu_allocation_max: int | None
                    """
                    Set the maximum number of CPU used for the data plane.
                    This setting is useful on virtual Route
                    Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                    """
                    flow_tracker_type: str | None
                    """
                    Set the flow tracker type.
                    Override the `default_flow_tracker_type`` set at the `node_type_key`
                    level.
                    `default_flow_tracker_type` default value is `sampled`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        downlink_pools: list[DownlinkPoolsItem] | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        platform: str | None | UndefinedType = Undefined,
                        mac_address: str | None | UndefinedType = Undefined,
                        system_mac_address: str | None | UndefinedType = Undefined,
                        serial_number: str | None | UndefinedType = Undefined,
                        rack: str | None | UndefinedType = Undefined,
                        mgmt_ip: str | None | UndefinedType = Undefined,
                        mgmt_gateway: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                        mgmt_interface: str | None | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                        always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                        uplink_type: str | None | UndefinedType = Undefined,
                        uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                        uplink_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switches: list[str] | UndefinedType = Undefined,
                        uplink_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_mtu: int | None | UndefinedType = Undefined,
                        max_uplink_switches: int | None | UndefinedType = Undefined,
                        max_parallel_uplinks: int | None | UndefinedType = Undefined,
                        uplink_bfd: bool | None | UndefinedType = Undefined,
                        uplink_native_vlan: int | None | UndefinedType = Undefined,
                        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                        uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                        uplink_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_structured_config: dict | UndefinedType = Undefined,
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                        short_esi: str | None | UndefinedType = Undefined,
                        isis_system_id_prefix: str | None | UndefinedType = Undefined,
                        isis_maximum_paths: int | None | UndefinedType = Undefined,
                        is_type: str | None | UndefinedType = Undefined,
                        node_sid_base: int | None | UndefinedType = Undefined,
                        loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                        loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                        vtep: bool | None | UndefinedType = Undefined,
                        vtep_loopback: str | None | UndefinedType = Undefined,
                        bgp_as: str | None | UndefinedType = Undefined,
                        bgp_defaults: list[str] | UndefinedType = Undefined,
                        evpn_role: str | None | UndefinedType = Undefined,
                        evpn_route_servers: list[str] | UndefinedType = Undefined,
                        evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                        ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                        mlag: bool | None | UndefinedType = Undefined,
                        mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                        mlag_interfaces: list[str] | UndefinedType = Undefined,
                        mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                        mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                        mlag_peer_address_family: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                        mlag_port_channel_id: int | None | UndefinedType = Undefined,
                        mlag_domain_id: str | None | UndefinedType = Undefined,
                        spanning_tree_mode: str | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                        virtual_router_mac_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_interface: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                        inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ip: str | None | UndefinedType = Undefined,
                        inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_description: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                        inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                        inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                        inband_ztp: bool | None | UndefinedType = Undefined,
                        inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                        mpls_overlay_role: str | None | UndefinedType = Undefined,
                        overlay_address_families: list[str] | UndefinedType = Undefined,
                        mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                        bgp_cluster_id: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        wan_role: str | None | UndefinedType = Undefined,
                        cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                        cv_pathfinder_region: str | None | UndefinedType = Undefined,
                        cv_pathfinder_site: str | None | UndefinedType = Undefined,
                        wan_ha: WanHa | UndefinedType = Undefined,
                        dps_mss_ipv4: str | None | UndefinedType = Undefined,
                        l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                        data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                        flow_tracker_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: The Node Name is used as "hostname".
                            downlink_pools:
                               IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                               with `uplink_ipv4_pool` set on the downlink switch.
                            id: Unique identifier used for IP addressing and other algorithms.
                            platform: Arista platform family.
                            mac_address: Leverage to document management interface mac address.
                            system_mac_address:
                               System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                               Set to the same MAC address as
                               available in "show version" on the device.
                               "system_mac_address" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            serial_number:
                               Set to the Serial Number of the device.
                               Only used for documentation purpose in the fabric
                               documentation and part of the structured_config.
                               "serial_number" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            rack: Rack that the switch is located in (only used in snmp_settings location).
                            mgmt_ip: Node management interface IPv4 address.
                            mgmt_gateway:
                               This key sets the management gateway for the device. It takes precedence over the global
                               `mgmt_gateway`.
                            ipv6_mgmt_ip: Node management interface IPv6 address.
                            ipv6_mgmt_gateway:
                               This key sets the ipv6 management gateway for the device. It takes precedence over the global
                               `ipv6_mgmt_gateway`.
                            mgmt_interface:
                               Management Interface Name.
                               Default -> platform_management_interface -> mgmt_interface ->
                               "Management1".
                            link_tracking:
                               This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                               the upstream interfaces.
                               Useful in EVPN multhoming designs.
                            lacp_port_id_range:
                               This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                               number of nodes in the "node_group".
                               Unique LACP port-id ranges are recommended for EVPN Multihoming
                               designs.
                            always_configure_ip_routing:
                               Force configuration of "ip routing" even on L2 devices.
                               Use this to retain behavior of AVD versions
                               below 4.0.0.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.
                            uplink_type:
                               Override the default `uplink_type` set at the `node_type_key` level.
                               `uplink_type` must be "p2p" if
                               `vtep` or `underlay_router` is true for the `node_type_key` definition.
                            uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                            uplink_interfaces:
                               Local uplink interfaces.
                               Each list item supports range syntax that can be expanded into a list of
                               interfaces.
                               If uplink_interfaces is not defined, platform-specific defaults (defined under
                               default_interfaces) will be used instead.
                               Please note that default_interfaces are not defined by
                               default, you should define these yourself.
                            uplink_switch_interfaces: Interfaces located on uplink switches.
                            uplink_switches: uplink_switches
                            uplink_interface_speed:
                               Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                               (Uplink switch
                               interface speed can be overridden with `uplink_switch_interface_speed`).
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_switch_interface_speed:
                               Set point-to-Point interface speed for the uplink switch interface only.
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                            max_uplink_switches:
                               Maximum number of uplink switches.
                               Changing this value may change IP Addressing on uplinks.
                               Can be
                               used to reserve IP space for future expansions.
                            max_parallel_uplinks:
                               Number of parallel links towards uplink switches.
                               Changing this value may change interface naming on
                               uplinks (and corresponding downlinks).
                               Can be used to reserve interfaces for future parallel
                               uplinks.
                            uplink_bfd: Enable bfd on uplink interfaces.
                            uplink_native_vlan:
                               Only applicable to switches with layer-2 port-channel uplinks.
                               A suspended (disabled) vlan will be
                               created in both ends of the link unless the vlan is defined under network services.
                               By default the
                               uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                            uplink_ptp: Enable PTP on all infrastructure links.
                            uplink_macsec: Enable MacSec on all uplinks.
                            uplink_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink Port-channel
                               ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                               For
                               example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [ Eth11/1, Eth22/1 ] -> ID 111
                               For
                               MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                               This
                               option overrides the default behavior and statically sets the local Port-channel ID.
                               Note! Make sure
                               the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                               value.
                            uplink_switch_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink switch Port-
                               channel ID will be set to the number of the first interface defined under
                               `uplink_switch_interfaces`.
                               For example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [
                               Eth11/1, Eth22/1 ] -> ID 111
                               For MLAG port-channels ID will be based on the lowest member interface
                               on the first MLAG switch.
                               This option overrides the default behavior and statically sets the Port-
                               channel ID on the uplink switch.
                               Note! Make sure the ID is unique and does not overlap with
                               autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between
                               1 and 2000 and both MLAG switches must have the same value.
                            uplink_structured_config:
                               Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                               When
                               uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                               for eos_cli_config_gen overrides the settings on the ethernet interface level.
                               When uplink_type ==
                               "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                               eos_cli_config_gen overrides the settings on the port-channel interface level.
                               "uplink_structured_config" is applied after "structured_config", so it can override
                               "structured_config" defined on node-level.
                               Note! The content of this dictionary is _not_ validated
                               by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                            mlag_port_channel_structured_config:
                               Custom structured config applied to MLAG peer link port-channel id.
                               Added under
                               port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the
                               port-channel interface level.
                               "mlag_port_channel_structured_config" is applied after
                               "structured_config", so it can override "structured_config" defined on node-level.
                            mlag_peer_vlan_structured_config:
                               Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                               override "structured_config" defined on node-level.
                            mlag_peer_l3_vlan_structured_config:
                               Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                               can override "structured_config" defined on node-level.
                            short_esi:
                               short_esi only valid for l2leaf devices using port-channel uplink.
                               Setting short_esi to "auto"
                               generates the short_esi automatically using a hash of configuration elements.
                               < 0000:0000:0000 |
                               auto >.
                            isis_system_id_prefix: (4.4 hexadecimal).
                            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                            is_type: is_type
                            node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                            loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                            loopback_ipv4_address:
                               IPv4 address without mask for Loopback0.
                               When set, it takes precedence over `loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                            vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                            vtep_loopback_ipv4_address:
                               IPv4 address without mask for VTEP-Loopback.
                               When set, it takes precedence over
                               `vtep_loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not
                               catch duplicates.
                            loopback_ipv4_offset:
                               Offset all assigned loopback IP addresses.
                               Required when the < loopback_ipv4_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                            loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                            loopback_ipv6_offset:
                               Offset all assigned loopback IPv6 addresses.
                               Required when the < loopback_ipv6_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid overlapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                            vtep:
                               Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                               Overrides VTEP
                               setting inherited from node_type_keys.
                            vtep_loopback: Set VXLAN source interface.
                            bgp_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                               Required with eBGP.
                            bgp_defaults: List of EOS commands to apply to BGP daemon.
                            evpn_role:
                               Acting role in EVPN control plane.
                               Default is set in node_type definition from node_type_keys.
                            evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                            evpn_services_l2_only:
                               Possibility to prevent configuration of Tenant VRFs and SVIs.
                               Override node definition
                               "network_services_l3" from node_type_keys.
                               This allows support for centralized routing.
                            filter:
                               Filter L3 and L2 network services based on tenant and tags (and operation filter).
                               If filter is not
                               defined it will default to all.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                            evpn_gateway:
                               Node is acting as EVPN Multi-Domain Gateway.
                               New BGP peer-group is generated between EVPN GWs in
                               different domains or between GWs and Route Servers.
                               Name can be changed under
                               "bgp_peer_groups.evpn_overlay_core" variable.
                               L3 rechability for different EVPN GWs must be already
                               in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                               same Ansible inventory.
                            ipvpn_gateway:
                               Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                               this is "bgp_peer_groups.ipvpn_gateway_peers".
                               L3 Reachability is required for this to work, the
                               preferred method to establish underlay connectivity is to use core_interfaces.
                            mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                            mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                            mlag_ibgp_origin_incomplete:
                               Set origin of routes received from MLAG iBGP peer to incomplete.
                               The purpose is to optimize routing
                               for leaf loopbacks from spine perspective and
                               avoid suboptimal routing via peerlink for control
                               plane traffic.
                            mlag_interfaces:
                               Each list item supports range syntax that can be expanded into a list of interfaces.
                               Required when
                               MLAG leafs are present in the topology.
                            mlag_interfaces_speed:
                               Set MLAG interface speed.
                               Speed should be set in the format `<interface_speed>` or `forced
                               <interface_speed>` or `auto <interface_speed>`.
                            mlag_peer_l3_vlan:
                               Underlay L3 peering SVI interface id.
                               If set to 0 or the same vlan as mlag_peer_vlan, the
                               mlag_peer_vlan will be used for L3 peering.
                            mlag_peer_l3_ipv4_pool:
                               IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                               Required when
                               MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                            mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                            mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                            mlag_peer_address_family:
                               IP address family used to establish MLAG Peer Link (control link).
                               `ipv6` requires EOS version
                               4.31.1F or higher.
                               Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                               (ex. `mlag_peer_l3_vlan` set to 4094).
                            mlag_peer_ipv4_pool:
                               IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                            mlag_peer_ipv6_pool:
                               IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                            mlag_port_channel_id:
                               If not set, the mlag port-channel id is generated based on the digits of the first interface present
                               in 'mlag_interfaces'.
                               Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                               999999 > for EOS >= 4.25.0F.
                            mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                            spanning_tree_mode: spanning_tree_mode
                            spanning_tree_priority:
                               Spanning-tree priority configured for the selected mode.
                               For `rapid-pvst` the priority can also be
                               set per VLAN under network services.
                            spanning_tree_root_super: spanning_tree_root_super
                            virtual_router_mac_address: Virtual router mac address for anycast gateway.
                            inband_mgmt_interface:
                               Pointer to interface used for inband management.
                               All configuration must be done using other data
                               models like network services or structured_config.
                               'inband_mgmt_interface' is only used to refer to
                               this interface as source in various management protocol settings (future feature).

                               On L2 switches,
                               this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                            inband_mgmt_vlan:
                               VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                               uplinks).
                               When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                               switch as well as all 'uplink_switches'.
                               When using 'inband_mgmt_ip' the VLAN and SVI will only be
                               created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                               created using network services data models.
                            inband_mgmt_subnet:
                               Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                               ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      : <subnet> +
                               2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       :
                               <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than total l2leafs + 5
                               Setting is ignored if 'inband_mgmt_ip' is set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ip:
                               IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                               If this is set the
                               VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN and SVI on
                               the parent switches must be created using network services data models.

                               This setting is applicable
                               to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                               is derived from 'inband_mgmt_subnet' if set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_address:
                               IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                               If this
                               is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN
                               and SVI on the parent switches must be created using network services data models.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_subnet:
                               Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                               on ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                               extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      :
                               <subnet> + 2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       : <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than
                               total l2leafs + 5

                               Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf'.
                               Used when `inband_mgmt_ipv6_address` is set.
                               Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_description:
                               Description configured on the Inband Management SVI.

                               This setting is only applied on the devices
                               where it is set, it does not automatically affect any parent/child devices configuration, so it must
                               be set on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vlan_name:
                               Name configured on the Inband Management VLAN.
                               This setting is only applied on the devices where it
                               is set, it does not automatically affect any parent/child devices configuration, so it must be set
                               on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vrf:
                               VRF configured on the Inband Management Interface.
                               The VRF is created if not already created by
                               other means.
                               This setting is only applied on the devices where it is set, it does not automatically
                               affect any parent/child devices configuration, so it must be set on each applicable node/node-
                               group/node-type as needed.
                            inband_mgmt_mtu:
                               MTU configured on the Inband Management Interface.
                               This setting is only applied on the devices where
                               it is set, it does not automatically affect any parent/child devices configuration, so it must be
                               set on each applicable node/node-group/node-type as needed.
                            inband_ztp:
                               Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                               inband.
                               This setting also requires that the `inband_mgmt_vlan` is set for the node.
                            inband_ztp_lacp_fallback_delay:
                               Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                               ZTP node.
                               This setting also requires that `inband_ztp` is set for the node.
                            mpls_overlay_role:
                               Set the default mpls overlay role.
                               Acting role in overlay control plane.
                            overlay_address_families: Set the default overlay address families.
                            mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                            bgp_cluster_id: Set BGP cluster id.
                            ptp: ptp
                            wan_role:
                               Override the default WAN role.

                               This is used both for AutoVPN and Pathfinder designs.
                               That means if
                               `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                               `server` indicates that the
                               router is a route-reflector.

                               Only supported if `overlay_routing_protocol` is set to `ibgp`.
                            cv_pathfinder_transit_mode:
                               Configure the transit mode for a WAN client for CV Pathfinder designs
                               only when the `wan_mode` root
                               key is set to `cv_pathfinder`.

                               'zone' is currently not supported.
                            cv_pathfinder_region:
                               The CV Pathfinder region name.
                               This key is required for WAN routers but optional for pathfinders.
                               The region name must be defined under 'cv_pathfinder_regions'.
                            cv_pathfinder_site:
                               The CV Pathfinder site name.
                               This key is required for WAN routers but optional for pathfinders.
                               For
                               WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                               relevant region under 'cv_pathfinder_regions'.
                               For pathfinders without `cv_pathfinder_region` set,
                               the site must be defined under `cv_pathfinder_global_sites`.
                            wan_ha:
                               PREVIEW: This key is currently not supported

                               The key is supported only if `wan_mode` == `cv-
                               pathfinder`.
                               AutoVPN support is still to be determined.

                               Maximum 2 devices supported by group for
                               HA.
                            dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                            l3_interfaces:
                               L3 Interfaces to configure on the node.
                               Used to define the node for WAN interfaces when
                               `wan_carrier` is set.
                            data_plane_cpu_allocation_max:
                               Set the maximum number of CPU used for the data plane.
                               This setting is useful on virtual Route
                               Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                            flow_tracker_type:
                               Set the flow tracker type.
                               Override the `default_flow_tracker_type`` set at the `node_type_key`
                               level.
                               `default_flow_tracker_type` default value is `sampled`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Nodes(AvdCollection[str, NodesItem]):
                    _primary_key: ClassVar[str] = "name"

                Nodes._item_type = NodesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "defaults": {"type": Defaults},
                    "node_groups": {"type": NodeGroups},
                    "nodes": {"type": Nodes},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                defaults: Defaults
                """Define variables for all nodes of this type."""
                node_groups: NodeGroups
                """Define variables related to all nodes part of this group."""
                nodes: Nodes
                """Define variables per node."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    defaults: Defaults | UndefinedType = Undefined,
                    node_groups: NodeGroups | UndefinedType = Undefined,
                    nodes: Nodes | UndefinedType = Undefined,
                ) -> None:
                    """
                    CustomNodeTypeKeysKey.

                    Args:
                    -----
                        _custom_data: _custom_data
                        defaults: Define variables for all nodes of this type.
                        node_groups: Define variables related to all nodes part of this group.
                        nodes: Define variables per node.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"key": {"type": str}, "value": {"type": CustomNodeTypeKeysKey, "key": "custom_node_type_keys_key"}}
            _required_fields: ClassVar[tuple] = ("key",)
            key: str
            """Key used as dynamic key"""
            value: CustomNodeTypeKeysKey
            """Value of dynamic key"""

            def __init__(self, *, key: str | UndefinedType = Undefined, value: CustomNodeTypeKeysKey | UndefinedType = Undefined) -> None:
                """
                DynamicCustomNodeTypeKeys.

                Args:
                -----
                    key: Key used as dynamic key
                    value: Value of dynamic key

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DynamicNetworkServicesKeys(AvdModel):
            class NetworkServicesKeysNameItem(AvdModel):
                class BgpPeerGroupsItem(AvdModel):
                    class AddressFamilyIpv4(AvdModel):
                        class DefaultOriginate(EosCliConfigGen.RouterBgp.AddressFamilyIpv4.PeerGroupsItem.DefaultOriginate):
                            pass

                        class NextHop(EosCliConfigGen.RouterBgp.AddressFamilyIpv4.PeerGroupsItem.NextHop):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "activate": {"type": bool},
                            "route_map_in": {"type": str},
                            "route_map_out": {"type": str},
                            "default_originate": {"type": DefaultOriginate},
                            "next_hop": {"type": NextHop},
                            "prefix_list_in": {"type": str},
                            "prefix_list_out": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        activate: bool | None
                        route_map_in: str | None
                        """Inbound route-map name."""
                        route_map_out: str | None
                        """Outbound route-map name."""
                        default_originate: DefaultOriginate
                        next_hop: NextHop
                        prefix_list_in: str | None
                        """Inbound prefix-list name."""
                        prefix_list_out: str | None
                        """Outbound prefix-list name."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            default_originate: DefaultOriginate | UndefinedType = Undefined,
                            next_hop: NextHop | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AddressFamilyIpv4.

                            Args:
                            -----
                                _custom_data: _custom_data
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                default_originate: default_originate
                                next_hop: next_hop
                                prefix_list_in: Inbound prefix-list name.
                                prefix_list_out: Outbound prefix-list name.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AddressFamilyIpv6(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "activate": {"type": bool},
                            "route_map_in": {"type": str},
                            "route_map_out": {"type": str},
                            "prefix_list_in": {"type": str},
                            "prefix_list_out": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        activate: bool | None
                        route_map_in: str | None
                        """Inbound route-map name."""
                        route_map_out: str | None
                        """Outbound route-map name."""
                        prefix_list_in: str | None
                        """Inbound prefix-list name."""
                        prefix_list_out: str | None
                        """Outbound prefix-list name."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            activate: bool | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AddressFamilyIpv6.

                            Args:
                            -----
                                _custom_data: _custom_data
                                activate: activate
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                prefix_list_in: Inbound prefix-list name.
                                prefix_list_out: Outbound prefix-list name.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AsPath(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_as_replace_out": {"type": bool},
                            "prepend_own_disabled": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_as_replace_out: bool | None
                        """Replace AS number with local AS number."""
                        prepend_own_disabled: bool | None
                        """Disable prepending own AS number to AS path."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_as_replace_out: bool | None | UndefinedType = Undefined,
                            prepend_own_disabled: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AsPath.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_as_replace_out: Replace AS number with local AS number.
                                prepend_own_disabled: Disable prepending own AS number to AS path.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class RemovePrivateAs(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "all": {"type": bool},
                            "replace_as": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        all: bool | None
                        replace_as: bool | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            all: bool | None | UndefinedType = Undefined,
                            replace_as: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RemovePrivateAs.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                all: all
                                replace_as: replace_as

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class RemovePrivateAsIngress(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "replace_as": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        replace_as: bool | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            replace_as: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RemovePrivateAsIngress.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                replace_as: replace_as

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class BfdTimers(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "interval": {"type": int},
                            "min_rx": {"type": int},
                            "multiplier": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "min_rx", "multiplier")
                        _custom_data: dict[str, Any]
                        interval: int
                        """Interval in milliseconds."""
                        min_rx: int
                        """Rate in milliseconds."""
                        multiplier: int

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            interval: int | UndefinedType = Undefined,
                            min_rx: int | UndefinedType = Undefined,
                            multiplier: int | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BfdTimers.

                            Args:
                            -----
                                _custom_data: _custom_data
                                interval: Interval in milliseconds.
                                min_rx: Rate in milliseconds.
                                multiplier: multiplier

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DefaultOriginate(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "always": {"type": bool},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        always: bool | None
                        route_map: str | None
                        """Route-map name."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            always: bool | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DefaultOriginate.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                always: always
                                route_map: Route-map name.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MissingPolicy(AvdModel):
                        class DirectionIn(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "action": {"type": str},
                                "include_community_list": {"type": bool},
                                "include_prefix_list": {"type": bool},
                                "include_sub_route_map": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                            _custom_data: dict[str, Any]
                            action: str
                            """Missing policy action."""
                            include_community_list: bool | None
                            """Include community-list references in missing policy decision."""
                            include_prefix_list: bool | None
                            """Include prefix-list references in missing policy decision."""
                            include_sub_route_map: bool | None
                            """Include sub-route-map references in missing policy decision."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                action: str | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionIn.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class DirectionOut(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "action": {"type": str},
                                "include_community_list": {"type": bool},
                                "include_prefix_list": {"type": bool},
                                "include_sub_route_map": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                            _custom_data: dict[str, Any]
                            action: str
                            """Missing policy action."""
                            include_community_list: bool | None
                            """Include community-list references in missing policy decision."""
                            include_prefix_list: bool | None
                            """Include prefix-list references in missing policy decision."""
                            include_sub_route_map: bool | None
                            """Include sub-route-map references in missing policy decision."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                action: str | UndefinedType = Undefined,
                                include_community_list: bool | None | UndefinedType = Undefined,
                                include_prefix_list: bool | None | UndefinedType = Undefined,
                                include_sub_route_map: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DirectionOut.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    action: Missing policy action.
                                    include_community_list: Include community-list references in missing policy decision.
                                    include_prefix_list: Include prefix-list references in missing policy decision.
                                    include_sub_route_map: Include sub-route-map references in missing policy decision.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "direction_in": {"type": DirectionIn},
                            "direction_out": {"type": DirectionOut},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in: DirectionIn
                        """Missing policy inbound direction."""
                        direction_out: DirectionOut
                        """Missing policy outbound direction."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in: DirectionIn | UndefinedType = Undefined,
                            direction_out: DirectionOut | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in: Missing policy inbound direction.
                                direction_out: Missing policy outbound direction.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LinkBandwidth(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "default": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        default: str | None
                        """nn.nn(K|M|G) link speed in bits/second."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            default: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkBandwidth.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                default: nn.nn(K|M|G) link speed in bits/second.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AllowasIn(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "times": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        times: int | None
                        """Number of local ASNs allowed in a BGP update."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            times: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AllowasIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                times: Number of local ASNs allowed in a BGP update.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class RibInPrePolicyRetain(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        all: bool | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            all: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            RibInPrePolicyRetain.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                all: all

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class SharedSecret(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "hash_algorithm": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "hash_algorithm")
                        _custom_data: dict[str, Any]
                        profile: str
                        """Name of profile defined under `management_security`."""
                        hash_algorithm: str
                        """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | UndefinedType = Undefined,
                            hash_algorithm: str | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SharedSecret.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: Name of profile defined under `management_security`.
                                hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "nodes": {"type": list, "items": str},
                        "address_family_ipv4": {"type": AddressFamilyIpv4},
                        "address_family_ipv6": {"type": AddressFamilyIpv6},
                        "type": {"type": str},
                        "remote_as": {"type": str},
                        "local_as": {"type": str},
                        "description": {"type": str},
                        "shutdown": {"type": bool},
                        "as_path": {"type": AsPath},
                        "remove_private_as": {"type": RemovePrivateAs},
                        "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                        "next_hop_unchanged": {"type": bool},
                        "update_source": {"type": str},
                        "route_reflector_client": {"type": bool},
                        "bfd": {"type": bool},
                        "bfd_timers": {"type": BfdTimers},
                        "ebgp_multihop": {"type": int},
                        "next_hop_self": {"type": bool},
                        "password": {"type": str},
                        "passive": {"type": bool},
                        "default_originate": {"type": DefaultOriginate},
                        "send_community": {"type": str},
                        "maximum_routes": {"type": int},
                        "maximum_routes_warning_limit": {"type": str},
                        "maximum_routes_warning_only": {"type": bool},
                        "missing_policy": {"type": MissingPolicy},
                        "link_bandwidth": {"type": LinkBandwidth},
                        "allowas_in": {"type": AllowasIn},
                        "weight": {"type": int},
                        "timers": {"type": str},
                        "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "session_tracker": {"type": str},
                        "shared_secret": {"type": SharedSecret},
                        "ttl_maximum_hops": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """BGP peer group name."""
                    nodes: list[str]
                    """
                    Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network.
                    If not
                    set the peer-group is created on devices which have a bgp_peer mapped to the corresponding
                    peer_group.
                    """
                    address_family_ipv4: AddressFamilyIpv4
                    address_family_ipv6: AddressFamilyIpv6
                    type: str | None
                    """Key only used for documentation or validation purposes."""
                    remote_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    """
                    local_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    """
                    description: str | None
                    shutdown: bool | None
                    as_path: AsPath
                    """BGP AS-PATH options."""
                    remove_private_as: RemovePrivateAs
                    """Remove private AS numbers in outbound AS path."""
                    remove_private_as_ingress: RemovePrivateAsIngress
                    next_hop_unchanged: bool | None
                    update_source: str | None
                    """IP address or interface name."""
                    route_reflector_client: bool | None
                    bfd: bool | None
                    """Enable BFD."""
                    bfd_timers: BfdTimers
                    """Override default BFD timers. BFD must be enabled with `bfd: true`."""
                    ebgp_multihop: int | None
                    """Time-to-live in range of hops."""
                    next_hop_self: bool | None
                    password: str | None
                    passive: bool | None
                    default_originate: DefaultOriginate
                    send_community: str | None
                    """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                    maximum_routes: int | None
                    """Maximum number of routes (0 means unlimited)."""
                    maximum_routes_warning_limit: str | None
                    """
                    Maximum number of routes after which a warning is issued (0 means never warn) or
                    Percentage of
                    maximum number of routes at which to warn ("<1-100> percent").
                    """
                    maximum_routes_warning_only: bool | None
                    missing_policy: MissingPolicy
                    """Missing policy configuration for all address-families."""
                    link_bandwidth: LinkBandwidth
                    allowas_in: AllowasIn
                    weight: int | None
                    timers: str | None
                    """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
                    rib_in_pre_policy_retain: RibInPrePolicyRetain
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    session_tracker: str | None
                    shared_secret: SharedSecret
                    ttl_maximum_hops: int | None
                    """Maximum number of hops."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        nodes: list[str] | UndefinedType = Undefined,
                        address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                        address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                        type: str | None | UndefinedType = Undefined,
                        remote_as: str | None | UndefinedType = Undefined,
                        local_as: str | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        shutdown: bool | None | UndefinedType = Undefined,
                        as_path: AsPath | UndefinedType = Undefined,
                        remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                        remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                        next_hop_unchanged: bool | None | UndefinedType = Undefined,
                        update_source: str | None | UndefinedType = Undefined,
                        route_reflector_client: bool | None | UndefinedType = Undefined,
                        bfd: bool | None | UndefinedType = Undefined,
                        bfd_timers: BfdTimers | UndefinedType = Undefined,
                        ebgp_multihop: int | None | UndefinedType = Undefined,
                        next_hop_self: bool | None | UndefinedType = Undefined,
                        password: str | None | UndefinedType = Undefined,
                        passive: bool | None | UndefinedType = Undefined,
                        default_originate: DefaultOriginate | UndefinedType = Undefined,
                        send_community: str | None | UndefinedType = Undefined,
                        maximum_routes: int | None | UndefinedType = Undefined,
                        maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                        maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                        allowas_in: AllowasIn | UndefinedType = Undefined,
                        weight: int | None | UndefinedType = Undefined,
                        timers: str | None | UndefinedType = Undefined,
                        rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        session_tracker: str | None | UndefinedType = Undefined,
                        shared_secret: SharedSecret | UndefinedType = Undefined,
                        ttl_maximum_hops: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BgpPeerGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: BGP peer group name.
                            nodes:
                               Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network.
                               If not
                               set the peer-group is created on devices which have a bgp_peer mapped to the corresponding
                               peer_group.
                            address_family_ipv4: address_family_ipv4
                            address_family_ipv6: address_family_ipv6
                            type: Key only used for documentation or validation purposes.
                            remote_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            local_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                            description: description
                            shutdown: shutdown
                            as_path: BGP AS-PATH options.
                            remove_private_as: Remove private AS numbers in outbound AS path.
                            remove_private_as_ingress: remove_private_as_ingress
                            next_hop_unchanged: next_hop_unchanged
                            update_source: IP address or interface name.
                            route_reflector_client: route_reflector_client
                            bfd: Enable BFD.
                            bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                            ebgp_multihop: Time-to-live in range of hops.
                            next_hop_self: next_hop_self
                            password: password
                            passive: passive
                            default_originate: default_originate
                            send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                            maximum_routes: Maximum number of routes (0 means unlimited).
                            maximum_routes_warning_limit:
                               Maximum number of routes after which a warning is issued (0 means never warn) or
                               Percentage of
                               maximum number of routes at which to warn ("<1-100> percent").
                            maximum_routes_warning_only: maximum_routes_warning_only
                            missing_policy: Missing policy configuration for all address-families.
                            link_bandwidth: link_bandwidth
                            allowas_in: allowas_in
                            weight: weight
                            timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                            rib_in_pre_policy_retain: rib_in_pre_policy_retain
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            session_tracker: session_tracker
                            shared_secret: shared_secret
                            ttl_maximum_hops: Maximum number of hops.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BgpPeerGroups(AvdCollection[str, BgpPeerGroupsItem]):
                    _primary_key: ClassVar[str] = "name"

                BgpPeerGroups._item_type = BgpPeerGroupsItem

                class EvpnL2Multicast(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "underlay_l2_multicast_group_ipv4_pool": {"type": str},
                        "underlay_l2_multicast_group_ipv4_pool_offset": {"type": int},
                        "fast_leave": {"type": bool},
                        "always_redistribute_igmp": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    underlay_l2_multicast_group_ipv4_pool: str | None
                    """IPv4_address/Mask."""
                    underlay_l2_multicast_group_ipv4_pool_offset: int | None
                    fast_leave: bool | None
                    """Enable IGMP snooping fast-leave feature for all SVIs and l2vlans within the Tenant."""
                    always_redistribute_igmp: bool | None
                    """
                    Always configure `redistribute igmp` under BGP for all SVIs within the Tenant if `evpn_l2_multicast`
                    is True.
                    By default `redistribute igmp` is only configured when `evpn_l2_multicast` is True and
                    `evpn_l3_multicast` for the VRF is False.
                    Configuring `redistribute igmp` when both L2 and L3 EVPN
                    Multicast is enabled will take up additional control-plane and data-plane resources,
                    but it is
                    required to support forwarding of TTL=1 multicast traffic within the VLAN.
                    This can be overridden
                    per SVI.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        underlay_l2_multicast_group_ipv4_pool: str | None | UndefinedType = Undefined,
                        underlay_l2_multicast_group_ipv4_pool_offset: int | None | UndefinedType = Undefined,
                        fast_leave: bool | None | UndefinedType = Undefined,
                        always_redistribute_igmp: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnL2Multicast.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            underlay_l2_multicast_group_ipv4_pool: IPv4_address/Mask.
                            underlay_l2_multicast_group_ipv4_pool_offset: underlay_l2_multicast_group_ipv4_pool_offset
                            fast_leave: Enable IGMP snooping fast-leave feature for all SVIs and l2vlans within the Tenant.
                            always_redistribute_igmp:
                               Always configure `redistribute igmp` under BGP for all SVIs within the Tenant if `evpn_l2_multicast`
                               is True.
                               By default `redistribute igmp` is only configured when `evpn_l2_multicast` is True and
                               `evpn_l3_multicast` for the VRF is False.
                               Configuring `redistribute igmp` when both L2 and L3 EVPN
                               Multicast is enabled will take up additional control-plane and data-plane resources,
                               but it is
                               required to support forwarding of TTL=1 multicast traffic within the VLAN.
                               This can be overridden
                               per SVI.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class EvpnL3Multicast(AvdModel):
                    class EvpnPegItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "nodes": {"type": list, "items": str}, "transit": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        nodes: list[str]
                        """A description will be applied to all nodes with RP addresses configured if not set."""
                        transit: bool | None
                        """Enable EVPN PEG transit mode."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                            transit: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnPegItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                nodes: A description will be applied to all nodes with RP addresses configured if not set.
                                transit: Enable EVPN PEG transit mode.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "evpn_underlay_l3_multicast_group_ipv4_pool": {"type": str},
                        "evpn_underlay_l3_multicast_group_ipv4_pool_offset": {"type": int},
                        "evpn_peg": {"type": list, "items": EvpnPegItem},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "evpn_underlay_l3_multicast_group_ipv4_pool")
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    evpn_underlay_l3_multicast_group_ipv4_pool: str
                    """IPv4_address/Mask."""
                    evpn_underlay_l3_multicast_group_ipv4_pool_offset: int | None
                    evpn_peg: list[EvpnPegItem]
                    """
                    For each group of nodes, allow configuration of EVPN PEG options.
                    The first group of settings where
                    the device's hostname is present in the 'nodes' list will be used.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        evpn_underlay_l3_multicast_group_ipv4_pool: str | UndefinedType = Undefined,
                        evpn_underlay_l3_multicast_group_ipv4_pool_offset: int | None | UndefinedType = Undefined,
                        evpn_peg: list[EvpnPegItem] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        EvpnL3Multicast.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            evpn_underlay_l3_multicast_group_ipv4_pool: IPv4_address/Mask.
                            evpn_underlay_l3_multicast_group_ipv4_pool_offset: evpn_underlay_l3_multicast_group_ipv4_pool_offset
                            evpn_peg:
                               For each group of nodes, allow configuration of EVPN PEG options.
                               The first group of settings where
                               the device's hostname is present in the 'nodes' list will be used.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PimRpAddressesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "rps": {"type": list, "items": str},
                        "nodes": {"type": list, "items": str},
                        "groups": {"type": list, "items": str},
                        "access_list_name": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    rps: list[str]
                    """List of Rendevouz Points."""
                    nodes: list[str]
                    """
                    Restrict configuration to specific nodes.
                    Configuration Will be applied to all nodes if not set.
                    """
                    groups: list[str]
                    access_list_name: str | None
                    """
                    List of groups to associate with the RP address set in 'rp'.
                    If access_list_name is set, a standard
                    access-list will be configured matching these groups.
                    Otherwise the groups are configured directly
                    on the RP command.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        rps: list[str] | UndefinedType = Undefined,
                        nodes: list[str] | UndefinedType = Undefined,
                        groups: list[str] | UndefinedType = Undefined,
                        access_list_name: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PimRpAddressesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rps: List of Rendevouz Points.
                            nodes:
                               Restrict configuration to specific nodes.
                               Configuration Will be applied to all nodes if not set.
                            groups: groups
                            access_list_name:
                               List of groups to associate with the RP address set in 'rp'.
                               If access_list_name is set, a standard
                               access-list will be configured matching these groups.
                               Otherwise the groups are configured directly
                               on the RP command.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class IgmpSnoopingQuerier(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "source_address": {"type": str},
                        "version": {"type": int, "default": 2},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Will be enabled automatically if "evpn_l2_multicast" is enabled."""
                    source_address: str | None
                    """Default IP address of Loopback0."""
                    version: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        source_address: str | None | UndefinedType = Undefined,
                        version: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        IgmpSnoopingQuerier.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Will be enabled automatically if "evpn_l2_multicast" is enabled.
                            source_address: Default IP address of Loopback0.
                            version: version

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VrfsItem(AvdModel):
                    class IpHelpersItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "ip_helper": {"type": str},
                            "source_interface": {"type": str},
                            "source_vrf": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
                        _custom_data: dict[str, Any]
                        ip_helper: str
                        """IPv4 DHCP server IP."""
                        source_interface: str | None
                        """Interface name."""
                        source_vrf: str | None
                        """VRF to originate DHCP relay packets to DHCP server. If not set, uses current VRF."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ip_helper: str | UndefinedType = Undefined,
                            source_interface: str | None | UndefinedType = Undefined,
                            source_vrf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpHelpersItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ip_helper: IPv4 DHCP server IP.
                                source_interface: Interface name.
                                source_vrf: VRF to originate DHCP relay packets to DHCP server. If not set, uses current VRF.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpHelpers(AvdCollection[str, IpHelpersItem]):
                        _primary_key: ClassVar[str] = "ip_helper"

                    IpHelpers._item_type = IpHelpersItem

                    class VtepDiagnostic(AvdModel):
                        class LoopbackIpPoolsItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pod": {"type": str}, "ipv4_pool": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            pod: str | None
                            """POD name."""
                            ipv4_pool: str | None
                            """IPv4_address/Mask."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                pod: str | None | UndefinedType = Undefined,
                                ipv4_pool: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LoopbackIpPoolsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    pod: POD name.
                                    ipv4_pool: IPv4_address/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "loopback": {"type": int},
                            "loopback_description": {"type": str},
                            "loopback_ip_range": {"type": str},
                            "loopback_ip_pools": {"type": list, "items": LoopbackIpPoolsItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        loopback: int | None
                        """Loopback interface number, required when vtep_diagnotics defined."""
                        loopback_description: str | None
                        """
                        Provide a custom description or description template to be used on the VRF diagnostic loopback
                        interface.
                        This can be a template using the AVD string formatter syntax:
                        https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
                        string-formatter-syntax.
                        The available template fields are:
                          - `interface`: The Loopback interface
                        name.
                          - `vrf`: The VRF name.
                          - `tenant`: The tenant name.

                        The default description is set by
                        `default_vrf_diag_loopback_description`.
                        By default the description is templated from the VRF name.
                        """
                        loopback_ip_range: str | None
                        """
                        IPv4_address/Mask.
                        Loopback ip range, a unique ip is derived from this ranged and assignedto each l3
                        leaf based on it's unique id.
                        Loopback is not created unless loopback_ip_range or loopback_ip_pools
                        are set.
                        """
                        loopback_ip_pools: list[LoopbackIpPoolsItem]
                        """
                        For inventories with multiple PODs a loopback range can be set per POD to avoid overlaps.
                        This only
                        takes effect when loopback_ip_range is not defined, ptional (loopback is not created unless
                        loopback_ip_range or loopback_ip_pools are set).
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            loopback: int | None | UndefinedType = Undefined,
                            loopback_description: str | None | UndefinedType = Undefined,
                            loopback_ip_range: str | None | UndefinedType = Undefined,
                            loopback_ip_pools: list[LoopbackIpPoolsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            VtepDiagnostic.

                            Args:
                            -----
                                _custom_data: _custom_data
                                loopback: Loopback interface number, required when vtep_diagnotics defined.
                                loopback_description:
                                   Provide a custom description or description template to be used on the VRF diagnostic loopback
                                   interface.
                                   This can be a template using the AVD string formatter syntax:
                                   https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
                                   string-formatter-syntax.
                                   The available template fields are:
                                     - `interface`: The Loopback interface
                                   name.
                                     - `vrf`: The VRF name.
                                     - `tenant`: The tenant name.

                                   The default description is set by
                                   `default_vrf_diag_loopback_description`.
                                   By default the description is templated from the VRF name.
                                loopback_ip_range:
                                   IPv4_address/Mask.
                                   Loopback ip range, a unique ip is derived from this ranged and assignedto each l3
                                   leaf based on it's unique id.
                                   Loopback is not created unless loopback_ip_range or loopback_ip_pools
                                   are set.
                                loopback_ip_pools:
                                   For inventories with multiple PODs a loopback range can be set per POD to avoid overlaps.
                                   This only
                                   takes effect when loopback_ip_range is not defined, ptional (loopback is not created unless
                                   loopback_ip_range or loopback_ip_pools are set).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospf(AvdModel):
                        class RedistributeBgp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": True}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            route_map: str | None
                            """Route-map name."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RedistributeBgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: Route-map name.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class RedistributeConnected(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            route_map: str | None
                            """Route-map name."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RedistributeConnected.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: Route-map name.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "process_id": {"type": int},
                            "router_id": {"type": str},
                            "max_lsa": {"type": int},
                            "bfd": {"type": bool, "default": False},
                            "redistribute_bgp": {"type": RedistributeBgp},
                            "redistribute_connected": {"type": RedistributeConnected},
                            "nodes": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        process_id: int | None
                        """If not set, "vrf_id" will be used."""
                        router_id: str | None
                        """If not set, switch router_id will be used."""
                        max_lsa: int | None
                        bfd: bool | None
                        redistribute_bgp: RedistributeBgp
                        redistribute_connected: RedistributeConnected
                        nodes: list[str]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            process_id: int | None | UndefinedType = Undefined,
                            router_id: str | None | UndefinedType = Undefined,
                            max_lsa: int | None | UndefinedType = Undefined,
                            bfd: bool | None | UndefinedType = Undefined,
                            redistribute_bgp: RedistributeBgp | UndefinedType = Undefined,
                            redistribute_connected: RedistributeConnected | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                process_id: If not set, "vrf_id" will be used.
                                router_id: If not set, switch router_id will be used.
                                max_lsa: max_lsa
                                bfd: bfd
                                redistribute_bgp: redistribute_bgp
                                redistribute_connected: redistribute_connected
                                nodes: nodes

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnL3Multicast(AvdModel):
                        class EvpnPegItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "nodes": {"type": list, "items": str},
                                "transit": {"type": bool, "default": False},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            nodes: list[str]
                            """
                            Restrict configuration to specific nodes.
                            Will apply to all nodes with RP addresses configured if
                            not set.
                            """
                            transit: bool | None
                            """Enable EVPN PEG transit mode."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                nodes: list[str] | UndefinedType = Undefined,
                                transit: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnPegItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    nodes:
                                       Restrict configuration to specific nodes.
                                       Will apply to all nodes with RP addresses configured if
                                       not set.
                                    transit: Enable EVPN PEG transit mode.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_underlay_l3_multicast_group": {"type": str},
                            "evpn_peg": {"type": list, "items": EvpnPegItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        evpn_underlay_l3_multicast_group: str | None
                        """
                        IPv4 address of evpn underlay l3 multicast group.
                        To override multicast range set using the formula
                        < l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool > + < vrf_id - 1 > + <
                        l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool_offset >.
                        """
                        evpn_peg: list[EvpnPegItem]
                        """For each group of nodes, allow configuration of EVPN PEG features."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            evpn_underlay_l3_multicast_group: str | None | UndefinedType = Undefined,
                            evpn_peg: list[EvpnPegItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnL3Multicast.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_underlay_l3_multicast_group:
                                   IPv4 address of evpn underlay l3 multicast group.
                                   To override multicast range set using the formula
                                   < l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool > + < vrf_id - 1 > + <
                                   l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool_offset >.
                                evpn_peg: For each group of nodes, allow configuration of EVPN PEG features.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class PimRpAddressesItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "rps": {"type": list, "items": str},
                            "nodes": {"type": list, "items": str},
                            "groups": {"type": list, "items": str},
                            "access_list_name": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        rps: list[str]
                        """A minimum of one RP must be specified."""
                        nodes: list[str]
                        """
                        Restrict configuration to specific nodes.
                        Configuration Will be applied to all nodes if not set.
                        """
                        groups: list[str]
                        access_list_name: str | None
                        """
                        List of groups to associate with the RP addresses set in 'rps'.
                        If access_list_name is set, a
                        standard access-list will be configured matching these groups.
                        Otherwise the groups are configured
                        directly on the RP command.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            rps: list[str] | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                            groups: list[str] | UndefinedType = Undefined,
                            access_list_name: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PimRpAddressesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                rps: A minimum of one RP must be specified.
                                nodes:
                                   Restrict configuration to specific nodes.
                                   Configuration Will be applied to all nodes if not set.
                                groups: groups
                                access_list_name:
                                   List of groups to associate with the RP addresses set in 'rps'.
                                   If access_list_name is set, a
                                   standard access-list will be configured matching these groups.
                                   Otherwise the groups are configured
                                   directly on the RP command.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class SvisItem(AvdModel):
                        class NodesItem(AvdModel):
                            class IpHelpersItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "ip_helper": {"type": str},
                                    "source_interface": {"type": str},
                                    "source_vrf": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
                                _custom_data: dict[str, Any]
                                ip_helper: str
                                """IPv4 DHCP server IP."""
                                source_interface: str | None
                                """Interface name to originate DHCP relay packets to DHCP server."""
                                source_vrf: str | None
                                """VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    ip_helper: str | UndefinedType = Undefined,
                                    source_interface: str | None | UndefinedType = Undefined,
                                    source_vrf: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    IpHelpersItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        ip_helper: IPv4 DHCP server IP.
                                        source_interface: Interface name to originate DHCP relay packets to DHCP server.
                                        source_vrf: VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class IpHelpers(AvdCollection[str, IpHelpersItem]):
                                _primary_key: ClassVar[str] = "ip_helper"

                            IpHelpers._item_type = IpHelpersItem

                            class EvpnL2Multicast(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool},
                                    "always_redistribute_igmp": {"type": bool},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                always_redistribute_igmp: bool | None
                                """
                                Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                                `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                                By default `redistribute
                                igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                                False.
                                Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                                additional control-plane and data-plane resources,
                                but it is required to support forwarding of TTL=1
                                multicast traffic within the VLAN.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    always_redistribute_igmp: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    EvpnL2Multicast.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        always_redistribute_igmp:
                                           Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                                           `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                                           By default `redistribute
                                           igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                                           False.
                                           Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                                           additional control-plane and data-plane resources,
                                           but it is required to support forwarding of TTL=1
                                           multicast traffic within the VLAN.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class EvpnL3Multicast(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    EvpnL3Multicast.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class IgmpSnoopingQuerier(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool},
                                    "source_address": {"type": str},
                                    "version": {"type": int},
                                    "fast_leave": {"type": bool},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                """Will be enabled automatically if evpn_l2_multicast is enabled."""
                                source_address: str | None
                                """
                                IPv4_address
                                If not set, IP address of "Loopback0" will be used.
                                """
                                version: int | None
                                """IGMP Version (By default EOS uses IGMP version 2 for IGMP querier)."""
                                fast_leave: bool | None
                                """Enable IGMP snooping fast-leave feature."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    source_address: str | None | UndefinedType = Undefined,
                                    version: int | None | UndefinedType = Undefined,
                                    fast_leave: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    IgmpSnoopingQuerier.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: Will be enabled automatically if evpn_l2_multicast is enabled.
                                        source_address:
                                           IPv4_address
                                           If not set, IP address of "Loopback0" will be used.
                                        version: IGMP Version (By default EOS uses IGMP version 2 for IGMP querier).
                                        fast_leave: Enable IGMP snooping fast-leave feature.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Ospf(AvdModel):
                                class MessageDigestKeysItem(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "id": {"type": int},
                                        "hash_algorithm": {"type": str, "default": "sha512"},
                                        "key": {"type": str},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    id: int | None
                                    hash_algorithm: str | None
                                    key: str | None
                                    """Type 7 encrypted key."""

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        id: int | None | UndefinedType = Undefined,
                                        hash_algorithm: str | None | UndefinedType = Undefined,
                                        key: str | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        MessageDigestKeysItem.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            id: id
                                            hash_algorithm: hash_algorithm
                                            key: Type 7 encrypted key.

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool},
                                    "point_to_point": {"type": bool, "default": True},
                                    "area": {"type": str, "default": "0.0.0.0"},
                                    "cost": {"type": int},
                                    "authentication": {"type": str},
                                    "simple_auth_key": {"type": str},
                                    "message_digest_keys": {"type": list, "items": MessageDigestKeysItem},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                point_to_point: bool | None
                                area: str | None
                                """OSPF area ID."""
                                cost: int | None
                                """OSPF link cost."""
                                authentication: str | None
                                simple_auth_key: str | None
                                """Password used with simple authentication."""
                                message_digest_keys: list[MessageDigestKeysItem]

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    point_to_point: bool | None | UndefinedType = Undefined,
                                    area: str | None | UndefinedType = Undefined,
                                    cost: int | None | UndefinedType = Undefined,
                                    authentication: str | None | UndefinedType = Undefined,
                                    simple_auth_key: str | None | UndefinedType = Undefined,
                                    message_digest_keys: list[MessageDigestKeysItem] | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Ospf.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        point_to_point: point_to_point
                                        area: OSPF area ID.
                                        cost: OSPF link cost.
                                        authentication: authentication
                                        simple_auth_key: Password used with simple authentication.
                                        message_digest_keys: message_digest_keys

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Bgp(AvdModel):
                                class StructuredConfig(EosCliConfigGen.RouterBgp.VlansItem):
                                    pass

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "structured_config": {"type": StructuredConfig},
                                    "raw_eos_cli": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                structured_config: StructuredConfig
                                """
                                Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                                This
                                configuration will not be applied to vlan aware bundles.
                                """
                                raw_eos_cli: str | None
                                """EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    structured_config: StructuredConfig | UndefinedType = Undefined,
                                    raw_eos_cli: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Bgp.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        structured_config:
                                           Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                                           This
                                           configuration will not be applied to vlan aware bundles.
                                        raw_eos_cli: EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class StructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                                pass

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "node": {"type": str},
                                "tags": {"type": list, "items": str, "default": ["all"]},
                                "name": {"type": str},
                                "enabled": {"type": bool},
                                "description": {"type": str},
                                "ip_address": {"type": str},
                                "ipv6_address": {"type": str},
                                "ipv6_enable": {"type": bool},
                                "ip_address_virtual": {"type": str},
                                "ipv6_address_virtuals": {"type": list, "items": str},
                                "ip_address_virtual_secondaries": {"type": list, "items": str},
                                "ip_virtual_router_addresses": {"type": list, "items": str},
                                "ipv6_virtual_router_addresses": {"type": list, "items": str},
                                "ipv4_acl_in": {"type": str},
                                "ipv4_acl_out": {"type": str},
                                "ip_helpers": {"type": IpHelpers},
                                "vni_override": {"type": int},
                                "rt_override": {"type": str},
                                "rd_override": {"type": str},
                                "trunk_groups": {"type": list, "items": str},
                                "evpn_l2_multicast": {"type": EvpnL2Multicast},
                                "evpn_l3_multicast": {"type": EvpnL3Multicast},
                                "igmp_snooping_enabled": {"type": bool},
                                "igmp_snooping_querier": {"type": IgmpSnoopingQuerier},
                                "vxlan": {"type": bool, "default": True},
                                "spanning_tree_priority": {"type": int},
                                "mtu": {"type": int},
                                "ospf": {"type": Ospf},
                                "bgp": {"type": Bgp},
                                "raw_eos_cli": {"type": str},
                                "structured_config": {"type": StructuredConfig},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "node")
                            _custom_data: dict[str, Any]
                            node: str
                            """l3_leaf inventory hostname."""
                            tags: list[str]
                            """
                            Tags leveraged for networks services filtering.
                            Tags are matched against "filter.tags" defined under
                            node type settings.
                            Tags are also matched against the "node_group" name under node type settings.
                            """
                            name: str | None
                            """VLAN name."""
                            enabled: bool | None
                            """Enable or disable interface."""
                            description: str | None
                            """SVI description. By default set to VLAN name."""
                            ip_address: str | None
                            """IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node."""
                            ipv6_address: str | None
                            """IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node."""
                            ipv6_enable: bool | None
                            """Explicitly enable/disable link-local IPv6 addressing."""
                            ip_address_virtual: str | None
                            """
                            IPv4_address/Mask.
                            IPv4 VXLAN Anycast IP address.
                            Conserves IP addresses in VXLAN deployments as it
                            doesn't require unique IP addresses on each node.
                            """
                            ipv6_address_virtuals: list[str]
                            """
                            IPv6 VXLAN Anycast IP addresses.
                            Conserves IPv6 addresses in VXLAN deployments as it doesn't require
                            unique IPv6 addresses on each node.
                            """
                            ip_address_virtual_secondaries: list[str]
                            """Secondary IPv4 VXLAN Anycast IP addresses."""
                            ip_virtual_router_addresses: list[str]
                            """
                            IPv4 VARP addresses.
                            Requires an IP address to be configured on the SVI.
                            If ip_address_virtual is
                            also set, ip_virtual_router_addresses will take precedence
                            _if_ there is an ip_address configured
                            for the node.
                            """
                            ipv6_virtual_router_addresses: list[str]
                            """
                            IPv6 VARP addresses.
                            Requires an IPv6 address to be configured on the SVI.
                            If ipv6_address_virtuals
                            is also set, ipv6_virtual_router_addresses will take precedence
                            _if_ there is an ipv6_address
                            configured for the node.
                            """
                            ipv4_acl_in: str | None
                            """
                            Name of the IPv4 access-list to be assigned in the ingress direction.
                            The access-list must be
                            defined under `ipv4_acls` and supports substitution of the field "interface_ip".
                            """
                            ipv4_acl_out: str | None
                            """
                            Name of the IPv4 Access-list to be assigned in the egress direction.
                            The access-list must be defined
                            under `ipv4_acls` and supports substitution of the field "interface_ip".
                            """
                            ip_helpers: IpHelpers
                            """IP helper for DHCP relay."""
                            vni_override: int | None
                            """
                            By default the VNI will be derived from "mac_vrf_vni_base".
                            The vni_override allows us to override
                            this value and statically define it (optional).
                            """
                            rt_override: str | None
                            """
                            By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                            The rt_override allows us
                            to override this value and statically define it.
                            rt_override will default to vni_override if set.
                            rt_override supports two formats:
                              - A single number which will be used in the RT fields instead of
                            mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                              - A full RT string with colon
                            separator which will override the full RT.
                            """
                            rd_override: str | None
                            """
                            By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                            The rt_override allows us
                            to override this value and statically define it.
                            rd_override will default to rt_override or
                            vni_override if set.

                            rd_override supports two formats:
                              - A single number which will be used in
                            the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                            - A full RD string with colon separator which will override the full RD.
                            """
                            trunk_groups: list[str]
                            evpn_l2_multicast: EvpnL2Multicast
                            """
                            Explicitly enable or disable evpn_l2_multicast to override setting of
                            `<network_services_key>.[].evpn_l2_multicast.enabled`.
                            When evpn_l2_multicast.enabled is set to true
                            for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
                            overriding those individual settings.
                            Requires `evpn_multicast` to also be set to `true`.
                            """
                            evpn_l3_multicast: EvpnL3Multicast
                            """
                            Explicitly enable or disable evpn_l3_multicast to override setting of
                            `<network_services_key>.[].evpn_l3_multicast.enabled` and
                            `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
                            Requires `evpn_multicast` to also be
                            set to `true`.
                            """
                            igmp_snooping_enabled: bool | None
                            """Enable IGMP Snooping (Enabled by default on EOS)."""
                            igmp_snooping_querier: IgmpSnoopingQuerier
                            vxlan: bool | None
                            """Extend this SVI over VXLAN."""
                            spanning_tree_priority: int | None
                            """
                            Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                            under node type settings.
                            The default priority for rapid-PVST is set under the node type settings
                            with `spanning_tree_priority` (default=32768).
                            """
                            mtu: int | None
                            """Interface MTU."""
                            ospf: Ospf
                            """OSPF interface configuration."""
                            bgp: Bgp
                            raw_eos_cli: str | None
                            """EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""
                            structured_config: StructuredConfig
                            """Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                node: str | UndefinedType = Undefined,
                                tags: list[str] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                description: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                ipv6_address: str | None | UndefinedType = Undefined,
                                ipv6_enable: bool | None | UndefinedType = Undefined,
                                ip_address_virtual: str | None | UndefinedType = Undefined,
                                ipv6_address_virtuals: list[str] | UndefinedType = Undefined,
                                ip_address_virtual_secondaries: list[str] | UndefinedType = Undefined,
                                ip_virtual_router_addresses: list[str] | UndefinedType = Undefined,
                                ipv6_virtual_router_addresses: list[str] | UndefinedType = Undefined,
                                ipv4_acl_in: str | None | UndefinedType = Undefined,
                                ipv4_acl_out: str | None | UndefinedType = Undefined,
                                ip_helpers: IpHelpers | UndefinedType = Undefined,
                                vni_override: int | None | UndefinedType = Undefined,
                                rt_override: str | None | UndefinedType = Undefined,
                                rd_override: str | None | UndefinedType = Undefined,
                                trunk_groups: list[str] | UndefinedType = Undefined,
                                evpn_l2_multicast: EvpnL2Multicast | UndefinedType = Undefined,
                                evpn_l3_multicast: EvpnL3Multicast | UndefinedType = Undefined,
                                igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                                igmp_snooping_querier: IgmpSnoopingQuerier | UndefinedType = Undefined,
                                vxlan: bool | None | UndefinedType = Undefined,
                                spanning_tree_priority: int | None | UndefinedType = Undefined,
                                mtu: int | None | UndefinedType = Undefined,
                                ospf: Ospf | UndefinedType = Undefined,
                                bgp: Bgp | UndefinedType = Undefined,
                                raw_eos_cli: str | None | UndefinedType = Undefined,
                                structured_config: StructuredConfig | UndefinedType = Undefined,
                            ) -> None:
                                """
                                NodesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    node: l3_leaf inventory hostname.
                                    tags:
                                       Tags leveraged for networks services filtering.
                                       Tags are matched against "filter.tags" defined under
                                       node type settings.
                                       Tags are also matched against the "node_group" name under node type settings.
                                    name: VLAN name.
                                    enabled: Enable or disable interface.
                                    description: SVI description. By default set to VLAN name.
                                    ip_address: IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node.
                                    ipv6_address: IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node.
                                    ipv6_enable: Explicitly enable/disable link-local IPv6 addressing.
                                    ip_address_virtual:
                                       IPv4_address/Mask.
                                       IPv4 VXLAN Anycast IP address.
                                       Conserves IP addresses in VXLAN deployments as it
                                       doesn't require unique IP addresses on each node.
                                    ipv6_address_virtuals:
                                       IPv6 VXLAN Anycast IP addresses.
                                       Conserves IPv6 addresses in VXLAN deployments as it doesn't require
                                       unique IPv6 addresses on each node.
                                    ip_address_virtual_secondaries: Secondary IPv4 VXLAN Anycast IP addresses.
                                    ip_virtual_router_addresses:
                                       IPv4 VARP addresses.
                                       Requires an IP address to be configured on the SVI.
                                       If ip_address_virtual is
                                       also set, ip_virtual_router_addresses will take precedence
                                       _if_ there is an ip_address configured
                                       for the node.
                                    ipv6_virtual_router_addresses:
                                       IPv6 VARP addresses.
                                       Requires an IPv6 address to be configured on the SVI.
                                       If ipv6_address_virtuals
                                       is also set, ipv6_virtual_router_addresses will take precedence
                                       _if_ there is an ipv6_address
                                       configured for the node.
                                    ipv4_acl_in:
                                       Name of the IPv4 access-list to be assigned in the ingress direction.
                                       The access-list must be
                                       defined under `ipv4_acls` and supports substitution of the field "interface_ip".
                                    ipv4_acl_out:
                                       Name of the IPv4 Access-list to be assigned in the egress direction.
                                       The access-list must be defined
                                       under `ipv4_acls` and supports substitution of the field "interface_ip".
                                    ip_helpers: IP helper for DHCP relay.
                                    vni_override:
                                       By default the VNI will be derived from "mac_vrf_vni_base".
                                       The vni_override allows us to override
                                       this value and statically define it (optional).
                                    rt_override:
                                       By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                                       The rt_override allows us
                                       to override this value and statically define it.
                                       rt_override will default to vni_override if set.
                                       rt_override supports two formats:
                                         - A single number which will be used in the RT fields instead of
                                       mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                                         - A full RT string with colon
                                       separator which will override the full RT.
                                    rd_override:
                                       By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                                       The rt_override allows us
                                       to override this value and statically define it.
                                       rd_override will default to rt_override or
                                       vni_override if set.

                                       rd_override supports two formats:
                                         - A single number which will be used in
                                       the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                                       - A full RD string with colon separator which will override the full RD.
                                    trunk_groups: trunk_groups
                                    evpn_l2_multicast:
                                       Explicitly enable or disable evpn_l2_multicast to override setting of
                                       `<network_services_key>.[].evpn_l2_multicast.enabled`.
                                       When evpn_l2_multicast.enabled is set to true
                                       for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
                                       overriding those individual settings.
                                       Requires `evpn_multicast` to also be set to `true`.
                                    evpn_l3_multicast:
                                       Explicitly enable or disable evpn_l3_multicast to override setting of
                                       `<network_services_key>.[].evpn_l3_multicast.enabled` and
                                       `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
                                       Requires `evpn_multicast` to also be
                                       set to `true`.
                                    igmp_snooping_enabled: Enable IGMP Snooping (Enabled by default on EOS).
                                    igmp_snooping_querier: igmp_snooping_querier
                                    vxlan: Extend this SVI over VXLAN.
                                    spanning_tree_priority:
                                       Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                                       under node type settings.
                                       The default priority for rapid-PVST is set under the node type settings
                                       with `spanning_tree_priority` (default=32768).
                                    mtu: Interface MTU.
                                    ospf: OSPF interface configuration.
                                    bgp: bgp
                                    raw_eos_cli: EOS CLI rendered directly on the VLAN interface in the final EOS configuration.
                                    structured_config: Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Nodes(AvdCollection[str, NodesItem]):
                            _primary_key: ClassVar[str] = "node"

                        Nodes._item_type = NodesItem

                        class IpHelpersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "ip_helper": {"type": str},
                                "source_interface": {"type": str},
                                "source_vrf": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
                            _custom_data: dict[str, Any]
                            ip_helper: str
                            """IPv4 DHCP server IP."""
                            source_interface: str | None
                            """Interface name to originate DHCP relay packets to DHCP server."""
                            source_vrf: str | None
                            """VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ip_helper: str | UndefinedType = Undefined,
                                source_interface: str | None | UndefinedType = Undefined,
                                source_vrf: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                IpHelpersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    ip_helper: IPv4 DHCP server IP.
                                    source_interface: Interface name to originate DHCP relay packets to DHCP server.
                                    source_vrf: VRF to originate DHCP relay packets to DHCP server. If not set, EOS uses the VRF on the SVI.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class IpHelpers(AvdCollection[str, IpHelpersItem]):
                            _primary_key: ClassVar[str] = "ip_helper"

                        IpHelpers._item_type = IpHelpersItem

                        class EvpnL2Multicast(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always_redistribute_igmp": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            always_redistribute_igmp: bool | None
                            """
                            Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                            `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                            By default `redistribute
                            igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                            False.
                            Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                            additional control-plane and data-plane resources,
                            but it is required to support forwarding of TTL=1
                            multicast traffic within the VLAN.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                always_redistribute_igmp: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL2Multicast.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    always_redistribute_igmp:
                                       Always configure `redistribute igmp` under BGP for the VLAN. Overrides the setting of
                                       `<network_services_key>.[].evpn_l2_multicast.always_redistribute_igmp`.
                                       By default `redistribute
                                       igmp` is only configured when `evpn_l2_multicast` is True and `evpn_l3_multicast` for the VRF is
                                       False.
                                       Configuring `redistribute igmp` when both L2 and L3 EVPN Multicast is enabled will take up
                                       additional control-plane and data-plane resources,
                                       but it is required to support forwarding of TTL=1
                                       multicast traffic within the VLAN.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3Multicast(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL3Multicast.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class IgmpSnoopingQuerier(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "source_address": {"type": str},
                                "version": {"type": int},
                                "fast_leave": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            """Will be enabled automatically if evpn_l2_multicast is enabled."""
                            source_address: str | None
                            """
                            IPv4_address
                            If not set, IP address of "Loopback0" will be used.
                            """
                            version: int | None
                            """IGMP Version (By default EOS uses IGMP version 2 for IGMP querier)."""
                            fast_leave: bool | None
                            """Enable IGMP snooping fast-leave feature."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                source_address: str | None | UndefinedType = Undefined,
                                version: int | None | UndefinedType = Undefined,
                                fast_leave: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                IgmpSnoopingQuerier.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: Will be enabled automatically if evpn_l2_multicast is enabled.
                                    source_address:
                                       IPv4_address
                                       If not set, IP address of "Loopback0" will be used.
                                    version: IGMP Version (By default EOS uses IGMP version 2 for IGMP querier).
                                    fast_leave: Enable IGMP snooping fast-leave feature.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Ospf(AvdModel):
                            class MessageDigestKeysItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "id": {"type": int},
                                    "hash_algorithm": {"type": str, "default": "sha512"},
                                    "key": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                id: int | None
                                hash_algorithm: str | None
                                key: str | None
                                """Type 7 encrypted key."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    id: int | None | UndefinedType = Undefined,
                                    hash_algorithm: str | None | UndefinedType = Undefined,
                                    key: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MessageDigestKeysItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        id: id
                                        hash_algorithm: hash_algorithm
                                        key: Type 7 encrypted key.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "point_to_point": {"type": bool, "default": True},
                                "area": {"type": str, "default": "0.0.0.0"},
                                "cost": {"type": int},
                                "authentication": {"type": str},
                                "simple_auth_key": {"type": str},
                                "message_digest_keys": {"type": list, "items": MessageDigestKeysItem},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            point_to_point: bool | None
                            area: str | None
                            """OSPF area ID."""
                            cost: int | None
                            """OSPF link cost."""
                            authentication: str | None
                            simple_auth_key: str | None
                            """Password used with simple authentication."""
                            message_digest_keys: list[MessageDigestKeysItem]

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                point_to_point: bool | None | UndefinedType = Undefined,
                                area: str | None | UndefinedType = Undefined,
                                cost: int | None | UndefinedType = Undefined,
                                authentication: str | None | UndefinedType = Undefined,
                                simple_auth_key: str | None | UndefinedType = Undefined,
                                message_digest_keys: list[MessageDigestKeysItem] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    point_to_point: point_to_point
                                    area: OSPF area ID.
                                    cost: OSPF link cost.
                                    authentication: authentication
                                    simple_auth_key: Password used with simple authentication.
                                    message_digest_keys: message_digest_keys

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Bgp(AvdModel):
                            class StructuredConfig(EosCliConfigGen.RouterBgp.VlansItem):
                                pass

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "structured_config": {"type": StructuredConfig},
                                "raw_eos_cli": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            structured_config: StructuredConfig
                            """
                            Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                            This
                            configuration will not be applied to vlan aware bundles.
                            """
                            raw_eos_cli: str | None
                            """EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                structured_config: StructuredConfig | UndefinedType = Undefined,
                                raw_eos_cli: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    structured_config:
                                       Structured configuration and EOS CLI commands rendered on router_bgp.vlans.[id=<vlan>].
                                       This
                                       configuration will not be applied to vlan aware bundles.
                                    raw_eos_cli: EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS configuration.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "id": {"type": int},
                            "name": {"type": str},
                            "profile": {"type": str},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "evpn_vlan_bundle": {"type": str},
                            "nodes": {"type": Nodes},
                            "enabled": {"type": bool},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "ipv6_address": {"type": str},
                            "ipv6_enable": {"type": bool},
                            "ip_address_virtual": {"type": str},
                            "ipv6_address_virtuals": {"type": list, "items": str},
                            "ip_address_virtual_secondaries": {"type": list, "items": str},
                            "ip_virtual_router_addresses": {"type": list, "items": str},
                            "ipv6_virtual_router_addresses": {"type": list, "items": str},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "ip_helpers": {"type": IpHelpers},
                            "vni_override": {"type": int},
                            "rt_override": {"type": str},
                            "rd_override": {"type": str},
                            "trunk_groups": {"type": list, "items": str},
                            "evpn_l2_multicast": {"type": EvpnL2Multicast},
                            "evpn_l3_multicast": {"type": EvpnL3Multicast},
                            "igmp_snooping_enabled": {"type": bool},
                            "igmp_snooping_querier": {"type": IgmpSnoopingQuerier},
                            "vxlan": {"type": bool, "default": True},
                            "spanning_tree_priority": {"type": int},
                            "mtu": {"type": int},
                            "ospf": {"type": Ospf},
                            "bgp": {"type": Bgp},
                            "raw_eos_cli": {"type": str},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "id", "name")
                        _custom_data: dict[str, Any]
                        id: int
                        """SVI interface id and VLAN id."""
                        name: str
                        """VLAN name."""
                        profile: str | None
                        """
                        SVI profile name to apply.
                        SVI can refer to one svi_profile which again can refer to another
                        svi_profile to inherit settings in up to two levels (svi -> svi_profile -> svi_parent_profile).
                        """
                        tags: list[str]
                        """
                        Tags leveraged for networks services filtering.
                        Tags are matched against "filter.tags" defined under
                        node type settings.
                        Tags are also matched against the "node_group" name under node type settings.
                        """
                        evpn_vlan_bundle: str | None
                        """
                        Name of a bundle defined under 'evpn_vlan_bundles' to inherit configuration.
                        This setting overrides
                        "evpn_vlan_bundle" set at tenant level.
                        The common option "evpn_vlan_aware_bundles" is disregarded
                        for this option.
                        """
                        nodes: Nodes
                        """
                        Define node specific configuration, such as unique IP addresses.
                        Any keys set here will be merged
                        onto the SVI config, except `structured_config` keys which will replace the `structured_config` set
                        on SVI level.
                        """
                        enabled: bool | None
                        """Enable or disable interface."""
                        description: str | None
                        """SVI description. By default set to VLAN name."""
                        ip_address: str | None
                        """IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node."""
                        ipv6_address: str | None
                        """IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node."""
                        ipv6_enable: bool | None
                        """Explicitly enable/disable link-local IPv6 addressing."""
                        ip_address_virtual: str | None
                        """
                        IPv4_address/Mask.
                        IPv4 VXLAN Anycast IP address.
                        Conserves IP addresses in VXLAN deployments as it
                        doesn't require unique IP addresses on each node.
                        """
                        ipv6_address_virtuals: list[str]
                        """
                        IPv6 VXLAN Anycast IP addresses.
                        Conserves IPv6 addresses in VXLAN deployments as it doesn't require
                        unique IPv6 addresses on each node.
                        """
                        ip_address_virtual_secondaries: list[str]
                        """Secondary IPv4 VXLAN Anycast IP addresses."""
                        ip_virtual_router_addresses: list[str]
                        """
                        IPv4 VARP addresses.
                        Requires an IP address to be configured on the SVI.
                        If ip_address_virtual is
                        also set, ip_virtual_router_addresses will take precedence
                        _if_ there is an ip_address configured
                        for the node.
                        """
                        ipv6_virtual_router_addresses: list[str]
                        """
                        IPv6 VARP addresses.
                        Requires an IPv6 address to be configured on the SVI.
                        If ipv6_address_virtuals
                        is also set, ipv6_virtual_router_addresses will take precedence
                        _if_ there is an ipv6_address
                        configured for the node.
                        """
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports substitution of the field "interface_ip".
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports substitution of the field "interface_ip".
                        """
                        ip_helpers: IpHelpers
                        """IP helper for DHCP relay."""
                        vni_override: int | None
                        """
                        By default the VNI will be derived from "mac_vrf_vni_base".
                        The vni_override allows us to override
                        this value and statically define it (optional).
                        """
                        rt_override: str | None
                        """
                        By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                        The rt_override allows us
                        to override this value and statically define it.
                        rt_override will default to vni_override if set.
                        rt_override supports two formats:
                          - A single number which will be used in the RT fields instead of
                        mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                          - A full RT string with colon
                        separator which will override the full RT.
                        """
                        rd_override: str | None
                        """
                        By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                        The rt_override allows us
                        to override this value and statically define it.
                        rd_override will default to rt_override or
                        vni_override if set.

                        rd_override supports two formats:
                          - A single number which will be used in
                        the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                        - A full RD string with colon separator which will override the full RD.
                        """
                        trunk_groups: list[str]
                        evpn_l2_multicast: EvpnL2Multicast
                        """
                        Explicitly enable or disable evpn_l2_multicast to override setting of
                        `<network_services_key>.[].evpn_l2_multicast.enabled`.
                        When evpn_l2_multicast.enabled is set to true
                        for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
                        overriding those individual settings.
                        Requires `evpn_multicast` to also be set to `true`.
                        """
                        evpn_l3_multicast: EvpnL3Multicast
                        """
                        Explicitly enable or disable evpn_l3_multicast to override setting of
                        `<network_services_key>.[].evpn_l3_multicast.enabled` and
                        `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
                        Requires `evpn_multicast` to also be
                        set to `true`.
                        """
                        igmp_snooping_enabled: bool | None
                        """Enable IGMP Snooping (Enabled by default on EOS)."""
                        igmp_snooping_querier: IgmpSnoopingQuerier
                        vxlan: bool | None
                        """Extend this SVI over VXLAN."""
                        spanning_tree_priority: int | None
                        """
                        Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                        under node type settings.
                        The default priority for rapid-PVST is set under the node type settings
                        with `spanning_tree_priority` (default=32768).
                        """
                        mtu: int | None
                        """Interface MTU."""
                        ospf: Ospf
                        """OSPF interface configuration."""
                        bgp: Bgp
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""
                        structured_config: StructuredConfig
                        """Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            id: int | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            evpn_vlan_bundle: str | None | UndefinedType = Undefined,
                            nodes: Nodes | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            ipv6_address: str | None | UndefinedType = Undefined,
                            ipv6_enable: bool | None | UndefinedType = Undefined,
                            ip_address_virtual: str | None | UndefinedType = Undefined,
                            ipv6_address_virtuals: list[str] | UndefinedType = Undefined,
                            ip_address_virtual_secondaries: list[str] | UndefinedType = Undefined,
                            ip_virtual_router_addresses: list[str] | UndefinedType = Undefined,
                            ipv6_virtual_router_addresses: list[str] | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            ip_helpers: IpHelpers | UndefinedType = Undefined,
                            vni_override: int | None | UndefinedType = Undefined,
                            rt_override: str | None | UndefinedType = Undefined,
                            rd_override: str | None | UndefinedType = Undefined,
                            trunk_groups: list[str] | UndefinedType = Undefined,
                            evpn_l2_multicast: EvpnL2Multicast | UndefinedType = Undefined,
                            evpn_l3_multicast: EvpnL3Multicast | UndefinedType = Undefined,
                            igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                            igmp_snooping_querier: IgmpSnoopingQuerier | UndefinedType = Undefined,
                            vxlan: bool | None | UndefinedType = Undefined,
                            spanning_tree_priority: int | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SvisItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: SVI interface id and VLAN id.
                                name: VLAN name.
                                profile:
                                   SVI profile name to apply.
                                   SVI can refer to one svi_profile which again can refer to another
                                   svi_profile to inherit settings in up to two levels (svi -> svi_profile -> svi_parent_profile).
                                tags:
                                   Tags leveraged for networks services filtering.
                                   Tags are matched against "filter.tags" defined under
                                   node type settings.
                                   Tags are also matched against the "node_group" name under node type settings.
                                evpn_vlan_bundle:
                                   Name of a bundle defined under 'evpn_vlan_bundles' to inherit configuration.
                                   This setting overrides
                                   "evpn_vlan_bundle" set at tenant level.
                                   The common option "evpn_vlan_aware_bundles" is disregarded
                                   for this option.
                                nodes:
                                   Define node specific configuration, such as unique IP addresses.
                                   Any keys set here will be merged
                                   onto the SVI config, except `structured_config` keys which will replace the `structured_config` set
                                   on SVI level.
                                enabled: Enable or disable interface.
                                description: SVI description. By default set to VLAN name.
                                ip_address: IPv4_address/Mask. Usually set under "nodes" to have unique IPv4 addresses per node.
                                ipv6_address: IPv6_address/Mask. Usually set under "nodes" to have unique IPv6 addresses per node.
                                ipv6_enable: Explicitly enable/disable link-local IPv6 addressing.
                                ip_address_virtual:
                                   IPv4_address/Mask.
                                   IPv4 VXLAN Anycast IP address.
                                   Conserves IP addresses in VXLAN deployments as it
                                   doesn't require unique IP addresses on each node.
                                ipv6_address_virtuals:
                                   IPv6 VXLAN Anycast IP addresses.
                                   Conserves IPv6 addresses in VXLAN deployments as it doesn't require
                                   unique IPv6 addresses on each node.
                                ip_address_virtual_secondaries: Secondary IPv4 VXLAN Anycast IP addresses.
                                ip_virtual_router_addresses:
                                   IPv4 VARP addresses.
                                   Requires an IP address to be configured on the SVI.
                                   If ip_address_virtual is
                                   also set, ip_virtual_router_addresses will take precedence
                                   _if_ there is an ip_address configured
                                   for the node.
                                ipv6_virtual_router_addresses:
                                   IPv6 VARP addresses.
                                   Requires an IPv6 address to be configured on the SVI.
                                   If ipv6_address_virtuals
                                   is also set, ipv6_virtual_router_addresses will take precedence
                                   _if_ there is an ipv6_address
                                   configured for the node.
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports substitution of the field "interface_ip".
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports substitution of the field "interface_ip".
                                ip_helpers: IP helper for DHCP relay.
                                vni_override:
                                   By default the VNI will be derived from "mac_vrf_vni_base".
                                   The vni_override allows us to override
                                   this value and statically define it (optional).
                                rt_override:
                                   By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                                   The rt_override allows us
                                   to override this value and statically define it.
                                   rt_override will default to vni_override if set.
                                   rt_override supports two formats:
                                     - A single number which will be used in the RT fields instead of
                                   mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                                     - A full RT string with colon
                                   separator which will override the full RT.
                                rd_override:
                                   By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                                   The rt_override allows us
                                   to override this value and statically define it.
                                   rd_override will default to rt_override or
                                   vni_override if set.

                                   rd_override supports two formats:
                                     - A single number which will be used in
                                   the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                                   - A full RD string with colon separator which will override the full RD.
                                trunk_groups: trunk_groups
                                evpn_l2_multicast:
                                   Explicitly enable or disable evpn_l2_multicast to override setting of
                                   `<network_services_key>.[].evpn_l2_multicast.enabled`.
                                   When evpn_l2_multicast.enabled is set to true
                                   for a vlan or a tenant, "igmp snooping" and "igmp snooping querier" will always be enabled,
                                   overriding those individual settings.
                                   Requires `evpn_multicast` to also be set to `true`.
                                evpn_l3_multicast:
                                   Explicitly enable or disable evpn_l3_multicast to override setting of
                                   `<network_services_key>.[].evpn_l3_multicast.enabled` and
                                   `<network_services_key>.[].vrfs.[].evpn_l3_multicast.enabled`.
                                   Requires `evpn_multicast` to also be
                                   set to `true`.
                                igmp_snooping_enabled: Enable IGMP Snooping (Enabled by default on EOS).
                                igmp_snooping_querier: igmp_snooping_querier
                                vxlan: Extend this SVI over VXLAN.
                                spanning_tree_priority:
                                   Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                                   under node type settings.
                                   The default priority for rapid-PVST is set under the node type settings
                                   with `spanning_tree_priority` (default=32768).
                                mtu: Interface MTU.
                                ospf: OSPF interface configuration.
                                bgp: bgp
                                raw_eos_cli: EOS CLI rendered directly on the VLAN interface in the final EOS configuration.
                                structured_config: Custom structured config added under vlan_interfaces.[name=<interface>] for eos_cli_config_gen.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Ospf(AvdModel):
                            class MessageDigestKeysItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "id": {"type": int},
                                    "hash_algorithm": {"type": str, "default": "sha512"},
                                    "key": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                id: int | None
                                hash_algorithm: str | None
                                key: str | None
                                """Key password."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    id: int | None | UndefinedType = Undefined,
                                    hash_algorithm: str | None | UndefinedType = Undefined,
                                    key: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MessageDigestKeysItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        id: id
                                        hash_algorithm: hash_algorithm
                                        key: Key password.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "point_to_point": {"type": bool, "default": False},
                                "area": {"type": str, "default": "0.0.0.0"},
                                "cost": {"type": int},
                                "authentication": {"type": str},
                                "simple_auth_key": {"type": str},
                                "message_digest_keys": {"type": list, "items": MessageDigestKeysItem},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            point_to_point: bool | None
                            area: str | None
                            """OSPF area ID."""
                            cost: int | None
                            """OSPF link cost."""
                            authentication: str | None
                            simple_auth_key: str | None
                            """Password used with simple authentication."""
                            message_digest_keys: list[MessageDigestKeysItem]

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                point_to_point: bool | None | UndefinedType = Undefined,
                                area: str | None | UndefinedType = Undefined,
                                cost: int | None | UndefinedType = Undefined,
                                authentication: str | None | UndefinedType = Undefined,
                                simple_auth_key: str | None | UndefinedType = Undefined,
                                message_digest_keys: list[MessageDigestKeysItem] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    point_to_point: point_to_point
                                    area: OSPF area ID.
                                    cost: OSPF link cost.
                                    authentication: authentication
                                    simple_auth_key: Password used with simple authentication.
                                    message_digest_keys: message_digest_keys

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Pim(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                Pim.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "interfaces": {"type": list, "items": str},
                            "encapsulation_dot1q_vlan": {"type": list, "items": int},
                            "ip_addresses": {"type": list, "items": str},
                            "nodes": {"type": list, "items": str},
                            "description": {"type": str},
                            "descriptions": {"type": list, "items": str},
                            "enabled": {"type": bool},
                            "mtu": {"type": int},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "ospf": {"type": Ospf},
                            "pim": {"type": Pim},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                            "raw_eos_cli": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        interfaces: list[str]
                        encapsulation_dot1q_vlan: list[int]
                        """
                        For sub-interfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        ip_addresses: list[str]
                        nodes: list[str]
                        description: str | None
                        descriptions: list[str]
                        """"descriptions" has precedence over "description"."""
                        enabled: bool | None
                        mtu: int | None
                        ipv4_acl_in: str | None
                        ipv4_acl_out: str | None
                        ospf: Ospf
                        """OSPF interface configuration."""
                        pim: Pim
                        """
                        Enable PIM sparse-mode on the interface; requires "evpn_l3_multicast" to be enabled on the
                        VRF/Tenant.
                        Enabling this implicitly makes the device a PIM External Gateway (PEG) in EVPN designs
                        only.
                        At least one RP address must be configured for EVPN PEG to be configured.
                        """
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen."""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the Ethernet interface in the final EOS configuration."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            interfaces: list[str] | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: list[int] | UndefinedType = Undefined,
                            ip_addresses: list[str] | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            descriptions: list[str] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            pim: Pim | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                interfaces: interfaces
                                encapsulation_dot1q_vlan:
                                   For sub-interfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                ip_addresses: ip_addresses
                                nodes: nodes
                                description: description
                                descriptions: "descriptions" has precedence over "description".
                                enabled: enabled
                                mtu: mtu
                                ipv4_acl_in: ipv4_acl_in
                                ipv4_acl_out: ipv4_acl_out
                                ospf: OSPF interface configuration.
                                pim:
                                   Enable PIM sparse-mode on the interface; requires "evpn_l3_multicast" to be enabled on the
                                   VRF/Tenant.
                                   Enabling this implicitly makes the device a PIM External Gateway (PEG) in EVPN designs
                                   only.
                                   At least one RP address must be configured for EVPN PEG to be configured.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config added under ethernet_interfaces.[name=<interface>] for eos_cli_config_gen.
                                raw_eos_cli: EOS CLI rendered directly on the Ethernet interface in the final EOS configuration.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LoopbacksItem(AvdModel):
                        class Ospf(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "area": {"type": str, "default": "0.0.0.0"},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            area: str | None
                            """OSPF area ID."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                area: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ospf.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    area: OSPF area ID.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "node": {"type": str},
                            "loopback": {"type": int},
                            "ip_address": {"type": str},
                            "description": {"type": str},
                            "enabled": {"type": bool, "default": True},
                            "ospf": {"type": Ospf},
                            "raw_eos_cli": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "node", "loopback", "ip_address")
                        _custom_data: dict[str, Any]
                        node: str
                        loopback: int
                        ip_address: str
                        description: str | None
                        enabled: bool | None
                        ospf: Ospf
                        """OSPF interface configuration."""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the Loopback interface in the final EOS configuration."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            node: str | UndefinedType = Undefined,
                            loopback: int | UndefinedType = Undefined,
                            ip_address: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ospf: Ospf | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LoopbacksItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                node: node
                                loopback: loopback
                                ip_address: ip_address
                                description: description
                                enabled: enabled
                                ospf: OSPF interface configuration.
                                raw_eos_cli: EOS CLI rendered directly on the Loopback interface in the final EOS configuration.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StaticRoutesItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "destination_address_prefix": {"type": str},
                            "gateway": {"type": str},
                            "track_bfd": {"type": bool},
                            "distance": {"type": int},
                            "tag": {"type": int},
                            "name": {"type": str},
                            "metric": {"type": int},
                            "interface": {"type": str},
                            "nodes": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        destination_address_prefix: str | None
                        """IPv4_address."""
                        gateway: str | None
                        """IPv4_address."""
                        track_bfd: bool | None
                        """Track next-hop using BFD."""
                        distance: int | None
                        tag: int | None
                        name: str | None
                        """description."""
                        metric: int | None
                        interface: str | None
                        nodes: list[str]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            destination_address_prefix: str | None | UndefinedType = Undefined,
                            gateway: str | None | UndefinedType = Undefined,
                            track_bfd: bool | None | UndefinedType = Undefined,
                            distance: int | None | UndefinedType = Undefined,
                            tag: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            metric: int | None | UndefinedType = Undefined,
                            interface: str | None | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            StaticRoutesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                destination_address_prefix: IPv4_address.
                                gateway: IPv4_address.
                                track_bfd: Track next-hop using BFD.
                                distance: distance
                                tag: tag
                                name: description.
                                metric: metric
                                interface: interface
                                nodes: nodes

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ipv6StaticRoutesItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "destination_address_prefix": {"type": str},
                            "gateway": {"type": str},
                            "track_bfd": {"type": bool},
                            "distance": {"type": int},
                            "tag": {"type": int},
                            "name": {"type": str},
                            "metric": {"type": int},
                            "interface": {"type": str},
                            "nodes": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        destination_address_prefix: str | None
                        """IPv6_address."""
                        gateway: str | None
                        track_bfd: bool | None
                        """Track next-hop using BFD."""
                        distance: int | None
                        tag: int | None
                        name: str | None
                        """description."""
                        metric: int | None
                        interface: str | None
                        nodes: list[str]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            destination_address_prefix: str | None | UndefinedType = Undefined,
                            gateway: str | None | UndefinedType = Undefined,
                            track_bfd: bool | None | UndefinedType = Undefined,
                            distance: int | None | UndefinedType = Undefined,
                            tag: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            metric: int | None | UndefinedType = Undefined,
                            interface: str | None | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ipv6StaticRoutesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                destination_address_prefix: IPv6_address.
                                gateway: gateway
                                track_bfd: Track next-hop using BFD.
                                distance: distance
                                tag: tag
                                name: description.
                                metric: metric
                                interface: interface
                                nodes: nodes

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class BgpPeersItem(AvdModel):
                        class DefaultOriginate(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "always": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            always: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, always: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                DefaultOriginate.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    always: always

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "ip_address": {"type": str},
                            "peer_group": {"type": str},
                            "remote_as": {"type": str},
                            "description": {"type": str},
                            "password": {"type": str},
                            "send_community": {"type": str},
                            "next_hop_self": {"type": bool},
                            "timers": {"type": str},
                            "maximum_routes": {"type": int},
                            "maximum_routes_warning_only": {"type": bool},
                            "default_originate": {"type": DefaultOriginate},
                            "update_source": {"type": str},
                            "ebgp_multihop": {"type": int},
                            "nodes": {"type": list, "items": str},
                            "set_ipv4_next_hop": {"type": str},
                            "set_ipv6_next_hop": {"type": str},
                            "route_map_out": {"type": str},
                            "route_map_in": {"type": str},
                            "prefix_list_in": {"type": str},
                            "prefix_list_out": {"type": str},
                            "local_as": {"type": str},
                            "weight": {"type": int},
                            "bfd": {"type": bool},
                            "shutdown": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                        _custom_data: dict[str, Any]
                        ip_address: str
                        """IPv4_address or IPv6_address."""
                        peer_group: str | None
                        """Peer group name."""
                        remote_as: str | None
                        """
                        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                        For asdot notation in
                        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                        number.
                        """
                        description: str | None
                        password: str | None
                        """Encrypted password."""
                        send_community: str | None
                        """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                        next_hop_self: bool | None
                        timers: str | None
                        """BGP Keepalive and Hold Timer values in seconds as string <0-3600> <0-3600>."""
                        maximum_routes: int | None
                        """Maximum number of routes (0 means unlimited)."""
                        maximum_routes_warning_only: bool | None
                        default_originate: DefaultOriginate
                        update_source: str | None
                        ebgp_multihop: int | None
                        """Time-to-live in range of hops."""
                        nodes: list[str]
                        """Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network."""
                        set_ipv4_next_hop: str | None
                        """
                        IPv4_address
                        Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by
                        a uniquely generated route-map per neighbor.
                        Next hop takes precedence over route_map_out.
                        """
                        set_ipv6_next_hop: str | None
                        """
                        IPv6_address
                        Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by
                        a uniquely generated route-map per neighbor.
                        Next hop takes precedence over route_map_out.
                        """
                        route_map_out: str | None
                        """Route-map name."""
                        route_map_in: str | None
                        """Route-map name."""
                        prefix_list_in: str | None
                        """
                        Inbound prefix list name.
                        The prefix-list will be associated under the IPv4 or IPv6 address family
                        based on the IP address.
                        """
                        prefix_list_out: str | None
                        """
                        Outbound prefix list name.
                        The prefix-list will be associated under the IPv4 or IPv6 address family
                        based on the IP address.
                        """
                        local_as: str | None
                        """
                        Local BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                        For asdot notation
                        in YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                        number.
                        """
                        weight: int | None
                        bfd: bool | None
                        shutdown: bool | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ip_address: str | UndefinedType = Undefined,
                            peer_group: str | None | UndefinedType = Undefined,
                            remote_as: str | None | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            password: str | None | UndefinedType = Undefined,
                            send_community: str | None | UndefinedType = Undefined,
                            next_hop_self: bool | None | UndefinedType = Undefined,
                            timers: str | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                            default_originate: DefaultOriginate | UndefinedType = Undefined,
                            update_source: str | None | UndefinedType = Undefined,
                            ebgp_multihop: int | None | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                            set_ipv4_next_hop: str | None | UndefinedType = Undefined,
                            set_ipv6_next_hop: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            prefix_list_in: str | None | UndefinedType = Undefined,
                            prefix_list_out: str | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                            bfd: bool | None | UndefinedType = Undefined,
                            shutdown: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BgpPeersItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ip_address: IPv4_address or IPv6_address.
                                peer_group: Peer group name.
                                remote_as:
                                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                   For asdot notation in
                                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                   number.
                                description: description
                                password: Encrypted password.
                                send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                                next_hop_self: next_hop_self
                                timers: BGP Keepalive and Hold Timer values in seconds as string <0-3600> <0-3600>.
                                maximum_routes: Maximum number of routes (0 means unlimited).
                                maximum_routes_warning_only: maximum_routes_warning_only
                                default_originate: default_originate
                                update_source: update_source
                                ebgp_multihop: Time-to-live in range of hops.
                                nodes: Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network.
                                set_ipv4_next_hop:
                                   IPv4_address
                                   Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by
                                   a uniquely generated route-map per neighbor.
                                   Next hop takes precedence over route_map_out.
                                set_ipv6_next_hop:
                                   IPv6_address
                                   Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by
                                   a uniquely generated route-map per neighbor.
                                   Next hop takes precedence over route_map_out.
                                route_map_out: Route-map name.
                                route_map_in: Route-map name.
                                prefix_list_in:
                                   Inbound prefix list name.
                                   The prefix-list will be associated under the IPv4 or IPv6 address family
                                   based on the IP address.
                                prefix_list_out:
                                   Outbound prefix list name.
                                   The prefix-list will be associated under the IPv4 or IPv6 address family
                                   based on the IP address.
                                local_as:
                                   Local BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                   For asdot notation
                                   in YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                   number.
                                weight: weight
                                bfd: bfd
                                shutdown: shutdown

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Bgp(AvdModel):
                        class StructuredConfig(EosCliConfigGen.RouterBgp.VrfsItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "raw_eos_cli": {"type": str},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """
                        Force (no) configuration of BGP for the VRF.
                        If not set, BGP will be configured when needed
                        according to the following rules:
                        - If the VRF is part of an overlay (`evpn` or `mpls`), BGP will be
                        configured for it.
                        - If any BGP peers are configured under the VRF, BGP will be configured for it.
                        This is useful for L2LS designs with VRFs.
                        - If uplink type is `p2p-vrfs` *and* the vrf is included
                        in the uplink VRFs, BGP will be configured for it.
                        """
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS configuration."""
                        structured_config: StructuredConfig
                        """Custom structured config added under router_bgp.vrfs.[name=<vrf>] for eos_cli_config_gen."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled:
                                   Force (no) configuration of BGP for the VRF.
                                   If not set, BGP will be configured when needed
                                   according to the following rules:
                                   - If the VRF is part of an overlay (`evpn` or `mpls`), BGP will be
                                   configured for it.
                                   - If any BGP peers are configured under the VRF, BGP will be configured for it.
                                   This is useful for L2LS designs with VRFs.
                                   - If uplink type is `p2p-vrfs` *and* the vrf is included
                                   in the uplink VRFs, BGP will be configured for it.
                                raw_eos_cli: EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS configuration.
                                structured_config: Custom structured config added under router_bgp.vrfs.[name=<vrf>] for eos_cli_config_gen.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class BgpPeerGroupsItem(AvdModel):
                        class AddressFamilyIpv4(AvdModel):
                            class DefaultOriginate(EosCliConfigGen.RouterBgp.AddressFamilyIpv4.PeerGroupsItem.DefaultOriginate):
                                pass

                            class NextHop(EosCliConfigGen.RouterBgp.AddressFamilyIpv4.PeerGroupsItem.NextHop):
                                pass

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "activate": {"type": bool},
                                "route_map_in": {"type": str},
                                "route_map_out": {"type": str},
                                "default_originate": {"type": DefaultOriginate},
                                "next_hop": {"type": NextHop},
                                "prefix_list_in": {"type": str},
                                "prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            activate: bool | None
                            route_map_in: str | None
                            """Inbound route-map name."""
                            route_map_out: str | None
                            """Outbound route-map name."""
                            default_originate: DefaultOriginate
                            next_hop: NextHop
                            prefix_list_in: str | None
                            """Inbound prefix-list name."""
                            prefix_list_out: str | None
                            """Outbound prefix-list name."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                activate: bool | None | UndefinedType = Undefined,
                                route_map_in: str | None | UndefinedType = Undefined,
                                route_map_out: str | None | UndefinedType = Undefined,
                                default_originate: DefaultOriginate | UndefinedType = Undefined,
                                next_hop: NextHop | UndefinedType = Undefined,
                                prefix_list_in: str | None | UndefinedType = Undefined,
                                prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AddressFamilyIpv4.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    activate: activate
                                    route_map_in: Inbound route-map name.
                                    route_map_out: Outbound route-map name.
                                    default_originate: default_originate
                                    next_hop: next_hop
                                    prefix_list_in: Inbound prefix-list name.
                                    prefix_list_out: Outbound prefix-list name.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class AddressFamilyIpv6(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "activate": {"type": bool},
                                "route_map_in": {"type": str},
                                "route_map_out": {"type": str},
                                "prefix_list_in": {"type": str},
                                "prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            activate: bool | None
                            route_map_in: str | None
                            """Inbound route-map name."""
                            route_map_out: str | None
                            """Outbound route-map name."""
                            prefix_list_in: str | None
                            """Inbound prefix-list name."""
                            prefix_list_out: str | None
                            """Outbound prefix-list name."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                activate: bool | None | UndefinedType = Undefined,
                                route_map_in: str | None | UndefinedType = Undefined,
                                route_map_out: str | None | UndefinedType = Undefined,
                                prefix_list_in: str | None | UndefinedType = Undefined,
                                prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AddressFamilyIpv6.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    activate: activate
                                    route_map_in: Inbound route-map name.
                                    route_map_out: Outbound route-map name.
                                    prefix_list_in: Inbound prefix-list name.
                                    prefix_list_out: Outbound prefix-list name.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class AsPath(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "remote_as_replace_out": {"type": bool},
                                "prepend_own_disabled": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            remote_as_replace_out: bool | None
                            """Replace AS number with local AS number."""
                            prepend_own_disabled: bool | None
                            """Disable prepending own AS number to AS path."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                remote_as_replace_out: bool | None | UndefinedType = Undefined,
                                prepend_own_disabled: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AsPath.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    remote_as_replace_out: Replace AS number with local AS number.
                                    prepend_own_disabled: Disable prepending own AS number to AS path.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class RemovePrivateAs(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "all": {"type": bool},
                                "replace_as": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            all: bool | None
                            replace_as: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                all: bool | None | UndefinedType = Undefined,
                                replace_as: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemovePrivateAs.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    all: all
                                    replace_as: replace_as

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class RemovePrivateAsIngress(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "replace_as": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            replace_as: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                replace_as: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemovePrivateAsIngress.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    replace_as: replace_as

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class BfdTimers(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "interval": {"type": int},
                                "min_rx": {"type": int},
                                "multiplier": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "min_rx", "multiplier")
                            _custom_data: dict[str, Any]
                            interval: int
                            """Interval in milliseconds."""
                            min_rx: int
                            """Rate in milliseconds."""
                            multiplier: int

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                interval: int | UndefinedType = Undefined,
                                min_rx: int | UndefinedType = Undefined,
                                multiplier: int | UndefinedType = Undefined,
                            ) -> None:
                                """
                                BfdTimers.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    interval: Interval in milliseconds.
                                    min_rx: Rate in milliseconds.
                                    multiplier: multiplier

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class DefaultOriginate(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "always": {"type": bool},
                                "route_map": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            always: bool | None
                            route_map: str | None
                            """Route-map name."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                always: bool | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DefaultOriginate.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    always: always
                                    route_map: Route-map name.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MissingPolicy(AvdModel):
                            class DirectionIn(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "action": {"type": str},
                                    "include_community_list": {"type": bool},
                                    "include_prefix_list": {"type": bool},
                                    "include_sub_route_map": {"type": bool},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                                _custom_data: dict[str, Any]
                                action: str
                                """Missing policy action."""
                                include_community_list: bool | None
                                """Include community-list references in missing policy decision."""
                                include_prefix_list: bool | None
                                """Include prefix-list references in missing policy decision."""
                                include_sub_route_map: bool | None
                                """Include sub-route-map references in missing policy decision."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    action: str | UndefinedType = Undefined,
                                    include_community_list: bool | None | UndefinedType = Undefined,
                                    include_prefix_list: bool | None | UndefinedType = Undefined,
                                    include_sub_route_map: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    DirectionIn.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        action: Missing policy action.
                                        include_community_list: Include community-list references in missing policy decision.
                                        include_prefix_list: Include prefix-list references in missing policy decision.
                                        include_sub_route_map: Include sub-route-map references in missing policy decision.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class DirectionOut(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "action": {"type": str},
                                    "include_community_list": {"type": bool},
                                    "include_prefix_list": {"type": bool},
                                    "include_sub_route_map": {"type": bool},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                                _custom_data: dict[str, Any]
                                action: str
                                """Missing policy action."""
                                include_community_list: bool | None
                                """Include community-list references in missing policy decision."""
                                include_prefix_list: bool | None
                                """Include prefix-list references in missing policy decision."""
                                include_sub_route_map: bool | None
                                """Include sub-route-map references in missing policy decision."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    action: str | UndefinedType = Undefined,
                                    include_community_list: bool | None | UndefinedType = Undefined,
                                    include_prefix_list: bool | None | UndefinedType = Undefined,
                                    include_sub_route_map: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    DirectionOut.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        action: Missing policy action.
                                        include_community_list: Include community-list references in missing policy decision.
                                        include_prefix_list: Include prefix-list references in missing policy decision.
                                        include_sub_route_map: Include sub-route-map references in missing policy decision.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "direction_in": {"type": DirectionIn},
                                "direction_out": {"type": DirectionOut},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            direction_in: DirectionIn
                            """Missing policy inbound direction."""
                            direction_out: DirectionOut
                            """Missing policy outbound direction."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                direction_in: DirectionIn | UndefinedType = Undefined,
                                direction_out: DirectionOut | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MissingPolicy.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    direction_in: Missing policy inbound direction.
                                    direction_out: Missing policy outbound direction.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class LinkBandwidth(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "default": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            default: str | None
                            """nn.nn(K|M|G) link speed in bits/second."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                default: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LinkBandwidth.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    default: nn.nn(K|M|G) link speed in bits/second.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class AllowasIn(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "times": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            times: int | None
                            """Number of local ASNs allowed in a BGP update."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                times: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AllowasIn.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    times: Number of local ASNs allowed in a BGP update.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class RibInPrePolicyRetain(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            all: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                all: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RibInPrePolicyRetain.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    all: all

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class SharedSecret(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "hash_algorithm": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "hash_algorithm")
                            _custom_data: dict[str, Any]
                            profile: str
                            """Name of profile defined under `management_security`."""
                            hash_algorithm: str
                            """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                profile: str | UndefinedType = Undefined,
                                hash_algorithm: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SharedSecret.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    profile: Name of profile defined under `management_security`.
                                    hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "name": {"type": str},
                            "nodes": {"type": list, "items": str},
                            "address_family_ipv4": {"type": AddressFamilyIpv4},
                            "address_family_ipv6": {"type": AddressFamilyIpv6},
                            "type": {"type": str},
                            "remote_as": {"type": str},
                            "local_as": {"type": str},
                            "description": {"type": str},
                            "shutdown": {"type": bool},
                            "as_path": {"type": AsPath},
                            "remove_private_as": {"type": RemovePrivateAs},
                            "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                            "next_hop_unchanged": {"type": bool},
                            "update_source": {"type": str},
                            "route_reflector_client": {"type": bool},
                            "bfd": {"type": bool},
                            "bfd_timers": {"type": BfdTimers},
                            "ebgp_multihop": {"type": int},
                            "next_hop_self": {"type": bool},
                            "password": {"type": str},
                            "passive": {"type": bool},
                            "default_originate": {"type": DefaultOriginate},
                            "send_community": {"type": str},
                            "maximum_routes": {"type": int},
                            "maximum_routes_warning_limit": {"type": str},
                            "maximum_routes_warning_only": {"type": bool},
                            "missing_policy": {"type": MissingPolicy},
                            "link_bandwidth": {"type": LinkBandwidth},
                            "allowas_in": {"type": AllowasIn},
                            "weight": {"type": int},
                            "timers": {"type": str},
                            "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                            "route_map_in": {"type": str},
                            "route_map_out": {"type": str},
                            "session_tracker": {"type": str},
                            "shared_secret": {"type": SharedSecret},
                            "ttl_maximum_hops": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        name: str | None
                        """BGP peer group name."""
                        nodes: list[str]
                        """
                        Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network.
                        If not
                        set the peer-group is created on devices which have a bgp_peer mapped to the corresponding
                        peer_group.
                        """
                        address_family_ipv4: AddressFamilyIpv4
                        address_family_ipv6: AddressFamilyIpv6
                        type: str | None
                        """Key only used for documentation or validation purposes."""
                        remote_as: str | None
                        """
                        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                        For asdot notation in
                        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                        number.
                        """
                        local_as: str | None
                        """
                        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                        For asdot notation in
                        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                        number.
                        """
                        description: str | None
                        shutdown: bool | None
                        as_path: AsPath
                        """BGP AS-PATH options."""
                        remove_private_as: RemovePrivateAs
                        """Remove private AS numbers in outbound AS path."""
                        remove_private_as_ingress: RemovePrivateAsIngress
                        next_hop_unchanged: bool | None
                        update_source: str | None
                        """IP address or interface name."""
                        route_reflector_client: bool | None
                        bfd: bool | None
                        """Enable BFD."""
                        bfd_timers: BfdTimers
                        """Override default BFD timers. BFD must be enabled with `bfd: true`."""
                        ebgp_multihop: int | None
                        """Time-to-live in range of hops."""
                        next_hop_self: bool | None
                        password: str | None
                        passive: bool | None
                        default_originate: DefaultOriginate
                        send_community: str | None
                        """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                        maximum_routes: int | None
                        """Maximum number of routes (0 means unlimited)."""
                        maximum_routes_warning_limit: str | None
                        """
                        Maximum number of routes after which a warning is issued (0 means never warn) or
                        Percentage of
                        maximum number of routes at which to warn ("<1-100> percent").
                        """
                        maximum_routes_warning_only: bool | None
                        missing_policy: MissingPolicy
                        """Missing policy configuration for all address-families."""
                        link_bandwidth: LinkBandwidth
                        allowas_in: AllowasIn
                        weight: int | None
                        timers: str | None
                        """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
                        rib_in_pre_policy_retain: RibInPrePolicyRetain
                        route_map_in: str | None
                        """Inbound route-map name."""
                        route_map_out: str | None
                        """Outbound route-map name."""
                        session_tracker: str | None
                        shared_secret: SharedSecret
                        ttl_maximum_hops: int | None
                        """Maximum number of hops."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                            address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                            address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                            type: str | None | UndefinedType = Undefined,
                            remote_as: str | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            shutdown: bool | None | UndefinedType = Undefined,
                            as_path: AsPath | UndefinedType = Undefined,
                            remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                            remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                            next_hop_unchanged: bool | None | UndefinedType = Undefined,
                            update_source: str | None | UndefinedType = Undefined,
                            route_reflector_client: bool | None | UndefinedType = Undefined,
                            bfd: bool | None | UndefinedType = Undefined,
                            bfd_timers: BfdTimers | UndefinedType = Undefined,
                            ebgp_multihop: int | None | UndefinedType = Undefined,
                            next_hop_self: bool | None | UndefinedType = Undefined,
                            password: str | None | UndefinedType = Undefined,
                            passive: bool | None | UndefinedType = Undefined,
                            default_originate: DefaultOriginate | UndefinedType = Undefined,
                            send_community: str | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                            maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                            missing_policy: MissingPolicy | UndefinedType = Undefined,
                            link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                            allowas_in: AllowasIn | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                            timers: str | None | UndefinedType = Undefined,
                            rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                            route_map_in: str | None | UndefinedType = Undefined,
                            route_map_out: str | None | UndefinedType = Undefined,
                            session_tracker: str | None | UndefinedType = Undefined,
                            shared_secret: SharedSecret | UndefinedType = Undefined,
                            ttl_maximum_hops: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BgpPeerGroupsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: BGP peer group name.
                                nodes:
                                   Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network.
                                   If not
                                   set the peer-group is created on devices which have a bgp_peer mapped to the corresponding
                                   peer_group.
                                address_family_ipv4: address_family_ipv4
                                address_family_ipv6: address_family_ipv6
                                type: Key only used for documentation or validation purposes.
                                remote_as:
                                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                   For asdot notation in
                                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                   number.
                                local_as:
                                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                   For asdot notation in
                                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                   number.
                                description: description
                                shutdown: shutdown
                                as_path: BGP AS-PATH options.
                                remove_private_as: Remove private AS numbers in outbound AS path.
                                remove_private_as_ingress: remove_private_as_ingress
                                next_hop_unchanged: next_hop_unchanged
                                update_source: IP address or interface name.
                                route_reflector_client: route_reflector_client
                                bfd: Enable BFD.
                                bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                                ebgp_multihop: Time-to-live in range of hops.
                                next_hop_self: next_hop_self
                                password: password
                                passive: passive
                                default_originate: default_originate
                                send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                                maximum_routes: Maximum number of routes (0 means unlimited).
                                maximum_routes_warning_limit:
                                   Maximum number of routes after which a warning is issued (0 means never warn) or
                                   Percentage of
                                   maximum number of routes at which to warn ("<1-100> percent").
                                maximum_routes_warning_only: maximum_routes_warning_only
                                missing_policy: Missing policy configuration for all address-families.
                                link_bandwidth: link_bandwidth
                                allowas_in: allowas_in
                                weight: weight
                                timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                                rib_in_pre_policy_retain: rib_in_pre_policy_retain
                                route_map_in: Inbound route-map name.
                                route_map_out: Outbound route-map name.
                                session_tracker: session_tracker
                                shared_secret: shared_secret
                                ttl_maximum_hops: Maximum number of hops.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalRouteTargetsItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "type": {"type": str},
                            "address_family": {"type": str},
                            "route_target": {"type": str},
                            "nodes": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        type: str | None
                        address_family: str | None
                        route_target: str | None
                        nodes: list[str]
                        """Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            type: str | None | UndefinedType = Undefined,
                            address_family: str | None | UndefinedType = Undefined,
                            route_target: str | None | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalRouteTargetsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                type: type
                                address_family: address_family
                                route_target: route_target
                                nodes: Nodes is required to restrict configuration of BGP neighbors to certain nodes in the network.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "address_families": {"type": list, "items": str},
                        "description": {"type": str},
                        "vrf_vni": {"type": int},
                        "vrf_id": {"type": int},
                        "rd_override": {"type": str},
                        "rt_override": {"type": str},
                        "mlag_ibgp_peering_ipv4_pool": {"type": str},
                        "ip_helpers": {"type": IpHelpers},
                        "enable_mlag_ibgp_peering_vrfs": {"type": bool},
                        "redistribute_mlag_ibgp_peering_vrfs": {"type": bool, "default": False},
                        "mlag_ibgp_peering_vlan": {"type": int},
                        "vtep_diagnostic": {"type": VtepDiagnostic},
                        "ospf": {"type": Ospf},
                        "redistribute_ospf": {"type": bool, "default": True},
                        "evpn_l3_multicast": {"type": EvpnL3Multicast},
                        "pim_rp_addresses": {"type": list, "items": PimRpAddressesItem},
                        "evpn_l2_multi_domain": {"type": bool},
                        "svis": {"type": list, "items": SvisItem},
                        "l3_interfaces": {"type": list, "items": L3InterfacesItem},
                        "loopbacks": {"type": list, "items": LoopbacksItem},
                        "static_routes": {"type": list, "items": StaticRoutesItem},
                        "ipv6_static_routes": {"type": list, "items": Ipv6StaticRoutesItem},
                        "redistribute_static": {"type": bool},
                        "bgp_peers": {"type": list, "items": BgpPeersItem},
                        "bgp": {"type": Bgp},
                        "bgp_peer_groups": {"type": list, "items": BgpPeerGroupsItem},
                        "additional_route_targets": {"type": list, "items": AdditionalRouteTargetsItem},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    address_families: list[str]
                    description: str | None
                    """VRF description."""
                    vrf_vni: int | None
                    """
                    Required if "vrf_id" is not set.
                    The VRF VNI range is not limited, but if vrf_id is not set,
                    "vrf_vni" is used for calculating MLAG iBGP peering vlan id.
                    "vrf_vni" may also be used for VRF
                    RD/RT ID. See "overlay_rd_type" and "overlay_rt_type" for details.
                    See
                    "mlag_ibgp_peering_vrfs.base_vlan" for details.
                    If vrf_vni > 10000 make sure to adjust
                    "mac_vrf_vni_base" accordingly to avoid overlap.
                    """
                    vrf_id: int | None
                    """
                    Required if "vrf_vni" is not set.
                    "vrf_id" is used as default value for "vrf_vni" and
                    "ospf.process_id" unless those are set.
                    "vrf_id" may also be used for VRF RD/RT ID. See
                    "overlay_rd_type" and "overlay_rt_type" for details.
                    "vrf_id" is preferred over "vrf_vni" for MLAG
                    iBGP peering vlan, see "mlag_ibgp_peering_vrfs.base_vlan" for details.
                    """
                    rd_override: str | None
                    """
                    By default, the VRF RD will be derived from the pattern defined in `overlay_rd_type`.
                    The
                    rd_override allows us to override this value and statically define it.

                    rd_override supports two
                    formats:
                      - A single number will be used in the RD assigned number subfield (second part of the
                    RD).
                      - A full RD string with colon separator which will override the full RD.
                    """
                    rt_override: str | None
                    """
                    By default, the VRF RT will be derived from the pattern defined in `overlay_rt_type`.
                    The
                    rt_override allows us to override this value and statically define it.

                    rt_override supports two
                    formats:
                      - A single number will be used in the RT assigned number subfield (second part of the
                    RT).
                      - A full RT string with colon separator which will override the full RT.
                    """
                    mlag_ibgp_peering_ipv4_pool: str | None
                    """
                    IPv4_address/Mask
                    The subnet used for iBGP peering in the VRF.
                    Each MLAG pair will be assigned a
                    subnet based on the ID of the primary MLAG switch.
                    If not set, "mlag_peer_l3_ipv4_pool" or
                    "mlag_peer_ipv4_pool" will be used.
                    """
                    ip_helpers: IpHelpers
                    """IP helper for DHCP relay."""
                    enable_mlag_ibgp_peering_vrfs: bool | None
                    """
                    MLAG iBGP peering per VRF.
                    By default an iBGP peering is configured per VRF between MLAG peers on
                    separate VLANs.
                    Setting `enable_mlag_ibgp_peering_vrfs: false` under a VRF will change this default
                    and/or override the tenant-wide setting.
                    """
                    redistribute_mlag_ibgp_peering_vrfs: bool | None
                    """
                    Redistribute the connected subnet for the MLAG iBGP peering per VRF into overlay BGP.
                    By default the
                    iBGP peering subnet is not redistributed into the overlay routing protocol per VRF.
                    Setting
                    `redistribute_mlag_ibgp_peering_vrfs: true` under a VRF will change this default and/or override the
                    tenant-wide setting.
                    """
                    mlag_ibgp_peering_vlan: int | None
                    """
                    Manually define the VLAN used on the MLAG pair for the iBGP session.
                    By default this parameter is
                    calculated using the following formula: `<mlag_ibgp_peering_vrfs.base_vlan>` + `<vrf_id>` - 1.
                    """
                    vtep_diagnostic: VtepDiagnostic
                    """
                    Enable VTEP Network diagnostics.
                    This will create a loopback with virtual source-nat enable to
                    perform diagnostics from the switch.
                    """
                    ospf: Ospf
                    """
                    Router OSPF configuration.
                    This will create an OSPF routing instance in the tenant VRF. If there is
                    no nodes definition, the OSPF instance will be
                    created on all leafs where the VRF is deployed. This
                    will also cause automatic OSPF redistribution into BGP unless
                    explicitly turned off with
                    "redistribute_ospf: false".
                    """
                    redistribute_ospf: bool | None
                    """Non-selectively enabling or disabling redistribute ospf inside the VRF."""
                    evpn_l3_multicast: EvpnL3Multicast
                    """
                    Explicitly enable or disable evpn_l3_multicast to override setting of
                    `<network_services_key>.[].evpn_l3_multicast.enabled`.
                    Allow override of
                    `<network_services_key>.[].evpn_l3_multicast` node_settings.
                    Requires `evpn_multicast` to also be
                    set to `true`.
                    """
                    pim_rp_addresses: list[PimRpAddressesItem]
                    """For each group of nodes, allow configuration of RP Addresses & associated groups."""
                    evpn_l2_multi_domain: bool | None
                    """
                    Explicitly extend all VLANs/VLAN-Aware Bundles inside the VRF to remote EVPN domains.
                    Overrides
                    `<network_services_key>.[].evpn_l2_multi_domain`.
                    """
                    svis: list[SvisItem]
                    """
                    List of SVIs.
                    This will create both the L3 SVI and L2 VLAN based on filters applied to the node.
                    """
                    l3_interfaces: list[L3InterfacesItem]
                    """
                    List of L3 interfaces.
                    This will create IP routed interface inside VRF. Length of interfaces, nodes
                    and ip_addresses must match.
                    """
                    loopbacks: list[LoopbacksItem]
                    """
                    List of Loopback interfaces.
                    This will create Loopback interfaces inside the VRF.
                    """
                    static_routes: list[StaticRoutesItem]
                    """
                    List of static routes for v4 and/or v6.
                    This will create static routes inside the tenant VRF.
                    If
                    nodes are not specified, all l3leafs that carry the VRF will also be applied the static routes.
                    If a
                    node has a static route in the VRF, redistribute static will be automatically enabled in that VRF.
                    This automatic behavior can be overridden non-selectively with the redistribute_static knob for the
                    VRF.
                    """
                    ipv6_static_routes: list[Ipv6StaticRoutesItem]
                    redistribute_static: bool | None
                    """Non-selectively enabling or disabling redistribute static inside the VRF."""
                    bgp_peers: list[BgpPeersItem]
                    """
                    List of BGP peer definitions.
                    This will configure BGP neighbors inside the tenant VRF for peering
                    with external devices.
                    The configured peer will automatically be activated for ipv4 or ipv6 address
                    family based on the ip address.
                    Note, only ipv4 and ipv6 address families are currently supported in
                    eos_designs.
                    For other address families, use custom_structured configuration with
                    eos_cli_config_gen.
                    """
                    bgp: Bgp
                    bgp_peer_groups: list[BgpPeerGroupsItem]
                    """
                    List of BGP peer groups definitions.
                    This will configure BGP peer groups to be used inside the
                    tenant VRF for peering with external devices.
                    Since BGP peer groups are configured at higher BGP
                    level, shared between VRFs,
                    peer_group names should not overlap between VRFs.
                    """
                    additional_route_targets: list[AdditionalRouteTargetsItem]
                    """
                    Configuration of extra route-targets for this VRF. Useful for route-leaking or gateway between
                    address families.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        address_families: list[str] | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        vrf_vni: int | None | UndefinedType = Undefined,
                        vrf_id: int | None | UndefinedType = Undefined,
                        rd_override: str | None | UndefinedType = Undefined,
                        rt_override: str | None | UndefinedType = Undefined,
                        mlag_ibgp_peering_ipv4_pool: str | None | UndefinedType = Undefined,
                        ip_helpers: IpHelpers | UndefinedType = Undefined,
                        enable_mlag_ibgp_peering_vrfs: bool | None | UndefinedType = Undefined,
                        redistribute_mlag_ibgp_peering_vrfs: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_peering_vlan: int | None | UndefinedType = Undefined,
                        vtep_diagnostic: VtepDiagnostic | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        redistribute_ospf: bool | None | UndefinedType = Undefined,
                        evpn_l3_multicast: EvpnL3Multicast | UndefinedType = Undefined,
                        pim_rp_addresses: list[PimRpAddressesItem] | UndefinedType = Undefined,
                        evpn_l2_multi_domain: bool | None | UndefinedType = Undefined,
                        svis: list[SvisItem] | UndefinedType = Undefined,
                        l3_interfaces: list[L3InterfacesItem] | UndefinedType = Undefined,
                        loopbacks: list[LoopbacksItem] | UndefinedType = Undefined,
                        static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                        ipv6_static_routes: list[Ipv6StaticRoutesItem] | UndefinedType = Undefined,
                        redistribute_static: bool | None | UndefinedType = Undefined,
                        bgp_peers: list[BgpPeersItem] | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        bgp_peer_groups: list[BgpPeerGroupsItem] | UndefinedType = Undefined,
                        additional_route_targets: list[AdditionalRouteTargetsItem] | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            address_families: address_families
                            description: VRF description.
                            vrf_vni:
                               Required if "vrf_id" is not set.
                               The VRF VNI range is not limited, but if vrf_id is not set,
                               "vrf_vni" is used for calculating MLAG iBGP peering vlan id.
                               "vrf_vni" may also be used for VRF
                               RD/RT ID. See "overlay_rd_type" and "overlay_rt_type" for details.
                               See
                               "mlag_ibgp_peering_vrfs.base_vlan" for details.
                               If vrf_vni > 10000 make sure to adjust
                               "mac_vrf_vni_base" accordingly to avoid overlap.
                            vrf_id:
                               Required if "vrf_vni" is not set.
                               "vrf_id" is used as default value for "vrf_vni" and
                               "ospf.process_id" unless those are set.
                               "vrf_id" may also be used for VRF RD/RT ID. See
                               "overlay_rd_type" and "overlay_rt_type" for details.
                               "vrf_id" is preferred over "vrf_vni" for MLAG
                               iBGP peering vlan, see "mlag_ibgp_peering_vrfs.base_vlan" for details.
                            rd_override:
                               By default, the VRF RD will be derived from the pattern defined in `overlay_rd_type`.
                               The
                               rd_override allows us to override this value and statically define it.

                               rd_override supports two
                               formats:
                                 - A single number will be used in the RD assigned number subfield (second part of the
                               RD).
                                 - A full RD string with colon separator which will override the full RD.
                            rt_override:
                               By default, the VRF RT will be derived from the pattern defined in `overlay_rt_type`.
                               The
                               rt_override allows us to override this value and statically define it.

                               rt_override supports two
                               formats:
                                 - A single number will be used in the RT assigned number subfield (second part of the
                               RT).
                                 - A full RT string with colon separator which will override the full RT.
                            mlag_ibgp_peering_ipv4_pool:
                               IPv4_address/Mask
                               The subnet used for iBGP peering in the VRF.
                               Each MLAG pair will be assigned a
                               subnet based on the ID of the primary MLAG switch.
                               If not set, "mlag_peer_l3_ipv4_pool" or
                               "mlag_peer_ipv4_pool" will be used.
                            ip_helpers: IP helper for DHCP relay.
                            enable_mlag_ibgp_peering_vrfs:
                               MLAG iBGP peering per VRF.
                               By default an iBGP peering is configured per VRF between MLAG peers on
                               separate VLANs.
                               Setting `enable_mlag_ibgp_peering_vrfs: false` under a VRF will change this default
                               and/or override the tenant-wide setting.
                            redistribute_mlag_ibgp_peering_vrfs:
                               Redistribute the connected subnet for the MLAG iBGP peering per VRF into overlay BGP.
                               By default the
                               iBGP peering subnet is not redistributed into the overlay routing protocol per VRF.
                               Setting
                               `redistribute_mlag_ibgp_peering_vrfs: true` under a VRF will change this default and/or override the
                               tenant-wide setting.
                            mlag_ibgp_peering_vlan:
                               Manually define the VLAN used on the MLAG pair for the iBGP session.
                               By default this parameter is
                               calculated using the following formula: `<mlag_ibgp_peering_vrfs.base_vlan>` + `<vrf_id>` - 1.
                            vtep_diagnostic:
                               Enable VTEP Network diagnostics.
                               This will create a loopback with virtual source-nat enable to
                               perform diagnostics from the switch.
                            ospf:
                               Router OSPF configuration.
                               This will create an OSPF routing instance in the tenant VRF. If there is
                               no nodes definition, the OSPF instance will be
                               created on all leafs where the VRF is deployed. This
                               will also cause automatic OSPF redistribution into BGP unless
                               explicitly turned off with
                               "redistribute_ospf: false".
                            redistribute_ospf: Non-selectively enabling or disabling redistribute ospf inside the VRF.
                            evpn_l3_multicast:
                               Explicitly enable or disable evpn_l3_multicast to override setting of
                               `<network_services_key>.[].evpn_l3_multicast.enabled`.
                               Allow override of
                               `<network_services_key>.[].evpn_l3_multicast` node_settings.
                               Requires `evpn_multicast` to also be
                               set to `true`.
                            pim_rp_addresses: For each group of nodes, allow configuration of RP Addresses & associated groups.
                            evpn_l2_multi_domain:
                               Explicitly extend all VLANs/VLAN-Aware Bundles inside the VRF to remote EVPN domains.
                               Overrides
                               `<network_services_key>.[].evpn_l2_multi_domain`.
                            svis:
                               List of SVIs.
                               This will create both the L3 SVI and L2 VLAN based on filters applied to the node.
                            l3_interfaces:
                               List of L3 interfaces.
                               This will create IP routed interface inside VRF. Length of interfaces, nodes
                               and ip_addresses must match.
                            loopbacks:
                               List of Loopback interfaces.
                               This will create Loopback interfaces inside the VRF.
                            static_routes:
                               List of static routes for v4 and/or v6.
                               This will create static routes inside the tenant VRF.
                               If
                               nodes are not specified, all l3leafs that carry the VRF will also be applied the static routes.
                               If a
                               node has a static route in the VRF, redistribute static will be automatically enabled in that VRF.
                               This automatic behavior can be overridden non-selectively with the redistribute_static knob for the
                               VRF.
                            ipv6_static_routes: ipv6_static_routes
                            redistribute_static: Non-selectively enabling or disabling redistribute static inside the VRF.
                            bgp_peers:
                               List of BGP peer definitions.
                               This will configure BGP neighbors inside the tenant VRF for peering
                               with external devices.
                               The configured peer will automatically be activated for ipv4 or ipv6 address
                               family based on the ip address.
                               Note, only ipv4 and ipv6 address families are currently supported in
                               eos_designs.
                               For other address families, use custom_structured configuration with
                               eos_cli_config_gen.
                            bgp: bgp
                            bgp_peer_groups:
                               List of BGP peer groups definitions.
                               This will configure BGP peer groups to be used inside the
                               tenant VRF for peering with external devices.
                               Since BGP peer groups are configured at higher BGP
                               level, shared between VRFs,
                               peer_group names should not overlap between VRFs.
                            additional_route_targets:
                               Configuration of extra route-targets for this VRF. Useful for route-leaking or gateway between
                               address families.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vrfs(AvdCollection[str, VrfsItem]):
                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                class L2vlansItem(AvdModel):
                    class EvpnL2Multicast(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            EvpnL2Multicast.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IgmpSnoopingQuerier(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "source_address": {"type": str},
                            "version": {"type": int, "default": 2},
                            "fast_leave": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Will be enabled automatically if evpn_l2_multicast is enabled."""
                        source_address: str | None
                        """
                        IPv4_address
                        If not set, IP address of "Loopback0" will be used.
                        """
                        version: int | None
                        fast_leave: bool | None
                        """Enable IGMP snooping fast-leave feature."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            source_address: str | None | UndefinedType = Undefined,
                            version: int | None | UndefinedType = Undefined,
                            fast_leave: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IgmpSnoopingQuerier.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Will be enabled automatically if evpn_l2_multicast is enabled.
                                source_address:
                                   IPv4_address
                                   If not set, IP address of "Loopback0" will be used.
                                version: version
                                fast_leave: Enable IGMP snooping fast-leave feature.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Bgp(AvdModel):
                        class StructuredConfig(EosCliConfigGen.RouterBgp.VlansItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "structured_config": {"type": StructuredConfig},
                            "raw_eos_cli": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        structured_config: StructuredConfig
                        """
                        Custom structured config added under router_bgp.vlans.[id=<vlan>] for eos_cli_config_gen.
                        This
                        configuration will not be applied to vlan aware bundles.
                        """
                        raw_eos_cli: str | None
                        """
                        EOS cli commands rendered on router_bgp.vlans.
                        This configuration will not be applied to vlan aware
                        bundles.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                structured_config:
                                   Custom structured config added under router_bgp.vlans.[id=<vlan>] for eos_cli_config_gen.
                                   This
                                   configuration will not be applied to vlan aware bundles.
                                raw_eos_cli:
                                   EOS cli commands rendered on router_bgp.vlans.
                                   This configuration will not be applied to vlan aware
                                   bundles.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "vni_override": {"type": int},
                        "rt_override": {"type": str},
                        "rd_override": {"type": str},
                        "name": {"type": str},
                        "tags": {"type": list, "items": str},
                        "vxlan": {"type": bool, "default": True},
                        "spanning_tree_priority": {"type": int},
                        "evpn_vlan_bundle": {"type": str},
                        "trunk_groups": {"type": list, "items": str},
                        "evpn_l2_multicast": {"type": EvpnL2Multicast},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "igmp_snooping_querier": {"type": IgmpSnoopingQuerier},
                        "bgp": {"type": Bgp},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "name")
                    _custom_data: dict[str, Any]
                    id: int
                    """VLAN ID."""
                    vni_override: int | None
                    """
                    By default the VNI will be derived from mac_vrf_vni_base.
                    The vni_override, allows to override this
                    value and statically define it.
                    """
                    rt_override: str | None
                    """
                    By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                    The rt_override allows us
                    to override this value and statically define it.
                    rt_override will default to vni_override if set.
                    rt_override supports two formats:
                      - A single number which will be used in the RT fields instead of
                    mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                      - A full RT string with colon
                    separator which will override the full RT.
                    """
                    rd_override: str | None
                    """
                    By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                    The rt_override allows us
                    to override this value and statically define it.
                    rd_override will default to rt_override or
                    vni_override if set.

                    rd_override supports two formats:
                      - A single number which will be used in
                    the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                    - A full RD string with colon separator which will override the full RD.
                    """
                    name: str
                    """VLAN name."""
                    tags: list[str]
                    """
                    Tags leveraged for networks services filtering.
                    Tags are matched against filter.tags defined under
                    node type settings.
                    Tags are also matched against the node_group name under node type settings.
                    """
                    vxlan: bool | None
                    """Extend this L2VLAN over VXLAN."""
                    spanning_tree_priority: int | None
                    """
                    Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                    under node type settings.
                    The default priority for rapid-PVST is set under the node type settings
                    with `spanning_tree_priority` (default=32768).
                    """
                    evpn_vlan_bundle: str | None
                    """
                    Name of a bundle defined under 'evpn_vlan_bundles' to inherit configuration.
                    This setting overrides
                    "evpn_vlan_bundle" set at tenant level.
                    The common option "evpn_vlan_aware_bundles" is disregarded
                    for this option.
                    """
                    trunk_groups: list[str]
                    evpn_l2_multicast: EvpnL2Multicast
                    """
                    Explicitly enable or disable evpn_l2_multicast to override setting of
                    `<network_services_key>.[].evpn_l2_multicast.enabled`.
                    When evpn_l2_multicast.enabled is set to true
                    for a vlan or a tenant, igmp snooping and igmp snooping querier will always be enabled, overriding
                    those individual settings.
                    Requires `evpn_multicast` to also be set to `true`.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping."""
                    igmp_snooping_querier: IgmpSnoopingQuerier
                    """
                    Enable igmp snooping querier, by default using IP address of Loopback 0.
                    When enabled, igmp snooping
                    querier will only be configured on l3 devices, i.e., uplink_type: p2p.
                    """
                    bgp: Bgp

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        vni_override: int | None | UndefinedType = Undefined,
                        rt_override: str | None | UndefinedType = Undefined,
                        rd_override: str | None | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        tags: list[str] | UndefinedType = Undefined,
                        vxlan: bool | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        evpn_vlan_bundle: str | None | UndefinedType = Undefined,
                        trunk_groups: list[str] | UndefinedType = Undefined,
                        evpn_l2_multicast: EvpnL2Multicast | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        igmp_snooping_querier: IgmpSnoopingQuerier | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                    ) -> None:
                        """
                        L2vlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: VLAN ID.
                            vni_override:
                               By default the VNI will be derived from mac_vrf_vni_base.
                               The vni_override, allows to override this
                               value and statically define it.
                            rt_override:
                               By default the MAC VRF RT will be derived from mac_vrf_id_base + vlan_id.
                               The rt_override allows us
                               to override this value and statically define it.
                               rt_override will default to vni_override if set.
                               rt_override supports two formats:
                                 - A single number which will be used in the RT fields instead of
                               mac_vrf_id/mac_vrf_vni (see 'overlay_rt_type' for details).
                                 - A full RT string with colon
                               separator which will override the full RT.
                            rd_override:
                               By default the MAC VRF RD will be derived from mac_vrf_id_base + vlan_id.
                               The rt_override allows us
                               to override this value and statically define it.
                               rd_override will default to rt_override or
                               vni_override if set.

                               rd_override supports two formats:
                                 - A single number which will be used in
                               the RD assigned number field instead of mac_vrf_id/mac_vrf_vni (see 'overlay_rd_type' for details).
                               - A full RD string with colon separator which will override the full RD.
                            name: VLAN name.
                            tags:
                               Tags leveraged for networks services filtering.
                               Tags are matched against filter.tags defined under
                               node type settings.
                               Tags are also matched against the node_group name under node type settings.
                            vxlan: Extend this L2VLAN over VXLAN.
                            spanning_tree_priority:
                               Setting spanning-tree priority per VLAN is only supported with `spanning_tree_mode: rapid-pvst`
                               under node type settings.
                               The default priority for rapid-PVST is set under the node type settings
                               with `spanning_tree_priority` (default=32768).
                            evpn_vlan_bundle:
                               Name of a bundle defined under 'evpn_vlan_bundles' to inherit configuration.
                               This setting overrides
                               "evpn_vlan_bundle" set at tenant level.
                               The common option "evpn_vlan_aware_bundles" is disregarded
                               for this option.
                            trunk_groups: trunk_groups
                            evpn_l2_multicast:
                               Explicitly enable or disable evpn_l2_multicast to override setting of
                               `<network_services_key>.[].evpn_l2_multicast.enabled`.
                               When evpn_l2_multicast.enabled is set to true
                               for a vlan or a tenant, igmp snooping and igmp snooping querier will always be enabled, overriding
                               those individual settings.
                               Requires `evpn_multicast` to also be set to `true`.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping.
                            igmp_snooping_querier:
                               Enable igmp snooping querier, by default using IP address of Loopback 0.
                               When enabled, igmp snooping
                               querier will only be configured on l3 devices, i.e., uplink_type: p2p.
                            bgp: bgp

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PointToPointServicesItem(AvdModel):
                    class SubinterfacesItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "number": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "number")
                        _custom_data: dict[str, Any]
                        number: int
                        """Subinterface number."""

                        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, number: int | UndefinedType = Undefined) -> None:
                            """
                            SubinterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                number: Subinterface number.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Subinterfaces(AvdCollection[int, SubinterfacesItem]):
                        _primary_key: ClassVar[str] = "number"

                    Subinterfaces._item_type = SubinterfacesItem

                    class EndpointsItem(AvdModel):
                        class PortChannel(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "short_esi": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            mode: str | None
                            short_esi: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                mode: str | None | UndefinedType = Undefined,
                                short_esi: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                PortChannel.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    mode: mode
                                    short_esi: short_esi

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "id": {"type": int},
                            "nodes": {"type": list, "items": str},
                            "interfaces": {"type": list, "items": str},
                            "port_channel": {"type": PortChannel},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "id", "nodes", "interfaces")
                        _custom_data: dict[str, Any]
                        id: int
                        """Pseudowire ID on this endpoint."""
                        nodes: list[str]
                        """Usually one node. With ESI multihoming we support two nodes per pseudowire endpoint."""
                        interfaces: list[str]
                        """
                        Interfaces patched to the pseudowire on this endpoints.
                        The list of interfaces is mapped to the list
                        of nodes, so they must have the same length.
                        """
                        port_channel: PortChannel

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            id: int | UndefinedType = Undefined,
                            nodes: list[str] | UndefinedType = Undefined,
                            interfaces: list[str] | UndefinedType = Undefined,
                            port_channel: PortChannel | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EndpointsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: Pseudowire ID on this endpoint.
                                nodes: Usually one node. With ESI multihoming we support two nodes per pseudowire endpoint.
                                interfaces:
                                   Interfaces patched to the pseudowire on this endpoints.
                                   The list of interfaces is mapped to the list
                                   of nodes, so they must have the same length.
                                port_channel: port_channel

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "type": {"type": str, "default": "vpws-pseudowire"},
                        "subinterfaces": {"type": Subinterfaces},
                        "endpoints": {"type": list, "items": EndpointsItem},
                        "lldp_disable": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """Pseudowire name."""
                    type: str | None
                    subinterfaces: Subinterfaces
                    """
                    Subinterfaces will create subinterfaces and additional pseudowires/patch panel config for each
                    endpoint.
                    """
                    endpoints: list[EndpointsItem]
                    """Pseudowire terminating endpoints. Must have exactly two items."""
                    lldp_disable: bool | None
                    """Disable LLDP RX/TX on port mode pseudowire services."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        type: str | None | UndefinedType = Undefined,
                        subinterfaces: Subinterfaces | UndefinedType = Undefined,
                        endpoints: list[EndpointsItem] | UndefinedType = Undefined,
                        lldp_disable: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PointToPointServicesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Pseudowire name.
                            type: type
                            subinterfaces:
                               Subinterfaces will create subinterfaces and additional pseudowires/patch panel config for each
                               endpoint.
                            endpoints: Pseudowire terminating endpoints. Must have exactly two items.
                            lldp_disable: Disable LLDP RX/TX on port mode pseudowire services.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PointToPointServices(AvdCollection[str, PointToPointServicesItem]):
                    _primary_key: ClassVar[str] = "name"

                PointToPointServices._item_type = PointToPointServicesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "mac_vrf_vni_base": {"type": int},
                    "mac_vrf_id_base": {"type": int},
                    "vlan_aware_bundle_number_base": {"type": int, "default": 0},
                    "pseudowire_rt_base": {"type": int},
                    "enable_mlag_ibgp_peering_vrfs": {"type": bool},
                    "redistribute_mlag_ibgp_peering_vrfs": {"type": bool, "default": False},
                    "evpn_vlan_bundle": {"type": str},
                    "bgp_peer_groups": {"type": BgpPeerGroups},
                    "evpn_l2_multicast": {"type": EvpnL2Multicast},
                    "evpn_l3_multicast": {"type": EvpnL3Multicast},
                    "pim_rp_addresses": {"type": list, "items": PimRpAddressesItem},
                    "igmp_snooping_querier": {"type": IgmpSnoopingQuerier},
                    "evpn_l2_multi_domain": {"type": bool, "default": True},
                    "vrfs": {"type": Vrfs},
                    "l2vlans": {"type": list, "items": L2vlansItem},
                    "point_to_point_services": {"type": PointToPointServices},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """
                Specify a tenant name.
                Tenant provide a construct to group L3 VRFs and L2 VLANs.
                Networks services
                can be filtered by tenant name.
                """
                mac_vrf_vni_base: int | None
                """
                Base number for MAC VRF VXLAN Network Identifier (required with VXLAN).
                VXLAN VNI is derived from
                the base number with simple addition.
                i.e. mac_vrf_vni_base = 10000, svi 100 = VNI 10100, svi 300 =
                VNI 10300.
                """
                mac_vrf_id_base: int | None
                """
                If not set, "mac_vrf_vni_base" will be used.
                Base number for MAC VRF RD/RT ID (Required unless
                mac_vrf_vni_base is set)
                ID is derived from the base number with simple addition.
                i.e.
                mac_vrf_id_base = 10000, svi 100 = RD/RT 10100, svi 300 = RD/RT 10300.
                """
                vlan_aware_bundle_number_base: int | None
                """
                Base number for VLAN aware bundle RD/RT.
                The "Assigned Number" part of RD/RT is derived from vrf_vni
                + vlan_aware_bundle_number_base.
                """
                pseudowire_rt_base: int | None
                """
                Pseudowire RT base, used to generate route targets for VPWS services.
                Avoid overlapping route target
                spaces between different services.
                """
                enable_mlag_ibgp_peering_vrfs: bool | None
                """
                MLAG iBGP peering per VRF.
                By default an iBGP peering is configured per VRF between MLAG peers on
                separate VLANs.
                Setting `enable_mlag_ibgp_peering_vrfs` false under a tenant will change this
                default to prevent configuration of these peerings and VLANs for all VRFs in the tenant.
                This
                setting can be overridden per VRF.
                """
                redistribute_mlag_ibgp_peering_vrfs: bool | None
                """
                Redistribute the connected subnet for the MLAG iBGP peering per VRF into overlay BGP.
                By default the
                iBGP peering subnet is not redistributed into the overlay routing protocol per VRF.
                Setting
                `redistribute_mlag_ibgp_peering_vrfs: true` under a tenant will change this default to
                redistribution of these subnets for all VRFs in the tenant.
                This setting can be overridden per VRF.
                """
                evpn_vlan_bundle: str | None
                """
                Enable `evpn_vlan_bundle` for all l2vlans and SVIs under the tenant. This `evpn_vlan_bundle` should
                be present in `evpn_vlan_bundles`.
                """
                bgp_peer_groups: BgpPeerGroups
                """
                List of BGP peer groups definitions.
                This will configure BGP peer groups to be used inside the
                tenant VRF for peering with external devices.
                Since BGP peer groups are configured at higher BGP
                level, shared between VRFs,
                peer_group names should not overlap between VRFs.
                """
                evpn_l2_multicast: EvpnL2Multicast
                """
                Enable EVPN L2 Multicast for all SVIs and l2vlans within Tenant.
                - Multicast group binding is
                created only for Multicast traffic. BULL traffic will use ingress-replication.
                - Configures binding
                between VXLAN, VLAN, and multicast group IPv4 address using the following formula:
                  <
                evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool > + < vlan_id - 1 > + <
                evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool_offset >.
                - The recommendation is to assign
                a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.
                - Enables `redistribute igmp` on
                the router bgp MAC VRF.
                - When evpn_l2_multicast.enabled is true for a VLAN or a tenant, "igmp
                snooping" and "igmp snooping querier" will always be enabled - overriding those individual settings.
                - Requires `evpn_multicast` to also be set to `true`.
                """
                evpn_l3_multicast: EvpnL3Multicast
                """
                Enable L3 Multicast for all SVIs and l3vlans within Tenant.
                - In the evpn-l3ls design type, this
                enables L3 EVPN Multicast (aka OISM)'.
                - Multicast group binding for VRF is created only for
                Multicast traffic. BULL traffic will use ingress-replication.
                - Configures binding between VXLAN,
                VLAN, and multicast group IPv4 address using the following formula:
                  <
                l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool > + < vrf_id - 1 > + <
                l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool_offset >.
                - The recommendation is to assign
                a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.
                - If enabled on an SVI using the
                anycast default gateway feature, a diagnostic loopback (see below) MUST be configured to source IGMP
                traffic.
                - Enables `evpn multicast` on the router bgp VRF.
                - When enabled on an SVI:
                     - If
                switch is part of an MLAG pair, enables "pim ipv4 sparse-mode" on the SVI.
                     - If switch is
                standalone or A-A MH, enables "ip igmp" on the SVI.
                     - If "ip address virtual" is configured,
                enables "pim ipv4 local-interface" and uses the diagnostic Loopback defined in the VRF
                - Requires
                `evpn_multicast` to also be set to `true`.
                """
                pim_rp_addresses: list[PimRpAddressesItem]
                """For each group of nodes, allow configuration of RP Addresses & associated groups."""
                igmp_snooping_querier: IgmpSnoopingQuerier
                """
                Enable IGMP snooping querier for each SVI/l2vlan within tenant, by default using IP address of
                Loopback 0.
                When enabled, IGMP snooping querier will only be configured on L3 devices, i.e.,
                uplink_type: p2p.
                """
                evpn_l2_multi_domain: bool | None
                """Explicitly extend all VLANs/VLAN-Aware Bundles inside the tenant to remote EVPN domains."""
                vrfs: Vrfs
                """
                VRFs will only be configured on a node if any of the underlying objects like `svis` or
                `l3_interfaces` apply to the node.

                It is recommended to only define a VRF in one Tenant. If the
                same VRF name is used across multiple tenants and those tenants
                are accepted by `filter.tenants` on
                the node, any object set under the duplicate VRFs must either be unique or be an exact match.

                VRF
                "default" is partially supported under network-services. Currently the supported options for
                "default" vrf are route-target,
                route-distinguisher settings, structured_config, raw_eos_cli in bgp
                and SVIs are the only supported interface type.
                Vlan-aware-bundles are supported as well inside
                default vrf. OSPF is not supported currently.
                """
                l2vlans: list[L2vlansItem]
                """Define L2 network services organized by vlan id."""
                point_to_point_services: PointToPointServices
                """
                Point to point services (pseudowires).
                Only supported for node types with "network_services.l1:
                true".
                By default this is only set for node type "pe" with "design.type: mpls"
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    mac_vrf_vni_base: int | None | UndefinedType = Undefined,
                    mac_vrf_id_base: int | None | UndefinedType = Undefined,
                    vlan_aware_bundle_number_base: int | None | UndefinedType = Undefined,
                    pseudowire_rt_base: int | None | UndefinedType = Undefined,
                    enable_mlag_ibgp_peering_vrfs: bool | None | UndefinedType = Undefined,
                    redistribute_mlag_ibgp_peering_vrfs: bool | None | UndefinedType = Undefined,
                    evpn_vlan_bundle: str | None | UndefinedType = Undefined,
                    bgp_peer_groups: BgpPeerGroups | UndefinedType = Undefined,
                    evpn_l2_multicast: EvpnL2Multicast | UndefinedType = Undefined,
                    evpn_l3_multicast: EvpnL3Multicast | UndefinedType = Undefined,
                    pim_rp_addresses: list[PimRpAddressesItem] | UndefinedType = Undefined,
                    igmp_snooping_querier: IgmpSnoopingQuerier | UndefinedType = Undefined,
                    evpn_l2_multi_domain: bool | None | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                    l2vlans: list[L2vlansItem] | UndefinedType = Undefined,
                    point_to_point_services: PointToPointServices | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworkServicesKeysNameItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name:
                           Specify a tenant name.
                           Tenant provide a construct to group L3 VRFs and L2 VLANs.
                           Networks services
                           can be filtered by tenant name.
                        mac_vrf_vni_base:
                           Base number for MAC VRF VXLAN Network Identifier (required with VXLAN).
                           VXLAN VNI is derived from
                           the base number with simple addition.
                           i.e. mac_vrf_vni_base = 10000, svi 100 = VNI 10100, svi 300 =
                           VNI 10300.
                        mac_vrf_id_base:
                           If not set, "mac_vrf_vni_base" will be used.
                           Base number for MAC VRF RD/RT ID (Required unless
                           mac_vrf_vni_base is set)
                           ID is derived from the base number with simple addition.
                           i.e.
                           mac_vrf_id_base = 10000, svi 100 = RD/RT 10100, svi 300 = RD/RT 10300.
                        vlan_aware_bundle_number_base:
                           Base number for VLAN aware bundle RD/RT.
                           The "Assigned Number" part of RD/RT is derived from vrf_vni
                           + vlan_aware_bundle_number_base.
                        pseudowire_rt_base:
                           Pseudowire RT base, used to generate route targets for VPWS services.
                           Avoid overlapping route target
                           spaces between different services.
                        enable_mlag_ibgp_peering_vrfs:
                           MLAG iBGP peering per VRF.
                           By default an iBGP peering is configured per VRF between MLAG peers on
                           separate VLANs.
                           Setting `enable_mlag_ibgp_peering_vrfs` false under a tenant will change this
                           default to prevent configuration of these peerings and VLANs for all VRFs in the tenant.
                           This
                           setting can be overridden per VRF.
                        redistribute_mlag_ibgp_peering_vrfs:
                           Redistribute the connected subnet for the MLAG iBGP peering per VRF into overlay BGP.
                           By default the
                           iBGP peering subnet is not redistributed into the overlay routing protocol per VRF.
                           Setting
                           `redistribute_mlag_ibgp_peering_vrfs: true` under a tenant will change this default to
                           redistribution of these subnets for all VRFs in the tenant.
                           This setting can be overridden per VRF.
                        evpn_vlan_bundle:
                           Enable `evpn_vlan_bundle` for all l2vlans and SVIs under the tenant. This `evpn_vlan_bundle` should
                           be present in `evpn_vlan_bundles`.
                        bgp_peer_groups:
                           List of BGP peer groups definitions.
                           This will configure BGP peer groups to be used inside the
                           tenant VRF for peering with external devices.
                           Since BGP peer groups are configured at higher BGP
                           level, shared between VRFs,
                           peer_group names should not overlap between VRFs.
                        evpn_l2_multicast:
                           Enable EVPN L2 Multicast for all SVIs and l2vlans within Tenant.
                           - Multicast group binding is
                           created only for Multicast traffic. BULL traffic will use ingress-replication.
                           - Configures binding
                           between VXLAN, VLAN, and multicast group IPv4 address using the following formula:
                             <
                           evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool > + < vlan_id - 1 > + <
                           evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool_offset >.
                           - The recommendation is to assign
                           a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.
                           - Enables `redistribute igmp` on
                           the router bgp MAC VRF.
                           - When evpn_l2_multicast.enabled is true for a VLAN or a tenant, "igmp
                           snooping" and "igmp snooping querier" will always be enabled - overriding those individual settings.
                           - Requires `evpn_multicast` to also be set to `true`.
                        evpn_l3_multicast:
                           Enable L3 Multicast for all SVIs and l3vlans within Tenant.
                           - In the evpn-l3ls design type, this
                           enables L3 EVPN Multicast (aka OISM)'.
                           - Multicast group binding for VRF is created only for
                           Multicast traffic. BULL traffic will use ingress-replication.
                           - Configures binding between VXLAN,
                           VLAN, and multicast group IPv4 address using the following formula:
                             <
                           l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool > + < vrf_id - 1 > + <
                           l3_multicast.evpn_underlay_l3_multicast_group_ipv4_pool_offset >.
                           - The recommendation is to assign
                           a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.
                           - If enabled on an SVI using the
                           anycast default gateway feature, a diagnostic loopback (see below) MUST be configured to source IGMP
                           traffic.
                           - Enables `evpn multicast` on the router bgp VRF.
                           - When enabled on an SVI:
                                - If
                           switch is part of an MLAG pair, enables "pim ipv4 sparse-mode" on the SVI.
                                - If switch is
                           standalone or A-A MH, enables "ip igmp" on the SVI.
                                - If "ip address virtual" is configured,
                           enables "pim ipv4 local-interface" and uses the diagnostic Loopback defined in the VRF
                           - Requires
                           `evpn_multicast` to also be set to `true`.
                        pim_rp_addresses: For each group of nodes, allow configuration of RP Addresses & associated groups.
                        igmp_snooping_querier:
                           Enable IGMP snooping querier for each SVI/l2vlan within tenant, by default using IP address of
                           Loopback 0.
                           When enabled, IGMP snooping querier will only be configured on L3 devices, i.e.,
                           uplink_type: p2p.
                        evpn_l2_multi_domain: Explicitly extend all VLANs/VLAN-Aware Bundles inside the tenant to remote EVPN domains.
                        vrfs:
                           VRFs will only be configured on a node if any of the underlying objects like `svis` or
                           `l3_interfaces` apply to the node.

                           It is recommended to only define a VRF in one Tenant. If the
                           same VRF name is used across multiple tenants and those tenants
                           are accepted by `filter.tenants` on
                           the node, any object set under the duplicate VRFs must either be unique or be an exact match.

                           VRF
                           "default" is partially supported under network-services. Currently the supported options for
                           "default" vrf are route-target,
                           route-distinguisher settings, structured_config, raw_eos_cli in bgp
                           and SVIs are the only supported interface type.
                           Vlan-aware-bundles are supported as well inside
                           default vrf. OSPF is not supported currently.
                        l2vlans: Define L2 network services organized by vlan id.
                        point_to_point_services:
                           Point to point services (pseudowires).
                           Only supported for node types with "network_services.l1:
                           true".
                           By default this is only set for node type "pe" with "design.type: mpls"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworkServicesKeysName(AvdCollection[str, NetworkServicesKeysNameItem]):
                _primary_key: ClassVar[str] = "name"

            NetworkServicesKeysName._item_type = NetworkServicesKeysNameItem

            _fields: ClassVar[dict] = {"key": {"type": str}, "value": {"type": NetworkServicesKeysName, "key": "network_services_keys_name"}}
            _required_fields: ClassVar[tuple] = ("key",)
            key: str
            """Key used as dynamic key"""
            value: NetworkServicesKeysName
            """Value of dynamic key"""

            def __init__(self, *, key: str | UndefinedType = Undefined, value: NetworkServicesKeysName | UndefinedType = Undefined) -> None:
                """
                DynamicNetworkServicesKeys.

                Args:
                -----
                    key: Key used as dynamic key
                    value: Value of dynamic key

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DynamicNodeTypeKeys(AvdModel):
            class NodeTypeKeysKey(AvdModel):
                class Defaults(AvdModel):
                    class LinkTracking(AvdModel):
                        class GroupsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "name": {"type": str},
                                "recovery_delay": {"type": int},
                                "links_minimum": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            name: str | None
                            """Tracking group name."""
                            recovery_delay: int | None
                            """default -> platform_settings_mlag_reload_delay -> 300."""
                            links_minimum: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                recovery_delay: int | None | UndefinedType = Undefined,
                                links_minimum: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                GroupsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    name: Tracking group name.
                                    recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                    links_minimum: links_minimum

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "groups": {
                                "type": list,
                                "items": GroupsItem,
                                "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                            },
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        groups: list[GroupsItem]
                        """
                        Link Tracking Groups.
                        By default a single group named "LT_GROUP1" is defined with default values.
                        Any groups defined under "groups" will replace the default.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            groups: list[GroupsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                groups:
                                   Link Tracking Groups.
                                   By default a single group named "LT_GROUP1" is defined with default values.
                                   Any groups defined under "groups" will replace the default.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LacpPortIdRange(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "size": {"type": int, "default": 128},
                            "offset": {"type": int, "default": 0},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        size: int | None
                        """Recommended size > = number of ports in the switch."""
                        offset: int | None
                        """
                        Offset is used to avoid overlapping port-id ranges of different switches.
                        Useful when a "connected-
                        endpoint" is connected to switches in different "node_groups".
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            offset: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LacpPortIdRange.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                size: Recommended size > = number of ports in the switch.
                                offset:
                                   Offset is used to avoid overlapping port-id ranges of different switches.
                                   Useful when a "connected-
                                   endpoint" is connected to switches in different "node_groups".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    class UplinkPtp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enable: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkPtp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enable: enable

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UplinkMacsec(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        profile: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkMacsec.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: profile

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                        pass

                    class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class Filter(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "tenants": {"type": list, "items": str, "default": ["all"]},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "always_include_vrfs_in_tenants": {"type": list, "items": str},
                            "only_vlans_in_use": {"type": bool, "default": False},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        tenants: list[str]
                        """
                        Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                        Tenants (default).
                        This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                        """
                        tags: list[str]
                        """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                        allow_vrfs: list[str]
                        """
                        Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                        (default).
                        This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                        """
                        deny_vrfs: list[str]
                        """
                        Prevent configuration of Network Services defined under these VRFs.
                        This list prevents the given
                        VRFs to be included by any other filtering mechanism.
                        """
                        always_include_vrfs_in_tenants: list[str]
                        """
                        List of tenants where VRFs will be configured even if VLANs are not included in tags.
                        Useful for L3
                        "border" leaf.
                        """
                        only_vlans_in_use: bool | None
                        """
                        Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                        Note! This
                        feature only considers configuration managed by eos_designs.
                        This excludes structured_config,
                        custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            tenants: list[str] | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            allow_vrfs: list[str] | UndefinedType = Undefined,
                            deny_vrfs: list[str] | UndefinedType = Undefined,
                            always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                            only_vlans_in_use: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.

                            Args:
                            -----
                                _custom_data: _custom_data
                                tenants:
                                   Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                   Tenants (default).
                                   This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                allow_vrfs:
                                   Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                   (default).
                                   This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                deny_vrfs:
                                   Prevent configuration of Network Services defined under these VRFs.
                                   This list prevents the given
                                   VRFs to be included by any other filtering mechanism.
                                always_include_vrfs_in_tenants:
                                   List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                   Useful for L3
                                   "border" leaf.
                                only_vlans_in_use:
                                   Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                   Note! This
                                   feature only considers configuration managed by eos_designs.
                                   This excludes structured_config,
                                   custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            hostname: str | None
                            """Hostname of remote EVPN GW server."""
                            ip_address: str | None
                            """Peering IP of remote Route Server."""
                            bgp_as: str | None
                            """
                            Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                            interpreted as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                bgp_as: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote EVPN GW server.
                                    ip_address: Peering IP of remote Route Server.
                                    bgp_as:
                                       Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                       interpreted as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL2(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL2.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "inter_domain": {"type": bool, "default": True},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            inter_domain: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                inter_domain: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL3.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    inter_domain: inter_domain

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                            "evpn_l2": {"type": EvpnL2},
                            "evpn_l3": {"type": EvpnL3},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_peers: list[RemotePeersItem]
                        """
                        Define remote peers of the EVPN VXLAN Gateway.
                        If the hostname can be found in the inventory,
                        ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                        If the
                        peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                        """
                        evpn_l2: EvpnL2
                        """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                        evpn_l3: EvpnL3
                        """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            evpn_l2: EvpnL2 | UndefinedType = Undefined,
                            evpn_l3: EvpnL3 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_peers:
                                   Define remote peers of the EVPN VXLAN Gateway.
                                   If the hostname can be found in the inventory,
                                   ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                   If the
                                   peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                            _custom_data: dict[str, Any]
                            hostname: str
                            """Hostname of remote IPVPN Peer."""
                            ip_address: str
                            """Peering IP of remote IPVPN Peer."""
                            bgp_as: str
                            """
                            Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For
                            asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                            as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | UndefinedType = Undefined,
                                ip_address: str | UndefinedType = Undefined,
                                bgp_as: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote IPVPN Peer.
                                    ip_address: Peering IP of remote IPVPN Peer.
                                    bgp_as:
                                       Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For
                                       asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                       as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_domain_id": {"type": str, "default": "65535:1"},
                            "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                            "enable_d_path": {"type": bool, "default": True},
                            "maximum_routes": {"type": int, "default": 0},
                            "local_as": {"type": str, "default": "none"},
                            "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        evpn_domain_id: str | None
                        """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                        ipvpn_domain_id: str | None
                        """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                        enable_d_path: bool | None
                        """Enable D-path for use with BGP bestpath selection algorithm."""
                        maximum_routes: int | None
                        """Maximum routes to accept from IPVPN remote peers."""
                        local_as: str | None
                        """
                        Local BGP AS applied to peering with IPVPN remote peers.
                        BGP AS <1-4294967295> or AS number in asdot
                        notation "<1-65535>.<0-65535>".
                        For asdot notation in YAML inputs, the value must be put in quotes,
                        to prevent it from being interpreted as a float number.
                        """
                        address_families: list[str]
                        """IPVPN address families to enable for remote peers."""
                        remote_peers: list[RemotePeersItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            evpn_domain_id: str | None | UndefinedType = Undefined,
                            ipvpn_domain_id: str | None | UndefinedType = Undefined,
                            enable_d_path: bool | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            address_families: list[str] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                local_as:
                                   Local BGP AS applied to peering with IPVPN remote peers.
                                   BGP AS <1-4294967295> or AS number in asdot
                                   notation "<1-65535>.<0-65535>".
                                   For asdot notation in YAML inputs, the value must be put in quotes,
                                   to prevent it from being interpreted as a float number.
                                address_families: IPVPN address families to enable for remote peers.
                                remote_peers: remote_peers

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        class Dscp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            general_messages: int | None
                            event_messages: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                general_messages: int | None | UndefinedType = Undefined,
                                event_messages: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dscp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    general_messages: general_messages
                                    event_messages: event_messages

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Monitor(AvdModel):
                            class Threshold(AvdModel):
                                class Drop(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int},
                                        "mean_path_delay": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Drop.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "offset_from_master": {"type": int, "default": 250},
                                    "mean_path_delay": {"type": int, "default": 1500},
                                    "drop": {"type": Drop},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                offset_from_master: int | None
                                mean_path_delay: int | None
                                drop: Drop

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    offset_from_master: int | None | UndefinedType = Undefined,
                                    mean_path_delay: int | None | UndefinedType = Undefined,
                                    drop: Drop | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Threshold.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        offset_from_master: offset_from_master
                                        mean_path_delay: mean_path_delay
                                        drop: drop

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class MissingMessage(AvdModel):
                                class Intervals(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "announce": {"type": int},
                                        "follow_up": {"type": int},
                                        "sync": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    announce: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Intervals.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            announce: announce
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class SequenceIds(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "enabled": {"type": bool, "default": True},
                                        "announce": {"type": int, "default": 3},
                                        "delay_resp": {"type": int, "default": 3},
                                        "follow_up": {"type": int, "default": 3},
                                        "sync": {"type": int, "default": 3},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    enabled: bool | None
                                    announce: int | None
                                    delay_resp: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        enabled: bool | None | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        delay_resp: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        SequenceIds.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            enabled: enabled
                                            announce: announce
                                            delay_resp: delay_resp
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "intervals": {"type": Intervals},
                                    "sequence_ids": {"type": SequenceIds},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                intervals: Intervals
                                sequence_ids: SequenceIds

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    intervals: Intervals | UndefinedType = Undefined,
                                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MissingMessage.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        intervals: intervals
                                        sequence_ids: sequence_ids

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "threshold": {"type": Threshold},
                                "missing_message": {"type": MissingMessage},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            threshold: Threshold
                            missing_message: MissingMessage

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                threshold: Threshold | UndefinedType = Undefined,
                                missing_message: MissingMessage | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Monitor.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    threshold: threshold
                                    missing_message: missing_message

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                            "mlag": {"type": bool, "default": False},
                            "domain": {"type": int, "default": 127},
                            "priority1": {"type": int},
                            "priority2": {"type": int},
                            "auto_clock_identity": {"type": bool, "default": True},
                            "clock_identity_prefix": {"type": str},
                            "clock_identity": {"type": str},
                            "source_ip": {"type": str},
                            "mode": {"type": str, "default": "boundary"},
                            "mode_one_step": {"type": bool, "default": False},
                            "ttl": {"type": int},
                            "forward_unicast": {"type": bool, "default": False},
                            "dscp": {"type": Dscp},
                            "monitor": {"type": Monitor},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """
                        mlag: bool | None
                        """
                        Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                        configured on the MLAG peer-link port-channel.
                        """
                        domain: int | None
                        priority1: int | None
                        """default -> automatically set based on node_type."""
                        priority2: int | None
                        """default -> (node_id modulus 256)."""
                        auto_clock_identity: bool | None
                        """
                        If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                        default EOS behaviour, simply disable the automatic PTP clock identity.
                        default ->
                        (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                        HEX).
                        """
                        clock_identity_prefix: str | None
                        """
                        PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                        By default the 3-byte prefix is "00:1C:73".
                        This
                        can be overridden if auto_clock_identity is set to true (which is the default).
                        """
                        clock_identity: str | None
                        """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                        source_ip: str | None
                        """
                        By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                        relevant SVI, which is the recommended behaviour.
                        This can be set manually if required, for example,
                        to a value of "10.1.2.3".
                        """
                        mode: str | None
                        mode_one_step: bool | None
                        ttl: int | None
                        forward_unicast: bool | None
                        """Enable PTP unicast forwarding."""
                        dscp: Dscp
                        monitor: Monitor

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            domain: int | None | UndefinedType = Undefined,
                            priority1: int | None | UndefinedType = Undefined,
                            priority2: int | None | UndefinedType = Undefined,
                            auto_clock_identity: bool | None | UndefinedType = Undefined,
                            clock_identity_prefix: str | None | UndefinedType = Undefined,
                            clock_identity: str | None | UndefinedType = Undefined,
                            source_ip: str | None | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            mode_one_step: bool | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            forward_unicast: bool | None | UndefinedType = Undefined,
                            dscp: Dscp | UndefinedType = Undefined,
                            monitor: Monitor | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"
                                mlag:
                                   Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                   configured on the MLAG peer-link port-channel.
                                domain: domain
                                priority1: default -> automatically set based on node_type.
                                priority2: default -> (node_id modulus 256).
                                auto_clock_identity:
                                   If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                   default EOS behaviour, simply disable the automatic PTP clock identity.
                                   default ->
                                   (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                   HEX).
                                clock_identity_prefix:
                                   PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                   By default the 3-byte prefix is "00:1C:73".
                                   This
                                   can be overridden if auto_clock_identity is set to true (which is the default).
                                clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                source_ip:
                                   By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                   relevant SVI, which is the recommended behaviour.
                                   This can be set manually if required, for example,
                                   to a value of "10.1.2.3".
                                mode: mode
                                mode_one_step: mode_one_step
                                ttl: ttl
                                forward_unicast: Enable PTP unicast forwarding.
                                dscp: dscp
                                monitor: monitor

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class WanHa(AvdModel):
                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": True},
                            "ipsec": {"type": bool, "default": True},
                            "mtu": {"type": int, "default": 9194},
                            "ha_interfaces": {"type": list, "items": str},
                            "ha_ipv4_pool": {"type": str},
                            "max_ha_interfaces": {"type": int},
                            "port_channel_id": {"type": int},
                            "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                            "flow_tracking": {"type": FlowTracking},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                        ipsec: bool | None
                        """Enable / Disable IPsec over HA path-group when HA is enabled."""
                        mtu: int | None
                        """Set MTU on WAN HA interfaces."""
                        ha_interfaces: list[str]
                        """
                        Local WAN HA interfaces
                        Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                        Can be used to filter uplink interfaces when there are multiple uplinks.
                        Limitations:
                          Either all
                        interfaces must be uplinks or all interfaces must not be uplinks.
                          Only one interface is supported
                        for non uplinks.
                        """
                        ha_ipv4_pool: str | None
                        """
                        IP address pool used for WAN HA connectivity.
                        IP is derived from the node ID.
                        Not used for uplink
                        interfaces.
                        """
                        max_ha_interfaces: int | None
                        """
                        Number of parallel links towards HA switches.
                        Can be used to reserve IP addresses for future
                        parallel HA links.
                        """
                        port_channel_id: int | None
                        """Port-channel ID to use for direct HA."""
                        use_port_channel_for_direct_ha: bool | None
                        """
                        Enable or disable using a port-channel interface for direct HA when there is only one interface.
                        This feature was introduced in EOS 4.33.0F.
                        """
                        flow_tracking: FlowTracking
                        """
                        Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                        setting.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ipsec: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ha_interfaces: list[str] | UndefinedType = Undefined,
                            ha_ipv4_pool: str | None | UndefinedType = Undefined,
                            max_ha_interfaces: int | None | UndefinedType = Undefined,
                            port_channel_id: int | None | UndefinedType = Undefined,
                            use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WanHa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                mtu: Set MTU on WAN HA interfaces.
                                ha_interfaces:
                                   Local WAN HA interfaces
                                   Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                   Can be used to filter uplink interfaces when there are multiple uplinks.
                                   Limitations:
                                     Either all
                                   interfaces must be uplinks or all interfaces must not be uplinks.
                                     Only one interface is supported
                                   for non uplinks.
                                ha_ipv4_pool:
                                   IP address pool used for WAN HA connectivity.
                                   IP is derived from the node ID.
                                   Not used for uplink
                                   interfaces.
                                max_ha_interfaces:
                                   Number of parallel links towards HA switches.
                                   Can be used to reserve IP addresses for future
                                   parallel HA links.
                                port_channel_id: Port-channel ID to use for direct HA.
                                use_port_channel_for_direct_ha:
                                   Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                   This feature was introduced in EOS 4.33.0F.
                                flow_tracking:
                                   Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                   setting.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Bgp(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "peer_as": {"type": str},
                                "ipv4_prefix_list_in": {"type": str},
                                "ipv4_prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                            _custom_data: dict[str, Any]
                            peer_as: str
                            """
                            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in
                            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                            number.
                            """
                            ipv4_prefix_list_in: str | None
                            """
                            Prefix List Name. Accept routes for only these prefixes from the peer.
                            Required for wan interfaces.
                            """
                            ipv4_prefix_list_out: str | None
                            """
                            Prefix List Name. Advertise routes for only these prefixes.
                            If not specified, nothing would be
                            advertised.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                peer_as: str | UndefinedType = Undefined,
                                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    peer_as:
                                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in
                                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                       number.
                                    ipv4_prefix_list_in:
                                       Prefix List Name. Accept routes for only these prefixes from the peer.
                                       Required for wan interfaces.
                                    ipv4_prefix_list_out:
                                       Prefix List Name. Advertise routes for only these prefixes.
                                       If not specified, nothing would be
                                       advertised.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StaticRoutesItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                            _custom_data: dict[str, Any]
                            prefix: str
                            """IPv4_network/Mask."""

                            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                                """
                                StaticRoutesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    prefix: IPv4_network/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class CvPathfinderInternetExit(AvdModel):
                            class PoliciesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                _custom_data: dict[str, Any]
                                name: str
                                """Internet-exit policy name."""
                                tunnel_interface_numbers: str | None
                                """
                                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                interface.
                                Examples: '1-3' or '100,200,300'
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | UndefinedType = Undefined,
                                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PoliciesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Internet-exit policy name.
                                        tunnel_interface_numbers:
                                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                           interface.
                                           Examples: '1-3' or '100,200,300'

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Policies(AvdCollection[str, PoliciesItem]):
                                _primary_key: ClassVar[str] = "name"

                            Policies._item_type = PoliciesItem

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            policies: Policies
                            """List of Internet-exit policies using this interface as exit."""

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                            ) -> None:
                                """
                                CvPathfinderInternetExit.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    policies: List of Internet-exit policies using this interface as exit.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "profile": {"type": str},
                            "name": {"type": str},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "dhcp_ip": {"type": str},
                            "public_ip": {"type": str},
                            "encapsulation_dot1q_vlan": {"type": int},
                            "dhcp_accept_default_route": {"type": bool, "default": True},
                            "enabled": {"type": bool, "default": True},
                            "speed": {"type": str},
                            "peer": {"type": str},
                            "peer_interface": {"type": str},
                            "peer_ip": {"type": str},
                            "bgp": {"type": Bgp},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "static_routes": {"type": list, "items": StaticRoutesItem},
                            "qos_profile": {"type": str},
                            "wan_carrier": {"type": str},
                            "wan_circuit_id": {"type": str},
                            "connected_to_pathfinder": {"type": bool, "default": True},
                            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                            "raw_eos_cli": {"type": str},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        profile: str | None
                        """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                        name: str
                        """
                        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                        For a
                        subinterface, the parent physical interface is automatically created.
                        """
                        description: str | None
                        """
                        Interface description.
                        If not set a default description will be configured with '[<peer>[
                        <peer_interface>]]'.
                        """
                        ip_address: str | None
                        """Node IPv4 address/Mask or 'dhcp'."""
                        dhcp_ip: str | None
                        """
                        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                        IPv4 address
                        (without mask) to be allocated on the interface if known.
                        This is not rendered in the configuration
                        but can be used for substitution of 'interface_ip' in the Access-list
                        set under `ipv4_acl_in` and
                        `ipv4_acl_out`.
                        """
                        public_ip: str | None
                        """
                        Node IPv4 address (no mask).

                        This is used to get the public IP (if known) when the device is behind
                        NAT.
                        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                        with the following preference:
                          `wan_route_servers.path_groups.interfaces.ip_address`
                              ->
                        `l3_interfaces.public_ip`
                                  -> `l3_interfaces.ip_address`

                        The determined Public IP is used
                        by WAN routers when peering with this interface.
                        """
                        encapsulation_dot1q_vlan: int | None
                        """
                        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        dhcp_accept_default_route: bool | None
                        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                        enabled: bool | None
                        """Enable or Shutdown the interface."""
                        speed: str | None
                        """
                        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                        <interface_speed>`.
                        """
                        peer: str | None
                        """The peer device name. Used for description and documentation."""
                        peer_interface: str | None
                        """The peer device interface. Used for description and documentation."""
                        peer_ip: str | None
                        """
                        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                        and `ip` is an IP address.
                        """
                        bgp: Bgp
                        """Enforce IPv4 BGP peering for the peer"""
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        Required
                        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                        `wan_carriers`.
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        """
                        static_routes: list[StaticRoutesItem]
                        """Configure IPv4 static routes pointing to `peer_ip`."""
                        qos_profile: str | None
                        """QOS service profile."""
                        wan_carrier: str | None
                        """
                        The WAN carrier this interface is connected to.
                        This is used to infer the path-groups in which this
                        interface should be configured.
                        Unless the carrier is marked as 'trusted' under `wan_carriers`,
                        `ipv4_acl_in` is also required on all WAN interfaces.
                        """
                        wan_circuit_id: str | None
                        """
                        The WAN circuit ID for this interface.
                        This is not rendered in the configuration but used for WAN
                        designs.
                        """
                        connected_to_pathfinder: bool | None
                        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                        cv_pathfinder_internet_exit: CvPathfinderInternetExit
                        """PREVIEW: This key is in preview mode"""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the interface in the final EOS configuration."""
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config for the Ethernet interface."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            dhcp_ip: str | None | UndefinedType = Undefined,
                            public_ip: str | None | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            speed: str | None | UndefinedType = Undefined,
                            peer: str | None | UndefinedType = Undefined,
                            peer_interface: str | None | UndefinedType = Undefined,
                            peer_ip: str | None | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                            qos_profile: str | None | UndefinedType = Undefined,
                            wan_carrier: str | None | UndefinedType = Undefined,
                            wan_circuit_id: str | None | UndefinedType = Undefined,
                            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                name:
                                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                   For a
                                   subinterface, the parent physical interface is automatically created.
                                description:
                                   Interface description.
                                   If not set a default description will be configured with '[<peer>[
                                   <peer_interface>]]'.
                                ip_address: Node IPv4 address/Mask or 'dhcp'.
                                dhcp_ip:
                                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                   IPv4 address
                                   (without mask) to be allocated on the interface if known.
                                   This is not rendered in the configuration
                                   but can be used for substitution of 'interface_ip' in the Access-list
                                   set under `ipv4_acl_in` and
                                   `ipv4_acl_out`.
                                public_ip:
                                   Node IPv4 address (no mask).

                                   This is used to get the public IP (if known) when the device is behind
                                   NAT.
                                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                   with the following preference:
                                     `wan_route_servers.path_groups.interfaces.ip_address`
                                         ->
                                   `l3_interfaces.public_ip`
                                             -> `l3_interfaces.ip_address`

                                   The determined Public IP is used
                                   by WAN routers when peering with this interface.
                                encapsulation_dot1q_vlan:
                                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                enabled: Enable or Shutdown the interface.
                                speed:
                                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                   <interface_speed>`.
                                peer: The peer device name. Used for description and documentation.
                                peer_interface: The peer device interface. Used for description and documentation.
                                peer_ip:
                                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                   and `ip` is an IP address.
                                bgp: Enforce IPv4 BGP peering for the peer
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                   Required
                                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                   `wan_carriers`.
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                qos_profile: QOS service profile.
                                wan_carrier:
                                   The WAN carrier this interface is connected to.
                                   This is used to infer the path-groups in which this
                                   interface should be configured.
                                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                   `ipv4_acl_in` is also required on all WAN interfaces.
                                wan_circuit_id:
                                   The WAN circuit ID for this interface.
                                   This is not rendered in the configuration but used for WAN
                                   designs.
                                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config for the Ethernet interface.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                        _primary_key: ClassVar[str] = "name"

                    L3Interfaces._item_type = L3InterfacesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "platform": {"type": str},
                        "mac_address": {"type": str},
                        "system_mac_address": {"type": str},
                        "serial_number": {"type": str},
                        "rack": {"type": str},
                        "mgmt_ip": {"type": str},
                        "mgmt_gateway": {"type": str},
                        "ipv6_mgmt_ip": {"type": str},
                        "ipv6_mgmt_gateway": {"type": str},
                        "mgmt_interface": {"type": str},
                        "link_tracking": {"type": LinkTracking},
                        "lacp_port_id_range": {"type": LacpPortIdRange},
                        "always_configure_ip_routing": {"type": bool, "default": False},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                        "uplink_type": {"type": str, "default": "p2p"},
                        "uplink_ipv4_pool": {"type": str},
                        "uplink_interfaces": {"type": list, "items": str},
                        "uplink_switch_interfaces": {"type": list, "items": str},
                        "uplink_switches": {"type": list, "items": str},
                        "uplink_interface_speed": {"type": str},
                        "uplink_switch_interface_speed": {"type": str},
                        "uplink_mtu": {"type": int},
                        "max_uplink_switches": {"type": int},
                        "max_parallel_uplinks": {"type": int},
                        "uplink_bfd": {"type": bool, "default": False},
                        "uplink_native_vlan": {"type": int},
                        "uplink_ptp": {"type": UplinkPtp},
                        "uplink_macsec": {"type": UplinkMacsec},
                        "uplink_port_channel_id": {"type": int},
                        "uplink_switch_port_channel_id": {"type": int},
                        "uplink_structured_config": {"type": dict},
                        "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                        "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                        "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                        "short_esi": {"type": str},
                        "isis_system_id_prefix": {"type": str},
                        "isis_maximum_paths": {"type": int},
                        "is_type": {"type": str, "default": "level-2"},
                        "node_sid_base": {"type": int, "default": 0},
                        "loopback_ipv4_pool": {"type": str},
                        "loopback_ipv4_address": {"type": str},
                        "vtep_loopback_ipv4_pool": {"type": str},
                        "vtep_loopback_ipv4_address": {"type": str},
                        "loopback_ipv4_offset": {"type": int, "default": 0},
                        "loopback_ipv6_pool": {"type": str},
                        "loopback_ipv6_offset": {"type": int, "default": 0},
                        "vtep": {"type": bool},
                        "vtep_loopback": {"type": str},
                        "bgp_as": {"type": str},
                        "bgp_defaults": {"type": list, "items": str},
                        "evpn_role": {"type": str},
                        "evpn_route_servers": {"type": list, "items": str},
                        "evpn_services_l2_only": {"type": bool, "default": False},
                        "filter": {"type": Filter},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "evpn_gateway": {"type": EvpnGateway},
                        "ipvpn_gateway": {"type": IpvpnGateway},
                        "mlag": {"type": bool, "default": True},
                        "mlag_dual_primary_detection": {"type": bool, "default": False},
                        "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                        "mlag_interfaces": {"type": list, "items": str},
                        "mlag_interfaces_speed": {"type": str},
                        "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                        "mlag_peer_l3_ipv4_pool": {"type": str},
                        "mlag_peer_vlan": {"type": int, "default": 4094},
                        "mlag_peer_link_allowed_vlans": {"type": str},
                        "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                        "mlag_peer_ipv4_pool": {"type": str},
                        "mlag_peer_ipv6_pool": {"type": str},
                        "mlag_port_channel_id": {"type": int},
                        "mlag_domain_id": {"type": str},
                        "spanning_tree_mode": {"type": str},
                        "spanning_tree_priority": {"type": int, "default": 32768},
                        "spanning_tree_root_super": {"type": bool, "default": False},
                        "virtual_router_mac_address": {"type": str},
                        "inband_mgmt_interface": {"type": str},
                        "inband_mgmt_vlan": {"type": int, "default": 4092},
                        "inband_mgmt_subnet": {"type": str},
                        "inband_mgmt_ip": {"type": str},
                        "inband_mgmt_gateway": {"type": str},
                        "inband_mgmt_ipv6_address": {"type": str},
                        "inband_mgmt_ipv6_subnet": {"type": str},
                        "inband_mgmt_ipv6_gateway": {"type": str},
                        "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vrf": {"type": str, "default": "default"},
                        "inband_mgmt_mtu": {"type": int, "default": 1500},
                        "inband_ztp": {"type": bool, "default": False},
                        "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                        "mpls_overlay_role": {"type": str},
                        "overlay_address_families": {"type": list, "items": str},
                        "mpls_route_reflectors": {"type": list, "items": str},
                        "bgp_cluster_id": {"type": str},
                        "ptp": {"type": Ptp},
                        "wan_role": {"type": str},
                        "cv_pathfinder_transit_mode": {"type": str},
                        "cv_pathfinder_region": {"type": str},
                        "cv_pathfinder_site": {"type": str},
                        "wan_ha": {"type": WanHa},
                        "dps_mss_ipv4": {"type": str, "default": "auto"},
                        "l3_interfaces": {"type": L3Interfaces},
                        "data_plane_cpu_allocation_max": {"type": int},
                        "flow_tracker_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    id: int | None
                    """Unique identifier used for IP addressing and other algorithms."""
                    platform: str | None
                    """Arista platform family."""
                    mac_address: str | None
                    """Leverage to document management interface mac address."""
                    system_mac_address: str | None
                    """
                    System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                    Set to the same MAC address as
                    available in "show version" on the device.
                    "system_mac_address" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    serial_number: str | None
                    """
                    Set to the Serial Number of the device.
                    Only used for documentation purpose in the fabric
                    documentation and part of the structured_config.
                    "serial_number" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    rack: str | None
                    """Rack that the switch is located in (only used in snmp_settings location)."""
                    mgmt_ip: str | None
                    """Node management interface IPv4 address."""
                    mgmt_gateway: str | None
                    """
                    This key sets the management gateway for the device. It takes precedence over the global
                    `mgmt_gateway`.
                    """
                    ipv6_mgmt_ip: str | None
                    """Node management interface IPv6 address."""
                    ipv6_mgmt_gateway: str | None
                    """
                    This key sets the ipv6 management gateway for the device. It takes precedence over the global
                    `ipv6_mgmt_gateway`.
                    """
                    mgmt_interface: str | None
                    """
                    Management Interface Name.
                    Default -> platform_management_interface -> mgmt_interface ->
                    "Management1".
                    """
                    link_tracking: LinkTracking
                    """
                    This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                    the upstream interfaces.
                    Useful in EVPN multhoming designs.
                    """
                    lacp_port_id_range: LacpPortIdRange
                    """
                    This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                    number of nodes in the "node_group".
                    Unique LACP port-id ranges are recommended for EVPN Multihoming
                    designs.
                    """
                    always_configure_ip_routing: bool | None
                    """
                    Force configuration of "ip routing" even on L2 devices.
                    Use this to retain behavior of AVD versions
                    below 4.0.0.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""
                    uplink_type: str | None
                    """
                    Override the default `uplink_type` set at the `node_type_key` level.
                    `uplink_type` must be "p2p" if
                    `vtep` or `underlay_router` is true for the `node_type_key` definition.
                    """
                    uplink_ipv4_pool: str | None
                    """IPv4 subnet to use to connect to uplink switches."""
                    uplink_interfaces: list[str]
                    """
                    Local uplink interfaces.
                    Each list item supports range syntax that can be expanded into a list of
                    interfaces.
                    If uplink_interfaces is not defined, platform-specific defaults (defined under
                    default_interfaces) will be used instead.
                    Please note that default_interfaces are not defined by
                    default, you should define these yourself.
                    """
                    uplink_switch_interfaces: list[str]
                    """Interfaces located on uplink switches."""
                    uplink_switches: list[str]
                    uplink_interface_speed: str | None
                    """
                    Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                    (Uplink switch
                    interface speed can be overridden with `uplink_switch_interface_speed`).
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_switch_interface_speed: str | None
                    """
                    Set point-to-Point interface speed for the uplink switch interface only.
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_mtu: int | None
                    """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                    max_uplink_switches: int | None
                    """
                    Maximum number of uplink switches.
                    Changing this value may change IP Addressing on uplinks.
                    Can be
                    used to reserve IP space for future expansions.
                    """
                    max_parallel_uplinks: int | None
                    """
                    Number of parallel links towards uplink switches.
                    Changing this value may change interface naming on
                    uplinks (and corresponding downlinks).
                    Can be used to reserve interfaces for future parallel
                    uplinks.
                    """
                    uplink_bfd: bool | None
                    """Enable bfd on uplink interfaces."""
                    uplink_native_vlan: int | None
                    """
                    Only applicable to switches with layer-2 port-channel uplinks.
                    A suspended (disabled) vlan will be
                    created in both ends of the link unless the vlan is defined under network services.
                    By default the
                    uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                    """
                    uplink_ptp: UplinkPtp
                    """Enable PTP on all infrastructure links."""
                    uplink_macsec: UplinkMacsec
                    """Enable MacSec on all uplinks."""
                    uplink_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink Port-channel
                    ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                    For
                    example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [ Eth11/1, Eth22/1 ] -> ID 111
                    For
                    MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                    This
                    option overrides the default behavior and statically sets the local Port-channel ID.
                    Note! Make sure
                    the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                    value.
                    """
                    uplink_switch_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink switch Port-
                    channel ID will be set to the number of the first interface defined under
                    `uplink_switch_interfaces`.
                    For example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [
                    Eth11/1, Eth22/1 ] -> ID 111
                    For MLAG port-channels ID will be based on the lowest member interface
                    on the first MLAG switch.
                    This option overrides the default behavior and statically sets the Port-
                    channel ID on the uplink switch.
                    Note! Make sure the ID is unique and does not overlap with
                    autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between
                    1 and 2000 and both MLAG switches must have the same value.
                    """
                    uplink_structured_config: dict
                    """
                    Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                    When
                    uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                    for eos_cli_config_gen overrides the settings on the ethernet interface level.
                    When uplink_type ==
                    "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                    eos_cli_config_gen overrides the settings on the port-channel interface level.
                    "uplink_structured_config" is applied after "structured_config", so it can override
                    "structured_config" defined on node-level.
                    Note! The content of this dictionary is _not_ validated
                    by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                    """
                    mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                    """
                    Custom structured config applied to MLAG peer link port-channel id.
                    Added under
                    port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the
                    port-channel interface level.
                    "mlag_port_channel_structured_config" is applied after
                    "structured_config", so it can override "structured_config" defined on node-level.
                    """
                    mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                    """
                    Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                    override "structured_config" defined on node-level.
                    """
                    mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                    """
                    Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                    can override "structured_config" defined on node-level.
                    """
                    short_esi: str | None
                    """
                    short_esi only valid for l2leaf devices using port-channel uplink.
                    Setting short_esi to "auto"
                    generates the short_esi automatically using a hash of configuration elements.
                    < 0000:0000:0000 |
                    auto >.
                    """
                    isis_system_id_prefix: str | None
                    """(4.4 hexadecimal)."""
                    isis_maximum_paths: int | None
                    """Number of path to configure in ECMP for ISIS."""
                    is_type: str | None
                    node_sid_base: int | None
                    """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                    loopback_ipv4_pool: str | None
                    """IPv4 subnet for Loopback0 allocation."""
                    loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for Loopback0.
                    When set, it takes precedence over `loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                    """
                    vtep_loopback_ipv4_pool: str | None
                    """IPv4 subnet for VTEP-Loopback allocation."""
                    vtep_loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for VTEP-Loopback.
                    When set, it takes precedence over
                    `vtep_loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not
                    catch duplicates.
                    """
                    loopback_ipv4_offset: int | None
                    """
                    Offset all assigned loopback IP addresses.
                    Required when the < loopback_ipv4_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                    """
                    loopback_ipv6_pool: str | None
                    """IPv6 subnet for Loopback0 allocation."""
                    loopback_ipv6_offset: int | None
                    """
                    Offset all assigned loopback IPv6 addresses.
                    Required when the < loopback_ipv6_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid overlapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                    """
                    vtep: bool | None
                    """
                    Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                    Overrides VTEP
                    setting inherited from node_type_keys.
                    """
                    vtep_loopback: str | None
                    """Set VXLAN source interface."""
                    bgp_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    Required with eBGP.
                    """
                    bgp_defaults: list[str]
                    """List of EOS commands to apply to BGP daemon."""
                    evpn_role: str | None
                    """
                    Acting role in EVPN control plane.
                    Default is set in node_type definition from node_type_keys.
                    """
                    evpn_route_servers: list[str]
                    """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                    evpn_services_l2_only: bool | None
                    """
                    Possibility to prevent configuration of Tenant VRFs and SVIs.
                    Override node definition
                    "network_services_l3" from node_type_keys.
                    This allows support for centralized routing.
                    """
                    filter: Filter
                    """
                    Filter L3 and L2 network services based on tenant and tags (and operation filter).
                    If filter is not
                    defined it will default to all.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping on device level."""
                    evpn_gateway: EvpnGateway
                    """
                    Node is acting as EVPN Multi-Domain Gateway.
                    New BGP peer-group is generated between EVPN GWs in
                    different domains or between GWs and Route Servers.
                    Name can be changed under
                    "bgp_peer_groups.evpn_overlay_core" variable.
                    L3 rechability for different EVPN GWs must be already
                    in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                    same Ansible inventory.
                    """
                    ipvpn_gateway: IpvpnGateway
                    """
                    Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                    this is "bgp_peer_groups.ipvpn_gateway_peers".
                    L3 Reachability is required for this to work, the
                    preferred method to establish underlay connectivity is to use core_interfaces.
                    """
                    mlag: bool | None
                    """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                    mlag_dual_primary_detection: bool | None
                    """Enable / Disable MLAG dual primary detection."""
                    mlag_ibgp_origin_incomplete: bool | None
                    """
                    Set origin of routes received from MLAG iBGP peer to incomplete.
                    The purpose is to optimize routing
                    for leaf loopbacks from spine perspective and
                    avoid suboptimal routing via peerlink for control
                    plane traffic.
                    """
                    mlag_interfaces: list[str]
                    """
                    Each list item supports range syntax that can be expanded into a list of interfaces.
                    Required when
                    MLAG leafs are present in the topology.
                    """
                    mlag_interfaces_speed: str | None
                    """
                    Set MLAG interface speed.
                    Speed should be set in the format `<interface_speed>` or `forced
                    <interface_speed>` or `auto <interface_speed>`.
                    """
                    mlag_peer_l3_vlan: int | None
                    """
                    Underlay L3 peering SVI interface id.
                    If set to 0 or the same vlan as mlag_peer_vlan, the
                    mlag_peer_vlan will be used for L3 peering.
                    """
                    mlag_peer_l3_ipv4_pool: str | None
                    """
                    IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                    Required when
                    MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                    """
                    mlag_peer_vlan: int | None
                    """MLAG Peer Link (control link) SVI interface id."""
                    mlag_peer_link_allowed_vlans: str | None
                    mlag_peer_address_family: str | None
                    """
                    IP address family used to establish MLAG Peer Link (control link).
                    `ipv6` requires EOS version
                    4.31.1F or higher.
                    Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                    (ex. `mlag_peer_l3_vlan` set to 4094).
                    """
                    mlag_peer_ipv4_pool: str | None
                    """
                    IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                    """
                    mlag_peer_ipv6_pool: str | None
                    """
                    IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                    """
                    mlag_port_channel_id: int | None
                    """
                    If not set, the mlag port-channel id is generated based on the digits of the first interface present
                    in 'mlag_interfaces'.
                    Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                    999999 > for EOS >= 4.25.0F.
                    """
                    mlag_domain_id: str | None
                    """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                    spanning_tree_mode: str | None
                    spanning_tree_priority: int | None
                    """
                    Spanning-tree priority configured for the selected mode.
                    For `rapid-pvst` the priority can also be
                    set per VLAN under network services.
                    """
                    spanning_tree_root_super: bool | None
                    virtual_router_mac_address: str | None
                    """Virtual router mac address for anycast gateway."""
                    inband_mgmt_interface: str | None
                    """
                    Pointer to interface used for inband management.
                    All configuration must be done using other data
                    models like network services or structured_config.
                    'inband_mgmt_interface' is only used to refer to
                    this interface as source in various management protocol settings (future feature).

                    On L2 switches,
                    this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                    """
                    inband_mgmt_vlan: int | None
                    """
                    VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                    uplinks).
                    When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                    switch as well as all 'uplink_switches'.
                    When using 'inband_mgmt_ip' the VLAN and SVI will only be
                    created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                    created using network services data models.
                    """
                    inband_mgmt_subnet: str | None
                    """
                    Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                    ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      : <subnet> +
                    2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       :
                    <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than total l2leafs + 5
                    Setting is ignored if 'inband_mgmt_ip' is set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ip: str | None
                    """
                    IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                    If this is set the
                    VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN and SVI on
                    the parent switches must be created using network services data models.

                    This setting is applicable
                    to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                    is derived from 'inband_mgmt_subnet' if set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_address: str | None
                    """
                    IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                    If this
                    is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN
                    and SVI on the parent switches must be created using network services data models.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_subnet: str | None
                    """
                    Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                    on ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                    extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      :
                    <subnet> + 2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       : <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than
                    total l2leafs + 5

                    Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf'.
                    Used when `inband_mgmt_ipv6_address` is set.
                    Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_description: str | None
                    """
                    Description configured on the Inband Management SVI.

                    This setting is only applied on the devices
                    where it is set, it does not automatically affect any parent/child devices configuration, so it must
                    be set on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vlan_name: str | None
                    """
                    Name configured on the Inband Management VLAN.
                    This setting is only applied on the devices where it
                    is set, it does not automatically affect any parent/child devices configuration, so it must be set
                    on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vrf: str | None
                    """
                    VRF configured on the Inband Management Interface.
                    The VRF is created if not already created by
                    other means.
                    This setting is only applied on the devices where it is set, it does not automatically
                    affect any parent/child devices configuration, so it must be set on each applicable node/node-
                    group/node-type as needed.
                    """
                    inband_mgmt_mtu: int | None
                    """
                    MTU configured on the Inband Management Interface.
                    This setting is only applied on the devices where
                    it is set, it does not automatically affect any parent/child devices configuration, so it must be
                    set on each applicable node/node-group/node-type as needed.
                    """
                    inband_ztp: bool | None
                    """
                    Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                    inband.
                    This setting also requires that the `inband_mgmt_vlan` is set for the node.
                    """
                    inband_ztp_lacp_fallback_delay: int | None
                    """
                    Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                    ZTP node.
                    This setting also requires that `inband_ztp` is set for the node.
                    """
                    mpls_overlay_role: str | None
                    """
                    Set the default mpls overlay role.
                    Acting role in overlay control plane.
                    """
                    overlay_address_families: list[str]
                    """Set the default overlay address families."""
                    mpls_route_reflectors: list[str]
                    """List of inventory hostname acting as MPLS route-reflectors."""
                    bgp_cluster_id: str | None
                    """Set BGP cluster id."""
                    ptp: Ptp
                    wan_role: str | None
                    """
                    Override the default WAN role.

                    This is used both for AutoVPN and Pathfinder designs.
                    That means if
                    `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                    `server` indicates that the
                    router is a route-reflector.

                    Only supported if `overlay_routing_protocol` is set to `ibgp`.
                    """
                    cv_pathfinder_transit_mode: str | None
                    """
                    Configure the transit mode for a WAN client for CV Pathfinder designs
                    only when the `wan_mode` root
                    key is set to `cv_pathfinder`.

                    'zone' is currently not supported.
                    """
                    cv_pathfinder_region: str | None
                    """
                    The CV Pathfinder region name.
                    This key is required for WAN routers but optional for pathfinders.
                    The region name must be defined under 'cv_pathfinder_regions'.
                    """
                    cv_pathfinder_site: str | None
                    """
                    The CV Pathfinder site name.
                    This key is required for WAN routers but optional for pathfinders.
                    For
                    WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                    relevant region under 'cv_pathfinder_regions'.
                    For pathfinders without `cv_pathfinder_region` set,
                    the site must be defined under `cv_pathfinder_global_sites`.
                    """
                    wan_ha: WanHa
                    """
                    PREVIEW: This key is currently not supported

                    The key is supported only if `wan_mode` == `cv-
                    pathfinder`.
                    AutoVPN support is still to be determined.

                    Maximum 2 devices supported by group for
                    HA.
                    """
                    dps_mss_ipv4: str | None
                    """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                    l3_interfaces: L3Interfaces
                    """
                    L3 Interfaces to configure on the node.
                    Used to define the node for WAN interfaces when
                    `wan_carrier` is set.
                    """
                    data_plane_cpu_allocation_max: int | None
                    """
                    Set the maximum number of CPU used for the data plane.
                    This setting is useful on virtual Route
                    Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                    """
                    flow_tracker_type: str | None
                    """
                    Set the flow tracker type.
                    Override the `default_flow_tracker_type`` set at the `node_type_key`
                    level.
                    `default_flow_tracker_type` default value is `sampled`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        platform: str | None | UndefinedType = Undefined,
                        mac_address: str | None | UndefinedType = Undefined,
                        system_mac_address: str | None | UndefinedType = Undefined,
                        serial_number: str | None | UndefinedType = Undefined,
                        rack: str | None | UndefinedType = Undefined,
                        mgmt_ip: str | None | UndefinedType = Undefined,
                        mgmt_gateway: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                        mgmt_interface: str | None | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                        always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                        uplink_type: str | None | UndefinedType = Undefined,
                        uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                        uplink_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switches: list[str] | UndefinedType = Undefined,
                        uplink_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_mtu: int | None | UndefinedType = Undefined,
                        max_uplink_switches: int | None | UndefinedType = Undefined,
                        max_parallel_uplinks: int | None | UndefinedType = Undefined,
                        uplink_bfd: bool | None | UndefinedType = Undefined,
                        uplink_native_vlan: int | None | UndefinedType = Undefined,
                        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                        uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                        uplink_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_structured_config: dict | UndefinedType = Undefined,
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                        short_esi: str | None | UndefinedType = Undefined,
                        isis_system_id_prefix: str | None | UndefinedType = Undefined,
                        isis_maximum_paths: int | None | UndefinedType = Undefined,
                        is_type: str | None | UndefinedType = Undefined,
                        node_sid_base: int | None | UndefinedType = Undefined,
                        loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                        loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                        vtep: bool | None | UndefinedType = Undefined,
                        vtep_loopback: str | None | UndefinedType = Undefined,
                        bgp_as: str | None | UndefinedType = Undefined,
                        bgp_defaults: list[str] | UndefinedType = Undefined,
                        evpn_role: str | None | UndefinedType = Undefined,
                        evpn_route_servers: list[str] | UndefinedType = Undefined,
                        evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                        ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                        mlag: bool | None | UndefinedType = Undefined,
                        mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                        mlag_interfaces: list[str] | UndefinedType = Undefined,
                        mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                        mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                        mlag_peer_address_family: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                        mlag_port_channel_id: int | None | UndefinedType = Undefined,
                        mlag_domain_id: str | None | UndefinedType = Undefined,
                        spanning_tree_mode: str | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                        virtual_router_mac_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_interface: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                        inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ip: str | None | UndefinedType = Undefined,
                        inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_description: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                        inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                        inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                        inband_ztp: bool | None | UndefinedType = Undefined,
                        inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                        mpls_overlay_role: str | None | UndefinedType = Undefined,
                        overlay_address_families: list[str] | UndefinedType = Undefined,
                        mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                        bgp_cluster_id: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        wan_role: str | None | UndefinedType = Undefined,
                        cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                        cv_pathfinder_region: str | None | UndefinedType = Undefined,
                        cv_pathfinder_site: str | None | UndefinedType = Undefined,
                        wan_ha: WanHa | UndefinedType = Undefined,
                        dps_mss_ipv4: str | None | UndefinedType = Undefined,
                        l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                        data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                        flow_tracker_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Defaults.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Unique identifier used for IP addressing and other algorithms.
                            platform: Arista platform family.
                            mac_address: Leverage to document management interface mac address.
                            system_mac_address:
                               System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                               Set to the same MAC address as
                               available in "show version" on the device.
                               "system_mac_address" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            serial_number:
                               Set to the Serial Number of the device.
                               Only used for documentation purpose in the fabric
                               documentation and part of the structured_config.
                               "serial_number" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            rack: Rack that the switch is located in (only used in snmp_settings location).
                            mgmt_ip: Node management interface IPv4 address.
                            mgmt_gateway:
                               This key sets the management gateway for the device. It takes precedence over the global
                               `mgmt_gateway`.
                            ipv6_mgmt_ip: Node management interface IPv6 address.
                            ipv6_mgmt_gateway:
                               This key sets the ipv6 management gateway for the device. It takes precedence over the global
                               `ipv6_mgmt_gateway`.
                            mgmt_interface:
                               Management Interface Name.
                               Default -> platform_management_interface -> mgmt_interface ->
                               "Management1".
                            link_tracking:
                               This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                               the upstream interfaces.
                               Useful in EVPN multhoming designs.
                            lacp_port_id_range:
                               This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                               number of nodes in the "node_group".
                               Unique LACP port-id ranges are recommended for EVPN Multihoming
                               designs.
                            always_configure_ip_routing:
                               Force configuration of "ip routing" even on L2 devices.
                               Use this to retain behavior of AVD versions
                               below 4.0.0.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.
                            uplink_type:
                               Override the default `uplink_type` set at the `node_type_key` level.
                               `uplink_type` must be "p2p" if
                               `vtep` or `underlay_router` is true for the `node_type_key` definition.
                            uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                            uplink_interfaces:
                               Local uplink interfaces.
                               Each list item supports range syntax that can be expanded into a list of
                               interfaces.
                               If uplink_interfaces is not defined, platform-specific defaults (defined under
                               default_interfaces) will be used instead.
                               Please note that default_interfaces are not defined by
                               default, you should define these yourself.
                            uplink_switch_interfaces: Interfaces located on uplink switches.
                            uplink_switches: uplink_switches
                            uplink_interface_speed:
                               Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                               (Uplink switch
                               interface speed can be overridden with `uplink_switch_interface_speed`).
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_switch_interface_speed:
                               Set point-to-Point interface speed for the uplink switch interface only.
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                            max_uplink_switches:
                               Maximum number of uplink switches.
                               Changing this value may change IP Addressing on uplinks.
                               Can be
                               used to reserve IP space for future expansions.
                            max_parallel_uplinks:
                               Number of parallel links towards uplink switches.
                               Changing this value may change interface naming on
                               uplinks (and corresponding downlinks).
                               Can be used to reserve interfaces for future parallel
                               uplinks.
                            uplink_bfd: Enable bfd on uplink interfaces.
                            uplink_native_vlan:
                               Only applicable to switches with layer-2 port-channel uplinks.
                               A suspended (disabled) vlan will be
                               created in both ends of the link unless the vlan is defined under network services.
                               By default the
                               uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                            uplink_ptp: Enable PTP on all infrastructure links.
                            uplink_macsec: Enable MacSec on all uplinks.
                            uplink_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink Port-channel
                               ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                               For
                               example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [ Eth11/1, Eth22/1 ] -> ID 111
                               For
                               MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                               This
                               option overrides the default behavior and statically sets the local Port-channel ID.
                               Note! Make sure
                               the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                               value.
                            uplink_switch_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink switch Port-
                               channel ID will be set to the number of the first interface defined under
                               `uplink_switch_interfaces`.
                               For example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [
                               Eth11/1, Eth22/1 ] -> ID 111
                               For MLAG port-channels ID will be based on the lowest member interface
                               on the first MLAG switch.
                               This option overrides the default behavior and statically sets the Port-
                               channel ID on the uplink switch.
                               Note! Make sure the ID is unique and does not overlap with
                               autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between
                               1 and 2000 and both MLAG switches must have the same value.
                            uplink_structured_config:
                               Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                               When
                               uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                               for eos_cli_config_gen overrides the settings on the ethernet interface level.
                               When uplink_type ==
                               "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                               eos_cli_config_gen overrides the settings on the port-channel interface level.
                               "uplink_structured_config" is applied after "structured_config", so it can override
                               "structured_config" defined on node-level.
                               Note! The content of this dictionary is _not_ validated
                               by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                            mlag_port_channel_structured_config:
                               Custom structured config applied to MLAG peer link port-channel id.
                               Added under
                               port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the
                               port-channel interface level.
                               "mlag_port_channel_structured_config" is applied after
                               "structured_config", so it can override "structured_config" defined on node-level.
                            mlag_peer_vlan_structured_config:
                               Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                               override "structured_config" defined on node-level.
                            mlag_peer_l3_vlan_structured_config:
                               Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                               can override "structured_config" defined on node-level.
                            short_esi:
                               short_esi only valid for l2leaf devices using port-channel uplink.
                               Setting short_esi to "auto"
                               generates the short_esi automatically using a hash of configuration elements.
                               < 0000:0000:0000 |
                               auto >.
                            isis_system_id_prefix: (4.4 hexadecimal).
                            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                            is_type: is_type
                            node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                            loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                            loopback_ipv4_address:
                               IPv4 address without mask for Loopback0.
                               When set, it takes precedence over `loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                            vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                            vtep_loopback_ipv4_address:
                               IPv4 address without mask for VTEP-Loopback.
                               When set, it takes precedence over
                               `vtep_loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not
                               catch duplicates.
                            loopback_ipv4_offset:
                               Offset all assigned loopback IP addresses.
                               Required when the < loopback_ipv4_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                            loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                            loopback_ipv6_offset:
                               Offset all assigned loopback IPv6 addresses.
                               Required when the < loopback_ipv6_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid overlapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                            vtep:
                               Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                               Overrides VTEP
                               setting inherited from node_type_keys.
                            vtep_loopback: Set VXLAN source interface.
                            bgp_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                               Required with eBGP.
                            bgp_defaults: List of EOS commands to apply to BGP daemon.
                            evpn_role:
                               Acting role in EVPN control plane.
                               Default is set in node_type definition from node_type_keys.
                            evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                            evpn_services_l2_only:
                               Possibility to prevent configuration of Tenant VRFs and SVIs.
                               Override node definition
                               "network_services_l3" from node_type_keys.
                               This allows support for centralized routing.
                            filter:
                               Filter L3 and L2 network services based on tenant and tags (and operation filter).
                               If filter is not
                               defined it will default to all.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                            evpn_gateway:
                               Node is acting as EVPN Multi-Domain Gateway.
                               New BGP peer-group is generated between EVPN GWs in
                               different domains or between GWs and Route Servers.
                               Name can be changed under
                               "bgp_peer_groups.evpn_overlay_core" variable.
                               L3 rechability for different EVPN GWs must be already
                               in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                               same Ansible inventory.
                            ipvpn_gateway:
                               Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                               this is "bgp_peer_groups.ipvpn_gateway_peers".
                               L3 Reachability is required for this to work, the
                               preferred method to establish underlay connectivity is to use core_interfaces.
                            mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                            mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                            mlag_ibgp_origin_incomplete:
                               Set origin of routes received from MLAG iBGP peer to incomplete.
                               The purpose is to optimize routing
                               for leaf loopbacks from spine perspective and
                               avoid suboptimal routing via peerlink for control
                               plane traffic.
                            mlag_interfaces:
                               Each list item supports range syntax that can be expanded into a list of interfaces.
                               Required when
                               MLAG leafs are present in the topology.
                            mlag_interfaces_speed:
                               Set MLAG interface speed.
                               Speed should be set in the format `<interface_speed>` or `forced
                               <interface_speed>` or `auto <interface_speed>`.
                            mlag_peer_l3_vlan:
                               Underlay L3 peering SVI interface id.
                               If set to 0 or the same vlan as mlag_peer_vlan, the
                               mlag_peer_vlan will be used for L3 peering.
                            mlag_peer_l3_ipv4_pool:
                               IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                               Required when
                               MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                            mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                            mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                            mlag_peer_address_family:
                               IP address family used to establish MLAG Peer Link (control link).
                               `ipv6` requires EOS version
                               4.31.1F or higher.
                               Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                               (ex. `mlag_peer_l3_vlan` set to 4094).
                            mlag_peer_ipv4_pool:
                               IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                            mlag_peer_ipv6_pool:
                               IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                            mlag_port_channel_id:
                               If not set, the mlag port-channel id is generated based on the digits of the first interface present
                               in 'mlag_interfaces'.
                               Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                               999999 > for EOS >= 4.25.0F.
                            mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                            spanning_tree_mode: spanning_tree_mode
                            spanning_tree_priority:
                               Spanning-tree priority configured for the selected mode.
                               For `rapid-pvst` the priority can also be
                               set per VLAN under network services.
                            spanning_tree_root_super: spanning_tree_root_super
                            virtual_router_mac_address: Virtual router mac address for anycast gateway.
                            inband_mgmt_interface:
                               Pointer to interface used for inband management.
                               All configuration must be done using other data
                               models like network services or structured_config.
                               'inband_mgmt_interface' is only used to refer to
                               this interface as source in various management protocol settings (future feature).

                               On L2 switches,
                               this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                            inband_mgmt_vlan:
                               VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                               uplinks).
                               When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                               switch as well as all 'uplink_switches'.
                               When using 'inband_mgmt_ip' the VLAN and SVI will only be
                               created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                               created using network services data models.
                            inband_mgmt_subnet:
                               Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                               ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      : <subnet> +
                               2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       :
                               <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than total l2leafs + 5
                               Setting is ignored if 'inband_mgmt_ip' is set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ip:
                               IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                               If this is set the
                               VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN and SVI on
                               the parent switches must be created using network services data models.

                               This setting is applicable
                               to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                               is derived from 'inband_mgmt_subnet' if set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_address:
                               IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                               If this
                               is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN
                               and SVI on the parent switches must be created using network services data models.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_subnet:
                               Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                               on ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                               extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      :
                               <subnet> + 2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       : <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than
                               total l2leafs + 5

                               Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf'.
                               Used when `inband_mgmt_ipv6_address` is set.
                               Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_description:
                               Description configured on the Inband Management SVI.

                               This setting is only applied on the devices
                               where it is set, it does not automatically affect any parent/child devices configuration, so it must
                               be set on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vlan_name:
                               Name configured on the Inband Management VLAN.
                               This setting is only applied on the devices where it
                               is set, it does not automatically affect any parent/child devices configuration, so it must be set
                               on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vrf:
                               VRF configured on the Inband Management Interface.
                               The VRF is created if not already created by
                               other means.
                               This setting is only applied on the devices where it is set, it does not automatically
                               affect any parent/child devices configuration, so it must be set on each applicable node/node-
                               group/node-type as needed.
                            inband_mgmt_mtu:
                               MTU configured on the Inband Management Interface.
                               This setting is only applied on the devices where
                               it is set, it does not automatically affect any parent/child devices configuration, so it must be
                               set on each applicable node/node-group/node-type as needed.
                            inband_ztp:
                               Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                               inband.
                               This setting also requires that the `inband_mgmt_vlan` is set for the node.
                            inband_ztp_lacp_fallback_delay:
                               Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                               ZTP node.
                               This setting also requires that `inband_ztp` is set for the node.
                            mpls_overlay_role:
                               Set the default mpls overlay role.
                               Acting role in overlay control plane.
                            overlay_address_families: Set the default overlay address families.
                            mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                            bgp_cluster_id: Set BGP cluster id.
                            ptp: ptp
                            wan_role:
                               Override the default WAN role.

                               This is used both for AutoVPN and Pathfinder designs.
                               That means if
                               `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                               `server` indicates that the
                               router is a route-reflector.

                               Only supported if `overlay_routing_protocol` is set to `ibgp`.
                            cv_pathfinder_transit_mode:
                               Configure the transit mode for a WAN client for CV Pathfinder designs
                               only when the `wan_mode` root
                               key is set to `cv_pathfinder`.

                               'zone' is currently not supported.
                            cv_pathfinder_region:
                               The CV Pathfinder region name.
                               This key is required for WAN routers but optional for pathfinders.
                               The region name must be defined under 'cv_pathfinder_regions'.
                            cv_pathfinder_site:
                               The CV Pathfinder site name.
                               This key is required for WAN routers but optional for pathfinders.
                               For
                               WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                               relevant region under 'cv_pathfinder_regions'.
                               For pathfinders without `cv_pathfinder_region` set,
                               the site must be defined under `cv_pathfinder_global_sites`.
                            wan_ha:
                               PREVIEW: This key is currently not supported

                               The key is supported only if `wan_mode` == `cv-
                               pathfinder`.
                               AutoVPN support is still to be determined.

                               Maximum 2 devices supported by group for
                               HA.
                            dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                            l3_interfaces:
                               L3 Interfaces to configure on the node.
                               Used to define the node for WAN interfaces when
                               `wan_carrier` is set.
                            data_plane_cpu_allocation_max:
                               Set the maximum number of CPU used for the data plane.
                               This setting is useful on virtual Route
                               Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                            flow_tracker_type:
                               Set the flow tracker type.
                               Override the `default_flow_tracker_type`` set at the `node_type_key`
                               level.
                               `default_flow_tracker_type` default value is `sampled`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodeGroupsItem(AvdModel):
                    class NodesItem(AvdModel):
                        class DownlinkPoolsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "ipv4_pool": {"type": str},
                                "downlink_interfaces": {"type": list, "items": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            ipv4_pool: str | None
                            """IPv4 pool from which subnets will be allocated for links to downlink switches."""
                            downlink_interfaces: list[str]
                            """
                            List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                            this list will determine which subnet will be taken from the pool.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                ipv4_pool: str | None | UndefinedType = Undefined,
                                downlink_interfaces: list[str] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                DownlinkPoolsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    ipv4_pool: IPv4 pool from which subnets will be allocated for links to downlink switches.
                                    downlink_interfaces:
                                       List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                                       this list will determine which subnet will be taken from the pool.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class LinkTracking(AvdModel):
                            class GroupsItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "name": {"type": str},
                                    "recovery_delay": {"type": int},
                                    "links_minimum": {"type": int},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                name: str | None
                                """Tracking group name."""
                                recovery_delay: int | None
                                """default -> platform_settings_mlag_reload_delay -> 300."""
                                links_minimum: int | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                    recovery_delay: int | None | UndefinedType = Undefined,
                                    links_minimum: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    GroupsItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Tracking group name.
                                        recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                        links_minimum: links_minimum

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "groups": {
                                    "type": list,
                                    "items": GroupsItem,
                                    "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                                },
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            groups: list[GroupsItem]
                            """
                            Link Tracking Groups.
                            By default a single group named "LT_GROUP1" is defined with default values.
                            Any groups defined under "groups" will replace the default.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                groups: list[GroupsItem] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LinkTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    groups:
                                       Link Tracking Groups.
                                       By default a single group named "LT_GROUP1" is defined with default values.
                                       Any groups defined under "groups" will replace the default.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class LacpPortIdRange(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "size": {"type": int, "default": 128},
                                "offset": {"type": int, "default": 0},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            size: int | None
                            """Recommended size > = number of ports in the switch."""
                            offset: int | None
                            """
                            Offset is used to avoid overlapping port-id ranges of different switches.
                            Useful when a "connected-
                            endpoint" is connected to switches in different "node_groups".
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                size: int | None | UndefinedType = Undefined,
                                offset: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                LacpPortIdRange.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    size: Recommended size > = number of ports in the switch.
                                    offset:
                                       Offset is used to avoid overlapping port-id ranges of different switches.
                                       Useful when a "connected-
                                       endpoint" is connected to switches in different "node_groups".

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen):
                            pass

                        class UplinkPtp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enable: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                UplinkPtp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enable: enable

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class UplinkMacsec(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            profile: str | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                UplinkMacsec.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    profile: profile

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                            pass

                        class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                            pass

                        class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                            pass

                        class Filter(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "tenants": {"type": list, "items": str, "default": ["all"]},
                                "tags": {"type": list, "items": str, "default": ["all"]},
                                "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                                "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                                "always_include_vrfs_in_tenants": {"type": list, "items": str},
                                "only_vlans_in_use": {"type": bool, "default": False},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            tenants: list[str]
                            """
                            Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                            Tenants (default).
                            This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                            """
                            tags: list[str]
                            """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                            allow_vrfs: list[str]
                            """
                            Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                            (default).
                            This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                            """
                            deny_vrfs: list[str]
                            """
                            Prevent configuration of Network Services defined under these VRFs.
                            This list prevents the given
                            VRFs to be included by any other filtering mechanism.
                            """
                            always_include_vrfs_in_tenants: list[str]
                            """
                            List of tenants where VRFs will be configured even if VLANs are not included in tags.
                            Useful for L3
                            "border" leaf.
                            """
                            only_vlans_in_use: bool | None
                            """
                            Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                            Note! This
                            feature only considers configuration managed by eos_designs.
                            This excludes structured_config,
                            custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                tenants: list[str] | UndefinedType = Undefined,
                                tags: list[str] | UndefinedType = Undefined,
                                allow_vrfs: list[str] | UndefinedType = Undefined,
                                deny_vrfs: list[str] | UndefinedType = Undefined,
                                always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                                only_vlans_in_use: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Filter.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    tenants:
                                       Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                       Tenants (default).
                                       This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                    tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                    allow_vrfs:
                                       Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                       (default).
                                       This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                    deny_vrfs:
                                       Prevent configuration of Network Services defined under these VRFs.
                                       This list prevents the given
                                       VRFs to be included by any other filtering mechanism.
                                    always_include_vrfs_in_tenants:
                                       List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                       Useful for L3
                                       "border" leaf.
                                    only_vlans_in_use:
                                       Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                       Note! This
                                       feature only considers configuration managed by eos_designs.
                                       This excludes structured_config,
                                       custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnGateway(AvdModel):
                            class RemotePeersItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "hostname": {"type": str},
                                    "ip_address": {"type": str},
                                    "bgp_as": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                hostname: str | None
                                """Hostname of remote EVPN GW server."""
                                ip_address: str | None
                                """Peering IP of remote Route Server."""
                                bgp_as: str | None
                                """
                                Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                interpreted as a float number.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    hostname: str | None | UndefinedType = Undefined,
                                    ip_address: str | None | UndefinedType = Undefined,
                                    bgp_as: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    RemotePeersItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        hostname: Hostname of remote EVPN GW server.
                                        ip_address: Peering IP of remote Route Server.
                                        bgp_as:
                                           Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                           For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                           interpreted as a float number.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class EvpnL2(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    EvpnL2.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class EvpnL3(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool, "default": False},
                                    "inter_domain": {"type": bool, "default": True},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                inter_domain: bool | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    inter_domain: bool | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    EvpnL3.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        inter_domain: inter_domain

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "remote_peers": {"type": list, "items": RemotePeersItem},
                                "evpn_l2": {"type": EvpnL2},
                                "evpn_l3": {"type": EvpnL3},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            remote_peers: list[RemotePeersItem]
                            """
                            Define remote peers of the EVPN VXLAN Gateway.
                            If the hostname can be found in the inventory,
                            ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                            If the
                            peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                            """
                            evpn_l2: EvpnL2
                            """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                            evpn_l3: EvpnL3
                            """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                                evpn_l2: EvpnL2 | UndefinedType = Undefined,
                                evpn_l3: EvpnL3 | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnGateway.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    remote_peers:
                                       Define remote peers of the EVPN VXLAN Gateway.
                                       If the hostname can be found in the inventory,
                                       ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                       If the
                                       peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                    evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                    evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class IpvpnGateway(AvdModel):
                            class RemotePeersItem(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "hostname": {"type": str},
                                    "ip_address": {"type": str},
                                    "bgp_as": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                                _custom_data: dict[str, Any]
                                hostname: str
                                """Hostname of remote IPVPN Peer."""
                                ip_address: str
                                """Peering IP of remote IPVPN Peer."""
                                bgp_as: str
                                """
                                Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                For
                                asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                as a float number.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    hostname: str | UndefinedType = Undefined,
                                    ip_address: str | UndefinedType = Undefined,
                                    bgp_as: str | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    RemotePeersItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        hostname: Hostname of remote IPVPN Peer.
                                        ip_address: Peering IP of remote IPVPN Peer.
                                        bgp_as:
                                           Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                           For
                                           asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                           as a float number.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "evpn_domain_id": {"type": str, "default": "65535:1"},
                                "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                                "enable_d_path": {"type": bool, "default": True},
                                "maximum_routes": {"type": int, "default": 0},
                                "local_as": {"type": str, "default": "none"},
                                "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                                "remote_peers": {"type": list, "items": RemotePeersItem},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            evpn_domain_id: str | None
                            """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                            ipvpn_domain_id: str | None
                            """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                            enable_d_path: bool | None
                            """Enable D-path for use with BGP bestpath selection algorithm."""
                            maximum_routes: int | None
                            """Maximum routes to accept from IPVPN remote peers."""
                            local_as: str | None
                            """
                            Local BGP AS applied to peering with IPVPN remote peers.
                            BGP AS <1-4294967295> or AS number in asdot
                            notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes,
                            to prevent it from being interpreted as a float number.
                            """
                            address_families: list[str]
                            """IPVPN address families to enable for remote peers."""
                            remote_peers: list[RemotePeersItem]

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                evpn_domain_id: str | None | UndefinedType = Undefined,
                                ipvpn_domain_id: str | None | UndefinedType = Undefined,
                                enable_d_path: bool | None | UndefinedType = Undefined,
                                maximum_routes: int | None | UndefinedType = Undefined,
                                local_as: str | None | UndefinedType = Undefined,
                                address_families: list[str] | UndefinedType = Undefined,
                                remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            ) -> None:
                                """
                                IpvpnGateway.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                    ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                    enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                    maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                    local_as:
                                       Local BGP AS applied to peering with IPVPN remote peers.
                                       BGP AS <1-4294967295> or AS number in asdot
                                       notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes,
                                       to prevent it from being interpreted as a float number.
                                    address_families: IPVPN address families to enable for remote peers.
                                    remote_peers: remote_peers

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Ptp(AvdModel):
                            class Dscp(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                general_messages: int | None
                                event_messages: int | None

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    general_messages: int | None | UndefinedType = Undefined,
                                    event_messages: int | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Dscp.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        general_messages: general_messages
                                        event_messages: event_messages

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Monitor(AvdModel):
                                class Threshold(AvdModel):
                                    class Drop(AvdModel):
                                        _fields: ClassVar[dict] = {
                                            "_custom_data": {"type": dict},
                                            "offset_from_master": {"type": int},
                                            "mean_path_delay": {"type": int},
                                        }
                                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                                        _custom_data: dict[str, Any]
                                        offset_from_master: int | None
                                        mean_path_delay: int | None

                                        def __init__(
                                            self,
                                            *,
                                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                            offset_from_master: int | None | UndefinedType = Undefined,
                                            mean_path_delay: int | None | UndefinedType = Undefined,
                                        ) -> None:
                                            """
                                            Drop.

                                            Args:
                                            -----
                                                _custom_data: _custom_data
                                                offset_from_master: offset_from_master
                                                mean_path_delay: mean_path_delay

                                            """
                                            for arg, arg_value in locals().items():
                                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                                    continue
                                                setattr(self, arg, arg_value)

                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int, "default": 250},
                                        "mean_path_delay": {"type": int, "default": 1500},
                                        "drop": {"type": Drop},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None
                                    drop: Drop

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                        drop: Drop | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Threshold.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay
                                            drop: drop

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class MissingMessage(AvdModel):
                                    class Intervals(AvdModel):
                                        _fields: ClassVar[dict] = {
                                            "_custom_data": {"type": dict},
                                            "announce": {"type": int},
                                            "follow_up": {"type": int},
                                            "sync": {"type": int},
                                        }
                                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                                        _custom_data: dict[str, Any]
                                        announce: int | None
                                        follow_up: int | None
                                        sync: int | None

                                        def __init__(
                                            self,
                                            *,
                                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                            announce: int | None | UndefinedType = Undefined,
                                            follow_up: int | None | UndefinedType = Undefined,
                                            sync: int | None | UndefinedType = Undefined,
                                        ) -> None:
                                            """
                                            Intervals.

                                            Args:
                                            -----
                                                _custom_data: _custom_data
                                                announce: announce
                                                follow_up: follow_up
                                                sync: sync

                                            """
                                            for arg, arg_value in locals().items():
                                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                                    continue
                                                setattr(self, arg, arg_value)

                                    class SequenceIds(AvdModel):
                                        _fields: ClassVar[dict] = {
                                            "_custom_data": {"type": dict},
                                            "enabled": {"type": bool, "default": True},
                                            "announce": {"type": int, "default": 3},
                                            "delay_resp": {"type": int, "default": 3},
                                            "follow_up": {"type": int, "default": 3},
                                            "sync": {"type": int, "default": 3},
                                        }
                                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                                        _custom_data: dict[str, Any]
                                        enabled: bool | None
                                        announce: int | None
                                        delay_resp: int | None
                                        follow_up: int | None
                                        sync: int | None

                                        def __init__(
                                            self,
                                            *,
                                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                            enabled: bool | None | UndefinedType = Undefined,
                                            announce: int | None | UndefinedType = Undefined,
                                            delay_resp: int | None | UndefinedType = Undefined,
                                            follow_up: int | None | UndefinedType = Undefined,
                                            sync: int | None | UndefinedType = Undefined,
                                        ) -> None:
                                            """
                                            SequenceIds.

                                            Args:
                                            -----
                                                _custom_data: _custom_data
                                                enabled: enabled
                                                announce: announce
                                                delay_resp: delay_resp
                                                follow_up: follow_up
                                                sync: sync

                                            """
                                            for arg, arg_value in locals().items():
                                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                                    continue
                                                setattr(self, arg, arg_value)

                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "intervals": {"type": Intervals},
                                        "sequence_ids": {"type": SequenceIds},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    intervals: Intervals
                                    sequence_ids: SequenceIds

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        intervals: Intervals | UndefinedType = Undefined,
                                        sequence_ids: SequenceIds | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        MissingMessage.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            intervals: intervals
                                            sequence_ids: sequence_ids

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "enabled": {"type": bool, "default": True},
                                    "threshold": {"type": Threshold},
                                    "missing_message": {"type": MissingMessage},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                threshold: Threshold
                                missing_message: MissingMessage

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    threshold: Threshold | UndefinedType = Undefined,
                                    missing_message: MissingMessage | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Monitor.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        threshold: threshold
                                        missing_message: missing_message

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "profile": {"type": str, "default": "aes67-r16-2016"},
                                "mlag": {"type": bool, "default": False},
                                "domain": {"type": int, "default": 127},
                                "priority1": {"type": int},
                                "priority2": {"type": int},
                                "auto_clock_identity": {"type": bool, "default": True},
                                "clock_identity_prefix": {"type": str},
                                "clock_identity": {"type": str},
                                "source_ip": {"type": str},
                                "mode": {"type": str, "default": "boundary"},
                                "mode_one_step": {"type": bool, "default": False},
                                "ttl": {"type": int},
                                "forward_unicast": {"type": bool, "default": False},
                                "dscp": {"type": Dscp},
                                "monitor": {"type": Monitor},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            profile: str | None
                            """
                            Default available profiles are:
                              - "aes67"
                              - "aes67-r16-2016"
                              - "smpte2059-2"
                            """
                            mlag: bool | None
                            """
                            Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                            configured on the MLAG peer-link port-channel.
                            """
                            domain: int | None
                            priority1: int | None
                            """default -> automatically set based on node_type."""
                            priority2: int | None
                            """default -> (node_id modulus 256)."""
                            auto_clock_identity: bool | None
                            """
                            If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                            default EOS behaviour, simply disable the automatic PTP clock identity.
                            default ->
                            (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                            HEX).
                            """
                            clock_identity_prefix: str | None
                            """
                            PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                            By default the 3-byte prefix is "00:1C:73".
                            This
                            can be overridden if auto_clock_identity is set to true (which is the default).
                            """
                            clock_identity: str | None
                            """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                            source_ip: str | None
                            """
                            By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                            relevant SVI, which is the recommended behaviour.
                            This can be set manually if required, for example,
                            to a value of "10.1.2.3".
                            """
                            mode: str | None
                            mode_one_step: bool | None
                            ttl: int | None
                            forward_unicast: bool | None
                            """Enable PTP unicast forwarding."""
                            dscp: Dscp
                            monitor: Monitor

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                profile: str | None | UndefinedType = Undefined,
                                mlag: bool | None | UndefinedType = Undefined,
                                domain: int | None | UndefinedType = Undefined,
                                priority1: int | None | UndefinedType = Undefined,
                                priority2: int | None | UndefinedType = Undefined,
                                auto_clock_identity: bool | None | UndefinedType = Undefined,
                                clock_identity_prefix: str | None | UndefinedType = Undefined,
                                clock_identity: str | None | UndefinedType = Undefined,
                                source_ip: str | None | UndefinedType = Undefined,
                                mode: str | None | UndefinedType = Undefined,
                                mode_one_step: bool | None | UndefinedType = Undefined,
                                ttl: int | None | UndefinedType = Undefined,
                                forward_unicast: bool | None | UndefinedType = Undefined,
                                dscp: Dscp | UndefinedType = Undefined,
                                monitor: Monitor | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Ptp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    profile:
                                       Default available profiles are:
                                         - "aes67"
                                         - "aes67-r16-2016"
                                         - "smpte2059-2"
                                    mlag:
                                       Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                       configured on the MLAG peer-link port-channel.
                                    domain: domain
                                    priority1: default -> automatically set based on node_type.
                                    priority2: default -> (node_id modulus 256).
                                    auto_clock_identity:
                                       If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                       default EOS behaviour, simply disable the automatic PTP clock identity.
                                       default ->
                                       (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                       HEX).
                                    clock_identity_prefix:
                                       PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                       By default the 3-byte prefix is "00:1C:73".
                                       This
                                       can be overridden if auto_clock_identity is set to true (which is the default).
                                    clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                    source_ip:
                                       By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                       relevant SVI, which is the recommended behaviour.
                                       This can be set manually if required, for example,
                                       to a value of "10.1.2.3".
                                    mode: mode
                                    mode_one_step: mode_one_step
                                    ttl: ttl
                                    forward_unicast: Enable PTP unicast forwarding.
                                    dscp: dscp
                                    monitor: monitor

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class WanHa(AvdModel):
                            class FlowTracking(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                name: str | None
                                """Flow tracker name as defined in flow_tracking_settings."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    FlowTracking.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        name: Flow tracker name as defined in flow_tracking_settings.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "ipsec": {"type": bool, "default": True},
                                "mtu": {"type": int, "default": 9194},
                                "ha_interfaces": {"type": list, "items": str},
                                "ha_ipv4_pool": {"type": str},
                                "max_ha_interfaces": {"type": int},
                                "port_channel_id": {"type": int},
                                "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                                "flow_tracking": {"type": FlowTracking},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                            ipsec: bool | None
                            """Enable / Disable IPsec over HA path-group when HA is enabled."""
                            mtu: int | None
                            """Set MTU on WAN HA interfaces."""
                            ha_interfaces: list[str]
                            """
                            Local WAN HA interfaces
                            Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                            Can be used to filter uplink interfaces when there are multiple uplinks.
                            Limitations:
                              Either all
                            interfaces must be uplinks or all interfaces must not be uplinks.
                              Only one interface is supported
                            for non uplinks.
                            """
                            ha_ipv4_pool: str | None
                            """
                            IP address pool used for WAN HA connectivity.
                            IP is derived from the node ID.
                            Not used for uplink
                            interfaces.
                            """
                            max_ha_interfaces: int | None
                            """
                            Number of parallel links towards HA switches.
                            Can be used to reserve IP addresses for future
                            parallel HA links.
                            """
                            port_channel_id: int | None
                            """Port-channel ID to use for direct HA."""
                            use_port_channel_for_direct_ha: bool | None
                            """
                            Enable or disable using a port-channel interface for direct HA when there is only one interface.
                            This feature was introduced in EOS 4.33.0F.
                            """
                            flow_tracking: FlowTracking
                            """
                            Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                            setting.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                ipsec: bool | None | UndefinedType = Undefined,
                                mtu: int | None | UndefinedType = Undefined,
                                ha_interfaces: list[str] | UndefinedType = Undefined,
                                ha_ipv4_pool: str | None | UndefinedType = Undefined,
                                max_ha_interfaces: int | None | UndefinedType = Undefined,
                                port_channel_id: int | None | UndefinedType = Undefined,
                                use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                                flow_tracking: FlowTracking | UndefinedType = Undefined,
                            ) -> None:
                                """
                                WanHa.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                    ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                    mtu: Set MTU on WAN HA interfaces.
                                    ha_interfaces:
                                       Local WAN HA interfaces
                                       Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                       Can be used to filter uplink interfaces when there are multiple uplinks.
                                       Limitations:
                                         Either all
                                       interfaces must be uplinks or all interfaces must not be uplinks.
                                         Only one interface is supported
                                       for non uplinks.
                                    ha_ipv4_pool:
                                       IP address pool used for WAN HA connectivity.
                                       IP is derived from the node ID.
                                       Not used for uplink
                                       interfaces.
                                    max_ha_interfaces:
                                       Number of parallel links towards HA switches.
                                       Can be used to reserve IP addresses for future
                                       parallel HA links.
                                    port_channel_id: Port-channel ID to use for direct HA.
                                    use_port_channel_for_direct_ha:
                                       Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                       This feature was introduced in EOS 4.33.0F.
                                    flow_tracking:
                                       Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                       setting.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class L3InterfacesItem(AvdModel):
                            class Bgp(AvdModel):
                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "peer_as": {"type": str},
                                    "ipv4_prefix_list_in": {"type": str},
                                    "ipv4_prefix_list_out": {"type": str},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                                _custom_data: dict[str, Any]
                                peer_as: str
                                """
                                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                For asdot notation in
                                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                number.
                                """
                                ipv4_prefix_list_in: str | None
                                """
                                Prefix List Name. Accept routes for only these prefixes from the peer.
                                Required for wan interfaces.
                                """
                                ipv4_prefix_list_out: str | None
                                """
                                Prefix List Name. Advertise routes for only these prefixes.
                                If not specified, nothing would be
                                advertised.
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    peer_as: str | UndefinedType = Undefined,
                                    ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                    ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Bgp.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        peer_as:
                                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                           For asdot notation in
                                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                           number.
                                        ipv4_prefix_list_in:
                                           Prefix List Name. Accept routes for only these prefixes from the peer.
                                           Required for wan interfaces.
                                        ipv4_prefix_list_out:
                                           Prefix List Name. Advertise routes for only these prefixes.
                                           If not specified, nothing would be
                                           advertised.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class StaticRoutesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                                _custom_data: dict[str, Any]
                                prefix: str
                                """IPv4_network/Mask."""

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    StaticRoutesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        prefix: IPv4_network/Mask.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class CvPathfinderInternetExit(AvdModel):
                                class PoliciesItem(AvdModel):
                                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                    _custom_data: dict[str, Any]
                                    name: str
                                    """Internet-exit policy name."""
                                    tunnel_interface_numbers: str | None
                                    """
                                    Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                    interface.
                                    Examples: '1-3' or '100,200,300'
                                    """

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        name: str | UndefinedType = Undefined,
                                        tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        PoliciesItem.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            name: Internet-exit policy name.
                                            tunnel_interface_numbers:
                                               Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                               interface.
                                               Examples: '1-3' or '100,200,300'

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class Policies(AvdCollection[str, PoliciesItem]):
                                    _primary_key: ClassVar[str] = "name"

                                Policies._item_type = PoliciesItem

                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                policies: Policies
                                """List of Internet-exit policies using this interface as exit."""

                                def __init__(
                                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                                ) -> None:
                                    """
                                    CvPathfinderInternetExit.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        policies: List of Internet-exit policies using this interface as exit.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class FlowTracking(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                enabled: bool | None
                                name: str | None
                                """Flow tracker name as defined in flow_tracking_settings."""

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    enabled: bool | None | UndefinedType = Undefined,
                                    name: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    FlowTracking.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        enabled: enabled
                                        name: Flow tracker name as defined in flow_tracking_settings.

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                                pass

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "profile": {"type": str},
                                "name": {"type": str},
                                "description": {"type": str},
                                "ip_address": {"type": str},
                                "dhcp_ip": {"type": str},
                                "public_ip": {"type": str},
                                "encapsulation_dot1q_vlan": {"type": int},
                                "dhcp_accept_default_route": {"type": bool, "default": True},
                                "enabled": {"type": bool, "default": True},
                                "speed": {"type": str},
                                "peer": {"type": str},
                                "peer_interface": {"type": str},
                                "peer_ip": {"type": str},
                                "bgp": {"type": Bgp},
                                "ipv4_acl_in": {"type": str},
                                "ipv4_acl_out": {"type": str},
                                "static_routes": {"type": list, "items": StaticRoutesItem},
                                "qos_profile": {"type": str},
                                "wan_carrier": {"type": str},
                                "wan_circuit_id": {"type": str},
                                "connected_to_pathfinder": {"type": bool, "default": True},
                                "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                                "raw_eos_cli": {"type": str},
                                "flow_tracking": {"type": FlowTracking},
                                "structured_config": {"type": StructuredConfig},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                            _custom_data: dict[str, Any]
                            profile: str | None
                            """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                            name: str
                            """
                            Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                            For a
                            subinterface, the parent physical interface is automatically created.
                            """
                            description: str | None
                            """
                            Interface description.
                            If not set a default description will be configured with '[<peer>[
                            <peer_interface>]]'.
                            """
                            ip_address: str | None
                            """Node IPv4 address/Mask or 'dhcp'."""
                            dhcp_ip: str | None
                            """
                            When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                            IPv4 address
                            (without mask) to be allocated on the interface if known.
                            This is not rendered in the configuration
                            but can be used for substitution of 'interface_ip' in the Access-list
                            set under `ipv4_acl_in` and
                            `ipv4_acl_out`.
                            """
                            public_ip: str | None
                            """
                            Node IPv4 address (no mask).

                            This is used to get the public IP (if known) when the device is behind
                            NAT.
                            This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                            with the following preference:
                              `wan_route_servers.path_groups.interfaces.ip_address`
                                  ->
                            `l3_interfaces.public_ip`
                                      -> `l3_interfaces.ip_address`

                            The determined Public IP is used
                            by WAN routers when peering with this interface.
                            """
                            encapsulation_dot1q_vlan: int | None
                            """
                            For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                            specified.
                            """
                            dhcp_accept_default_route: bool | None
                            """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                            enabled: bool | None
                            """Enable or Shutdown the interface."""
                            speed: str | None
                            """
                            Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                            <interface_speed>`.
                            """
                            peer: str | None
                            """The peer device name. Used for description and documentation."""
                            peer_interface: str | None
                            """The peer device interface. Used for description and documentation."""
                            peer_ip: str | None
                            """
                            The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                            and `ip` is an IP address.
                            """
                            bgp: Bgp
                            """Enforce IPv4 BGP peering for the peer"""
                            ipv4_acl_in: str | None
                            """
                            Name of the IPv4 access-list to be assigned in the ingress direction.
                            The access-list must be
                            defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                            Required
                            for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                            `wan_carriers`.
                            """
                            ipv4_acl_out: str | None
                            """
                            Name of the IPv4 Access-list to be assigned in the egress direction.
                            The access-list must be defined
                            under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                            """
                            static_routes: list[StaticRoutesItem]
                            """Configure IPv4 static routes pointing to `peer_ip`."""
                            qos_profile: str | None
                            """QOS service profile."""
                            wan_carrier: str | None
                            """
                            The WAN carrier this interface is connected to.
                            This is used to infer the path-groups in which this
                            interface should be configured.
                            Unless the carrier is marked as 'trusted' under `wan_carriers`,
                            `ipv4_acl_in` is also required on all WAN interfaces.
                            """
                            wan_circuit_id: str | None
                            """
                            The WAN circuit ID for this interface.
                            This is not rendered in the configuration but used for WAN
                            designs.
                            """
                            connected_to_pathfinder: bool | None
                            """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit
                            """PREVIEW: This key is in preview mode"""
                            raw_eos_cli: str | None
                            """EOS CLI rendered directly on the interface in the final EOS configuration."""
                            flow_tracking: FlowTracking
                            """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                            structured_config: StructuredConfig
                            """Custom structured config for the Ethernet interface."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                profile: str | None | UndefinedType = Undefined,
                                name: str | UndefinedType = Undefined,
                                description: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                dhcp_ip: str | None | UndefinedType = Undefined,
                                public_ip: str | None | UndefinedType = Undefined,
                                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                                dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                speed: str | None | UndefinedType = Undefined,
                                peer: str | None | UndefinedType = Undefined,
                                peer_interface: str | None | UndefinedType = Undefined,
                                peer_ip: str | None | UndefinedType = Undefined,
                                bgp: Bgp | UndefinedType = Undefined,
                                ipv4_acl_in: str | None | UndefinedType = Undefined,
                                ipv4_acl_out: str | None | UndefinedType = Undefined,
                                static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                                qos_profile: str | None | UndefinedType = Undefined,
                                wan_carrier: str | None | UndefinedType = Undefined,
                                wan_circuit_id: str | None | UndefinedType = Undefined,
                                connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                                cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                                raw_eos_cli: str | None | UndefinedType = Undefined,
                                flow_tracking: FlowTracking | UndefinedType = Undefined,
                                structured_config: StructuredConfig | UndefinedType = Undefined,
                            ) -> None:
                                """
                                L3InterfacesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                    name:
                                       Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                       For a
                                       subinterface, the parent physical interface is automatically created.
                                    description:
                                       Interface description.
                                       If not set a default description will be configured with '[<peer>[
                                       <peer_interface>]]'.
                                    ip_address: Node IPv4 address/Mask or 'dhcp'.
                                    dhcp_ip:
                                       When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                       IPv4 address
                                       (without mask) to be allocated on the interface if known.
                                       This is not rendered in the configuration
                                       but can be used for substitution of 'interface_ip' in the Access-list
                                       set under `ipv4_acl_in` and
                                       `ipv4_acl_out`.
                                    public_ip:
                                       Node IPv4 address (no mask).

                                       This is used to get the public IP (if known) when the device is behind
                                       NAT.
                                       This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                       with the following preference:
                                         `wan_route_servers.path_groups.interfaces.ip_address`
                                             ->
                                       `l3_interfaces.public_ip`
                                                 -> `l3_interfaces.ip_address`

                                       The determined Public IP is used
                                       by WAN routers when peering with this interface.
                                    encapsulation_dot1q_vlan:
                                       For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                       specified.
                                    dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                    enabled: Enable or Shutdown the interface.
                                    speed:
                                       Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                       <interface_speed>`.
                                    peer: The peer device name. Used for description and documentation.
                                    peer_interface: The peer device interface. Used for description and documentation.
                                    peer_ip:
                                       The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                       and `ip` is an IP address.
                                    bgp: Enforce IPv4 BGP peering for the peer
                                    ipv4_acl_in:
                                       Name of the IPv4 access-list to be assigned in the ingress direction.
                                       The access-list must be
                                       defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                       Required
                                       for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                       `wan_carriers`.
                                    ipv4_acl_out:
                                       Name of the IPv4 Access-list to be assigned in the egress direction.
                                       The access-list must be defined
                                       under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                    static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                    qos_profile: QOS service profile.
                                    wan_carrier:
                                       The WAN carrier this interface is connected to.
                                       This is used to infer the path-groups in which this
                                       interface should be configured.
                                       Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                       `ipv4_acl_in` is also required on all WAN interfaces.
                                    wan_circuit_id:
                                       The WAN circuit ID for this interface.
                                       This is not rendered in the configuration but used for WAN
                                       designs.
                                    connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                    cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                    raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                    flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                    structured_config: Custom structured config for the Ethernet interface.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                            _primary_key: ClassVar[str] = "name"

                        L3Interfaces._item_type = L3InterfacesItem

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "name": {"type": str},
                            "downlink_pools": {"type": list, "items": DownlinkPoolsItem},
                            "id": {"type": int},
                            "platform": {"type": str},
                            "mac_address": {"type": str},
                            "system_mac_address": {"type": str},
                            "serial_number": {"type": str},
                            "rack": {"type": str},
                            "mgmt_ip": {"type": str},
                            "mgmt_gateway": {"type": str},
                            "ipv6_mgmt_ip": {"type": str},
                            "ipv6_mgmt_gateway": {"type": str},
                            "mgmt_interface": {"type": str},
                            "link_tracking": {"type": LinkTracking},
                            "lacp_port_id_range": {"type": LacpPortIdRange},
                            "always_configure_ip_routing": {"type": bool, "default": False},
                            "raw_eos_cli": {"type": str},
                            "structured_config": {"type": StructuredConfig},
                            "uplink_type": {"type": str, "default": "p2p"},
                            "uplink_ipv4_pool": {"type": str},
                            "uplink_interfaces": {"type": list, "items": str},
                            "uplink_switch_interfaces": {"type": list, "items": str},
                            "uplink_switches": {"type": list, "items": str},
                            "uplink_interface_speed": {"type": str},
                            "uplink_switch_interface_speed": {"type": str},
                            "uplink_mtu": {"type": int},
                            "max_uplink_switches": {"type": int},
                            "max_parallel_uplinks": {"type": int},
                            "uplink_bfd": {"type": bool, "default": False},
                            "uplink_native_vlan": {"type": int},
                            "uplink_ptp": {"type": UplinkPtp},
                            "uplink_macsec": {"type": UplinkMacsec},
                            "uplink_port_channel_id": {"type": int},
                            "uplink_switch_port_channel_id": {"type": int},
                            "uplink_structured_config": {"type": dict},
                            "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                            "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                            "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                            "short_esi": {"type": str},
                            "isis_system_id_prefix": {"type": str},
                            "isis_maximum_paths": {"type": int},
                            "is_type": {"type": str, "default": "level-2"},
                            "node_sid_base": {"type": int, "default": 0},
                            "loopback_ipv4_pool": {"type": str},
                            "loopback_ipv4_address": {"type": str},
                            "vtep_loopback_ipv4_pool": {"type": str},
                            "vtep_loopback_ipv4_address": {"type": str},
                            "loopback_ipv4_offset": {"type": int, "default": 0},
                            "loopback_ipv6_pool": {"type": str},
                            "loopback_ipv6_offset": {"type": int, "default": 0},
                            "vtep": {"type": bool},
                            "vtep_loopback": {"type": str},
                            "bgp_as": {"type": str},
                            "bgp_defaults": {"type": list, "items": str},
                            "evpn_role": {"type": str},
                            "evpn_route_servers": {"type": list, "items": str},
                            "evpn_services_l2_only": {"type": bool, "default": False},
                            "filter": {"type": Filter},
                            "igmp_snooping_enabled": {"type": bool, "default": True},
                            "evpn_gateway": {"type": EvpnGateway},
                            "ipvpn_gateway": {"type": IpvpnGateway},
                            "mlag": {"type": bool, "default": True},
                            "mlag_dual_primary_detection": {"type": bool, "default": False},
                            "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                            "mlag_interfaces": {"type": list, "items": str},
                            "mlag_interfaces_speed": {"type": str},
                            "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                            "mlag_peer_l3_ipv4_pool": {"type": str},
                            "mlag_peer_vlan": {"type": int, "default": 4094},
                            "mlag_peer_link_allowed_vlans": {"type": str},
                            "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                            "mlag_peer_ipv4_pool": {"type": str},
                            "mlag_peer_ipv6_pool": {"type": str},
                            "mlag_port_channel_id": {"type": int},
                            "mlag_domain_id": {"type": str},
                            "spanning_tree_mode": {"type": str},
                            "spanning_tree_priority": {"type": int, "default": 32768},
                            "spanning_tree_root_super": {"type": bool, "default": False},
                            "virtual_router_mac_address": {"type": str},
                            "inband_mgmt_interface": {"type": str},
                            "inband_mgmt_vlan": {"type": int, "default": 4092},
                            "inband_mgmt_subnet": {"type": str},
                            "inband_mgmt_ip": {"type": str},
                            "inband_mgmt_gateway": {"type": str},
                            "inband_mgmt_ipv6_address": {"type": str},
                            "inband_mgmt_ipv6_subnet": {"type": str},
                            "inband_mgmt_ipv6_gateway": {"type": str},
                            "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                            "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                            "inband_mgmt_vrf": {"type": str, "default": "default"},
                            "inband_mgmt_mtu": {"type": int, "default": 1500},
                            "inband_ztp": {"type": bool, "default": False},
                            "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                            "mpls_overlay_role": {"type": str},
                            "overlay_address_families": {"type": list, "items": str},
                            "mpls_route_reflectors": {"type": list, "items": str},
                            "bgp_cluster_id": {"type": str},
                            "ptp": {"type": Ptp},
                            "wan_role": {"type": str},
                            "cv_pathfinder_transit_mode": {"type": str},
                            "cv_pathfinder_region": {"type": str},
                            "cv_pathfinder_site": {"type": str},
                            "wan_ha": {"type": WanHa},
                            "dps_mss_ipv4": {"type": str, "default": "auto"},
                            "l3_interfaces": {"type": L3Interfaces},
                            "data_plane_cpu_allocation_max": {"type": int},
                            "flow_tracker_type": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        name: str
                        """The Node Name is used as "hostname"."""
                        downlink_pools: list[DownlinkPoolsItem]
                        """
                        IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                        with `uplink_ipv4_pool` set on the downlink switch.
                        """
                        id: int | None
                        """Unique identifier used for IP addressing and other algorithms."""
                        platform: str | None
                        """Arista platform family."""
                        mac_address: str | None
                        """Leverage to document management interface mac address."""
                        system_mac_address: str | None
                        """
                        System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                        Set to the same MAC address as
                        available in "show version" on the device.
                        "system_mac_address" can also be set directly as a
                        hostvar.
                        If both are set, the setting under node type settings takes precedence.
                        """
                        serial_number: str | None
                        """
                        Set to the Serial Number of the device.
                        Only used for documentation purpose in the fabric
                        documentation and part of the structured_config.
                        "serial_number" can also be set directly as a
                        hostvar.
                        If both are set, the setting under node type settings takes precedence.
                        """
                        rack: str | None
                        """Rack that the switch is located in (only used in snmp_settings location)."""
                        mgmt_ip: str | None
                        """Node management interface IPv4 address."""
                        mgmt_gateway: str | None
                        """
                        This key sets the management gateway for the device. It takes precedence over the global
                        `mgmt_gateway`.
                        """
                        ipv6_mgmt_ip: str | None
                        """Node management interface IPv6 address."""
                        ipv6_mgmt_gateway: str | None
                        """
                        This key sets the ipv6 management gateway for the device. It takes precedence over the global
                        `ipv6_mgmt_gateway`.
                        """
                        mgmt_interface: str | None
                        """
                        Management Interface Name.
                        Default -> platform_management_interface -> mgmt_interface ->
                        "Management1".
                        """
                        link_tracking: LinkTracking
                        """
                        This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                        the upstream interfaces.
                        Useful in EVPN multhoming designs.
                        """
                        lacp_port_id_range: LacpPortIdRange
                        """
                        This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                        number of nodes in the "node_group".
                        Unique LACP port-id ranges are recommended for EVPN Multihoming
                        designs.
                        """
                        always_configure_ip_routing: bool | None
                        """
                        Force configuration of "ip routing" even on L2 devices.
                        Use this to retain behavior of AVD versions
                        below 4.0.0.
                        """
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the root level of the final EOS configuration."""
                        structured_config: StructuredConfig
                        """Custom structured config for eos_cli_config_gen."""
                        uplink_type: str | None
                        """
                        Override the default `uplink_type` set at the `node_type_key` level.
                        `uplink_type` must be "p2p" if
                        `vtep` or `underlay_router` is true for the `node_type_key` definition.
                        """
                        uplink_ipv4_pool: str | None
                        """IPv4 subnet to use to connect to uplink switches."""
                        uplink_interfaces: list[str]
                        """
                        Local uplink interfaces.
                        Each list item supports range syntax that can be expanded into a list of
                        interfaces.
                        If uplink_interfaces is not defined, platform-specific defaults (defined under
                        default_interfaces) will be used instead.
                        Please note that default_interfaces are not defined by
                        default, you should define these yourself.
                        """
                        uplink_switch_interfaces: list[str]
                        """Interfaces located on uplink switches."""
                        uplink_switches: list[str]
                        uplink_interface_speed: str | None
                        """
                        Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                        (Uplink switch
                        interface speed can be overridden with `uplink_switch_interface_speed`).
                        Speed should be set in the
                        format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                        """
                        uplink_switch_interface_speed: str | None
                        """
                        Set point-to-Point interface speed for the uplink switch interface only.
                        Speed should be set in the
                        format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                        """
                        uplink_mtu: int | None
                        """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                        max_uplink_switches: int | None
                        """
                        Maximum number of uplink switches.
                        Changing this value may change IP Addressing on uplinks.
                        Can be
                        used to reserve IP space for future expansions.
                        """
                        max_parallel_uplinks: int | None
                        """
                        Number of parallel links towards uplink switches.
                        Changing this value may change interface naming on
                        uplinks (and corresponding downlinks).
                        Can be used to reserve interfaces for future parallel
                        uplinks.
                        """
                        uplink_bfd: bool | None
                        """Enable bfd on uplink interfaces."""
                        uplink_native_vlan: int | None
                        """
                        Only applicable to switches with layer-2 port-channel uplinks.
                        A suspended (disabled) vlan will be
                        created in both ends of the link unless the vlan is defined under network services.
                        By default the
                        uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                        """
                        uplink_ptp: UplinkPtp
                        """Enable PTP on all infrastructure links."""
                        uplink_macsec: UplinkMacsec
                        """Enable MacSec on all uplinks."""
                        uplink_port_channel_id: int | None
                        """
                        Only applicable for L2 switches with `uplink_type: port-channel`.
                        By default the uplink Port-channel
                        ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                        For
                        example:
                          member ports [ Eth22, Eth23 ] -> ID 22
                          member ports [ Eth11/1, Eth22/1 ] -> ID 111
                        For
                        MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                        This
                        option overrides the default behavior and statically sets the local Port-channel ID.
                        Note! Make sure
                        the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                        Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                        value.
                        """
                        uplink_switch_port_channel_id: int | None
                        """
                        Only applicable for L2 switches with `uplink_type: port-channel`.
                        By default the uplink switch Port-
                        channel ID will be set to the number of the first interface defined under
                        `uplink_switch_interfaces`.
                        For example:
                          member ports [ Eth22, Eth23 ] -> ID 22
                          member ports [
                        Eth11/1, Eth22/1 ] -> ID 111
                        For MLAG port-channels ID will be based on the lowest member interface
                        on the first MLAG switch.
                        This option overrides the default behavior and statically sets the Port-
                        channel ID on the uplink switch.
                        Note! Make sure the ID is unique and does not overlap with
                        autogenerated Port-channel IDs in the Network Services.
                        Note! For MLAG pairs the ID must be between
                        1 and 2000 and both MLAG switches must have the same value.
                        """
                        uplink_structured_config: dict
                        """
                        Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                        When
                        uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                        for eos_cli_config_gen overrides the settings on the ethernet interface level.
                        When uplink_type ==
                        "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                        eos_cli_config_gen overrides the settings on the port-channel interface level.
                        "uplink_structured_config" is applied after "structured_config", so it can override
                        "structured_config" defined on node-level.
                        Note! The content of this dictionary is _not_ validated
                        by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                        """
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                        """
                        Custom structured config applied to MLAG peer link port-channel id.
                        Added under
                        port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                        Overrides the settings on the
                        port-channel interface level.
                        "mlag_port_channel_structured_config" is applied after
                        "structured_config", so it can override "structured_config" defined on node-level.
                        """
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                        """
                        Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                        Added under
                        vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                        Overrides the settings on the vlan
                        interface level.
                        "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                        override "structured_config" defined on node-level.
                        """
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                        """
                        Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                        Added under
                        vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                        Overrides the settings on the vlan
                        interface level.
                        "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                        can override "structured_config" defined on node-level.
                        """
                        short_esi: str | None
                        """
                        short_esi only valid for l2leaf devices using port-channel uplink.
                        Setting short_esi to "auto"
                        generates the short_esi automatically using a hash of configuration elements.
                        < 0000:0000:0000 |
                        auto >.
                        """
                        isis_system_id_prefix: str | None
                        """(4.4 hexadecimal)."""
                        isis_maximum_paths: int | None
                        """Number of path to configure in ECMP for ISIS."""
                        is_type: str | None
                        node_sid_base: int | None
                        """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                        loopback_ipv4_pool: str | None
                        """IPv4 subnet for Loopback0 allocation."""
                        loopback_ipv4_address: str | None
                        """
                        IPv4 address without mask for Loopback0.
                        When set, it takes precedence over `loopback_ipv4_pool`.
                        Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                        """
                        vtep_loopback_ipv4_pool: str | None
                        """IPv4 subnet for VTEP-Loopback allocation."""
                        vtep_loopback_ipv4_address: str | None
                        """
                        IPv4 address without mask for VTEP-Loopback.
                        When set, it takes precedence over
                        `vtep_loopback_ipv4_pool`.
                        Note: AVD does not check for validity of the IPv4 address and does not
                        catch duplicates.
                        """
                        loopback_ipv4_offset: int | None
                        """
                        Offset all assigned loopback IP addresses.
                        Required when the < loopback_ipv4_pool > is same for 2
                        different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                        For example, set the minimum
                        offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                        """
                        loopback_ipv6_pool: str | None
                        """IPv6 subnet for Loopback0 allocation."""
                        loopback_ipv6_offset: int | None
                        """
                        Offset all assigned loopback IPv6 addresses.
                        Required when the < loopback_ipv6_pool > is same for 2
                        different node_types (like spine and l3leaf) to avoid overlapping IPs.
                        For example, set the minimum
                        offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                        """
                        vtep: bool | None
                        """
                        Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                        Overrides VTEP
                        setting inherited from node_type_keys.
                        """
                        vtep_loopback: str | None
                        """Set VXLAN source interface."""
                        bgp_as: str | None
                        """
                        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                        For asdot notation in
                        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                        number.
                        Required with eBGP.
                        """
                        bgp_defaults: list[str]
                        """List of EOS commands to apply to BGP daemon."""
                        evpn_role: str | None
                        """
                        Acting role in EVPN control plane.
                        Default is set in node_type definition from node_type_keys.
                        """
                        evpn_route_servers: list[str]
                        """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                        evpn_services_l2_only: bool | None
                        """
                        Possibility to prevent configuration of Tenant VRFs and SVIs.
                        Override node definition
                        "network_services_l3" from node_type_keys.
                        This allows support for centralized routing.
                        """
                        filter: Filter
                        """
                        Filter L3 and L2 network services based on tenant and tags (and operation filter).
                        If filter is not
                        defined it will default to all.
                        """
                        igmp_snooping_enabled: bool | None
                        """Activate or deactivate IGMP snooping on device level."""
                        evpn_gateway: EvpnGateway
                        """
                        Node is acting as EVPN Multi-Domain Gateway.
                        New BGP peer-group is generated between EVPN GWs in
                        different domains or between GWs and Route Servers.
                        Name can be changed under
                        "bgp_peer_groups.evpn_overlay_core" variable.
                        L3 rechability for different EVPN GWs must be already
                        in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                        same Ansible inventory.
                        """
                        ipvpn_gateway: IpvpnGateway
                        """
                        Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                        this is "bgp_peer_groups.ipvpn_gateway_peers".
                        L3 Reachability is required for this to work, the
                        preferred method to establish underlay connectivity is to use core_interfaces.
                        """
                        mlag: bool | None
                        """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                        mlag_dual_primary_detection: bool | None
                        """Enable / Disable MLAG dual primary detection."""
                        mlag_ibgp_origin_incomplete: bool | None
                        """
                        Set origin of routes received from MLAG iBGP peer to incomplete.
                        The purpose is to optimize routing
                        for leaf loopbacks from spine perspective and
                        avoid suboptimal routing via peerlink for control
                        plane traffic.
                        """
                        mlag_interfaces: list[str]
                        """
                        Each list item supports range syntax that can be expanded into a list of interfaces.
                        Required when
                        MLAG leafs are present in the topology.
                        """
                        mlag_interfaces_speed: str | None
                        """
                        Set MLAG interface speed.
                        Speed should be set in the format `<interface_speed>` or `forced
                        <interface_speed>` or `auto <interface_speed>`.
                        """
                        mlag_peer_l3_vlan: int | None
                        """
                        Underlay L3 peering SVI interface id.
                        If set to 0 or the same vlan as mlag_peer_vlan, the
                        mlag_peer_vlan will be used for L3 peering.
                        """
                        mlag_peer_l3_ipv4_pool: str | None
                        """
                        IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                        Required when
                        MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                        """
                        mlag_peer_vlan: int | None
                        """MLAG Peer Link (control link) SVI interface id."""
                        mlag_peer_link_allowed_vlans: str | None
                        mlag_peer_address_family: str | None
                        """
                        IP address family used to establish MLAG Peer Link (control link).
                        `ipv6` requires EOS version
                        4.31.1F or higher.
                        Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                        (ex. `mlag_peer_l3_vlan` set to 4094).
                        """
                        mlag_peer_ipv4_pool: str | None
                        """
                        IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                        Required
                        for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                        """
                        mlag_peer_ipv6_pool: str | None
                        """
                        IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                        Required
                        for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                        """
                        mlag_port_channel_id: int | None
                        """
                        If not set, the mlag port-channel id is generated based on the digits of the first interface present
                        in 'mlag_interfaces'.
                        Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                        999999 > for EOS >= 4.25.0F.
                        """
                        mlag_domain_id: str | None
                        """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                        spanning_tree_mode: str | None
                        spanning_tree_priority: int | None
                        """
                        Spanning-tree priority configured for the selected mode.
                        For `rapid-pvst` the priority can also be
                        set per VLAN under network services.
                        """
                        spanning_tree_root_super: bool | None
                        virtual_router_mac_address: str | None
                        """Virtual router mac address for anycast gateway."""
                        inband_mgmt_interface: str | None
                        """
                        Pointer to interface used for inband management.
                        All configuration must be done using other data
                        models like network services or structured_config.
                        'inband_mgmt_interface' is only used to refer to
                        this interface as source in various management protocol settings (future feature).

                        On L2 switches,
                        this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                        """
                        inband_mgmt_vlan: int | None
                        """
                        VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                        uplinks).
                        When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                        switch as well as all 'uplink_switches'.
                        When using 'inband_mgmt_ip' the VLAN and SVI will only be
                        created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                        created using network services data models.
                        """
                        inband_mgmt_subnet: str | None
                        """
                        Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                        as uplinks).
                        Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                        ARP.
                        This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                        SVI IP address will be assigned as follows:
                        virtual-router: <subnet> + 1
                        l3leaf A      : <subnet> +
                        2 (same IP on all l3leaf A)
                        l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                        l2leafs       :
                        <subnet> + 3 + <l2leaf id>
                        GW on l2leafs : <subnet> + 1
                        Assign range larger than total l2leafs + 5
                        Setting is ignored if 'inband_mgmt_ip' is set.

                        This setting is applicable to L2 switches (switches
                        using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ip: str | None
                        """
                        IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                        This overrides
                        'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                        If this is set the
                        VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                        The VLAN and SVI on
                        the parent switches must be created using network services data models.

                        This setting is applicable
                        to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_gateway: str | None
                        """
                        Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                        is derived from 'inband_mgmt_subnet' if set.

                        This setting is applicable to L2 switches (switches
                        using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ipv6_address: str | None
                        """
                        IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                        This overrides
                        'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                        If this
                        is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                        The VLAN
                        and SVI on the parent switches must be created using network services data models.

                        This setting is
                        applicable to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ipv6_subnet: str | None
                        """
                        Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                        as uplinks).
                        Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                        on ARP.
                        This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                        extension.
                        SVI IP address will be assigned as follows:
                        virtual-router: <subnet> + 1
                        l3leaf A      :
                        <subnet> + 2 (same IP on all l3leaf A)
                        l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                        l2leafs       : <subnet> + 3 + <l2leaf id>
                        GW on l2leafs : <subnet> + 1
                        Assign range larger than
                        total l2leafs + 5

                        Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                        This setting is
                        applicable to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_ipv6_gateway: str | None
                        """
                        Default gateway configured in the 'inband_mgmt_vrf'.
                        Used when `inband_mgmt_ipv6_address` is set.
                        Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                        This setting is
                        applicable to L2 switches (switches using port-channel trunks as uplinks).
                        """
                        inband_mgmt_description: str | None
                        """
                        Description configured on the Inband Management SVI.

                        This setting is only applied on the devices
                        where it is set, it does not automatically affect any parent/child devices configuration, so it must
                        be set on each applicable node/node-group/node-type as needed.
                        """
                        inband_mgmt_vlan_name: str | None
                        """
                        Name configured on the Inband Management VLAN.
                        This setting is only applied on the devices where it
                        is set, it does not automatically affect any parent/child devices configuration, so it must be set
                        on each applicable node/node-group/node-type as needed.
                        """
                        inband_mgmt_vrf: str | None
                        """
                        VRF configured on the Inband Management Interface.
                        The VRF is created if not already created by
                        other means.
                        This setting is only applied on the devices where it is set, it does not automatically
                        affect any parent/child devices configuration, so it must be set on each applicable node/node-
                        group/node-type as needed.
                        """
                        inband_mgmt_mtu: int | None
                        """
                        MTU configured on the Inband Management Interface.
                        This setting is only applied on the devices where
                        it is set, it does not automatically affect any parent/child devices configuration, so it must be
                        set on each applicable node/node-group/node-type as needed.
                        """
                        inband_ztp: bool | None
                        """
                        Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                        inband.
                        This setting also requires that the `inband_mgmt_vlan` is set for the node.
                        """
                        inband_ztp_lacp_fallback_delay: int | None
                        """
                        Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                        ZTP node.
                        This setting also requires that `inband_ztp` is set for the node.
                        """
                        mpls_overlay_role: str | None
                        """
                        Set the default mpls overlay role.
                        Acting role in overlay control plane.
                        """
                        overlay_address_families: list[str]
                        """Set the default overlay address families."""
                        mpls_route_reflectors: list[str]
                        """List of inventory hostname acting as MPLS route-reflectors."""
                        bgp_cluster_id: str | None
                        """Set BGP cluster id."""
                        ptp: Ptp
                        wan_role: str | None
                        """
                        Override the default WAN role.

                        This is used both for AutoVPN and Pathfinder designs.
                        That means if
                        `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                        `server` indicates that the
                        router is a route-reflector.

                        Only supported if `overlay_routing_protocol` is set to `ibgp`.
                        """
                        cv_pathfinder_transit_mode: str | None
                        """
                        Configure the transit mode for a WAN client for CV Pathfinder designs
                        only when the `wan_mode` root
                        key is set to `cv_pathfinder`.

                        'zone' is currently not supported.
                        """
                        cv_pathfinder_region: str | None
                        """
                        The CV Pathfinder region name.
                        This key is required for WAN routers but optional for pathfinders.
                        The region name must be defined under 'cv_pathfinder_regions'.
                        """
                        cv_pathfinder_site: str | None
                        """
                        The CV Pathfinder site name.
                        This key is required for WAN routers but optional for pathfinders.
                        For
                        WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                        relevant region under 'cv_pathfinder_regions'.
                        For pathfinders without `cv_pathfinder_region` set,
                        the site must be defined under `cv_pathfinder_global_sites`.
                        """
                        wan_ha: WanHa
                        """
                        PREVIEW: This key is currently not supported

                        The key is supported only if `wan_mode` == `cv-
                        pathfinder`.
                        AutoVPN support is still to be determined.

                        Maximum 2 devices supported by group for
                        HA.
                        """
                        dps_mss_ipv4: str | None
                        """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                        l3_interfaces: L3Interfaces
                        """
                        L3 Interfaces to configure on the node.
                        Used to define the node for WAN interfaces when
                        `wan_carrier` is set.
                        """
                        data_plane_cpu_allocation_max: int | None
                        """
                        Set the maximum number of CPU used for the data plane.
                        This setting is useful on virtual Route
                        Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                        """
                        flow_tracker_type: str | None
                        """
                        Set the flow tracker type.
                        Override the `default_flow_tracker_type`` set at the `node_type_key`
                        level.
                        `default_flow_tracker_type` default value is `sampled`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            downlink_pools: list[DownlinkPoolsItem] | UndefinedType = Undefined,
                            id: int | None | UndefinedType = Undefined,
                            platform: str | None | UndefinedType = Undefined,
                            mac_address: str | None | UndefinedType = Undefined,
                            system_mac_address: str | None | UndefinedType = Undefined,
                            serial_number: str | None | UndefinedType = Undefined,
                            rack: str | None | UndefinedType = Undefined,
                            mgmt_ip: str | None | UndefinedType = Undefined,
                            mgmt_gateway: str | None | UndefinedType = Undefined,
                            ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                            ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                            mgmt_interface: str | None | UndefinedType = Undefined,
                            link_tracking: LinkTracking | UndefinedType = Undefined,
                            lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                            always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                            uplink_type: str | None | UndefinedType = Undefined,
                            uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                            uplink_interfaces: list[str] | UndefinedType = Undefined,
                            uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                            uplink_switches: list[str] | UndefinedType = Undefined,
                            uplink_interface_speed: str | None | UndefinedType = Undefined,
                            uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                            uplink_mtu: int | None | UndefinedType = Undefined,
                            max_uplink_switches: int | None | UndefinedType = Undefined,
                            max_parallel_uplinks: int | None | UndefinedType = Undefined,
                            uplink_bfd: bool | None | UndefinedType = Undefined,
                            uplink_native_vlan: int | None | UndefinedType = Undefined,
                            uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                            uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                            uplink_port_channel_id: int | None | UndefinedType = Undefined,
                            uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                            uplink_structured_config: dict | UndefinedType = Undefined,
                            mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                            mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                            mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                            short_esi: str | None | UndefinedType = Undefined,
                            isis_system_id_prefix: str | None | UndefinedType = Undefined,
                            isis_maximum_paths: int | None | UndefinedType = Undefined,
                            is_type: str | None | UndefinedType = Undefined,
                            node_sid_base: int | None | UndefinedType = Undefined,
                            loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                            loopback_ipv4_address: str | None | UndefinedType = Undefined,
                            vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                            vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                            loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                            loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                            loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                            vtep: bool | None | UndefinedType = Undefined,
                            vtep_loopback: str | None | UndefinedType = Undefined,
                            bgp_as: str | None | UndefinedType = Undefined,
                            bgp_defaults: list[str] | UndefinedType = Undefined,
                            evpn_role: str | None | UndefinedType = Undefined,
                            evpn_route_servers: list[str] | UndefinedType = Undefined,
                            evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                            filter: Filter | UndefinedType = Undefined,
                            igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                            evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                            ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                            mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                            mlag_interfaces: list[str] | UndefinedType = Undefined,
                            mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                            mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                            mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                            mlag_peer_vlan: int | None | UndefinedType = Undefined,
                            mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                            mlag_peer_address_family: str | None | UndefinedType = Undefined,
                            mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                            mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                            mlag_port_channel_id: int | None | UndefinedType = Undefined,
                            mlag_domain_id: str | None | UndefinedType = Undefined,
                            spanning_tree_mode: str | None | UndefinedType = Undefined,
                            spanning_tree_priority: int | None | UndefinedType = Undefined,
                            spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                            virtual_router_mac_address: str | None | UndefinedType = Undefined,
                            inband_mgmt_interface: str | None | UndefinedType = Undefined,
                            inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                            inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                            inband_mgmt_ip: str | None | UndefinedType = Undefined,
                            inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                            inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                            inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                            inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                            inband_mgmt_description: str | None | UndefinedType = Undefined,
                            inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                            inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                            inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                            inband_ztp: bool | None | UndefinedType = Undefined,
                            inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                            mpls_overlay_role: str | None | UndefinedType = Undefined,
                            overlay_address_families: list[str] | UndefinedType = Undefined,
                            mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                            bgp_cluster_id: str | None | UndefinedType = Undefined,
                            ptp: Ptp | UndefinedType = Undefined,
                            wan_role: str | None | UndefinedType = Undefined,
                            cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                            cv_pathfinder_region: str | None | UndefinedType = Undefined,
                            cv_pathfinder_site: str | None | UndefinedType = Undefined,
                            wan_ha: WanHa | UndefinedType = Undefined,
                            dps_mss_ipv4: str | None | UndefinedType = Undefined,
                            l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                            data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                            flow_tracker_type: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NodesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: The Node Name is used as "hostname".
                                downlink_pools:
                                   IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                                   with `uplink_ipv4_pool` set on the downlink switch.
                                id: Unique identifier used for IP addressing and other algorithms.
                                platform: Arista platform family.
                                mac_address: Leverage to document management interface mac address.
                                system_mac_address:
                                   System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                                   Set to the same MAC address as
                                   available in "show version" on the device.
                                   "system_mac_address" can also be set directly as a
                                   hostvar.
                                   If both are set, the setting under node type settings takes precedence.
                                serial_number:
                                   Set to the Serial Number of the device.
                                   Only used for documentation purpose in the fabric
                                   documentation and part of the structured_config.
                                   "serial_number" can also be set directly as a
                                   hostvar.
                                   If both are set, the setting under node type settings takes precedence.
                                rack: Rack that the switch is located in (only used in snmp_settings location).
                                mgmt_ip: Node management interface IPv4 address.
                                mgmt_gateway:
                                   This key sets the management gateway for the device. It takes precedence over the global
                                   `mgmt_gateway`.
                                ipv6_mgmt_ip: Node management interface IPv6 address.
                                ipv6_mgmt_gateway:
                                   This key sets the ipv6 management gateway for the device. It takes precedence over the global
                                   `ipv6_mgmt_gateway`.
                                mgmt_interface:
                                   Management Interface Name.
                                   Default -> platform_management_interface -> mgmt_interface ->
                                   "Management1".
                                link_tracking:
                                   This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                                   the upstream interfaces.
                                   Useful in EVPN multhoming designs.
                                lacp_port_id_range:
                                   This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                                   number of nodes in the "node_group".
                                   Unique LACP port-id ranges are recommended for EVPN Multihoming
                                   designs.
                                always_configure_ip_routing:
                                   Force configuration of "ip routing" even on L2 devices.
                                   Use this to retain behavior of AVD versions
                                   below 4.0.0.
                                raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                                structured_config: Custom structured config for eos_cli_config_gen.
                                uplink_type:
                                   Override the default `uplink_type` set at the `node_type_key` level.
                                   `uplink_type` must be "p2p" if
                                   `vtep` or `underlay_router` is true for the `node_type_key` definition.
                                uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                                uplink_interfaces:
                                   Local uplink interfaces.
                                   Each list item supports range syntax that can be expanded into a list of
                                   interfaces.
                                   If uplink_interfaces is not defined, platform-specific defaults (defined under
                                   default_interfaces) will be used instead.
                                   Please note that default_interfaces are not defined by
                                   default, you should define these yourself.
                                uplink_switch_interfaces: Interfaces located on uplink switches.
                                uplink_switches: uplink_switches
                                uplink_interface_speed:
                                   Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                                   (Uplink switch
                                   interface speed can be overridden with `uplink_switch_interface_speed`).
                                   Speed should be set in the
                                   format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                                uplink_switch_interface_speed:
                                   Set point-to-Point interface speed for the uplink switch interface only.
                                   Speed should be set in the
                                   format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                                uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                                max_uplink_switches:
                                   Maximum number of uplink switches.
                                   Changing this value may change IP Addressing on uplinks.
                                   Can be
                                   used to reserve IP space for future expansions.
                                max_parallel_uplinks:
                                   Number of parallel links towards uplink switches.
                                   Changing this value may change interface naming on
                                   uplinks (and corresponding downlinks).
                                   Can be used to reserve interfaces for future parallel
                                   uplinks.
                                uplink_bfd: Enable bfd on uplink interfaces.
                                uplink_native_vlan:
                                   Only applicable to switches with layer-2 port-channel uplinks.
                                   A suspended (disabled) vlan will be
                                   created in both ends of the link unless the vlan is defined under network services.
                                   By default the
                                   uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                                uplink_ptp: Enable PTP on all infrastructure links.
                                uplink_macsec: Enable MacSec on all uplinks.
                                uplink_port_channel_id:
                                   Only applicable for L2 switches with `uplink_type: port-channel`.
                                   By default the uplink Port-channel
                                   ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                                   For
                                   example:
                                     member ports [ Eth22, Eth23 ] -> ID 22
                                     member ports [ Eth11/1, Eth22/1 ] -> ID 111
                                   For
                                   MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                                   This
                                   option overrides the default behavior and statically sets the local Port-channel ID.
                                   Note! Make sure
                                   the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                                   Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                                   value.
                                uplink_switch_port_channel_id:
                                   Only applicable for L2 switches with `uplink_type: port-channel`.
                                   By default the uplink switch Port-
                                   channel ID will be set to the number of the first interface defined under
                                   `uplink_switch_interfaces`.
                                   For example:
                                     member ports [ Eth22, Eth23 ] -> ID 22
                                     member ports [
                                   Eth11/1, Eth22/1 ] -> ID 111
                                   For MLAG port-channels ID will be based on the lowest member interface
                                   on the first MLAG switch.
                                   This option overrides the default behavior and statically sets the Port-
                                   channel ID on the uplink switch.
                                   Note! Make sure the ID is unique and does not overlap with
                                   autogenerated Port-channel IDs in the Network Services.
                                   Note! For MLAG pairs the ID must be between
                                   1 and 2000 and both MLAG switches must have the same value.
                                uplink_structured_config:
                                   Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                                   When
                                   uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                                   for eos_cli_config_gen overrides the settings on the ethernet interface level.
                                   When uplink_type ==
                                   "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                                   eos_cli_config_gen overrides the settings on the port-channel interface level.
                                   "uplink_structured_config" is applied after "structured_config", so it can override
                                   "structured_config" defined on node-level.
                                   Note! The content of this dictionary is _not_ validated
                                   by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                                mlag_port_channel_structured_config:
                                   Custom structured config applied to MLAG peer link port-channel id.
                                   Added under
                                   port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                                   Overrides the settings on the
                                   port-channel interface level.
                                   "mlag_port_channel_structured_config" is applied after
                                   "structured_config", so it can override "structured_config" defined on node-level.
                                mlag_peer_vlan_structured_config:
                                   Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                                   Added under
                                   vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                                   Overrides the settings on the vlan
                                   interface level.
                                   "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                                   override "structured_config" defined on node-level.
                                mlag_peer_l3_vlan_structured_config:
                                   Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                                   Added under
                                   vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                                   Overrides the settings on the vlan
                                   interface level.
                                   "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                                   can override "structured_config" defined on node-level.
                                short_esi:
                                   short_esi only valid for l2leaf devices using port-channel uplink.
                                   Setting short_esi to "auto"
                                   generates the short_esi automatically using a hash of configuration elements.
                                   < 0000:0000:0000 |
                                   auto >.
                                isis_system_id_prefix: (4.4 hexadecimal).
                                isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                                is_type: is_type
                                node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                                loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                                loopback_ipv4_address:
                                   IPv4 address without mask for Loopback0.
                                   When set, it takes precedence over `loopback_ipv4_pool`.
                                   Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                                vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                                vtep_loopback_ipv4_address:
                                   IPv4 address without mask for VTEP-Loopback.
                                   When set, it takes precedence over
                                   `vtep_loopback_ipv4_pool`.
                                   Note: AVD does not check for validity of the IPv4 address and does not
                                   catch duplicates.
                                loopback_ipv4_offset:
                                   Offset all assigned loopback IP addresses.
                                   Required when the < loopback_ipv4_pool > is same for 2
                                   different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                                   For example, set the minimum
                                   offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                                loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                                loopback_ipv6_offset:
                                   Offset all assigned loopback IPv6 addresses.
                                   Required when the < loopback_ipv6_pool > is same for 2
                                   different node_types (like spine and l3leaf) to avoid overlapping IPs.
                                   For example, set the minimum
                                   offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                                vtep:
                                   Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                                   Overrides VTEP
                                   setting inherited from node_type_keys.
                                vtep_loopback: Set VXLAN source interface.
                                bgp_as:
                                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                   For asdot notation in
                                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                   number.
                                   Required with eBGP.
                                bgp_defaults: List of EOS commands to apply to BGP daemon.
                                evpn_role:
                                   Acting role in EVPN control plane.
                                   Default is set in node_type definition from node_type_keys.
                                evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                                evpn_services_l2_only:
                                   Possibility to prevent configuration of Tenant VRFs and SVIs.
                                   Override node definition
                                   "network_services_l3" from node_type_keys.
                                   This allows support for centralized routing.
                                filter:
                                   Filter L3 and L2 network services based on tenant and tags (and operation filter).
                                   If filter is not
                                   defined it will default to all.
                                igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                                evpn_gateway:
                                   Node is acting as EVPN Multi-Domain Gateway.
                                   New BGP peer-group is generated between EVPN GWs in
                                   different domains or between GWs and Route Servers.
                                   Name can be changed under
                                   "bgp_peer_groups.evpn_overlay_core" variable.
                                   L3 rechability for different EVPN GWs must be already
                                   in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                                   same Ansible inventory.
                                ipvpn_gateway:
                                   Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                                   this is "bgp_peer_groups.ipvpn_gateway_peers".
                                   L3 Reachability is required for this to work, the
                                   preferred method to establish underlay connectivity is to use core_interfaces.
                                mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                                mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                                mlag_ibgp_origin_incomplete:
                                   Set origin of routes received from MLAG iBGP peer to incomplete.
                                   The purpose is to optimize routing
                                   for leaf loopbacks from spine perspective and
                                   avoid suboptimal routing via peerlink for control
                                   plane traffic.
                                mlag_interfaces:
                                   Each list item supports range syntax that can be expanded into a list of interfaces.
                                   Required when
                                   MLAG leafs are present in the topology.
                                mlag_interfaces_speed:
                                   Set MLAG interface speed.
                                   Speed should be set in the format `<interface_speed>` or `forced
                                   <interface_speed>` or `auto <interface_speed>`.
                                mlag_peer_l3_vlan:
                                   Underlay L3 peering SVI interface id.
                                   If set to 0 or the same vlan as mlag_peer_vlan, the
                                   mlag_peer_vlan will be used for L3 peering.
                                mlag_peer_l3_ipv4_pool:
                                   IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                                   Required when
                                   MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                                mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                                mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                                mlag_peer_address_family:
                                   IP address family used to establish MLAG Peer Link (control link).
                                   `ipv6` requires EOS version
                                   4.31.1F or higher.
                                   Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                                   (ex. `mlag_peer_l3_vlan` set to 4094).
                                mlag_peer_ipv4_pool:
                                   IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                                   Required
                                   for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                                mlag_peer_ipv6_pool:
                                   IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                                   Required
                                   for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                                mlag_port_channel_id:
                                   If not set, the mlag port-channel id is generated based on the digits of the first interface present
                                   in 'mlag_interfaces'.
                                   Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                                   999999 > for EOS >= 4.25.0F.
                                mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                                spanning_tree_mode: spanning_tree_mode
                                spanning_tree_priority:
                                   Spanning-tree priority configured for the selected mode.
                                   For `rapid-pvst` the priority can also be
                                   set per VLAN under network services.
                                spanning_tree_root_super: spanning_tree_root_super
                                virtual_router_mac_address: Virtual router mac address for anycast gateway.
                                inband_mgmt_interface:
                                   Pointer to interface used for inband management.
                                   All configuration must be done using other data
                                   models like network services or structured_config.
                                   'inband_mgmt_interface' is only used to refer to
                                   this interface as source in various management protocol settings (future feature).

                                   On L2 switches,
                                   this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                                inband_mgmt_vlan:
                                   VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                                   uplinks).
                                   When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                                   switch as well as all 'uplink_switches'.
                                   When using 'inband_mgmt_ip' the VLAN and SVI will only be
                                   created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                                   created using network services data models.
                                inband_mgmt_subnet:
                                   Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                                   as uplinks).
                                   Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                                   ARP.
                                   This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                                   SVI IP address will be assigned as follows:
                                   virtual-router: <subnet> + 1
                                   l3leaf A      : <subnet> +
                                   2 (same IP on all l3leaf A)
                                   l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                                   l2leafs       :
                                   <subnet> + 3 + <l2leaf id>
                                   GW on l2leafs : <subnet> + 1
                                   Assign range larger than total l2leafs + 5
                                   Setting is ignored if 'inband_mgmt_ip' is set.

                                   This setting is applicable to L2 switches (switches
                                   using port-channel trunks as uplinks).
                                inband_mgmt_ip:
                                   IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                                   This overrides
                                   'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                                   If this is set the
                                   VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                                   The VLAN and SVI on
                                   the parent switches must be created using network services data models.

                                   This setting is applicable
                                   to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_gateway:
                                   Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                                   is derived from 'inband_mgmt_subnet' if set.

                                   This setting is applicable to L2 switches (switches
                                   using port-channel trunks as uplinks).
                                inband_mgmt_ipv6_address:
                                   IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                                   This overrides
                                   'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                                   If this
                                   is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                                   The VLAN
                                   and SVI on the parent switches must be created using network services data models.

                                   This setting is
                                   applicable to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_ipv6_subnet:
                                   Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                                   as uplinks).
                                   Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                                   on ARP.
                                   This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                                   extension.
                                   SVI IP address will be assigned as follows:
                                   virtual-router: <subnet> + 1
                                   l3leaf A      :
                                   <subnet> + 2 (same IP on all l3leaf A)
                                   l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                                   l2leafs       : <subnet> + 3 + <l2leaf id>
                                   GW on l2leafs : <subnet> + 1
                                   Assign range larger than
                                   total l2leafs + 5

                                   Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                                   This setting is
                                   applicable to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_ipv6_gateway:
                                   Default gateway configured in the 'inband_mgmt_vrf'.
                                   Used when `inband_mgmt_ipv6_address` is set.
                                   Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                                   This setting is
                                   applicable to L2 switches (switches using port-channel trunks as uplinks).
                                inband_mgmt_description:
                                   Description configured on the Inband Management SVI.

                                   This setting is only applied on the devices
                                   where it is set, it does not automatically affect any parent/child devices configuration, so it must
                                   be set on each applicable node/node-group/node-type as needed.
                                inband_mgmt_vlan_name:
                                   Name configured on the Inband Management VLAN.
                                   This setting is only applied on the devices where it
                                   is set, it does not automatically affect any parent/child devices configuration, so it must be set
                                   on each applicable node/node-group/node-type as needed.
                                inband_mgmt_vrf:
                                   VRF configured on the Inband Management Interface.
                                   The VRF is created if not already created by
                                   other means.
                                   This setting is only applied on the devices where it is set, it does not automatically
                                   affect any parent/child devices configuration, so it must be set on each applicable node/node-
                                   group/node-type as needed.
                                inband_mgmt_mtu:
                                   MTU configured on the Inband Management Interface.
                                   This setting is only applied on the devices where
                                   it is set, it does not automatically affect any parent/child devices configuration, so it must be
                                   set on each applicable node/node-group/node-type as needed.
                                inband_ztp:
                                   Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                                   inband.
                                   This setting also requires that the `inband_mgmt_vlan` is set for the node.
                                inband_ztp_lacp_fallback_delay:
                                   Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                                   ZTP node.
                                   This setting also requires that `inband_ztp` is set for the node.
                                mpls_overlay_role:
                                   Set the default mpls overlay role.
                                   Acting role in overlay control plane.
                                overlay_address_families: Set the default overlay address families.
                                mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                                bgp_cluster_id: Set BGP cluster id.
                                ptp: ptp
                                wan_role:
                                   Override the default WAN role.

                                   This is used both for AutoVPN and Pathfinder designs.
                                   That means if
                                   `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                                   `server` indicates that the
                                   router is a route-reflector.

                                   Only supported if `overlay_routing_protocol` is set to `ibgp`.
                                cv_pathfinder_transit_mode:
                                   Configure the transit mode for a WAN client for CV Pathfinder designs
                                   only when the `wan_mode` root
                                   key is set to `cv_pathfinder`.

                                   'zone' is currently not supported.
                                cv_pathfinder_region:
                                   The CV Pathfinder region name.
                                   This key is required for WAN routers but optional for pathfinders.
                                   The region name must be defined under 'cv_pathfinder_regions'.
                                cv_pathfinder_site:
                                   The CV Pathfinder site name.
                                   This key is required for WAN routers but optional for pathfinders.
                                   For
                                   WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                                   relevant region under 'cv_pathfinder_regions'.
                                   For pathfinders without `cv_pathfinder_region` set,
                                   the site must be defined under `cv_pathfinder_global_sites`.
                                wan_ha:
                                   PREVIEW: This key is currently not supported

                                   The key is supported only if `wan_mode` == `cv-
                                   pathfinder`.
                                   AutoVPN support is still to be determined.

                                   Maximum 2 devices supported by group for
                                   HA.
                                dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                                l3_interfaces:
                                   L3 Interfaces to configure on the node.
                                   Used to define the node for WAN interfaces when
                                   `wan_carrier` is set.
                                data_plane_cpu_allocation_max:
                                   Set the maximum number of CPU used for the data plane.
                                   This setting is useful on virtual Route
                                   Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                                flow_tracker_type:
                                   Set the flow tracker type.
                                   Override the `default_flow_tracker_type`` set at the `node_type_key`
                                   level.
                                   `default_flow_tracker_type` default value is `sampled`.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Nodes(AvdCollection[str, NodesItem]):
                        _primary_key: ClassVar[str] = "name"

                    Nodes._item_type = NodesItem

                    class LinkTracking(AvdModel):
                        class GroupsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "name": {"type": str},
                                "recovery_delay": {"type": int},
                                "links_minimum": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            name: str | None
                            """Tracking group name."""
                            recovery_delay: int | None
                            """default -> platform_settings_mlag_reload_delay -> 300."""
                            links_minimum: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                recovery_delay: int | None | UndefinedType = Undefined,
                                links_minimum: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                GroupsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    name: Tracking group name.
                                    recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                    links_minimum: links_minimum

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "groups": {
                                "type": list,
                                "items": GroupsItem,
                                "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                            },
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        groups: list[GroupsItem]
                        """
                        Link Tracking Groups.
                        By default a single group named "LT_GROUP1" is defined with default values.
                        Any groups defined under "groups" will replace the default.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            groups: list[GroupsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                groups:
                                   Link Tracking Groups.
                                   By default a single group named "LT_GROUP1" is defined with default values.
                                   Any groups defined under "groups" will replace the default.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LacpPortIdRange(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "size": {"type": int, "default": 128},
                            "offset": {"type": int, "default": 0},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        size: int | None
                        """Recommended size > = number of ports in the switch."""
                        offset: int | None
                        """
                        Offset is used to avoid overlapping port-id ranges of different switches.
                        Useful when a "connected-
                        endpoint" is connected to switches in different "node_groups".
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            offset: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LacpPortIdRange.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                size: Recommended size > = number of ports in the switch.
                                offset:
                                   Offset is used to avoid overlapping port-id ranges of different switches.
                                   Useful when a "connected-
                                   endpoint" is connected to switches in different "node_groups".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    class UplinkPtp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enable: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkPtp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enable: enable

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UplinkMacsec(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        profile: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkMacsec.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: profile

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                        pass

                    class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class Filter(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "tenants": {"type": list, "items": str, "default": ["all"]},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "always_include_vrfs_in_tenants": {"type": list, "items": str},
                            "only_vlans_in_use": {"type": bool, "default": False},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        tenants: list[str]
                        """
                        Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                        Tenants (default).
                        This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                        """
                        tags: list[str]
                        """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                        allow_vrfs: list[str]
                        """
                        Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                        (default).
                        This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                        """
                        deny_vrfs: list[str]
                        """
                        Prevent configuration of Network Services defined under these VRFs.
                        This list prevents the given
                        VRFs to be included by any other filtering mechanism.
                        """
                        always_include_vrfs_in_tenants: list[str]
                        """
                        List of tenants where VRFs will be configured even if VLANs are not included in tags.
                        Useful for L3
                        "border" leaf.
                        """
                        only_vlans_in_use: bool | None
                        """
                        Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                        Note! This
                        feature only considers configuration managed by eos_designs.
                        This excludes structured_config,
                        custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            tenants: list[str] | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            allow_vrfs: list[str] | UndefinedType = Undefined,
                            deny_vrfs: list[str] | UndefinedType = Undefined,
                            always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                            only_vlans_in_use: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.

                            Args:
                            -----
                                _custom_data: _custom_data
                                tenants:
                                   Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                   Tenants (default).
                                   This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                allow_vrfs:
                                   Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                   (default).
                                   This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                deny_vrfs:
                                   Prevent configuration of Network Services defined under these VRFs.
                                   This list prevents the given
                                   VRFs to be included by any other filtering mechanism.
                                always_include_vrfs_in_tenants:
                                   List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                   Useful for L3
                                   "border" leaf.
                                only_vlans_in_use:
                                   Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                   Note! This
                                   feature only considers configuration managed by eos_designs.
                                   This excludes structured_config,
                                   custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            hostname: str | None
                            """Hostname of remote EVPN GW server."""
                            ip_address: str | None
                            """Peering IP of remote Route Server."""
                            bgp_as: str | None
                            """
                            Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                            interpreted as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                bgp_as: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote EVPN GW server.
                                    ip_address: Peering IP of remote Route Server.
                                    bgp_as:
                                       Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                       interpreted as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL2(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL2.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "inter_domain": {"type": bool, "default": True},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            inter_domain: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                inter_domain: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL3.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    inter_domain: inter_domain

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                            "evpn_l2": {"type": EvpnL2},
                            "evpn_l3": {"type": EvpnL3},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_peers: list[RemotePeersItem]
                        """
                        Define remote peers of the EVPN VXLAN Gateway.
                        If the hostname can be found in the inventory,
                        ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                        If the
                        peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                        """
                        evpn_l2: EvpnL2
                        """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                        evpn_l3: EvpnL3
                        """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            evpn_l2: EvpnL2 | UndefinedType = Undefined,
                            evpn_l3: EvpnL3 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_peers:
                                   Define remote peers of the EVPN VXLAN Gateway.
                                   If the hostname can be found in the inventory,
                                   ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                   If the
                                   peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                            _custom_data: dict[str, Any]
                            hostname: str
                            """Hostname of remote IPVPN Peer."""
                            ip_address: str
                            """Peering IP of remote IPVPN Peer."""
                            bgp_as: str
                            """
                            Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For
                            asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                            as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | UndefinedType = Undefined,
                                ip_address: str | UndefinedType = Undefined,
                                bgp_as: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote IPVPN Peer.
                                    ip_address: Peering IP of remote IPVPN Peer.
                                    bgp_as:
                                       Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For
                                       asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                       as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_domain_id": {"type": str, "default": "65535:1"},
                            "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                            "enable_d_path": {"type": bool, "default": True},
                            "maximum_routes": {"type": int, "default": 0},
                            "local_as": {"type": str, "default": "none"},
                            "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        evpn_domain_id: str | None
                        """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                        ipvpn_domain_id: str | None
                        """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                        enable_d_path: bool | None
                        """Enable D-path for use with BGP bestpath selection algorithm."""
                        maximum_routes: int | None
                        """Maximum routes to accept from IPVPN remote peers."""
                        local_as: str | None
                        """
                        Local BGP AS applied to peering with IPVPN remote peers.
                        BGP AS <1-4294967295> or AS number in asdot
                        notation "<1-65535>.<0-65535>".
                        For asdot notation in YAML inputs, the value must be put in quotes,
                        to prevent it from being interpreted as a float number.
                        """
                        address_families: list[str]
                        """IPVPN address families to enable for remote peers."""
                        remote_peers: list[RemotePeersItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            evpn_domain_id: str | None | UndefinedType = Undefined,
                            ipvpn_domain_id: str | None | UndefinedType = Undefined,
                            enable_d_path: bool | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            address_families: list[str] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                local_as:
                                   Local BGP AS applied to peering with IPVPN remote peers.
                                   BGP AS <1-4294967295> or AS number in asdot
                                   notation "<1-65535>.<0-65535>".
                                   For asdot notation in YAML inputs, the value must be put in quotes,
                                   to prevent it from being interpreted as a float number.
                                address_families: IPVPN address families to enable for remote peers.
                                remote_peers: remote_peers

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        class Dscp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            general_messages: int | None
                            event_messages: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                general_messages: int | None | UndefinedType = Undefined,
                                event_messages: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dscp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    general_messages: general_messages
                                    event_messages: event_messages

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Monitor(AvdModel):
                            class Threshold(AvdModel):
                                class Drop(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int},
                                        "mean_path_delay": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Drop.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "offset_from_master": {"type": int, "default": 250},
                                    "mean_path_delay": {"type": int, "default": 1500},
                                    "drop": {"type": Drop},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                offset_from_master: int | None
                                mean_path_delay: int | None
                                drop: Drop

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    offset_from_master: int | None | UndefinedType = Undefined,
                                    mean_path_delay: int | None | UndefinedType = Undefined,
                                    drop: Drop | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Threshold.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        offset_from_master: offset_from_master
                                        mean_path_delay: mean_path_delay
                                        drop: drop

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class MissingMessage(AvdModel):
                                class Intervals(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "announce": {"type": int},
                                        "follow_up": {"type": int},
                                        "sync": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    announce: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Intervals.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            announce: announce
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class SequenceIds(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "enabled": {"type": bool, "default": True},
                                        "announce": {"type": int, "default": 3},
                                        "delay_resp": {"type": int, "default": 3},
                                        "follow_up": {"type": int, "default": 3},
                                        "sync": {"type": int, "default": 3},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    enabled: bool | None
                                    announce: int | None
                                    delay_resp: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        enabled: bool | None | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        delay_resp: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        SequenceIds.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            enabled: enabled
                                            announce: announce
                                            delay_resp: delay_resp
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "intervals": {"type": Intervals},
                                    "sequence_ids": {"type": SequenceIds},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                intervals: Intervals
                                sequence_ids: SequenceIds

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    intervals: Intervals | UndefinedType = Undefined,
                                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MissingMessage.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        intervals: intervals
                                        sequence_ids: sequence_ids

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "threshold": {"type": Threshold},
                                "missing_message": {"type": MissingMessage},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            threshold: Threshold
                            missing_message: MissingMessage

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                threshold: Threshold | UndefinedType = Undefined,
                                missing_message: MissingMessage | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Monitor.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    threshold: threshold
                                    missing_message: missing_message

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                            "mlag": {"type": bool, "default": False},
                            "domain": {"type": int, "default": 127},
                            "priority1": {"type": int},
                            "priority2": {"type": int},
                            "auto_clock_identity": {"type": bool, "default": True},
                            "clock_identity_prefix": {"type": str},
                            "clock_identity": {"type": str},
                            "source_ip": {"type": str},
                            "mode": {"type": str, "default": "boundary"},
                            "mode_one_step": {"type": bool, "default": False},
                            "ttl": {"type": int},
                            "forward_unicast": {"type": bool, "default": False},
                            "dscp": {"type": Dscp},
                            "monitor": {"type": Monitor},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """
                        mlag: bool | None
                        """
                        Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                        configured on the MLAG peer-link port-channel.
                        """
                        domain: int | None
                        priority1: int | None
                        """default -> automatically set based on node_type."""
                        priority2: int | None
                        """default -> (node_id modulus 256)."""
                        auto_clock_identity: bool | None
                        """
                        If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                        default EOS behaviour, simply disable the automatic PTP clock identity.
                        default ->
                        (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                        HEX).
                        """
                        clock_identity_prefix: str | None
                        """
                        PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                        By default the 3-byte prefix is "00:1C:73".
                        This
                        can be overridden if auto_clock_identity is set to true (which is the default).
                        """
                        clock_identity: str | None
                        """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                        source_ip: str | None
                        """
                        By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                        relevant SVI, which is the recommended behaviour.
                        This can be set manually if required, for example,
                        to a value of "10.1.2.3".
                        """
                        mode: str | None
                        mode_one_step: bool | None
                        ttl: int | None
                        forward_unicast: bool | None
                        """Enable PTP unicast forwarding."""
                        dscp: Dscp
                        monitor: Monitor

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            domain: int | None | UndefinedType = Undefined,
                            priority1: int | None | UndefinedType = Undefined,
                            priority2: int | None | UndefinedType = Undefined,
                            auto_clock_identity: bool | None | UndefinedType = Undefined,
                            clock_identity_prefix: str | None | UndefinedType = Undefined,
                            clock_identity: str | None | UndefinedType = Undefined,
                            source_ip: str | None | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            mode_one_step: bool | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            forward_unicast: bool | None | UndefinedType = Undefined,
                            dscp: Dscp | UndefinedType = Undefined,
                            monitor: Monitor | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"
                                mlag:
                                   Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                   configured on the MLAG peer-link port-channel.
                                domain: domain
                                priority1: default -> automatically set based on node_type.
                                priority2: default -> (node_id modulus 256).
                                auto_clock_identity:
                                   If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                   default EOS behaviour, simply disable the automatic PTP clock identity.
                                   default ->
                                   (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                   HEX).
                                clock_identity_prefix:
                                   PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                   By default the 3-byte prefix is "00:1C:73".
                                   This
                                   can be overridden if auto_clock_identity is set to true (which is the default).
                                clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                source_ip:
                                   By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                   relevant SVI, which is the recommended behaviour.
                                   This can be set manually if required, for example,
                                   to a value of "10.1.2.3".
                                mode: mode
                                mode_one_step: mode_one_step
                                ttl: ttl
                                forward_unicast: Enable PTP unicast forwarding.
                                dscp: dscp
                                monitor: monitor

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class WanHa(AvdModel):
                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": True},
                            "ipsec": {"type": bool, "default": True},
                            "mtu": {"type": int, "default": 9194},
                            "ha_interfaces": {"type": list, "items": str},
                            "ha_ipv4_pool": {"type": str},
                            "max_ha_interfaces": {"type": int},
                            "port_channel_id": {"type": int},
                            "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                            "flow_tracking": {"type": FlowTracking},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                        ipsec: bool | None
                        """Enable / Disable IPsec over HA path-group when HA is enabled."""
                        mtu: int | None
                        """Set MTU on WAN HA interfaces."""
                        ha_interfaces: list[str]
                        """
                        Local WAN HA interfaces
                        Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                        Can be used to filter uplink interfaces when there are multiple uplinks.
                        Limitations:
                          Either all
                        interfaces must be uplinks or all interfaces must not be uplinks.
                          Only one interface is supported
                        for non uplinks.
                        """
                        ha_ipv4_pool: str | None
                        """
                        IP address pool used for WAN HA connectivity.
                        IP is derived from the node ID.
                        Not used for uplink
                        interfaces.
                        """
                        max_ha_interfaces: int | None
                        """
                        Number of parallel links towards HA switches.
                        Can be used to reserve IP addresses for future
                        parallel HA links.
                        """
                        port_channel_id: int | None
                        """Port-channel ID to use for direct HA."""
                        use_port_channel_for_direct_ha: bool | None
                        """
                        Enable or disable using a port-channel interface for direct HA when there is only one interface.
                        This feature was introduced in EOS 4.33.0F.
                        """
                        flow_tracking: FlowTracking
                        """
                        Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                        setting.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ipsec: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ha_interfaces: list[str] | UndefinedType = Undefined,
                            ha_ipv4_pool: str | None | UndefinedType = Undefined,
                            max_ha_interfaces: int | None | UndefinedType = Undefined,
                            port_channel_id: int | None | UndefinedType = Undefined,
                            use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WanHa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                mtu: Set MTU on WAN HA interfaces.
                                ha_interfaces:
                                   Local WAN HA interfaces
                                   Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                   Can be used to filter uplink interfaces when there are multiple uplinks.
                                   Limitations:
                                     Either all
                                   interfaces must be uplinks or all interfaces must not be uplinks.
                                     Only one interface is supported
                                   for non uplinks.
                                ha_ipv4_pool:
                                   IP address pool used for WAN HA connectivity.
                                   IP is derived from the node ID.
                                   Not used for uplink
                                   interfaces.
                                max_ha_interfaces:
                                   Number of parallel links towards HA switches.
                                   Can be used to reserve IP addresses for future
                                   parallel HA links.
                                port_channel_id: Port-channel ID to use for direct HA.
                                use_port_channel_for_direct_ha:
                                   Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                   This feature was introduced in EOS 4.33.0F.
                                flow_tracking:
                                   Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                   setting.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Bgp(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "peer_as": {"type": str},
                                "ipv4_prefix_list_in": {"type": str},
                                "ipv4_prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                            _custom_data: dict[str, Any]
                            peer_as: str
                            """
                            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in
                            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                            number.
                            """
                            ipv4_prefix_list_in: str | None
                            """
                            Prefix List Name. Accept routes for only these prefixes from the peer.
                            Required for wan interfaces.
                            """
                            ipv4_prefix_list_out: str | None
                            """
                            Prefix List Name. Advertise routes for only these prefixes.
                            If not specified, nothing would be
                            advertised.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                peer_as: str | UndefinedType = Undefined,
                                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    peer_as:
                                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in
                                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                       number.
                                    ipv4_prefix_list_in:
                                       Prefix List Name. Accept routes for only these prefixes from the peer.
                                       Required for wan interfaces.
                                    ipv4_prefix_list_out:
                                       Prefix List Name. Advertise routes for only these prefixes.
                                       If not specified, nothing would be
                                       advertised.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StaticRoutesItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                            _custom_data: dict[str, Any]
                            prefix: str
                            """IPv4_network/Mask."""

                            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                                """
                                StaticRoutesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    prefix: IPv4_network/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class CvPathfinderInternetExit(AvdModel):
                            class PoliciesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                _custom_data: dict[str, Any]
                                name: str
                                """Internet-exit policy name."""
                                tunnel_interface_numbers: str | None
                                """
                                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                interface.
                                Examples: '1-3' or '100,200,300'
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | UndefinedType = Undefined,
                                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PoliciesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Internet-exit policy name.
                                        tunnel_interface_numbers:
                                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                           interface.
                                           Examples: '1-3' or '100,200,300'

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Policies(AvdCollection[str, PoliciesItem]):
                                _primary_key: ClassVar[str] = "name"

                            Policies._item_type = PoliciesItem

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            policies: Policies
                            """List of Internet-exit policies using this interface as exit."""

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                            ) -> None:
                                """
                                CvPathfinderInternetExit.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    policies: List of Internet-exit policies using this interface as exit.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "profile": {"type": str},
                            "name": {"type": str},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "dhcp_ip": {"type": str},
                            "public_ip": {"type": str},
                            "encapsulation_dot1q_vlan": {"type": int},
                            "dhcp_accept_default_route": {"type": bool, "default": True},
                            "enabled": {"type": bool, "default": True},
                            "speed": {"type": str},
                            "peer": {"type": str},
                            "peer_interface": {"type": str},
                            "peer_ip": {"type": str},
                            "bgp": {"type": Bgp},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "static_routes": {"type": list, "items": StaticRoutesItem},
                            "qos_profile": {"type": str},
                            "wan_carrier": {"type": str},
                            "wan_circuit_id": {"type": str},
                            "connected_to_pathfinder": {"type": bool, "default": True},
                            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                            "raw_eos_cli": {"type": str},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        profile: str | None
                        """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                        name: str
                        """
                        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                        For a
                        subinterface, the parent physical interface is automatically created.
                        """
                        description: str | None
                        """
                        Interface description.
                        If not set a default description will be configured with '[<peer>[
                        <peer_interface>]]'.
                        """
                        ip_address: str | None
                        """Node IPv4 address/Mask or 'dhcp'."""
                        dhcp_ip: str | None
                        """
                        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                        IPv4 address
                        (without mask) to be allocated on the interface if known.
                        This is not rendered in the configuration
                        but can be used for substitution of 'interface_ip' in the Access-list
                        set under `ipv4_acl_in` and
                        `ipv4_acl_out`.
                        """
                        public_ip: str | None
                        """
                        Node IPv4 address (no mask).

                        This is used to get the public IP (if known) when the device is behind
                        NAT.
                        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                        with the following preference:
                          `wan_route_servers.path_groups.interfaces.ip_address`
                              ->
                        `l3_interfaces.public_ip`
                                  -> `l3_interfaces.ip_address`

                        The determined Public IP is used
                        by WAN routers when peering with this interface.
                        """
                        encapsulation_dot1q_vlan: int | None
                        """
                        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        dhcp_accept_default_route: bool | None
                        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                        enabled: bool | None
                        """Enable or Shutdown the interface."""
                        speed: str | None
                        """
                        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                        <interface_speed>`.
                        """
                        peer: str | None
                        """The peer device name. Used for description and documentation."""
                        peer_interface: str | None
                        """The peer device interface. Used for description and documentation."""
                        peer_ip: str | None
                        """
                        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                        and `ip` is an IP address.
                        """
                        bgp: Bgp
                        """Enforce IPv4 BGP peering for the peer"""
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        Required
                        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                        `wan_carriers`.
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        """
                        static_routes: list[StaticRoutesItem]
                        """Configure IPv4 static routes pointing to `peer_ip`."""
                        qos_profile: str | None
                        """QOS service profile."""
                        wan_carrier: str | None
                        """
                        The WAN carrier this interface is connected to.
                        This is used to infer the path-groups in which this
                        interface should be configured.
                        Unless the carrier is marked as 'trusted' under `wan_carriers`,
                        `ipv4_acl_in` is also required on all WAN interfaces.
                        """
                        wan_circuit_id: str | None
                        """
                        The WAN circuit ID for this interface.
                        This is not rendered in the configuration but used for WAN
                        designs.
                        """
                        connected_to_pathfinder: bool | None
                        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                        cv_pathfinder_internet_exit: CvPathfinderInternetExit
                        """PREVIEW: This key is in preview mode"""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the interface in the final EOS configuration."""
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config for the Ethernet interface."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            dhcp_ip: str | None | UndefinedType = Undefined,
                            public_ip: str | None | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            speed: str | None | UndefinedType = Undefined,
                            peer: str | None | UndefinedType = Undefined,
                            peer_interface: str | None | UndefinedType = Undefined,
                            peer_ip: str | None | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                            qos_profile: str | None | UndefinedType = Undefined,
                            wan_carrier: str | None | UndefinedType = Undefined,
                            wan_circuit_id: str | None | UndefinedType = Undefined,
                            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                name:
                                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                   For a
                                   subinterface, the parent physical interface is automatically created.
                                description:
                                   Interface description.
                                   If not set a default description will be configured with '[<peer>[
                                   <peer_interface>]]'.
                                ip_address: Node IPv4 address/Mask or 'dhcp'.
                                dhcp_ip:
                                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                   IPv4 address
                                   (without mask) to be allocated on the interface if known.
                                   This is not rendered in the configuration
                                   but can be used for substitution of 'interface_ip' in the Access-list
                                   set under `ipv4_acl_in` and
                                   `ipv4_acl_out`.
                                public_ip:
                                   Node IPv4 address (no mask).

                                   This is used to get the public IP (if known) when the device is behind
                                   NAT.
                                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                   with the following preference:
                                     `wan_route_servers.path_groups.interfaces.ip_address`
                                         ->
                                   `l3_interfaces.public_ip`
                                             -> `l3_interfaces.ip_address`

                                   The determined Public IP is used
                                   by WAN routers when peering with this interface.
                                encapsulation_dot1q_vlan:
                                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                enabled: Enable or Shutdown the interface.
                                speed:
                                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                   <interface_speed>`.
                                peer: The peer device name. Used for description and documentation.
                                peer_interface: The peer device interface. Used for description and documentation.
                                peer_ip:
                                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                   and `ip` is an IP address.
                                bgp: Enforce IPv4 BGP peering for the peer
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                   Required
                                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                   `wan_carriers`.
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                qos_profile: QOS service profile.
                                wan_carrier:
                                   The WAN carrier this interface is connected to.
                                   This is used to infer the path-groups in which this
                                   interface should be configured.
                                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                   `ipv4_acl_in` is also required on all WAN interfaces.
                                wan_circuit_id:
                                   The WAN circuit ID for this interface.
                                   This is not rendered in the configuration but used for WAN
                                   designs.
                                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config for the Ethernet interface.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                        _primary_key: ClassVar[str] = "name"

                    L3Interfaces._item_type = L3InterfacesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "group": {"type": str},
                        "nodes": {"type": Nodes},
                        "id": {"type": int},
                        "platform": {"type": str},
                        "mac_address": {"type": str},
                        "system_mac_address": {"type": str},
                        "serial_number": {"type": str},
                        "rack": {"type": str},
                        "mgmt_ip": {"type": str},
                        "mgmt_gateway": {"type": str},
                        "ipv6_mgmt_ip": {"type": str},
                        "ipv6_mgmt_gateway": {"type": str},
                        "mgmt_interface": {"type": str},
                        "link_tracking": {"type": LinkTracking},
                        "lacp_port_id_range": {"type": LacpPortIdRange},
                        "always_configure_ip_routing": {"type": bool, "default": False},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                        "uplink_type": {"type": str, "default": "p2p"},
                        "uplink_ipv4_pool": {"type": str},
                        "uplink_interfaces": {"type": list, "items": str},
                        "uplink_switch_interfaces": {"type": list, "items": str},
                        "uplink_switches": {"type": list, "items": str},
                        "uplink_interface_speed": {"type": str},
                        "uplink_switch_interface_speed": {"type": str},
                        "uplink_mtu": {"type": int},
                        "max_uplink_switches": {"type": int},
                        "max_parallel_uplinks": {"type": int},
                        "uplink_bfd": {"type": bool, "default": False},
                        "uplink_native_vlan": {"type": int},
                        "uplink_ptp": {"type": UplinkPtp},
                        "uplink_macsec": {"type": UplinkMacsec},
                        "uplink_port_channel_id": {"type": int},
                        "uplink_switch_port_channel_id": {"type": int},
                        "uplink_structured_config": {"type": dict},
                        "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                        "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                        "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                        "short_esi": {"type": str},
                        "isis_system_id_prefix": {"type": str},
                        "isis_maximum_paths": {"type": int},
                        "is_type": {"type": str, "default": "level-2"},
                        "node_sid_base": {"type": int, "default": 0},
                        "loopback_ipv4_pool": {"type": str},
                        "loopback_ipv4_address": {"type": str},
                        "vtep_loopback_ipv4_pool": {"type": str},
                        "vtep_loopback_ipv4_address": {"type": str},
                        "loopback_ipv4_offset": {"type": int, "default": 0},
                        "loopback_ipv6_pool": {"type": str},
                        "loopback_ipv6_offset": {"type": int, "default": 0},
                        "vtep": {"type": bool},
                        "vtep_loopback": {"type": str},
                        "bgp_as": {"type": str},
                        "bgp_defaults": {"type": list, "items": str},
                        "evpn_role": {"type": str},
                        "evpn_route_servers": {"type": list, "items": str},
                        "evpn_services_l2_only": {"type": bool, "default": False},
                        "filter": {"type": Filter},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "evpn_gateway": {"type": EvpnGateway},
                        "ipvpn_gateway": {"type": IpvpnGateway},
                        "mlag": {"type": bool, "default": True},
                        "mlag_dual_primary_detection": {"type": bool, "default": False},
                        "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                        "mlag_interfaces": {"type": list, "items": str},
                        "mlag_interfaces_speed": {"type": str},
                        "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                        "mlag_peer_l3_ipv4_pool": {"type": str},
                        "mlag_peer_vlan": {"type": int, "default": 4094},
                        "mlag_peer_link_allowed_vlans": {"type": str},
                        "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                        "mlag_peer_ipv4_pool": {"type": str},
                        "mlag_peer_ipv6_pool": {"type": str},
                        "mlag_port_channel_id": {"type": int},
                        "mlag_domain_id": {"type": str},
                        "spanning_tree_mode": {"type": str},
                        "spanning_tree_priority": {"type": int, "default": 32768},
                        "spanning_tree_root_super": {"type": bool, "default": False},
                        "virtual_router_mac_address": {"type": str},
                        "inband_mgmt_interface": {"type": str},
                        "inband_mgmt_vlan": {"type": int, "default": 4092},
                        "inband_mgmt_subnet": {"type": str},
                        "inband_mgmt_ip": {"type": str},
                        "inband_mgmt_gateway": {"type": str},
                        "inband_mgmt_ipv6_address": {"type": str},
                        "inband_mgmt_ipv6_subnet": {"type": str},
                        "inband_mgmt_ipv6_gateway": {"type": str},
                        "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vrf": {"type": str, "default": "default"},
                        "inband_mgmt_mtu": {"type": int, "default": 1500},
                        "inband_ztp": {"type": bool, "default": False},
                        "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                        "mpls_overlay_role": {"type": str},
                        "overlay_address_families": {"type": list, "items": str},
                        "mpls_route_reflectors": {"type": list, "items": str},
                        "bgp_cluster_id": {"type": str},
                        "ptp": {"type": Ptp},
                        "wan_role": {"type": str},
                        "cv_pathfinder_transit_mode": {"type": str},
                        "cv_pathfinder_region": {"type": str},
                        "cv_pathfinder_site": {"type": str},
                        "wan_ha": {"type": WanHa},
                        "dps_mss_ipv4": {"type": str, "default": "auto"},
                        "l3_interfaces": {"type": L3Interfaces},
                        "data_plane_cpu_allocation_max": {"type": int},
                        "flow_tracker_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "group")
                    _custom_data: dict[str, Any]
                    group: str
                    """
                    The Node Group Name is used for MLAG domain unless set with 'mlag_domain_id'.
                    The Node Group Name is
                    also used for peer description on downstream switches' uplinks.
                    """
                    nodes: Nodes
                    """Define variables per node."""
                    id: int | None
                    """Unique identifier used for IP addressing and other algorithms."""
                    platform: str | None
                    """Arista platform family."""
                    mac_address: str | None
                    """Leverage to document management interface mac address."""
                    system_mac_address: str | None
                    """
                    System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                    Set to the same MAC address as
                    available in "show version" on the device.
                    "system_mac_address" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    serial_number: str | None
                    """
                    Set to the Serial Number of the device.
                    Only used for documentation purpose in the fabric
                    documentation and part of the structured_config.
                    "serial_number" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    rack: str | None
                    """Rack that the switch is located in (only used in snmp_settings location)."""
                    mgmt_ip: str | None
                    """Node management interface IPv4 address."""
                    mgmt_gateway: str | None
                    """
                    This key sets the management gateway for the device. It takes precedence over the global
                    `mgmt_gateway`.
                    """
                    ipv6_mgmt_ip: str | None
                    """Node management interface IPv6 address."""
                    ipv6_mgmt_gateway: str | None
                    """
                    This key sets the ipv6 management gateway for the device. It takes precedence over the global
                    `ipv6_mgmt_gateway`.
                    """
                    mgmt_interface: str | None
                    """
                    Management Interface Name.
                    Default -> platform_management_interface -> mgmt_interface ->
                    "Management1".
                    """
                    link_tracking: LinkTracking
                    """
                    This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                    the upstream interfaces.
                    Useful in EVPN multhoming designs.
                    """
                    lacp_port_id_range: LacpPortIdRange
                    """
                    This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                    number of nodes in the "node_group".
                    Unique LACP port-id ranges are recommended for EVPN Multihoming
                    designs.
                    """
                    always_configure_ip_routing: bool | None
                    """
                    Force configuration of "ip routing" even on L2 devices.
                    Use this to retain behavior of AVD versions
                    below 4.0.0.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""
                    uplink_type: str | None
                    """
                    Override the default `uplink_type` set at the `node_type_key` level.
                    `uplink_type` must be "p2p" if
                    `vtep` or `underlay_router` is true for the `node_type_key` definition.
                    """
                    uplink_ipv4_pool: str | None
                    """IPv4 subnet to use to connect to uplink switches."""
                    uplink_interfaces: list[str]
                    """
                    Local uplink interfaces.
                    Each list item supports range syntax that can be expanded into a list of
                    interfaces.
                    If uplink_interfaces is not defined, platform-specific defaults (defined under
                    default_interfaces) will be used instead.
                    Please note that default_interfaces are not defined by
                    default, you should define these yourself.
                    """
                    uplink_switch_interfaces: list[str]
                    """Interfaces located on uplink switches."""
                    uplink_switches: list[str]
                    uplink_interface_speed: str | None
                    """
                    Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                    (Uplink switch
                    interface speed can be overridden with `uplink_switch_interface_speed`).
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_switch_interface_speed: str | None
                    """
                    Set point-to-Point interface speed for the uplink switch interface only.
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_mtu: int | None
                    """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                    max_uplink_switches: int | None
                    """
                    Maximum number of uplink switches.
                    Changing this value may change IP Addressing on uplinks.
                    Can be
                    used to reserve IP space for future expansions.
                    """
                    max_parallel_uplinks: int | None
                    """
                    Number of parallel links towards uplink switches.
                    Changing this value may change interface naming on
                    uplinks (and corresponding downlinks).
                    Can be used to reserve interfaces for future parallel
                    uplinks.
                    """
                    uplink_bfd: bool | None
                    """Enable bfd on uplink interfaces."""
                    uplink_native_vlan: int | None
                    """
                    Only applicable to switches with layer-2 port-channel uplinks.
                    A suspended (disabled) vlan will be
                    created in both ends of the link unless the vlan is defined under network services.
                    By default the
                    uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                    """
                    uplink_ptp: UplinkPtp
                    """Enable PTP on all infrastructure links."""
                    uplink_macsec: UplinkMacsec
                    """Enable MacSec on all uplinks."""
                    uplink_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink Port-channel
                    ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                    For
                    example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [ Eth11/1, Eth22/1 ] -> ID 111
                    For
                    MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                    This
                    option overrides the default behavior and statically sets the local Port-channel ID.
                    Note! Make sure
                    the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                    value.
                    """
                    uplink_switch_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink switch Port-
                    channel ID will be set to the number of the first interface defined under
                    `uplink_switch_interfaces`.
                    For example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [
                    Eth11/1, Eth22/1 ] -> ID 111
                    For MLAG port-channels ID will be based on the lowest member interface
                    on the first MLAG switch.
                    This option overrides the default behavior and statically sets the Port-
                    channel ID on the uplink switch.
                    Note! Make sure the ID is unique and does not overlap with
                    autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between
                    1 and 2000 and both MLAG switches must have the same value.
                    """
                    uplink_structured_config: dict
                    """
                    Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                    When
                    uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                    for eos_cli_config_gen overrides the settings on the ethernet interface level.
                    When uplink_type ==
                    "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                    eos_cli_config_gen overrides the settings on the port-channel interface level.
                    "uplink_structured_config" is applied after "structured_config", so it can override
                    "structured_config" defined on node-level.
                    Note! The content of this dictionary is _not_ validated
                    by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                    """
                    mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                    """
                    Custom structured config applied to MLAG peer link port-channel id.
                    Added under
                    port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the
                    port-channel interface level.
                    "mlag_port_channel_structured_config" is applied after
                    "structured_config", so it can override "structured_config" defined on node-level.
                    """
                    mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                    """
                    Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                    override "structured_config" defined on node-level.
                    """
                    mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                    """
                    Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                    can override "structured_config" defined on node-level.
                    """
                    short_esi: str | None
                    """
                    short_esi only valid for l2leaf devices using port-channel uplink.
                    Setting short_esi to "auto"
                    generates the short_esi automatically using a hash of configuration elements.
                    < 0000:0000:0000 |
                    auto >.
                    """
                    isis_system_id_prefix: str | None
                    """(4.4 hexadecimal)."""
                    isis_maximum_paths: int | None
                    """Number of path to configure in ECMP for ISIS."""
                    is_type: str | None
                    node_sid_base: int | None
                    """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                    loopback_ipv4_pool: str | None
                    """IPv4 subnet for Loopback0 allocation."""
                    loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for Loopback0.
                    When set, it takes precedence over `loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                    """
                    vtep_loopback_ipv4_pool: str | None
                    """IPv4 subnet for VTEP-Loopback allocation."""
                    vtep_loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for VTEP-Loopback.
                    When set, it takes precedence over
                    `vtep_loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not
                    catch duplicates.
                    """
                    loopback_ipv4_offset: int | None
                    """
                    Offset all assigned loopback IP addresses.
                    Required when the < loopback_ipv4_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                    """
                    loopback_ipv6_pool: str | None
                    """IPv6 subnet for Loopback0 allocation."""
                    loopback_ipv6_offset: int | None
                    """
                    Offset all assigned loopback IPv6 addresses.
                    Required when the < loopback_ipv6_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid overlapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                    """
                    vtep: bool | None
                    """
                    Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                    Overrides VTEP
                    setting inherited from node_type_keys.
                    """
                    vtep_loopback: str | None
                    """Set VXLAN source interface."""
                    bgp_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    Required with eBGP.
                    """
                    bgp_defaults: list[str]
                    """List of EOS commands to apply to BGP daemon."""
                    evpn_role: str | None
                    """
                    Acting role in EVPN control plane.
                    Default is set in node_type definition from node_type_keys.
                    """
                    evpn_route_servers: list[str]
                    """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                    evpn_services_l2_only: bool | None
                    """
                    Possibility to prevent configuration of Tenant VRFs and SVIs.
                    Override node definition
                    "network_services_l3" from node_type_keys.
                    This allows support for centralized routing.
                    """
                    filter: Filter
                    """
                    Filter L3 and L2 network services based on tenant and tags (and operation filter).
                    If filter is not
                    defined it will default to all.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping on device level."""
                    evpn_gateway: EvpnGateway
                    """
                    Node is acting as EVPN Multi-Domain Gateway.
                    New BGP peer-group is generated between EVPN GWs in
                    different domains or between GWs and Route Servers.
                    Name can be changed under
                    "bgp_peer_groups.evpn_overlay_core" variable.
                    L3 rechability for different EVPN GWs must be already
                    in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                    same Ansible inventory.
                    """
                    ipvpn_gateway: IpvpnGateway
                    """
                    Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                    this is "bgp_peer_groups.ipvpn_gateway_peers".
                    L3 Reachability is required for this to work, the
                    preferred method to establish underlay connectivity is to use core_interfaces.
                    """
                    mlag: bool | None
                    """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                    mlag_dual_primary_detection: bool | None
                    """Enable / Disable MLAG dual primary detection."""
                    mlag_ibgp_origin_incomplete: bool | None
                    """
                    Set origin of routes received from MLAG iBGP peer to incomplete.
                    The purpose is to optimize routing
                    for leaf loopbacks from spine perspective and
                    avoid suboptimal routing via peerlink for control
                    plane traffic.
                    """
                    mlag_interfaces: list[str]
                    """
                    Each list item supports range syntax that can be expanded into a list of interfaces.
                    Required when
                    MLAG leafs are present in the topology.
                    """
                    mlag_interfaces_speed: str | None
                    """
                    Set MLAG interface speed.
                    Speed should be set in the format `<interface_speed>` or `forced
                    <interface_speed>` or `auto <interface_speed>`.
                    """
                    mlag_peer_l3_vlan: int | None
                    """
                    Underlay L3 peering SVI interface id.
                    If set to 0 or the same vlan as mlag_peer_vlan, the
                    mlag_peer_vlan will be used for L3 peering.
                    """
                    mlag_peer_l3_ipv4_pool: str | None
                    """
                    IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                    Required when
                    MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                    """
                    mlag_peer_vlan: int | None
                    """MLAG Peer Link (control link) SVI interface id."""
                    mlag_peer_link_allowed_vlans: str | None
                    mlag_peer_address_family: str | None
                    """
                    IP address family used to establish MLAG Peer Link (control link).
                    `ipv6` requires EOS version
                    4.31.1F or higher.
                    Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                    (ex. `mlag_peer_l3_vlan` set to 4094).
                    """
                    mlag_peer_ipv4_pool: str | None
                    """
                    IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                    """
                    mlag_peer_ipv6_pool: str | None
                    """
                    IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                    """
                    mlag_port_channel_id: int | None
                    """
                    If not set, the mlag port-channel id is generated based on the digits of the first interface present
                    in 'mlag_interfaces'.
                    Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                    999999 > for EOS >= 4.25.0F.
                    """
                    mlag_domain_id: str | None
                    """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                    spanning_tree_mode: str | None
                    spanning_tree_priority: int | None
                    """
                    Spanning-tree priority configured for the selected mode.
                    For `rapid-pvst` the priority can also be
                    set per VLAN under network services.
                    """
                    spanning_tree_root_super: bool | None
                    virtual_router_mac_address: str | None
                    """Virtual router mac address for anycast gateway."""
                    inband_mgmt_interface: str | None
                    """
                    Pointer to interface used for inband management.
                    All configuration must be done using other data
                    models like network services or structured_config.
                    'inband_mgmt_interface' is only used to refer to
                    this interface as source in various management protocol settings (future feature).

                    On L2 switches,
                    this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                    """
                    inband_mgmt_vlan: int | None
                    """
                    VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                    uplinks).
                    When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                    switch as well as all 'uplink_switches'.
                    When using 'inband_mgmt_ip' the VLAN and SVI will only be
                    created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                    created using network services data models.
                    """
                    inband_mgmt_subnet: str | None
                    """
                    Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                    ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      : <subnet> +
                    2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       :
                    <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than total l2leafs + 5
                    Setting is ignored if 'inband_mgmt_ip' is set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ip: str | None
                    """
                    IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                    If this is set the
                    VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN and SVI on
                    the parent switches must be created using network services data models.

                    This setting is applicable
                    to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                    is derived from 'inband_mgmt_subnet' if set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_address: str | None
                    """
                    IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                    If this
                    is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN
                    and SVI on the parent switches must be created using network services data models.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_subnet: str | None
                    """
                    Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                    on ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                    extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      :
                    <subnet> + 2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       : <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than
                    total l2leafs + 5

                    Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf'.
                    Used when `inband_mgmt_ipv6_address` is set.
                    Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_description: str | None
                    """
                    Description configured on the Inband Management SVI.

                    This setting is only applied on the devices
                    where it is set, it does not automatically affect any parent/child devices configuration, so it must
                    be set on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vlan_name: str | None
                    """
                    Name configured on the Inband Management VLAN.
                    This setting is only applied on the devices where it
                    is set, it does not automatically affect any parent/child devices configuration, so it must be set
                    on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vrf: str | None
                    """
                    VRF configured on the Inband Management Interface.
                    The VRF is created if not already created by
                    other means.
                    This setting is only applied on the devices where it is set, it does not automatically
                    affect any parent/child devices configuration, so it must be set on each applicable node/node-
                    group/node-type as needed.
                    """
                    inband_mgmt_mtu: int | None
                    """
                    MTU configured on the Inband Management Interface.
                    This setting is only applied on the devices where
                    it is set, it does not automatically affect any parent/child devices configuration, so it must be
                    set on each applicable node/node-group/node-type as needed.
                    """
                    inband_ztp: bool | None
                    """
                    Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                    inband.
                    This setting also requires that the `inband_mgmt_vlan` is set for the node.
                    """
                    inband_ztp_lacp_fallback_delay: int | None
                    """
                    Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                    ZTP node.
                    This setting also requires that `inband_ztp` is set for the node.
                    """
                    mpls_overlay_role: str | None
                    """
                    Set the default mpls overlay role.
                    Acting role in overlay control plane.
                    """
                    overlay_address_families: list[str]
                    """Set the default overlay address families."""
                    mpls_route_reflectors: list[str]
                    """List of inventory hostname acting as MPLS route-reflectors."""
                    bgp_cluster_id: str | None
                    """Set BGP cluster id."""
                    ptp: Ptp
                    wan_role: str | None
                    """
                    Override the default WAN role.

                    This is used both for AutoVPN and Pathfinder designs.
                    That means if
                    `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                    `server` indicates that the
                    router is a route-reflector.

                    Only supported if `overlay_routing_protocol` is set to `ibgp`.
                    """
                    cv_pathfinder_transit_mode: str | None
                    """
                    Configure the transit mode for a WAN client for CV Pathfinder designs
                    only when the `wan_mode` root
                    key is set to `cv_pathfinder`.

                    'zone' is currently not supported.
                    """
                    cv_pathfinder_region: str | None
                    """
                    The CV Pathfinder region name.
                    This key is required for WAN routers but optional for pathfinders.
                    The region name must be defined under 'cv_pathfinder_regions'.
                    """
                    cv_pathfinder_site: str | None
                    """
                    The CV Pathfinder site name.
                    This key is required for WAN routers but optional for pathfinders.
                    For
                    WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                    relevant region under 'cv_pathfinder_regions'.
                    For pathfinders without `cv_pathfinder_region` set,
                    the site must be defined under `cv_pathfinder_global_sites`.
                    """
                    wan_ha: WanHa
                    """
                    PREVIEW: This key is currently not supported

                    The key is supported only if `wan_mode` == `cv-
                    pathfinder`.
                    AutoVPN support is still to be determined.

                    Maximum 2 devices supported by group for
                    HA.
                    """
                    dps_mss_ipv4: str | None
                    """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                    l3_interfaces: L3Interfaces
                    """
                    L3 Interfaces to configure on the node.
                    Used to define the node for WAN interfaces when
                    `wan_carrier` is set.
                    """
                    data_plane_cpu_allocation_max: int | None
                    """
                    Set the maximum number of CPU used for the data plane.
                    This setting is useful on virtual Route
                    Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                    """
                    flow_tracker_type: str | None
                    """
                    Set the flow tracker type.
                    Override the `default_flow_tracker_type`` set at the `node_type_key`
                    level.
                    `default_flow_tracker_type` default value is `sampled`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        group: str | UndefinedType = Undefined,
                        nodes: Nodes | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        platform: str | None | UndefinedType = Undefined,
                        mac_address: str | None | UndefinedType = Undefined,
                        system_mac_address: str | None | UndefinedType = Undefined,
                        serial_number: str | None | UndefinedType = Undefined,
                        rack: str | None | UndefinedType = Undefined,
                        mgmt_ip: str | None | UndefinedType = Undefined,
                        mgmt_gateway: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                        mgmt_interface: str | None | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                        always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                        uplink_type: str | None | UndefinedType = Undefined,
                        uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                        uplink_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switches: list[str] | UndefinedType = Undefined,
                        uplink_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_mtu: int | None | UndefinedType = Undefined,
                        max_uplink_switches: int | None | UndefinedType = Undefined,
                        max_parallel_uplinks: int | None | UndefinedType = Undefined,
                        uplink_bfd: bool | None | UndefinedType = Undefined,
                        uplink_native_vlan: int | None | UndefinedType = Undefined,
                        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                        uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                        uplink_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_structured_config: dict | UndefinedType = Undefined,
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                        short_esi: str | None | UndefinedType = Undefined,
                        isis_system_id_prefix: str | None | UndefinedType = Undefined,
                        isis_maximum_paths: int | None | UndefinedType = Undefined,
                        is_type: str | None | UndefinedType = Undefined,
                        node_sid_base: int | None | UndefinedType = Undefined,
                        loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                        loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                        vtep: bool | None | UndefinedType = Undefined,
                        vtep_loopback: str | None | UndefinedType = Undefined,
                        bgp_as: str | None | UndefinedType = Undefined,
                        bgp_defaults: list[str] | UndefinedType = Undefined,
                        evpn_role: str | None | UndefinedType = Undefined,
                        evpn_route_servers: list[str] | UndefinedType = Undefined,
                        evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                        ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                        mlag: bool | None | UndefinedType = Undefined,
                        mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                        mlag_interfaces: list[str] | UndefinedType = Undefined,
                        mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                        mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                        mlag_peer_address_family: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                        mlag_port_channel_id: int | None | UndefinedType = Undefined,
                        mlag_domain_id: str | None | UndefinedType = Undefined,
                        spanning_tree_mode: str | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                        virtual_router_mac_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_interface: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                        inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ip: str | None | UndefinedType = Undefined,
                        inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_description: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                        inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                        inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                        inband_ztp: bool | None | UndefinedType = Undefined,
                        inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                        mpls_overlay_role: str | None | UndefinedType = Undefined,
                        overlay_address_families: list[str] | UndefinedType = Undefined,
                        mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                        bgp_cluster_id: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        wan_role: str | None | UndefinedType = Undefined,
                        cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                        cv_pathfinder_region: str | None | UndefinedType = Undefined,
                        cv_pathfinder_site: str | None | UndefinedType = Undefined,
                        wan_ha: WanHa | UndefinedType = Undefined,
                        dps_mss_ipv4: str | None | UndefinedType = Undefined,
                        l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                        data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                        flow_tracker_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodeGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            group:
                               The Node Group Name is used for MLAG domain unless set with 'mlag_domain_id'.
                               The Node Group Name is
                               also used for peer description on downstream switches' uplinks.
                            nodes: Define variables per node.
                            id: Unique identifier used for IP addressing and other algorithms.
                            platform: Arista platform family.
                            mac_address: Leverage to document management interface mac address.
                            system_mac_address:
                               System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                               Set to the same MAC address as
                               available in "show version" on the device.
                               "system_mac_address" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            serial_number:
                               Set to the Serial Number of the device.
                               Only used for documentation purpose in the fabric
                               documentation and part of the structured_config.
                               "serial_number" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            rack: Rack that the switch is located in (only used in snmp_settings location).
                            mgmt_ip: Node management interface IPv4 address.
                            mgmt_gateway:
                               This key sets the management gateway for the device. It takes precedence over the global
                               `mgmt_gateway`.
                            ipv6_mgmt_ip: Node management interface IPv6 address.
                            ipv6_mgmt_gateway:
                               This key sets the ipv6 management gateway for the device. It takes precedence over the global
                               `ipv6_mgmt_gateway`.
                            mgmt_interface:
                               Management Interface Name.
                               Default -> platform_management_interface -> mgmt_interface ->
                               "Management1".
                            link_tracking:
                               This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                               the upstream interfaces.
                               Useful in EVPN multhoming designs.
                            lacp_port_id_range:
                               This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                               number of nodes in the "node_group".
                               Unique LACP port-id ranges are recommended for EVPN Multihoming
                               designs.
                            always_configure_ip_routing:
                               Force configuration of "ip routing" even on L2 devices.
                               Use this to retain behavior of AVD versions
                               below 4.0.0.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.
                            uplink_type:
                               Override the default `uplink_type` set at the `node_type_key` level.
                               `uplink_type` must be "p2p" if
                               `vtep` or `underlay_router` is true for the `node_type_key` definition.
                            uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                            uplink_interfaces:
                               Local uplink interfaces.
                               Each list item supports range syntax that can be expanded into a list of
                               interfaces.
                               If uplink_interfaces is not defined, platform-specific defaults (defined under
                               default_interfaces) will be used instead.
                               Please note that default_interfaces are not defined by
                               default, you should define these yourself.
                            uplink_switch_interfaces: Interfaces located on uplink switches.
                            uplink_switches: uplink_switches
                            uplink_interface_speed:
                               Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                               (Uplink switch
                               interface speed can be overridden with `uplink_switch_interface_speed`).
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_switch_interface_speed:
                               Set point-to-Point interface speed for the uplink switch interface only.
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                            max_uplink_switches:
                               Maximum number of uplink switches.
                               Changing this value may change IP Addressing on uplinks.
                               Can be
                               used to reserve IP space for future expansions.
                            max_parallel_uplinks:
                               Number of parallel links towards uplink switches.
                               Changing this value may change interface naming on
                               uplinks (and corresponding downlinks).
                               Can be used to reserve interfaces for future parallel
                               uplinks.
                            uplink_bfd: Enable bfd on uplink interfaces.
                            uplink_native_vlan:
                               Only applicable to switches with layer-2 port-channel uplinks.
                               A suspended (disabled) vlan will be
                               created in both ends of the link unless the vlan is defined under network services.
                               By default the
                               uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                            uplink_ptp: Enable PTP on all infrastructure links.
                            uplink_macsec: Enable MacSec on all uplinks.
                            uplink_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink Port-channel
                               ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                               For
                               example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [ Eth11/1, Eth22/1 ] -> ID 111
                               For
                               MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                               This
                               option overrides the default behavior and statically sets the local Port-channel ID.
                               Note! Make sure
                               the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                               value.
                            uplink_switch_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink switch Port-
                               channel ID will be set to the number of the first interface defined under
                               `uplink_switch_interfaces`.
                               For example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [
                               Eth11/1, Eth22/1 ] -> ID 111
                               For MLAG port-channels ID will be based on the lowest member interface
                               on the first MLAG switch.
                               This option overrides the default behavior and statically sets the Port-
                               channel ID on the uplink switch.
                               Note! Make sure the ID is unique and does not overlap with
                               autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between
                               1 and 2000 and both MLAG switches must have the same value.
                            uplink_structured_config:
                               Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                               When
                               uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                               for eos_cli_config_gen overrides the settings on the ethernet interface level.
                               When uplink_type ==
                               "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                               eos_cli_config_gen overrides the settings on the port-channel interface level.
                               "uplink_structured_config" is applied after "structured_config", so it can override
                               "structured_config" defined on node-level.
                               Note! The content of this dictionary is _not_ validated
                               by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                            mlag_port_channel_structured_config:
                               Custom structured config applied to MLAG peer link port-channel id.
                               Added under
                               port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the
                               port-channel interface level.
                               "mlag_port_channel_structured_config" is applied after
                               "structured_config", so it can override "structured_config" defined on node-level.
                            mlag_peer_vlan_structured_config:
                               Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                               override "structured_config" defined on node-level.
                            mlag_peer_l3_vlan_structured_config:
                               Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                               can override "structured_config" defined on node-level.
                            short_esi:
                               short_esi only valid for l2leaf devices using port-channel uplink.
                               Setting short_esi to "auto"
                               generates the short_esi automatically using a hash of configuration elements.
                               < 0000:0000:0000 |
                               auto >.
                            isis_system_id_prefix: (4.4 hexadecimal).
                            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                            is_type: is_type
                            node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                            loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                            loopback_ipv4_address:
                               IPv4 address without mask for Loopback0.
                               When set, it takes precedence over `loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                            vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                            vtep_loopback_ipv4_address:
                               IPv4 address without mask for VTEP-Loopback.
                               When set, it takes precedence over
                               `vtep_loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not
                               catch duplicates.
                            loopback_ipv4_offset:
                               Offset all assigned loopback IP addresses.
                               Required when the < loopback_ipv4_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                            loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                            loopback_ipv6_offset:
                               Offset all assigned loopback IPv6 addresses.
                               Required when the < loopback_ipv6_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid overlapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                            vtep:
                               Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                               Overrides VTEP
                               setting inherited from node_type_keys.
                            vtep_loopback: Set VXLAN source interface.
                            bgp_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                               Required with eBGP.
                            bgp_defaults: List of EOS commands to apply to BGP daemon.
                            evpn_role:
                               Acting role in EVPN control plane.
                               Default is set in node_type definition from node_type_keys.
                            evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                            evpn_services_l2_only:
                               Possibility to prevent configuration of Tenant VRFs and SVIs.
                               Override node definition
                               "network_services_l3" from node_type_keys.
                               This allows support for centralized routing.
                            filter:
                               Filter L3 and L2 network services based on tenant and tags (and operation filter).
                               If filter is not
                               defined it will default to all.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                            evpn_gateway:
                               Node is acting as EVPN Multi-Domain Gateway.
                               New BGP peer-group is generated between EVPN GWs in
                               different domains or between GWs and Route Servers.
                               Name can be changed under
                               "bgp_peer_groups.evpn_overlay_core" variable.
                               L3 rechability for different EVPN GWs must be already
                               in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                               same Ansible inventory.
                            ipvpn_gateway:
                               Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                               this is "bgp_peer_groups.ipvpn_gateway_peers".
                               L3 Reachability is required for this to work, the
                               preferred method to establish underlay connectivity is to use core_interfaces.
                            mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                            mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                            mlag_ibgp_origin_incomplete:
                               Set origin of routes received from MLAG iBGP peer to incomplete.
                               The purpose is to optimize routing
                               for leaf loopbacks from spine perspective and
                               avoid suboptimal routing via peerlink for control
                               plane traffic.
                            mlag_interfaces:
                               Each list item supports range syntax that can be expanded into a list of interfaces.
                               Required when
                               MLAG leafs are present in the topology.
                            mlag_interfaces_speed:
                               Set MLAG interface speed.
                               Speed should be set in the format `<interface_speed>` or `forced
                               <interface_speed>` or `auto <interface_speed>`.
                            mlag_peer_l3_vlan:
                               Underlay L3 peering SVI interface id.
                               If set to 0 or the same vlan as mlag_peer_vlan, the
                               mlag_peer_vlan will be used for L3 peering.
                            mlag_peer_l3_ipv4_pool:
                               IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                               Required when
                               MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                            mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                            mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                            mlag_peer_address_family:
                               IP address family used to establish MLAG Peer Link (control link).
                               `ipv6` requires EOS version
                               4.31.1F or higher.
                               Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                               (ex. `mlag_peer_l3_vlan` set to 4094).
                            mlag_peer_ipv4_pool:
                               IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                            mlag_peer_ipv6_pool:
                               IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                            mlag_port_channel_id:
                               If not set, the mlag port-channel id is generated based on the digits of the first interface present
                               in 'mlag_interfaces'.
                               Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                               999999 > for EOS >= 4.25.0F.
                            mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                            spanning_tree_mode: spanning_tree_mode
                            spanning_tree_priority:
                               Spanning-tree priority configured for the selected mode.
                               For `rapid-pvst` the priority can also be
                               set per VLAN under network services.
                            spanning_tree_root_super: spanning_tree_root_super
                            virtual_router_mac_address: Virtual router mac address for anycast gateway.
                            inband_mgmt_interface:
                               Pointer to interface used for inband management.
                               All configuration must be done using other data
                               models like network services or structured_config.
                               'inband_mgmt_interface' is only used to refer to
                               this interface as source in various management protocol settings (future feature).

                               On L2 switches,
                               this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                            inband_mgmt_vlan:
                               VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                               uplinks).
                               When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                               switch as well as all 'uplink_switches'.
                               When using 'inband_mgmt_ip' the VLAN and SVI will only be
                               created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                               created using network services data models.
                            inband_mgmt_subnet:
                               Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                               ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      : <subnet> +
                               2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       :
                               <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than total l2leafs + 5
                               Setting is ignored if 'inband_mgmt_ip' is set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ip:
                               IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                               If this is set the
                               VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN and SVI on
                               the parent switches must be created using network services data models.

                               This setting is applicable
                               to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                               is derived from 'inband_mgmt_subnet' if set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_address:
                               IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                               If this
                               is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN
                               and SVI on the parent switches must be created using network services data models.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_subnet:
                               Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                               on ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                               extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      :
                               <subnet> + 2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       : <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than
                               total l2leafs + 5

                               Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf'.
                               Used when `inband_mgmt_ipv6_address` is set.
                               Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_description:
                               Description configured on the Inband Management SVI.

                               This setting is only applied on the devices
                               where it is set, it does not automatically affect any parent/child devices configuration, so it must
                               be set on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vlan_name:
                               Name configured on the Inband Management VLAN.
                               This setting is only applied on the devices where it
                               is set, it does not automatically affect any parent/child devices configuration, so it must be set
                               on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vrf:
                               VRF configured on the Inband Management Interface.
                               The VRF is created if not already created by
                               other means.
                               This setting is only applied on the devices where it is set, it does not automatically
                               affect any parent/child devices configuration, so it must be set on each applicable node/node-
                               group/node-type as needed.
                            inband_mgmt_mtu:
                               MTU configured on the Inband Management Interface.
                               This setting is only applied on the devices where
                               it is set, it does not automatically affect any parent/child devices configuration, so it must be
                               set on each applicable node/node-group/node-type as needed.
                            inband_ztp:
                               Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                               inband.
                               This setting also requires that the `inband_mgmt_vlan` is set for the node.
                            inband_ztp_lacp_fallback_delay:
                               Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                               ZTP node.
                               This setting also requires that `inband_ztp` is set for the node.
                            mpls_overlay_role:
                               Set the default mpls overlay role.
                               Acting role in overlay control plane.
                            overlay_address_families: Set the default overlay address families.
                            mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                            bgp_cluster_id: Set BGP cluster id.
                            ptp: ptp
                            wan_role:
                               Override the default WAN role.

                               This is used both for AutoVPN and Pathfinder designs.
                               That means if
                               `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                               `server` indicates that the
                               router is a route-reflector.

                               Only supported if `overlay_routing_protocol` is set to `ibgp`.
                            cv_pathfinder_transit_mode:
                               Configure the transit mode for a WAN client for CV Pathfinder designs
                               only when the `wan_mode` root
                               key is set to `cv_pathfinder`.

                               'zone' is currently not supported.
                            cv_pathfinder_region:
                               The CV Pathfinder region name.
                               This key is required for WAN routers but optional for pathfinders.
                               The region name must be defined under 'cv_pathfinder_regions'.
                            cv_pathfinder_site:
                               The CV Pathfinder site name.
                               This key is required for WAN routers but optional for pathfinders.
                               For
                               WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                               relevant region under 'cv_pathfinder_regions'.
                               For pathfinders without `cv_pathfinder_region` set,
                               the site must be defined under `cv_pathfinder_global_sites`.
                            wan_ha:
                               PREVIEW: This key is currently not supported

                               The key is supported only if `wan_mode` == `cv-
                               pathfinder`.
                               AutoVPN support is still to be determined.

                               Maximum 2 devices supported by group for
                               HA.
                            dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                            l3_interfaces:
                               L3 Interfaces to configure on the node.
                               Used to define the node for WAN interfaces when
                               `wan_carrier` is set.
                            data_plane_cpu_allocation_max:
                               Set the maximum number of CPU used for the data plane.
                               This setting is useful on virtual Route
                               Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                            flow_tracker_type:
                               Set the flow tracker type.
                               Override the `default_flow_tracker_type`` set at the `node_type_key`
                               level.
                               `default_flow_tracker_type` default value is `sampled`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NodeGroups(AvdCollection[str, NodeGroupsItem]):
                    _primary_key: ClassVar[str] = "group"

                NodeGroups._item_type = NodeGroupsItem

                class NodesItem(AvdModel):
                    class DownlinkPoolsItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "ipv4_pool": {"type": str},
                            "downlink_interfaces": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        ipv4_pool: str | None
                        """IPv4 pool from which subnets will be allocated for links to downlink switches."""
                        downlink_interfaces: list[str]
                        """
                        List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                        this list will determine which subnet will be taken from the pool.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ipv4_pool: str | None | UndefinedType = Undefined,
                            downlink_interfaces: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DownlinkPoolsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ipv4_pool: IPv4 pool from which subnets will be allocated for links to downlink switches.
                                downlink_interfaces:
                                   List of downlink interfaces or ranges of interfaces to use this pool. The index of the interface in
                                   this list will determine which subnet will be taken from the pool.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LinkTracking(AvdModel):
                        class GroupsItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "name": {"type": str},
                                "recovery_delay": {"type": int},
                                "links_minimum": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            name: str | None
                            """Tracking group name."""
                            recovery_delay: int | None
                            """default -> platform_settings_mlag_reload_delay -> 300."""
                            links_minimum: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                                recovery_delay: int | None | UndefinedType = Undefined,
                                links_minimum: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                GroupsItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    name: Tracking group name.
                                    recovery_delay: default -> platform_settings_mlag_reload_delay -> 300.
                                    links_minimum: links_minimum

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "groups": {
                                "type": list,
                                "items": GroupsItem,
                                "default": lambda cls: coerce_type([{"name": "LT_GROUP1"}], target_type=list, list_items_type=cls),
                            },
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        groups: list[GroupsItem]
                        """
                        Link Tracking Groups.
                        By default a single group named "LT_GROUP1" is defined with default values.
                        Any groups defined under "groups" will replace the default.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            groups: list[GroupsItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LinkTracking.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                groups:
                                   Link Tracking Groups.
                                   By default a single group named "LT_GROUP1" is defined with default values.
                                   Any groups defined under "groups" will replace the default.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class LacpPortIdRange(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "size": {"type": int, "default": 128},
                            "offset": {"type": int, "default": 0},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        size: int | None
                        """Recommended size > = number of ports in the switch."""
                        offset: int | None
                        """
                        Offset is used to avoid overlapping port-id ranges of different switches.
                        Useful when a "connected-
                        endpoint" is connected to switches in different "node_groups".
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            size: int | None | UndefinedType = Undefined,
                            offset: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            LacpPortIdRange.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                size: Recommended size > = number of ports in the switch.
                                offset:
                                   Offset is used to avoid overlapping port-id ranges of different switches.
                                   Useful when a "connected-
                                   endpoint" is connected to switches in different "node_groups".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class StructuredConfig(EosCliConfigGen):
                        pass

                    class UplinkPtp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": False}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enable: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enable: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkPtp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enable: enable

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UplinkMacsec(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        profile: str | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            UplinkMacsec.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: profile

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MlagPortChannelStructuredConfig(EosCliConfigGen.PortChannelInterfacesItem):
                        pass

                    class MlagPeerVlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class MlagPeerL3VlanStructuredConfig(EosCliConfigGen.VlanInterfacesItem):
                        pass

                    class Filter(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "tenants": {"type": list, "items": str, "default": ["all"]},
                            "tags": {"type": list, "items": str, "default": ["all"]},
                            "allow_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "deny_vrfs": {"type": list, "items": str, "default": ["all"]},
                            "always_include_vrfs_in_tenants": {"type": list, "items": str},
                            "only_vlans_in_use": {"type": bool, "default": False},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        tenants: list[str]
                        """
                        Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                        Tenants (default).
                        This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                        """
                        tags: list[str]
                        """Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default)."""
                        allow_vrfs: list[str]
                        """
                        Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                        (default).
                        This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                        """
                        deny_vrfs: list[str]
                        """
                        Prevent configuration of Network Services defined under these VRFs.
                        This list prevents the given
                        VRFs to be included by any other filtering mechanism.
                        """
                        always_include_vrfs_in_tenants: list[str]
                        """
                        List of tenants where VRFs will be configured even if VLANs are not included in tags.
                        Useful for L3
                        "border" leaf.
                        """
                        only_vlans_in_use: bool | None
                        """
                        Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                        Note! This
                        feature only considers configuration managed by eos_designs.
                        This excludes structured_config,
                        custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            tenants: list[str] | UndefinedType = Undefined,
                            tags: list[str] | UndefinedType = Undefined,
                            allow_vrfs: list[str] | UndefinedType = Undefined,
                            deny_vrfs: list[str] | UndefinedType = Undefined,
                            always_include_vrfs_in_tenants: list[str] | UndefinedType = Undefined,
                            only_vlans_in_use: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Filter.

                            Args:
                            -----
                                _custom_data: _custom_data
                                tenants:
                                   Limit configured Network Services to those defined under these Tenants. Set to ['all'] for all
                                   Tenants (default).
                                   This list also limits Tenants included by `always_include_vrfs_in_tenants`.
                                tags: Limit configured VLANs to those matching the given tags. Set to ['all'] for all VLANs (default).
                                allow_vrfs:
                                   Limit configured Network Services to those defined under these VRFs. Set to ['all'] for all VRFs
                                   (default).
                                   This list also limits VRFs included by `always_include_vrfs_in_tenants`.
                                deny_vrfs:
                                   Prevent configuration of Network Services defined under these VRFs.
                                   This list prevents the given
                                   VRFs to be included by any other filtering mechanism.
                                always_include_vrfs_in_tenants:
                                   List of tenants where VRFs will be configured even if VLANs are not included in tags.
                                   Useful for L3
                                   "border" leaf.
                                only_vlans_in_use:
                                   Only configure VLANs, SVIs, VRFs in use by connected endpoints or downstream L2 switches.
                                   Note! This
                                   feature only considers configuration managed by eos_designs.
                                   This excludes structured_config,
                                   custom_structured_configuration_, raw_eos_cli, eos_cli, custom templates, configlets etc.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class EvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            hostname: str | None
                            """Hostname of remote EVPN GW server."""
                            ip_address: str | None
                            """Peering IP of remote Route Server."""
                            bgp_as: str | None
                            """
                            Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                            interpreted as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | None | UndefinedType = Undefined,
                                ip_address: str | None | UndefinedType = Undefined,
                                bgp_as: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote EVPN GW server.
                                    ip_address: Peering IP of remote Route Server.
                                    bgp_as:
                                       Remote Route Server's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being
                                       interpreted as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL2(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool, "default": False}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                EvpnL2.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class EvpnL3(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": False},
                                "inter_domain": {"type": bool, "default": True},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            inter_domain: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                inter_domain: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                EvpnL3.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    inter_domain: inter_domain

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                            "evpn_l2": {"type": EvpnL2},
                            "evpn_l3": {"type": EvpnL3},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        remote_peers: list[RemotePeersItem]
                        """
                        Define remote peers of the EVPN VXLAN Gateway.
                        If the hostname can be found in the inventory,
                        ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                        If the
                        peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                        """
                        evpn_l2: EvpnL2
                        """Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET)."""
                        evpn_l3: EvpnL3
                        """Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX)."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                            evpn_l2: EvpnL2 | UndefinedType = Undefined,
                            evpn_l3: EvpnL3 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            EvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                remote_peers:
                                   Define remote peers of the EVPN VXLAN Gateway.
                                   If the hostname can be found in the inventory,
                                   ip_address and BGP ASN will be automatically populated. Manual override takes precedence.
                                   If the
                                   peer's hostname can not be found in the inventory, ip_address and bgp_as must be defined.
                                evpn_l2: Enable EVPN Gateway functionality for route-types 2 (MAC-IP) and 3 (IMET).
                                evpn_l3: Enable EVPN Gateway functionality for route-type 5 (IP-PREFIX).

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class IpvpnGateway(AvdModel):
                        class RemotePeersItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "hostname": {"type": str},
                                "ip_address": {"type": str},
                                "bgp_as": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "hostname", "ip_address", "bgp_as")
                            _custom_data: dict[str, Any]
                            hostname: str
                            """Hostname of remote IPVPN Peer."""
                            ip_address: str
                            """Peering IP of remote IPVPN Peer."""
                            bgp_as: str
                            """
                            Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For
                            asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                            as a float number.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                hostname: str | UndefinedType = Undefined,
                                ip_address: str | UndefinedType = Undefined,
                                bgp_as: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                RemotePeersItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    hostname: Hostname of remote IPVPN Peer.
                                    ip_address: Peering IP of remote IPVPN Peer.
                                    bgp_as:
                                       Remote IPVPN Peer's BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For
                                       asdot notation in YAML inputs, the value must be put in quotes, to prevent it from being interpreted
                                       as a float number.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "evpn_domain_id": {"type": str, "default": "65535:1"},
                            "ipvpn_domain_id": {"type": str, "default": "65535:2"},
                            "enable_d_path": {"type": bool, "default": True},
                            "maximum_routes": {"type": int, "default": 0},
                            "local_as": {"type": str, "default": "none"},
                            "address_families": {"type": list, "items": str, "default": ["vpn-ipv4"]},
                            "remote_peers": {"type": list, "items": RemotePeersItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        evpn_domain_id: str | None
                        """Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>."""
                        ipvpn_domain_id: str | None
                        """Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>."""
                        enable_d_path: bool | None
                        """Enable D-path for use with BGP bestpath selection algorithm."""
                        maximum_routes: int | None
                        """Maximum routes to accept from IPVPN remote peers."""
                        local_as: str | None
                        """
                        Local BGP AS applied to peering with IPVPN remote peers.
                        BGP AS <1-4294967295> or AS number in asdot
                        notation "<1-65535>.<0-65535>".
                        For asdot notation in YAML inputs, the value must be put in quotes,
                        to prevent it from being interpreted as a float number.
                        """
                        address_families: list[str]
                        """IPVPN address families to enable for remote peers."""
                        remote_peers: list[RemotePeersItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            evpn_domain_id: str | None | UndefinedType = Undefined,
                            ipvpn_domain_id: str | None | UndefinedType = Undefined,
                            enable_d_path: bool | None | UndefinedType = Undefined,
                            maximum_routes: int | None | UndefinedType = Undefined,
                            local_as: str | None | UndefinedType = Undefined,
                            address_families: list[str] | UndefinedType = Undefined,
                            remote_peers: list[RemotePeersItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            IpvpnGateway.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                evpn_domain_id: Domain ID to assign to EVPN address family for use with D-path. Format <nn>:<nn>.
                                ipvpn_domain_id: Domain ID to assign to IPVPN address families for use with D-path. Format <nn>:<nn>.
                                enable_d_path: Enable D-path for use with BGP bestpath selection algorithm.
                                maximum_routes: Maximum routes to accept from IPVPN remote peers.
                                local_as:
                                   Local BGP AS applied to peering with IPVPN remote peers.
                                   BGP AS <1-4294967295> or AS number in asdot
                                   notation "<1-65535>.<0-65535>".
                                   For asdot notation in YAML inputs, the value must be put in quotes,
                                   to prevent it from being interpreted as a float number.
                                address_families: IPVPN address families to enable for remote peers.
                                remote_peers: remote_peers

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ptp(AvdModel):
                        class Dscp(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general_messages": {"type": int}, "event_messages": {"type": int}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            general_messages: int | None
                            event_messages: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                general_messages: int | None | UndefinedType = Undefined,
                                event_messages: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Dscp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    general_messages: general_messages
                                    event_messages: event_messages

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class Monitor(AvdModel):
                            class Threshold(AvdModel):
                                class Drop(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "offset_from_master": {"type": int},
                                        "mean_path_delay": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    offset_from_master: int | None
                                    mean_path_delay: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        offset_from_master: int | None | UndefinedType = Undefined,
                                        mean_path_delay: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Drop.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            offset_from_master: offset_from_master
                                            mean_path_delay: mean_path_delay

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "offset_from_master": {"type": int, "default": 250},
                                    "mean_path_delay": {"type": int, "default": 1500},
                                    "drop": {"type": Drop},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                offset_from_master: int | None
                                mean_path_delay: int | None
                                drop: Drop

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    offset_from_master: int | None | UndefinedType = Undefined,
                                    mean_path_delay: int | None | UndefinedType = Undefined,
                                    drop: Drop | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    Threshold.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        offset_from_master: offset_from_master
                                        mean_path_delay: mean_path_delay
                                        drop: drop

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class MissingMessage(AvdModel):
                                class Intervals(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "announce": {"type": int},
                                        "follow_up": {"type": int},
                                        "sync": {"type": int},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    announce: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        Intervals.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            announce: announce
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                class SequenceIds(AvdModel):
                                    _fields: ClassVar[dict] = {
                                        "_custom_data": {"type": dict},
                                        "enabled": {"type": bool, "default": True},
                                        "announce": {"type": int, "default": 3},
                                        "delay_resp": {"type": int, "default": 3},
                                        "follow_up": {"type": int, "default": 3},
                                        "sync": {"type": int, "default": 3},
                                    }
                                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                                    _custom_data: dict[str, Any]
                                    enabled: bool | None
                                    announce: int | None
                                    delay_resp: int | None
                                    follow_up: int | None
                                    sync: int | None

                                    def __init__(
                                        self,
                                        *,
                                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                        enabled: bool | None | UndefinedType = Undefined,
                                        announce: int | None | UndefinedType = Undefined,
                                        delay_resp: int | None | UndefinedType = Undefined,
                                        follow_up: int | None | UndefinedType = Undefined,
                                        sync: int | None | UndefinedType = Undefined,
                                    ) -> None:
                                        """
                                        SequenceIds.

                                        Args:
                                        -----
                                            _custom_data: _custom_data
                                            enabled: enabled
                                            announce: announce
                                            delay_resp: delay_resp
                                            follow_up: follow_up
                                            sync: sync

                                        """
                                        for arg, arg_value in locals().items():
                                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                                continue
                                            setattr(self, arg, arg_value)

                                _fields: ClassVar[dict] = {
                                    "_custom_data": {"type": dict},
                                    "intervals": {"type": Intervals},
                                    "sequence_ids": {"type": SequenceIds},
                                }
                                _required_fields: ClassVar[tuple] = ("_custom_data",)
                                _custom_data: dict[str, Any]
                                intervals: Intervals
                                sequence_ids: SequenceIds

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    intervals: Intervals | UndefinedType = Undefined,
                                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    MissingMessage.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        intervals: intervals
                                        sequence_ids: sequence_ids

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool, "default": True},
                                "threshold": {"type": Threshold},
                                "missing_message": {"type": MissingMessage},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            threshold: Threshold
                            missing_message: MissingMessage

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                threshold: Threshold | UndefinedType = Undefined,
                                missing_message: MissingMessage | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Monitor.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    threshold: threshold
                                    missing_message: missing_message

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": False},
                            "profile": {"type": str, "default": "aes67-r16-2016"},
                            "mlag": {"type": bool, "default": False},
                            "domain": {"type": int, "default": 127},
                            "priority1": {"type": int},
                            "priority2": {"type": int},
                            "auto_clock_identity": {"type": bool, "default": True},
                            "clock_identity_prefix": {"type": str},
                            "clock_identity": {"type": str},
                            "source_ip": {"type": str},
                            "mode": {"type": str, "default": "boundary"},
                            "mode_one_step": {"type": bool, "default": False},
                            "ttl": {"type": int},
                            "forward_unicast": {"type": bool, "default": False},
                            "dscp": {"type": Dscp},
                            "monitor": {"type": Monitor},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        profile: str | None
                        """
                        Default available profiles are:
                          - "aes67"
                          - "aes67-r16-2016"
                          - "smpte2059-2"
                        """
                        mlag: bool | None
                        """
                        Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                        configured on the MLAG peer-link port-channel.
                        """
                        domain: int | None
                        priority1: int | None
                        """default -> automatically set based on node_type."""
                        priority2: int | None
                        """default -> (node_id modulus 256)."""
                        auto_clock_identity: bool | None
                        """
                        If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                        default EOS behaviour, simply disable the automatic PTP clock identity.
                        default ->
                        (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                        HEX).
                        """
                        clock_identity_prefix: str | None
                        """
                        PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                        By default the 3-byte prefix is "00:1C:73".
                        This
                        can be overridden if auto_clock_identity is set to true (which is the default).
                        """
                        clock_identity: str | None
                        """Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06"."""
                        source_ip: str | None
                        """
                        By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                        relevant SVI, which is the recommended behaviour.
                        This can be set manually if required, for example,
                        to a value of "10.1.2.3".
                        """
                        mode: str | None
                        mode_one_step: bool | None
                        ttl: int | None
                        forward_unicast: bool | None
                        """Enable PTP unicast forwarding."""
                        dscp: Dscp
                        monitor: Monitor

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            mlag: bool | None | UndefinedType = Undefined,
                            domain: int | None | UndefinedType = Undefined,
                            priority1: int | None | UndefinedType = Undefined,
                            priority2: int | None | UndefinedType = Undefined,
                            auto_clock_identity: bool | None | UndefinedType = Undefined,
                            clock_identity_prefix: str | None | UndefinedType = Undefined,
                            clock_identity: str | None | UndefinedType = Undefined,
                            source_ip: str | None | UndefinedType = Undefined,
                            mode: str | None | UndefinedType = Undefined,
                            mode_one_step: bool | None | UndefinedType = Undefined,
                            ttl: int | None | UndefinedType = Undefined,
                            forward_unicast: bool | None | UndefinedType = Undefined,
                            dscp: Dscp | UndefinedType = Undefined,
                            monitor: Monitor | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ptp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                profile:
                                   Default available profiles are:
                                     - "aes67"
                                     - "aes67-r16-2016"
                                     - "smpte2059-2"
                                mlag:
                                   Configure PTP on the MLAG peer-link port-channel when PTP is enabled. By default PTP will not be
                                   configured on the MLAG peer-link port-channel.
                                domain: domain
                                priority1: default -> automatically set based on node_type.
                                priority2: default -> (node_id modulus 256).
                                auto_clock_identity:
                                   If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the
                                   default EOS behaviour, simply disable the automatic PTP clock identity.
                                   default ->
                                   (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as
                                   HEX).
                                clock_identity_prefix:
                                   PTP clock idetentiy 3-byte prefix. i.e. "01:02:03".
                                   By default the 3-byte prefix is "00:1C:73".
                                   This
                                   can be overridden if auto_clock_identity is set to true (which is the default).
                                clock_identity: Set PTP clock identity manually. 6-byte value i.e. "01:02:03:04:05:06".
                                source_ip:
                                   By default in EOS, PTP packets are sourced with an IP address from the routed port or from the
                                   relevant SVI, which is the recommended behaviour.
                                   This can be set manually if required, for example,
                                   to a value of "10.1.2.3".
                                mode: mode
                                mode_one_step: mode_one_step
                                ttl: ttl
                                forward_unicast: Enable PTP unicast forwarding.
                                dscp: dscp
                                monitor: monitor

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class WanHa(AvdModel):
                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool, "default": True},
                            "ipsec": {"type": bool, "default": True},
                            "mtu": {"type": int, "default": 9194},
                            "ha_interfaces": {"type": list, "items": str},
                            "ha_ipv4_pool": {"type": str},
                            "max_ha_interfaces": {"type": int},
                            "port_channel_id": {"type": int},
                            "use_port_channel_for_direct_ha": {"type": bool, "default": True},
                            "flow_tracking": {"type": FlowTracking},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group."""
                        ipsec: bool | None
                        """Enable / Disable IPsec over HA path-group when HA is enabled."""
                        mtu: int | None
                        """Set MTU on WAN HA interfaces."""
                        ha_interfaces: list[str]
                        """
                        Local WAN HA interfaces
                        Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                        Can be used to filter uplink interfaces when there are multiple uplinks.
                        Limitations:
                          Either all
                        interfaces must be uplinks or all interfaces must not be uplinks.
                          Only one interface is supported
                        for non uplinks.
                        """
                        ha_ipv4_pool: str | None
                        """
                        IP address pool used for WAN HA connectivity.
                        IP is derived from the node ID.
                        Not used for uplink
                        interfaces.
                        """
                        max_ha_interfaces: int | None
                        """
                        Number of parallel links towards HA switches.
                        Can be used to reserve IP addresses for future
                        parallel HA links.
                        """
                        port_channel_id: int | None
                        """Port-channel ID to use for direct HA."""
                        use_port_channel_for_direct_ha: bool | None
                        """
                        Enable or disable using a port-channel interface for direct HA when there is only one interface.
                        This feature was introduced in EOS 4.33.0F.
                        """
                        flow_tracking: FlowTracking
                        """
                        Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                        setting.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            ipsec: bool | None | UndefinedType = Undefined,
                            mtu: int | None | UndefinedType = Undefined,
                            ha_interfaces: list[str] | UndefinedType = Undefined,
                            ha_ipv4_pool: str | None | UndefinedType = Undefined,
                            max_ha_interfaces: int | None | UndefinedType = Undefined,
                            port_channel_id: int | None | UndefinedType = Undefined,
                            use_port_channel_for_direct_ha: bool | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                        ) -> None:
                            """
                            WanHa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Enable / Disable auto CV-Pathfinder HA, when two nodes are defined in the same node_group.
                                ipsec: Enable / Disable IPsec over HA path-group when HA is enabled.
                                mtu: Set MTU on WAN HA interfaces.
                                ha_interfaces:
                                   Local WAN HA interfaces
                                   Overwrite the default behavior which is to pick all the `uplink_interfaces`.
                                   Can be used to filter uplink interfaces when there are multiple uplinks.
                                   Limitations:
                                     Either all
                                   interfaces must be uplinks or all interfaces must not be uplinks.
                                     Only one interface is supported
                                   for non uplinks.
                                ha_ipv4_pool:
                                   IP address pool used for WAN HA connectivity.
                                   IP is derived from the node ID.
                                   Not used for uplink
                                   interfaces.
                                max_ha_interfaces:
                                   Number of parallel links towards HA switches.
                                   Can be used to reserve IP addresses for future
                                   parallel HA links.
                                port_channel_id: Port-channel ID to use for direct HA.
                                use_port_channel_for_direct_ha:
                                   Enable or disable using a port-channel interface for direct HA when there is only one interface.
                                   This feature was introduced in EOS 4.33.0F.
                                flow_tracking:
                                   Configures flow-tracking on the HA interfaces. Overrides `fabric_flow_tracking.wan_ha_links`
                                   setting.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3InterfacesItem(AvdModel):
                        class Bgp(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "peer_as": {"type": str},
                                "ipv4_prefix_list_in": {"type": str},
                                "ipv4_prefix_list_out": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "peer_as")
                            _custom_data: dict[str, Any]
                            peer_as: str
                            """
                            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                            For asdot notation in
                            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                            number.
                            """
                            ipv4_prefix_list_in: str | None
                            """
                            Prefix List Name. Accept routes for only these prefixes from the peer.
                            Required for wan interfaces.
                            """
                            ipv4_prefix_list_out: str | None
                            """
                            Prefix List Name. Advertise routes for only these prefixes.
                            If not specified, nothing would be
                            advertised.
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                peer_as: str | UndefinedType = Undefined,
                                ipv4_prefix_list_in: str | None | UndefinedType = Undefined,
                                ipv4_prefix_list_out: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Bgp.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    peer_as:
                                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                                       For asdot notation in
                                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                                       number.
                                    ipv4_prefix_list_in:
                                       Prefix List Name. Accept routes for only these prefixes from the peer.
                                       Required for wan interfaces.
                                    ipv4_prefix_list_out:
                                       Prefix List Name. Advertise routes for only these prefixes.
                                       If not specified, nothing would be
                                       advertised.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StaticRoutesItem(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                            _custom_data: dict[str, Any]
                            prefix: str
                            """IPv4_network/Mask."""

                            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix: str | UndefinedType = Undefined) -> None:
                                """
                                StaticRoutesItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    prefix: IPv4_network/Mask.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class CvPathfinderInternetExit(AvdModel):
                            class PoliciesItem(AvdModel):
                                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "tunnel_interface_numbers": {"type": str}}
                                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                                _custom_data: dict[str, Any]
                                name: str
                                """Internet-exit policy name."""
                                tunnel_interface_numbers: str | None
                                """
                                Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                interface.
                                Examples: '1-3' or '100,200,300'
                                """

                                def __init__(
                                    self,
                                    *,
                                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                    name: str | UndefinedType = Undefined,
                                    tunnel_interface_numbers: str | None | UndefinedType = Undefined,
                                ) -> None:
                                    """
                                    PoliciesItem.

                                    Args:
                                    -----
                                        _custom_data: _custom_data
                                        name: Internet-exit policy name.
                                        tunnel_interface_numbers:
                                           Number range to use for Tunnel interfaces to an internet-exit service provider using this local
                                           interface.
                                           Examples: '1-3' or '100,200,300'

                                    """
                                    for arg, arg_value in locals().items():
                                        if arg_value is Undefined or arg in ("self", "kwargs"):
                                            continue
                                        setattr(self, arg, arg_value)

                            class Policies(AvdCollection[str, PoliciesItem]):
                                _primary_key: ClassVar[str] = "name"

                            Policies._item_type = PoliciesItem

                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            policies: Policies
                            """List of Internet-exit policies using this interface as exit."""

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policies: Policies | UndefinedType = Undefined
                            ) -> None:
                                """
                                CvPathfinderInternetExit.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    policies: List of Internet-exit policies using this interface as exit.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class FlowTracking(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "name": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            enabled: bool | None
                            name: str | None
                            """Flow tracker name as defined in flow_tracking_settings."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | None | UndefinedType = Undefined,
                                name: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                FlowTracking.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    name: Flow tracker name as defined in flow_tracking_settings.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class StructuredConfig(EosCliConfigGen.EthernetInterfacesItem):
                            pass

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "profile": {"type": str},
                            "name": {"type": str},
                            "description": {"type": str},
                            "ip_address": {"type": str},
                            "dhcp_ip": {"type": str},
                            "public_ip": {"type": str},
                            "encapsulation_dot1q_vlan": {"type": int},
                            "dhcp_accept_default_route": {"type": bool, "default": True},
                            "enabled": {"type": bool, "default": True},
                            "speed": {"type": str},
                            "peer": {"type": str},
                            "peer_interface": {"type": str},
                            "peer_ip": {"type": str},
                            "bgp": {"type": Bgp},
                            "ipv4_acl_in": {"type": str},
                            "ipv4_acl_out": {"type": str},
                            "static_routes": {"type": list, "items": StaticRoutesItem},
                            "qos_profile": {"type": str},
                            "wan_carrier": {"type": str},
                            "wan_circuit_id": {"type": str},
                            "connected_to_pathfinder": {"type": bool, "default": True},
                            "cv_pathfinder_internet_exit": {"type": CvPathfinderInternetExit},
                            "raw_eos_cli": {"type": str},
                            "flow_tracking": {"type": FlowTracking},
                            "structured_config": {"type": StructuredConfig},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                        _custom_data: dict[str, Any]
                        profile: str | None
                        """L3 interface profile name. Profile defined under `l3_interface_profiles`."""
                        name: str
                        """
                        Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                        For a
                        subinterface, the parent physical interface is automatically created.
                        """
                        description: str | None
                        """
                        Interface description.
                        If not set a default description will be configured with '[<peer>[
                        <peer_interface>]]'.
                        """
                        ip_address: str | None
                        """Node IPv4 address/Mask or 'dhcp'."""
                        dhcp_ip: str | None
                        """
                        When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                        IPv4 address
                        (without mask) to be allocated on the interface if known.
                        This is not rendered in the configuration
                        but can be used for substitution of 'interface_ip' in the Access-list
                        set under `ipv4_acl_in` and
                        `ipv4_acl_out`.
                        """
                        public_ip: str | None
                        """
                        Node IPv4 address (no mask).

                        This is used to get the public IP (if known) when the device is behind
                        NAT.
                        This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                        with the following preference:
                          `wan_route_servers.path_groups.interfaces.ip_address`
                              ->
                        `l3_interfaces.public_ip`
                                  -> `l3_interfaces.ip_address`

                        The determined Public IP is used
                        by WAN routers when peering with this interface.
                        """
                        encapsulation_dot1q_vlan: int | None
                        """
                        For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                        specified.
                        """
                        dhcp_accept_default_route: bool | None
                        """Accept a default route from DHCP if `ip_address` is set to `dhcp`."""
                        enabled: bool | None
                        """Enable or Shutdown the interface."""
                        speed: str | None
                        """
                        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                        <interface_speed>`.
                        """
                        peer: str | None
                        """The peer device name. Used for description and documentation."""
                        peer_interface: str | None
                        """The peer device interface. Used for description and documentation."""
                        peer_ip: str | None
                        """
                        The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                        and `ip` is an IP address.
                        """
                        bgp: Bgp
                        """Enforce IPv4 BGP peering for the peer"""
                        ipv4_acl_in: str | None
                        """
                        Name of the IPv4 access-list to be assigned in the ingress direction.
                        The access-list must be
                        defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        Required
                        for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                        `wan_carriers`.
                        """
                        ipv4_acl_out: str | None
                        """
                        Name of the IPv4 Access-list to be assigned in the egress direction.
                        The access-list must be defined
                        under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                        """
                        static_routes: list[StaticRoutesItem]
                        """Configure IPv4 static routes pointing to `peer_ip`."""
                        qos_profile: str | None
                        """QOS service profile."""
                        wan_carrier: str | None
                        """
                        The WAN carrier this interface is connected to.
                        This is used to infer the path-groups in which this
                        interface should be configured.
                        Unless the carrier is marked as 'trusted' under `wan_carriers`,
                        `ipv4_acl_in` is also required on all WAN interfaces.
                        """
                        wan_circuit_id: str | None
                        """
                        The WAN circuit ID for this interface.
                        This is not rendered in the configuration but used for WAN
                        designs.
                        """
                        connected_to_pathfinder: bool | None
                        """For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders."""
                        cv_pathfinder_internet_exit: CvPathfinderInternetExit
                        """PREVIEW: This key is in preview mode"""
                        raw_eos_cli: str | None
                        """EOS CLI rendered directly on the interface in the final EOS configuration."""
                        flow_tracking: FlowTracking
                        """Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting."""
                        structured_config: StructuredConfig
                        """Custom structured config for the Ethernet interface."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            profile: str | None | UndefinedType = Undefined,
                            name: str | UndefinedType = Undefined,
                            description: str | None | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            dhcp_ip: str | None | UndefinedType = Undefined,
                            public_ip: str | None | UndefinedType = Undefined,
                            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                            dhcp_accept_default_route: bool | None | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            speed: str | None | UndefinedType = Undefined,
                            peer: str | None | UndefinedType = Undefined,
                            peer_interface: str | None | UndefinedType = Undefined,
                            peer_ip: str | None | UndefinedType = Undefined,
                            bgp: Bgp | UndefinedType = Undefined,
                            ipv4_acl_in: str | None | UndefinedType = Undefined,
                            ipv4_acl_out: str | None | UndefinedType = Undefined,
                            static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
                            qos_profile: str | None | UndefinedType = Undefined,
                            wan_carrier: str | None | UndefinedType = Undefined,
                            wan_circuit_id: str | None | UndefinedType = Undefined,
                            connected_to_pathfinder: bool | None | UndefinedType = Undefined,
                            cv_pathfinder_internet_exit: CvPathfinderInternetExit | UndefinedType = Undefined,
                            raw_eos_cli: str | None | UndefinedType = Undefined,
                            flow_tracking: FlowTracking | UndefinedType = Undefined,
                            structured_config: StructuredConfig | UndefinedType = Undefined,
                        ) -> None:
                            """
                            L3InterfacesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                profile: L3 interface profile name. Profile defined under `l3_interface_profiles`.
                                name:
                                   Ethernet interface name like 'Ethernet2' or subinterface name like 'Ethernet2.42'.
                                   For a
                                   subinterface, the parent physical interface is automatically created.
                                description:
                                   Interface description.
                                   If not set a default description will be configured with '[<peer>[
                                   <peer_interface>]]'.
                                ip_address: Node IPv4 address/Mask or 'dhcp'.
                                dhcp_ip:
                                   When the `ip_address` is `dhcp`, this optional field allows to indicate the expected
                                   IPv4 address
                                   (without mask) to be allocated on the interface if known.
                                   This is not rendered in the configuration
                                   but can be used for substitution of 'interface_ip' in the Access-list
                                   set under `ipv4_acl_in` and
                                   `ipv4_acl_out`.
                                public_ip:
                                   Node IPv4 address (no mask).

                                   This is used to get the public IP (if known) when the device is behind
                                   NAT.
                                   This is only used for `wan_rr` routers (AutoVPN RRs and Pathfinders) to determine the Public IP
                                   with the following preference:
                                     `wan_route_servers.path_groups.interfaces.ip_address`
                                         ->
                                   `l3_interfaces.public_ip`
                                             -> `l3_interfaces.ip_address`

                                   The determined Public IP is used
                                   by WAN routers when peering with this interface.
                                encapsulation_dot1q_vlan:
                                   For subinterfaces the dot1q vlan is derived from the interface name by default, but can also be
                                   specified.
                                dhcp_accept_default_route: Accept a default route from DHCP if `ip_address` is set to `dhcp`.
                                enabled: Enable or Shutdown the interface.
                                speed:
                                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                                   <interface_speed>`.
                                peer: The peer device name. Used for description and documentation.
                                peer_interface: The peer device interface. Used for description and documentation.
                                peer_ip:
                                   The peer device IPv4 address (no mask). Used as default route gateway if `set_default_route` is true
                                   and `ip` is an IP address.
                                bgp: Enforce IPv4 BGP peering for the peer
                                ipv4_acl_in:
                                   Name of the IPv4 access-list to be assigned in the ingress direction.
                                   The access-list must be
                                   defined under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                   Required
                                   for all WAN interfaces (`wan_carrier` is set) unless the carrier is marked as 'trusted' under
                                   `wan_carriers`.
                                ipv4_acl_out:
                                   Name of the IPv4 Access-list to be assigned in the egress direction.
                                   The access-list must be defined
                                   under `ipv4_acls` and supports field substitution for "interface_ip" and "peer_ip".
                                static_routes: Configure IPv4 static routes pointing to `peer_ip`.
                                qos_profile: QOS service profile.
                                wan_carrier:
                                   The WAN carrier this interface is connected to.
                                   This is used to infer the path-groups in which this
                                   interface should be configured.
                                   Unless the carrier is marked as 'trusted' under `wan_carriers`,
                                   `ipv4_acl_in` is also required on all WAN interfaces.
                                wan_circuit_id:
                                   The WAN circuit ID for this interface.
                                   This is not rendered in the configuration but used for WAN
                                   designs.
                                connected_to_pathfinder: For a WAN interface (`wan_carrier` is set), allow to disable the static tunnel towards Pathfinders.
                                cv_pathfinder_internet_exit: PREVIEW: This key is in preview mode
                                raw_eos_cli: EOS CLI rendered directly on the interface in the final EOS configuration.
                                flow_tracking: Configures flow-tracking on the interface. Overrides `fabric_flow_tracking.l3_interfaces` setting.
                                structured_config: Custom structured config for the Ethernet interface.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class L3Interfaces(AvdCollection[str, L3InterfacesItem]):
                        _primary_key: ClassVar[str] = "name"

                    L3Interfaces._item_type = L3InterfacesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "downlink_pools": {"type": list, "items": DownlinkPoolsItem},
                        "id": {"type": int},
                        "platform": {"type": str},
                        "mac_address": {"type": str},
                        "system_mac_address": {"type": str},
                        "serial_number": {"type": str},
                        "rack": {"type": str},
                        "mgmt_ip": {"type": str},
                        "mgmt_gateway": {"type": str},
                        "ipv6_mgmt_ip": {"type": str},
                        "ipv6_mgmt_gateway": {"type": str},
                        "mgmt_interface": {"type": str},
                        "link_tracking": {"type": LinkTracking},
                        "lacp_port_id_range": {"type": LacpPortIdRange},
                        "always_configure_ip_routing": {"type": bool, "default": False},
                        "raw_eos_cli": {"type": str},
                        "structured_config": {"type": StructuredConfig},
                        "uplink_type": {"type": str, "default": "p2p"},
                        "uplink_ipv4_pool": {"type": str},
                        "uplink_interfaces": {"type": list, "items": str},
                        "uplink_switch_interfaces": {"type": list, "items": str},
                        "uplink_switches": {"type": list, "items": str},
                        "uplink_interface_speed": {"type": str},
                        "uplink_switch_interface_speed": {"type": str},
                        "uplink_mtu": {"type": int},
                        "max_uplink_switches": {"type": int},
                        "max_parallel_uplinks": {"type": int},
                        "uplink_bfd": {"type": bool, "default": False},
                        "uplink_native_vlan": {"type": int},
                        "uplink_ptp": {"type": UplinkPtp},
                        "uplink_macsec": {"type": UplinkMacsec},
                        "uplink_port_channel_id": {"type": int},
                        "uplink_switch_port_channel_id": {"type": int},
                        "uplink_structured_config": {"type": dict},
                        "mlag_port_channel_structured_config": {"type": MlagPortChannelStructuredConfig},
                        "mlag_peer_vlan_structured_config": {"type": MlagPeerVlanStructuredConfig},
                        "mlag_peer_l3_vlan_structured_config": {"type": MlagPeerL3VlanStructuredConfig},
                        "short_esi": {"type": str},
                        "isis_system_id_prefix": {"type": str},
                        "isis_maximum_paths": {"type": int},
                        "is_type": {"type": str, "default": "level-2"},
                        "node_sid_base": {"type": int, "default": 0},
                        "loopback_ipv4_pool": {"type": str},
                        "loopback_ipv4_address": {"type": str},
                        "vtep_loopback_ipv4_pool": {"type": str},
                        "vtep_loopback_ipv4_address": {"type": str},
                        "loopback_ipv4_offset": {"type": int, "default": 0},
                        "loopback_ipv6_pool": {"type": str},
                        "loopback_ipv6_offset": {"type": int, "default": 0},
                        "vtep": {"type": bool},
                        "vtep_loopback": {"type": str},
                        "bgp_as": {"type": str},
                        "bgp_defaults": {"type": list, "items": str},
                        "evpn_role": {"type": str},
                        "evpn_route_servers": {"type": list, "items": str},
                        "evpn_services_l2_only": {"type": bool, "default": False},
                        "filter": {"type": Filter},
                        "igmp_snooping_enabled": {"type": bool, "default": True},
                        "evpn_gateway": {"type": EvpnGateway},
                        "ipvpn_gateway": {"type": IpvpnGateway},
                        "mlag": {"type": bool, "default": True},
                        "mlag_dual_primary_detection": {"type": bool, "default": False},
                        "mlag_ibgp_origin_incomplete": {"type": bool, "default": True},
                        "mlag_interfaces": {"type": list, "items": str},
                        "mlag_interfaces_speed": {"type": str},
                        "mlag_peer_l3_vlan": {"type": int, "default": 4093},
                        "mlag_peer_l3_ipv4_pool": {"type": str},
                        "mlag_peer_vlan": {"type": int, "default": 4094},
                        "mlag_peer_link_allowed_vlans": {"type": str},
                        "mlag_peer_address_family": {"type": str, "default": "ipv4"},
                        "mlag_peer_ipv4_pool": {"type": str},
                        "mlag_peer_ipv6_pool": {"type": str},
                        "mlag_port_channel_id": {"type": int},
                        "mlag_domain_id": {"type": str},
                        "spanning_tree_mode": {"type": str},
                        "spanning_tree_priority": {"type": int, "default": 32768},
                        "spanning_tree_root_super": {"type": bool, "default": False},
                        "virtual_router_mac_address": {"type": str},
                        "inband_mgmt_interface": {"type": str},
                        "inband_mgmt_vlan": {"type": int, "default": 4092},
                        "inband_mgmt_subnet": {"type": str},
                        "inband_mgmt_ip": {"type": str},
                        "inband_mgmt_gateway": {"type": str},
                        "inband_mgmt_ipv6_address": {"type": str},
                        "inband_mgmt_ipv6_subnet": {"type": str},
                        "inband_mgmt_ipv6_gateway": {"type": str},
                        "inband_mgmt_description": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vlan_name": {"type": str, "default": "Inband Management"},
                        "inband_mgmt_vrf": {"type": str, "default": "default"},
                        "inband_mgmt_mtu": {"type": int, "default": 1500},
                        "inband_ztp": {"type": bool, "default": False},
                        "inband_ztp_lacp_fallback_delay": {"type": int, "default": 30},
                        "mpls_overlay_role": {"type": str},
                        "overlay_address_families": {"type": list, "items": str},
                        "mpls_route_reflectors": {"type": list, "items": str},
                        "bgp_cluster_id": {"type": str},
                        "ptp": {"type": Ptp},
                        "wan_role": {"type": str},
                        "cv_pathfinder_transit_mode": {"type": str},
                        "cv_pathfinder_region": {"type": str},
                        "cv_pathfinder_site": {"type": str},
                        "wan_ha": {"type": WanHa},
                        "dps_mss_ipv4": {"type": str, "default": "auto"},
                        "l3_interfaces": {"type": L3Interfaces},
                        "data_plane_cpu_allocation_max": {"type": int},
                        "flow_tracker_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """The Node Name is used as "hostname"."""
                    downlink_pools: list[DownlinkPoolsItem]
                    """
                    IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                    with `uplink_ipv4_pool` set on the downlink switch.
                    """
                    id: int | None
                    """Unique identifier used for IP addressing and other algorithms."""
                    platform: str | None
                    """Arista platform family."""
                    mac_address: str | None
                    """Leverage to document management interface mac address."""
                    system_mac_address: str | None
                    """
                    System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                    Set to the same MAC address as
                    available in "show version" on the device.
                    "system_mac_address" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    serial_number: str | None
                    """
                    Set to the Serial Number of the device.
                    Only used for documentation purpose in the fabric
                    documentation and part of the structured_config.
                    "serial_number" can also be set directly as a
                    hostvar.
                    If both are set, the setting under node type settings takes precedence.
                    """
                    rack: str | None
                    """Rack that the switch is located in (only used in snmp_settings location)."""
                    mgmt_ip: str | None
                    """Node management interface IPv4 address."""
                    mgmt_gateway: str | None
                    """
                    This key sets the management gateway for the device. It takes precedence over the global
                    `mgmt_gateway`.
                    """
                    ipv6_mgmt_ip: str | None
                    """Node management interface IPv6 address."""
                    ipv6_mgmt_gateway: str | None
                    """
                    This key sets the ipv6 management gateway for the device. It takes precedence over the global
                    `ipv6_mgmt_gateway`.
                    """
                    mgmt_interface: str | None
                    """
                    Management Interface Name.
                    Default -> platform_management_interface -> mgmt_interface ->
                    "Management1".
                    """
                    link_tracking: LinkTracking
                    """
                    This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                    the upstream interfaces.
                    Useful in EVPN multhoming designs.
                    """
                    lacp_port_id_range: LacpPortIdRange
                    """
                    This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                    number of nodes in the "node_group".
                    Unique LACP port-id ranges are recommended for EVPN Multihoming
                    designs.
                    """
                    always_configure_ip_routing: bool | None
                    """
                    Force configuration of "ip routing" even on L2 devices.
                    Use this to retain behavior of AVD versions
                    below 4.0.0.
                    """
                    raw_eos_cli: str | None
                    """EOS CLI rendered directly on the root level of the final EOS configuration."""
                    structured_config: StructuredConfig
                    """Custom structured config for eos_cli_config_gen."""
                    uplink_type: str | None
                    """
                    Override the default `uplink_type` set at the `node_type_key` level.
                    `uplink_type` must be "p2p" if
                    `vtep` or `underlay_router` is true for the `node_type_key` definition.
                    """
                    uplink_ipv4_pool: str | None
                    """IPv4 subnet to use to connect to uplink switches."""
                    uplink_interfaces: list[str]
                    """
                    Local uplink interfaces.
                    Each list item supports range syntax that can be expanded into a list of
                    interfaces.
                    If uplink_interfaces is not defined, platform-specific defaults (defined under
                    default_interfaces) will be used instead.
                    Please note that default_interfaces are not defined by
                    default, you should define these yourself.
                    """
                    uplink_switch_interfaces: list[str]
                    """Interfaces located on uplink switches."""
                    uplink_switches: list[str]
                    uplink_interface_speed: str | None
                    """
                    Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                    (Uplink switch
                    interface speed can be overridden with `uplink_switch_interface_speed`).
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_switch_interface_speed: str | None
                    """
                    Set point-to-Point interface speed for the uplink switch interface only.
                    Speed should be set in the
                    format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                    """
                    uplink_mtu: int | None
                    """Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting."""
                    max_uplink_switches: int | None
                    """
                    Maximum number of uplink switches.
                    Changing this value may change IP Addressing on uplinks.
                    Can be
                    used to reserve IP space for future expansions.
                    """
                    max_parallel_uplinks: int | None
                    """
                    Number of parallel links towards uplink switches.
                    Changing this value may change interface naming on
                    uplinks (and corresponding downlinks).
                    Can be used to reserve interfaces for future parallel
                    uplinks.
                    """
                    uplink_bfd: bool | None
                    """Enable bfd on uplink interfaces."""
                    uplink_native_vlan: int | None
                    """
                    Only applicable to switches with layer-2 port-channel uplinks.
                    A suspended (disabled) vlan will be
                    created in both ends of the link unless the vlan is defined under network services.
                    By default the
                    uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                    """
                    uplink_ptp: UplinkPtp
                    """Enable PTP on all infrastructure links."""
                    uplink_macsec: UplinkMacsec
                    """Enable MacSec on all uplinks."""
                    uplink_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink Port-channel
                    ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                    For
                    example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [ Eth11/1, Eth22/1 ] -> ID 111
                    For
                    MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                    This
                    option overrides the default behavior and statically sets the local Port-channel ID.
                    Note! Make sure
                    the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                    value.
                    """
                    uplink_switch_port_channel_id: int | None
                    """
                    Only applicable for L2 switches with `uplink_type: port-channel`.
                    By default the uplink switch Port-
                    channel ID will be set to the number of the first interface defined under
                    `uplink_switch_interfaces`.
                    For example:
                      member ports [ Eth22, Eth23 ] -> ID 22
                      member ports [
                    Eth11/1, Eth22/1 ] -> ID 111
                    For MLAG port-channels ID will be based on the lowest member interface
                    on the first MLAG switch.
                    This option overrides the default behavior and statically sets the Port-
                    channel ID on the uplink switch.
                    Note! Make sure the ID is unique and does not overlap with
                    autogenerated Port-channel IDs in the Network Services.
                    Note! For MLAG pairs the ID must be between
                    1 and 2000 and both MLAG switches must have the same value.
                    """
                    uplink_structured_config: dict
                    """
                    Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                    When
                    uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                    for eos_cli_config_gen overrides the settings on the ethernet interface level.
                    When uplink_type ==
                    "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                    eos_cli_config_gen overrides the settings on the port-channel interface level.
                    "uplink_structured_config" is applied after "structured_config", so it can override
                    "structured_config" defined on node-level.
                    Note! The content of this dictionary is _not_ validated
                    by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                    """
                    mlag_port_channel_structured_config: MlagPortChannelStructuredConfig
                    """
                    Custom structured config applied to MLAG peer link port-channel id.
                    Added under
                    port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the
                    port-channel interface level.
                    "mlag_port_channel_structured_config" is applied after
                    "structured_config", so it can override "structured_config" defined on node-level.
                    """
                    mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig
                    """
                    Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                    override "structured_config" defined on node-level.
                    """
                    mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig
                    """
                    Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                    Added under
                    vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                    Overrides the settings on the vlan
                    interface level.
                    "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                    can override "structured_config" defined on node-level.
                    """
                    short_esi: str | None
                    """
                    short_esi only valid for l2leaf devices using port-channel uplink.
                    Setting short_esi to "auto"
                    generates the short_esi automatically using a hash of configuration elements.
                    < 0000:0000:0000 |
                    auto >.
                    """
                    isis_system_id_prefix: str | None
                    """(4.4 hexadecimal)."""
                    isis_maximum_paths: int | None
                    """Number of path to configure in ECMP for ISIS."""
                    is_type: str | None
                    node_sid_base: int | None
                    """Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID."""
                    loopback_ipv4_pool: str | None
                    """IPv4 subnet for Loopback0 allocation."""
                    loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for Loopback0.
                    When set, it takes precedence over `loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                    """
                    vtep_loopback_ipv4_pool: str | None
                    """IPv4 subnet for VTEP-Loopback allocation."""
                    vtep_loopback_ipv4_address: str | None
                    """
                    IPv4 address without mask for VTEP-Loopback.
                    When set, it takes precedence over
                    `vtep_loopback_ipv4_pool`.
                    Note: AVD does not check for validity of the IPv4 address and does not
                    catch duplicates.
                    """
                    loopback_ipv4_offset: int | None
                    """
                    Offset all assigned loopback IP addresses.
                    Required when the < loopback_ipv4_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                    """
                    loopback_ipv6_pool: str | None
                    """IPv6 subnet for Loopback0 allocation."""
                    loopback_ipv6_offset: int | None
                    """
                    Offset all assigned loopback IPv6 addresses.
                    Required when the < loopback_ipv6_pool > is same for 2
                    different node_types (like spine and l3leaf) to avoid overlapping IPs.
                    For example, set the minimum
                    offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                    """
                    vtep: bool | None
                    """
                    Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                    Overrides VTEP
                    setting inherited from node_type_keys.
                    """
                    vtep_loopback: str | None
                    """Set VXLAN source interface."""
                    bgp_as: str | None
                    """
                    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                    For asdot notation in
                    YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                    number.
                    Required with eBGP.
                    """
                    bgp_defaults: list[str]
                    """List of EOS commands to apply to BGP daemon."""
                    evpn_role: str | None
                    """
                    Acting role in EVPN control plane.
                    Default is set in node_type definition from node_type_keys.
                    """
                    evpn_route_servers: list[str]
                    """List of nodes acting as EVPN Route-Servers / Route-Reflectors."""
                    evpn_services_l2_only: bool | None
                    """
                    Possibility to prevent configuration of Tenant VRFs and SVIs.
                    Override node definition
                    "network_services_l3" from node_type_keys.
                    This allows support for centralized routing.
                    """
                    filter: Filter
                    """
                    Filter L3 and L2 network services based on tenant and tags (and operation filter).
                    If filter is not
                    defined it will default to all.
                    """
                    igmp_snooping_enabled: bool | None
                    """Activate or deactivate IGMP snooping on device level."""
                    evpn_gateway: EvpnGateway
                    """
                    Node is acting as EVPN Multi-Domain Gateway.
                    New BGP peer-group is generated between EVPN GWs in
                    different domains or between GWs and Route Servers.
                    Name can be changed under
                    "bgp_peer_groups.evpn_overlay_core" variable.
                    L3 rechability for different EVPN GWs must be already
                    in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                    same Ansible inventory.
                    """
                    ipvpn_gateway: IpvpnGateway
                    """
                    Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                    this is "bgp_peer_groups.ipvpn_gateway_peers".
                    L3 Reachability is required for this to work, the
                    preferred method to establish underlay connectivity is to use core_interfaces.
                    """
                    mlag: bool | None
                    """Enable / Disable auto MLAG, when two nodes are defined in node group."""
                    mlag_dual_primary_detection: bool | None
                    """Enable / Disable MLAG dual primary detection."""
                    mlag_ibgp_origin_incomplete: bool | None
                    """
                    Set origin of routes received from MLAG iBGP peer to incomplete.
                    The purpose is to optimize routing
                    for leaf loopbacks from spine perspective and
                    avoid suboptimal routing via peerlink for control
                    plane traffic.
                    """
                    mlag_interfaces: list[str]
                    """
                    Each list item supports range syntax that can be expanded into a list of interfaces.
                    Required when
                    MLAG leafs are present in the topology.
                    """
                    mlag_interfaces_speed: str | None
                    """
                    Set MLAG interface speed.
                    Speed should be set in the format `<interface_speed>` or `forced
                    <interface_speed>` or `auto <interface_speed>`.
                    """
                    mlag_peer_l3_vlan: int | None
                    """
                    Underlay L3 peering SVI interface id.
                    If set to 0 or the same vlan as mlag_peer_vlan, the
                    mlag_peer_vlan will be used for L3 peering.
                    """
                    mlag_peer_l3_ipv4_pool: str | None
                    """
                    IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                    Required when
                    MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                    """
                    mlag_peer_vlan: int | None
                    """MLAG Peer Link (control link) SVI interface id."""
                    mlag_peer_link_allowed_vlans: str | None
                    mlag_peer_address_family: str | None
                    """
                    IP address family used to establish MLAG Peer Link (control link).
                    `ipv6` requires EOS version
                    4.31.1F or higher.
                    Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                    (ex. `mlag_peer_l3_vlan` set to 4094).
                    """
                    mlag_peer_ipv4_pool: str | None
                    """
                    IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                    """
                    mlag_peer_ipv6_pool: str | None
                    """
                    IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                    Required
                    for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                    """
                    mlag_port_channel_id: int | None
                    """
                    If not set, the mlag port-channel id is generated based on the digits of the first interface present
                    in 'mlag_interfaces'.
                    Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                    999999 > for EOS >= 4.25.0F.
                    """
                    mlag_domain_id: str | None
                    """MLAG Domain ID. If not set the node group name (Set with "group" key) will be used."""
                    spanning_tree_mode: str | None
                    spanning_tree_priority: int | None
                    """
                    Spanning-tree priority configured for the selected mode.
                    For `rapid-pvst` the priority can also be
                    set per VLAN under network services.
                    """
                    spanning_tree_root_super: bool | None
                    virtual_router_mac_address: str | None
                    """Virtual router mac address for anycast gateway."""
                    inband_mgmt_interface: str | None
                    """
                    Pointer to interface used for inband management.
                    All configuration must be done using other data
                    models like network services or structured_config.
                    'inband_mgmt_interface' is only used to refer to
                    this interface as source in various management protocol settings (future feature).

                    On L2 switches,
                    this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                    """
                    inband_mgmt_vlan: int | None
                    """
                    VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                    uplinks).
                    When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                    switch as well as all 'uplink_switches'.
                    When using 'inband_mgmt_ip' the VLAN and SVI will only be
                    created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                    created using network services data models.
                    """
                    inband_mgmt_subnet: str | None
                    """
                    Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                    ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      : <subnet> +
                    2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       :
                    <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than total l2leafs + 5
                    Setting is ignored if 'inband_mgmt_ip' is set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ip: str | None
                    """
                    IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                    If this is set the
                    VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN and SVI on
                    the parent switches must be created using network services data models.

                    This setting is applicable
                    to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                    is derived from 'inband_mgmt_subnet' if set.

                    This setting is applicable to L2 switches (switches
                    using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_address: str | None
                    """
                    IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                    This overrides
                    'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                    If this
                    is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                    The VLAN
                    and SVI on the parent switches must be created using network services data models.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_subnet: str | None
                    """
                    Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                    as uplinks).
                    Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                    on ARP.
                    This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                    extension.
                    SVI IP address will be assigned as follows:
                    virtual-router: <subnet> + 1
                    l3leaf A      :
                    <subnet> + 2 (same IP on all l3leaf A)
                    l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                    l2leafs       : <subnet> + 3 + <l2leaf id>
                    GW on l2leafs : <subnet> + 1
                    Assign range larger than
                    total l2leafs + 5

                    Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_ipv6_gateway: str | None
                    """
                    Default gateway configured in the 'inband_mgmt_vrf'.
                    Used when `inband_mgmt_ipv6_address` is set.
                    Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                    This setting is
                    applicable to L2 switches (switches using port-channel trunks as uplinks).
                    """
                    inband_mgmt_description: str | None
                    """
                    Description configured on the Inband Management SVI.

                    This setting is only applied on the devices
                    where it is set, it does not automatically affect any parent/child devices configuration, so it must
                    be set on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vlan_name: str | None
                    """
                    Name configured on the Inband Management VLAN.
                    This setting is only applied on the devices where it
                    is set, it does not automatically affect any parent/child devices configuration, so it must be set
                    on each applicable node/node-group/node-type as needed.
                    """
                    inband_mgmt_vrf: str | None
                    """
                    VRF configured on the Inband Management Interface.
                    The VRF is created if not already created by
                    other means.
                    This setting is only applied on the devices where it is set, it does not automatically
                    affect any parent/child devices configuration, so it must be set on each applicable node/node-
                    group/node-type as needed.
                    """
                    inband_mgmt_mtu: int | None
                    """
                    MTU configured on the Inband Management Interface.
                    This setting is only applied on the devices where
                    it is set, it does not automatically affect any parent/child devices configuration, so it must be
                    set on each applicable node/node-group/node-type as needed.
                    """
                    inband_ztp: bool | None
                    """
                    Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                    inband.
                    This setting also requires that the `inband_mgmt_vlan` is set for the node.
                    """
                    inband_ztp_lacp_fallback_delay: int | None
                    """
                    Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                    ZTP node.
                    This setting also requires that `inband_ztp` is set for the node.
                    """
                    mpls_overlay_role: str | None
                    """
                    Set the default mpls overlay role.
                    Acting role in overlay control plane.
                    """
                    overlay_address_families: list[str]
                    """Set the default overlay address families."""
                    mpls_route_reflectors: list[str]
                    """List of inventory hostname acting as MPLS route-reflectors."""
                    bgp_cluster_id: str | None
                    """Set BGP cluster id."""
                    ptp: Ptp
                    wan_role: str | None
                    """
                    Override the default WAN role.

                    This is used both for AutoVPN and Pathfinder designs.
                    That means if
                    `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                    `server` indicates that the
                    router is a route-reflector.

                    Only supported if `overlay_routing_protocol` is set to `ibgp`.
                    """
                    cv_pathfinder_transit_mode: str | None
                    """
                    Configure the transit mode for a WAN client for CV Pathfinder designs
                    only when the `wan_mode` root
                    key is set to `cv_pathfinder`.

                    'zone' is currently not supported.
                    """
                    cv_pathfinder_region: str | None
                    """
                    The CV Pathfinder region name.
                    This key is required for WAN routers but optional for pathfinders.
                    The region name must be defined under 'cv_pathfinder_regions'.
                    """
                    cv_pathfinder_site: str | None
                    """
                    The CV Pathfinder site name.
                    This key is required for WAN routers but optional for pathfinders.
                    For
                    WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                    relevant region under 'cv_pathfinder_regions'.
                    For pathfinders without `cv_pathfinder_region` set,
                    the site must be defined under `cv_pathfinder_global_sites`.
                    """
                    wan_ha: WanHa
                    """
                    PREVIEW: This key is currently not supported

                    The key is supported only if `wan_mode` == `cv-
                    pathfinder`.
                    AutoVPN support is still to be determined.

                    Maximum 2 devices supported by group for
                    HA.
                    """
                    dps_mss_ipv4: str | None
                    """IPv4 MSS value configured under "router path-selection" on WAN Devices."""
                    l3_interfaces: L3Interfaces
                    """
                    L3 Interfaces to configure on the node.
                    Used to define the node for WAN interfaces when
                    `wan_carrier` is set.
                    """
                    data_plane_cpu_allocation_max: int | None
                    """
                    Set the maximum number of CPU used for the data plane.
                    This setting is useful on virtual Route
                    Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                    """
                    flow_tracker_type: str | None
                    """
                    Set the flow tracker type.
                    Override the `default_flow_tracker_type`` set at the `node_type_key`
                    level.
                    `default_flow_tracker_type` default value is `sampled`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        downlink_pools: list[DownlinkPoolsItem] | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        platform: str | None | UndefinedType = Undefined,
                        mac_address: str | None | UndefinedType = Undefined,
                        system_mac_address: str | None | UndefinedType = Undefined,
                        serial_number: str | None | UndefinedType = Undefined,
                        rack: str | None | UndefinedType = Undefined,
                        mgmt_ip: str | None | UndefinedType = Undefined,
                        mgmt_gateway: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_ip: str | None | UndefinedType = Undefined,
                        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
                        mgmt_interface: str | None | UndefinedType = Undefined,
                        link_tracking: LinkTracking | UndefinedType = Undefined,
                        lacp_port_id_range: LacpPortIdRange | UndefinedType = Undefined,
                        always_configure_ip_routing: bool | None | UndefinedType = Undefined,
                        raw_eos_cli: str | None | UndefinedType = Undefined,
                        structured_config: StructuredConfig | UndefinedType = Undefined,
                        uplink_type: str | None | UndefinedType = Undefined,
                        uplink_ipv4_pool: str | None | UndefinedType = Undefined,
                        uplink_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switch_interfaces: list[str] | UndefinedType = Undefined,
                        uplink_switches: list[str] | UndefinedType = Undefined,
                        uplink_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_switch_interface_speed: str | None | UndefinedType = Undefined,
                        uplink_mtu: int | None | UndefinedType = Undefined,
                        max_uplink_switches: int | None | UndefinedType = Undefined,
                        max_parallel_uplinks: int | None | UndefinedType = Undefined,
                        uplink_bfd: bool | None | UndefinedType = Undefined,
                        uplink_native_vlan: int | None | UndefinedType = Undefined,
                        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
                        uplink_macsec: UplinkMacsec | UndefinedType = Undefined,
                        uplink_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_switch_port_channel_id: int | None | UndefinedType = Undefined,
                        uplink_structured_config: dict | UndefinedType = Undefined,
                        mlag_port_channel_structured_config: MlagPortChannelStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_vlan_structured_config: MlagPeerVlanStructuredConfig | UndefinedType = Undefined,
                        mlag_peer_l3_vlan_structured_config: MlagPeerL3VlanStructuredConfig | UndefinedType = Undefined,
                        short_esi: str | None | UndefinedType = Undefined,
                        isis_system_id_prefix: str | None | UndefinedType = Undefined,
                        isis_maximum_paths: int | None | UndefinedType = Undefined,
                        is_type: str | None | UndefinedType = Undefined,
                        node_sid_base: int | None | UndefinedType = Undefined,
                        loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_pool: str | None | UndefinedType = Undefined,
                        vtep_loopback_ipv4_address: str | None | UndefinedType = Undefined,
                        loopback_ipv4_offset: int | None | UndefinedType = Undefined,
                        loopback_ipv6_pool: str | None | UndefinedType = Undefined,
                        loopback_ipv6_offset: int | None | UndefinedType = Undefined,
                        vtep: bool | None | UndefinedType = Undefined,
                        vtep_loopback: str | None | UndefinedType = Undefined,
                        bgp_as: str | None | UndefinedType = Undefined,
                        bgp_defaults: list[str] | UndefinedType = Undefined,
                        evpn_role: str | None | UndefinedType = Undefined,
                        evpn_route_servers: list[str] | UndefinedType = Undefined,
                        evpn_services_l2_only: bool | None | UndefinedType = Undefined,
                        filter: Filter | UndefinedType = Undefined,
                        igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
                        evpn_gateway: EvpnGateway | UndefinedType = Undefined,
                        ipvpn_gateway: IpvpnGateway | UndefinedType = Undefined,
                        mlag: bool | None | UndefinedType = Undefined,
                        mlag_dual_primary_detection: bool | None | UndefinedType = Undefined,
                        mlag_ibgp_origin_incomplete: bool | None | UndefinedType = Undefined,
                        mlag_interfaces: list[str] | UndefinedType = Undefined,
                        mlag_interfaces_speed: str | None | UndefinedType = Undefined,
                        mlag_peer_l3_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_l3_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_vlan: int | None | UndefinedType = Undefined,
                        mlag_peer_link_allowed_vlans: str | None | UndefinedType = Undefined,
                        mlag_peer_address_family: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv4_pool: str | None | UndefinedType = Undefined,
                        mlag_peer_ipv6_pool: str | None | UndefinedType = Undefined,
                        mlag_port_channel_id: int | None | UndefinedType = Undefined,
                        mlag_domain_id: str | None | UndefinedType = Undefined,
                        spanning_tree_mode: str | None | UndefinedType = Undefined,
                        spanning_tree_priority: int | None | UndefinedType = Undefined,
                        spanning_tree_root_super: bool | None | UndefinedType = Undefined,
                        virtual_router_mac_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_interface: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan: int | None | UndefinedType = Undefined,
                        inband_mgmt_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ip: str | None | UndefinedType = Undefined,
                        inband_mgmt_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_address: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_subnet: str | None | UndefinedType = Undefined,
                        inband_mgmt_ipv6_gateway: str | None | UndefinedType = Undefined,
                        inband_mgmt_description: str | None | UndefinedType = Undefined,
                        inband_mgmt_vlan_name: str | None | UndefinedType = Undefined,
                        inband_mgmt_vrf: str | None | UndefinedType = Undefined,
                        inband_mgmt_mtu: int | None | UndefinedType = Undefined,
                        inband_ztp: bool | None | UndefinedType = Undefined,
                        inband_ztp_lacp_fallback_delay: int | None | UndefinedType = Undefined,
                        mpls_overlay_role: str | None | UndefinedType = Undefined,
                        overlay_address_families: list[str] | UndefinedType = Undefined,
                        mpls_route_reflectors: list[str] | UndefinedType = Undefined,
                        bgp_cluster_id: str | None | UndefinedType = Undefined,
                        ptp: Ptp | UndefinedType = Undefined,
                        wan_role: str | None | UndefinedType = Undefined,
                        cv_pathfinder_transit_mode: str | None | UndefinedType = Undefined,
                        cv_pathfinder_region: str | None | UndefinedType = Undefined,
                        cv_pathfinder_site: str | None | UndefinedType = Undefined,
                        wan_ha: WanHa | UndefinedType = Undefined,
                        dps_mss_ipv4: str | None | UndefinedType = Undefined,
                        l3_interfaces: L3Interfaces | UndefinedType = Undefined,
                        data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined,
                        flow_tracker_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NodesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: The Node Name is used as "hostname".
                            downlink_pools:
                               IPv4 pools used for links to downlink switches. Set this on the parent switch. Cannot be combined
                               with `uplink_ipv4_pool` set on the downlink switch.
                            id: Unique identifier used for IP addressing and other algorithms.
                            platform: Arista platform family.
                            mac_address: Leverage to document management interface mac address.
                            system_mac_address:
                               System MAC Address in this following format: "xx:xx:xx:xx:xx:xx".
                               Set to the same MAC address as
                               available in "show version" on the device.
                               "system_mac_address" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            serial_number:
                               Set to the Serial Number of the device.
                               Only used for documentation purpose in the fabric
                               documentation and part of the structured_config.
                               "serial_number" can also be set directly as a
                               hostvar.
                               If both are set, the setting under node type settings takes precedence.
                            rack: Rack that the switch is located in (only used in snmp_settings location).
                            mgmt_ip: Node management interface IPv4 address.
                            mgmt_gateway:
                               This key sets the management gateway for the device. It takes precedence over the global
                               `mgmt_gateway`.
                            ipv6_mgmt_ip: Node management interface IPv6 address.
                            ipv6_mgmt_gateway:
                               This key sets the ipv6 management gateway for the device. It takes precedence over the global
                               `ipv6_mgmt_gateway`.
                            mgmt_interface:
                               Management Interface Name.
                               Default -> platform_management_interface -> mgmt_interface ->
                               "Management1".
                            link_tracking:
                               This configures the Link Tracking Group on a switch as well as adds the p2p-uplinks of the switch as
                               the upstream interfaces.
                               Useful in EVPN multhoming designs.
                            lacp_port_id_range:
                               This will generate the "lacp port-id range", "begin" and "end" values based on node "id" and the
                               number of nodes in the "node_group".
                               Unique LACP port-id ranges are recommended for EVPN Multihoming
                               designs.
                            always_configure_ip_routing:
                               Force configuration of "ip routing" even on L2 devices.
                               Use this to retain behavior of AVD versions
                               below 4.0.0.
                            raw_eos_cli: EOS CLI rendered directly on the root level of the final EOS configuration.
                            structured_config: Custom structured config for eos_cli_config_gen.
                            uplink_type:
                               Override the default `uplink_type` set at the `node_type_key` level.
                               `uplink_type` must be "p2p" if
                               `vtep` or `underlay_router` is true for the `node_type_key` definition.
                            uplink_ipv4_pool: IPv4 subnet to use to connect to uplink switches.
                            uplink_interfaces:
                               Local uplink interfaces.
                               Each list item supports range syntax that can be expanded into a list of
                               interfaces.
                               If uplink_interfaces is not defined, platform-specific defaults (defined under
                               default_interfaces) will be used instead.
                               Please note that default_interfaces are not defined by
                               default, you should define these yourself.
                            uplink_switch_interfaces: Interfaces located on uplink switches.
                            uplink_switches: uplink_switches
                            uplink_interface_speed:
                               Set point-to-Point interface speed and will apply to uplink interfaces on both ends.
                               (Uplink switch
                               interface speed can be overridden with `uplink_switch_interface_speed`).
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_switch_interface_speed:
                               Set point-to-Point interface speed for the uplink switch interface only.
                               Speed should be set in the
                               format `<interface_speed>` or `forced <interface_speed>` or `auto <interface_speed>`.
                            uplink_mtu: Point-to-Point uplinks MTU in bytes. This setting overrides the `p2p_uplinks_mtu` setting.
                            max_uplink_switches:
                               Maximum number of uplink switches.
                               Changing this value may change IP Addressing on uplinks.
                               Can be
                               used to reserve IP space for future expansions.
                            max_parallel_uplinks:
                               Number of parallel links towards uplink switches.
                               Changing this value may change interface naming on
                               uplinks (and corresponding downlinks).
                               Can be used to reserve interfaces for future parallel
                               uplinks.
                            uplink_bfd: Enable bfd on uplink interfaces.
                            uplink_native_vlan:
                               Only applicable to switches with layer-2 port-channel uplinks.
                               A suspended (disabled) vlan will be
                               created in both ends of the link unless the vlan is defined under network services.
                               By default the
                               uplink will not have a native_vlan configured, so EOS defaults to vlan 1.
                            uplink_ptp: Enable PTP on all infrastructure links.
                            uplink_macsec: Enable MacSec on all uplinks.
                            uplink_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink Port-channel
                               ID will be set to the number of the lowest member interface defined under `uplink_interfaces`.
                               For
                               example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [ Eth11/1, Eth22/1 ] -> ID 111
                               For
                               MLAG port-channels ID will be based on the lowest member interface on the first MLAG switch.
                               This
                               option overrides the default behavior and statically sets the local Port-channel ID.
                               Note! Make sure
                               the ID is unique and does not overlap with autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between 1 and 2000 and both MLAG switches must have the same
                               value.
                            uplink_switch_port_channel_id:
                               Only applicable for L2 switches with `uplink_type: port-channel`.
                               By default the uplink switch Port-
                               channel ID will be set to the number of the first interface defined under
                               `uplink_switch_interfaces`.
                               For example:
                                 member ports [ Eth22, Eth23 ] -> ID 22
                                 member ports [
                               Eth11/1, Eth22/1 ] -> ID 111
                               For MLAG port-channels ID will be based on the lowest member interface
                               on the first MLAG switch.
                               This option overrides the default behavior and statically sets the Port-
                               channel ID on the uplink switch.
                               Note! Make sure the ID is unique and does not overlap with
                               autogenerated Port-channel IDs in the Network Services.
                               Note! For MLAG pairs the ID must be between
                               1 and 2000 and both MLAG switches must have the same value.
                            uplink_structured_config:
                               Custom structured config applied to "uplink_interfaces", and "uplink_switch_interfaces".
                               When
                               uplink_type == "p2p", custom structured config added under ethernet_interfaces.[name=<interface>]
                               for eos_cli_config_gen overrides the settings on the ethernet interface level.
                               When uplink_type ==
                               "port-channel", custom structured config added under port_channel_interfaces.[name=<interface>] for
                               eos_cli_config_gen overrides the settings on the port-channel interface level.
                               "uplink_structured_config" is applied after "structured_config", so it can override
                               "structured_config" defined on node-level.
                               Note! The content of this dictionary is _not_ validated
                               by the schema, since it can be either ethernet_interfaces or port_channel_interfaces.
                            mlag_port_channel_structured_config:
                               Custom structured config applied to MLAG peer link port-channel id.
                               Added under
                               port_channel_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the
                               port-channel interface level.
                               "mlag_port_channel_structured_config" is applied after
                               "structured_config", so it can override "structured_config" defined on node-level.
                            mlag_peer_vlan_structured_config:
                               Custom structured config applied to MLAG Peer Link (control link) SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_vlan_structured_config" is applied after "structured_config", so it can
                               override "structured_config" defined on node-level.
                            mlag_peer_l3_vlan_structured_config:
                               Custom structured config applied to MLAG underlay L3 peering SVI interface id.
                               Added under
                               vlan_interfaces.[name=<interface>] for eos_cli_config_gen.
                               Overrides the settings on the vlan
                               interface level.
                               "mlag_peer_l3_vlan_structured_config" is applied after "structured_config", so it
                               can override "structured_config" defined on node-level.
                            short_esi:
                               short_esi only valid for l2leaf devices using port-channel uplink.
                               Setting short_esi to "auto"
                               generates the short_esi automatically using a hash of configuration elements.
                               < 0000:0000:0000 |
                               auto >.
                            isis_system_id_prefix: (4.4 hexadecimal).
                            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
                            is_type: is_type
                            node_sid_base: Node-SID base for isis-sr underlay variants. Combined with node id to generate ISIS-SR node-SID.
                            loopback_ipv4_pool: IPv4 subnet for Loopback0 allocation.
                            loopback_ipv4_address:
                               IPv4 address without mask for Loopback0.
                               When set, it takes precedence over `loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not catch duplicates.
                            vtep_loopback_ipv4_pool: IPv4 subnet for VTEP-Loopback allocation.
                            vtep_loopback_ipv4_address:
                               IPv4 address without mask for VTEP-Loopback.
                               When set, it takes precedence over
                               `vtep_loopback_ipv4_pool`.
                               Note: AVD does not check for validity of the IPv4 address and does not
                               catch duplicates.
                            loopback_ipv4_offset:
                               Offset all assigned loopback IP addresses.
                               Required when the < loopback_ipv4_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid over-lapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv4_offset: < total # spine switches > or vice versa.
                            loopback_ipv6_pool: IPv6 subnet for Loopback0 allocation.
                            loopback_ipv6_offset:
                               Offset all assigned loopback IPv6 addresses.
                               Required when the < loopback_ipv6_pool > is same for 2
                               different node_types (like spine and l3leaf) to avoid overlapping IPs.
                               For example, set the minimum
                               offset l3leaf.defaults.loopback_ipv6_offset: < total # spine switches > or vice versa.
                            vtep:
                               Node is configured as a VTEP when applicable based on 'overlay_routing_protocol'.
                               Overrides VTEP
                               setting inherited from node_type_keys.
                            vtep_loopback: Set VXLAN source interface.
                            bgp_as:
                               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                               For asdot notation in
                               YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                               number.
                               Required with eBGP.
                            bgp_defaults: List of EOS commands to apply to BGP daemon.
                            evpn_role:
                               Acting role in EVPN control plane.
                               Default is set in node_type definition from node_type_keys.
                            evpn_route_servers: List of nodes acting as EVPN Route-Servers / Route-Reflectors.
                            evpn_services_l2_only:
                               Possibility to prevent configuration of Tenant VRFs and SVIs.
                               Override node definition
                               "network_services_l3" from node_type_keys.
                               This allows support for centralized routing.
                            filter:
                               Filter L3 and L2 network services based on tenant and tags (and operation filter).
                               If filter is not
                               defined it will default to all.
                            igmp_snooping_enabled: Activate or deactivate IGMP snooping on device level.
                            evpn_gateway:
                               Node is acting as EVPN Multi-Domain Gateway.
                               New BGP peer-group is generated between EVPN GWs in
                               different domains or between GWs and Route Servers.
                               Name can be changed under
                               "bgp_peer_groups.evpn_overlay_core" variable.
                               L3 rechability for different EVPN GWs must be already
                               in place, it is recommended to use DCI & L3 Edge if Route Servers and GWs are not defined under the
                               same Ansible inventory.
                            ipvpn_gateway:
                               Node is acting as IP-VPN Gateway for EVPN to MPLS-IP-VPN Interworking. The BGP peer group used for
                               this is "bgp_peer_groups.ipvpn_gateway_peers".
                               L3 Reachability is required for this to work, the
                               preferred method to establish underlay connectivity is to use core_interfaces.
                            mlag: Enable / Disable auto MLAG, when two nodes are defined in node group.
                            mlag_dual_primary_detection: Enable / Disable MLAG dual primary detection.
                            mlag_ibgp_origin_incomplete:
                               Set origin of routes received from MLAG iBGP peer to incomplete.
                               The purpose is to optimize routing
                               for leaf loopbacks from spine perspective and
                               avoid suboptimal routing via peerlink for control
                               plane traffic.
                            mlag_interfaces:
                               Each list item supports range syntax that can be expanded into a list of interfaces.
                               Required when
                               MLAG leafs are present in the topology.
                            mlag_interfaces_speed:
                               Set MLAG interface speed.
                               Speed should be set in the format `<interface_speed>` or `forced
                               <interface_speed>` or `auto <interface_speed>`.
                            mlag_peer_l3_vlan:
                               Underlay L3 peering SVI interface id.
                               If set to 0 or the same vlan as mlag_peer_vlan, the
                               mlag_peer_vlan will be used for L3 peering.
                            mlag_peer_l3_ipv4_pool:
                               IP address pool used for MLAG underlay L3 peering. IP is derived from the node id.
                               Required when
                               MLAG leafs present in topology and they are using a separate L3 peering VLAN.
                            mlag_peer_vlan: MLAG Peer Link (control link) SVI interface id.
                            mlag_peer_link_allowed_vlans: mlag_peer_link_allowed_vlans
                            mlag_peer_address_family:
                               IP address family used to establish MLAG Peer Link (control link).
                               `ipv6` requires EOS version
                               4.31.1F or higher.
                               Note: `ipv6` is not supported in combination with a common MLAG peer link VLAN
                               (ex. `mlag_peer_l3_vlan` set to 4094).
                            mlag_peer_ipv4_pool:
                               IPv4 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv4` (default).
                            mlag_peer_ipv6_pool:
                               IPv6 address pool used for MLAG Peer Link (control link). IP is derived from the node id.
                               Required
                               for MLAG leafs when `mlag_peer_address_family` is `ipv6`.
                            mlag_port_channel_id:
                               If not set, the mlag port-channel id is generated based on the digits of the first interface present
                               in 'mlag_interfaces'.
                               Valid port-channel id numbers are < 1-2000 > for EOS < 4.25.0F and < 1 -
                               999999 > for EOS >= 4.25.0F.
                            mlag_domain_id: MLAG Domain ID. If not set the node group name (Set with "group" key) will be used.
                            spanning_tree_mode: spanning_tree_mode
                            spanning_tree_priority:
                               Spanning-tree priority configured for the selected mode.
                               For `rapid-pvst` the priority can also be
                               set per VLAN under network services.
                            spanning_tree_root_super: spanning_tree_root_super
                            virtual_router_mac_address: Virtual router mac address for anycast gateway.
                            inband_mgmt_interface:
                               Pointer to interface used for inband management.
                               All configuration must be done using other data
                               models like network services or structured_config.
                               'inband_mgmt_interface' is only used to refer to
                               this interface as source in various management protocol settings (future feature).

                               On L2 switches,
                               this defaults to Vlan<inband_mgmt_vlan> if either 'inband_mgmt_subnet' or 'inband_mgmt_ip' is set.
                            inband_mgmt_vlan:
                               VLAN number used for inband management on L2 switches (switches using port-channel trunks as
                               uplinks).
                               When using 'inband_mgmt_subnet' the VLAN and SVIs will be created automatically on this
                               switch as well as all 'uplink_switches'.
                               When using 'inband_mgmt_ip' the VLAN and SVI will only be
                               created on this device and added to uplink trunk. The VLAN and SVI on the parent switches must be
                               created using network services data models.
                            inband_mgmt_subnet:
                               Optional IP subnet assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ip virtual-router" and host-route injection based on
                               ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      : <subnet> +
                               2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       :
                               <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than total l2leafs + 5
                               Setting is ignored if 'inband_mgmt_ip' is set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ip:
                               IP address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_subnet', hence all behavior of 'inband_mgmt_subnet' is removed.

                               If this is set the
                               VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN and SVI on
                               the parent switches must be created using network services data models.

                               This setting is applicable
                               to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf' when using 'inband_mgmt_ip'. Otherwise gateway
                               is derived from 'inband_mgmt_subnet' if set.

                               This setting is applicable to L2 switches (switches
                               using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_address:
                               IPv6 address assigned to the inband management interface set with 'inband_mgmt_vlan'.
                               This overrides
                               'inband_mgmt_ipv6_subnet', hence the configuration of 'inband_mgmt_ipv6_subnet' is ignored.

                               If this
                               is set the VLAN and SVI will only be created on the L2 switch and added to uplink trunk.
                               The VLAN
                               and SVI on the parent switches must be created using network services data models.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_subnet:
                               Optional IPv6 prefix assigned to inband management SVIs on L2 switches (switches using port-channels
                               as uplinks).
                               Parent l3leafs will have SVI with "ipv6 virtual-router" and host-route injection based
                               on ARP.
                               This allows all l3leafs to reuse the same subnet across multiple racks without VXLAN
                               extension.
                               SVI IP address will be assigned as follows:
                               virtual-router: <subnet> + 1
                               l3leaf A      :
                               <subnet> + 2 (same IP on all l3leaf A)
                               l3leaf B      : <subnet> + 3 (same IP on all l3leaf B)
                               l2leafs       : <subnet> + 3 + <l2leaf id>
                               GW on l2leafs : <subnet> + 1
                               Assign range larger than
                               total l2leafs + 5

                               Setting is ignored if 'inband_mgmt_ipv6_address' is set.

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_ipv6_gateway:
                               Default gateway configured in the 'inband_mgmt_vrf'.
                               Used when `inband_mgmt_ipv6_address` is set.
                               Ignored when 'inband_mgmt_ipv6_subnet' is set (first IP in subnet used as gateway).

                               This setting is
                               applicable to L2 switches (switches using port-channel trunks as uplinks).
                            inband_mgmt_description:
                               Description configured on the Inband Management SVI.

                               This setting is only applied on the devices
                               where it is set, it does not automatically affect any parent/child devices configuration, so it must
                               be set on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vlan_name:
                               Name configured on the Inband Management VLAN.
                               This setting is only applied on the devices where it
                               is set, it does not automatically affect any parent/child devices configuration, so it must be set
                               on each applicable node/node-group/node-type as needed.
                            inband_mgmt_vrf:
                               VRF configured on the Inband Management Interface.
                               The VRF is created if not already created by
                               other means.
                               This setting is only applied on the devices where it is set, it does not automatically
                               affect any parent/child devices configuration, so it must be set on each applicable node/node-
                               group/node-type as needed.
                            inband_mgmt_mtu:
                               MTU configured on the Inband Management Interface.
                               This setting is only applied on the devices where
                               it is set, it does not automatically affect any parent/child devices configuration, so it must be
                               set on each applicable node/node-group/node-type as needed.
                            inband_ztp:
                               Enable to configure upstream device with proper configuration to allow downstream devices to ZTP
                               inband.
                               This setting also requires that the `inband_mgmt_vlan` is set for the node.
                            inband_ztp_lacp_fallback_delay:
                               Set the LACP fallback timeout of the upstream device's port-channel towards the downstream inband
                               ZTP node.
                               This setting also requires that `inband_ztp` is set for the node.
                            mpls_overlay_role:
                               Set the default mpls overlay role.
                               Acting role in overlay control plane.
                            overlay_address_families: Set the default overlay address families.
                            mpls_route_reflectors: List of inventory hostname acting as MPLS route-reflectors.
                            bgp_cluster_id: Set BGP cluster id.
                            ptp: ptp
                            wan_role:
                               Override the default WAN role.

                               This is used both for AutoVPN and Pathfinder designs.
                               That means if
                               `wan_mode` root key is set to `legacy-autovpn` or `cv-pathfinder`.
                               `server` indicates that the
                               router is a route-reflector.

                               Only supported if `overlay_routing_protocol` is set to `ibgp`.
                            cv_pathfinder_transit_mode:
                               Configure the transit mode for a WAN client for CV Pathfinder designs
                               only when the `wan_mode` root
                               key is set to `cv_pathfinder`.

                               'zone' is currently not supported.
                            cv_pathfinder_region:
                               The CV Pathfinder region name.
                               This key is required for WAN routers but optional for pathfinders.
                               The region name must be defined under 'cv_pathfinder_regions'.
                            cv_pathfinder_site:
                               The CV Pathfinder site name.
                               This key is required for WAN routers but optional for pathfinders.
                               For
                               WAN routers and pathfinders with `cv_pathfinder_region`, the site name must be defined for the
                               relevant region under 'cv_pathfinder_regions'.
                               For pathfinders without `cv_pathfinder_region` set,
                               the site must be defined under `cv_pathfinder_global_sites`.
                            wan_ha:
                               PREVIEW: This key is currently not supported

                               The key is supported only if `wan_mode` == `cv-
                               pathfinder`.
                               AutoVPN support is still to be determined.

                               Maximum 2 devices supported by group for
                               HA.
                            dps_mss_ipv4: IPv4 MSS value configured under "router path-selection" on WAN Devices.
                            l3_interfaces:
                               L3 Interfaces to configure on the node.
                               Used to define the node for WAN interfaces when
                               `wan_carrier` is set.
                            data_plane_cpu_allocation_max:
                               Set the maximum number of CPU used for the data plane.
                               This setting is useful on virtual Route
                               Reflectors and Pathfinders where more CPU cores should be allocated for control plane.
                            flow_tracker_type:
                               Set the flow tracker type.
                               Override the `default_flow_tracker_type`` set at the `node_type_key`
                               level.
                               `default_flow_tracker_type` default value is `sampled`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Nodes(AvdCollection[str, NodesItem]):
                    _primary_key: ClassVar[str] = "name"

                Nodes._item_type = NodesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "defaults": {"type": Defaults},
                    "node_groups": {"type": NodeGroups},
                    "nodes": {"type": Nodes},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                defaults: Defaults
                """Define variables for all nodes of this type."""
                node_groups: NodeGroups
                """Define variables related to all nodes part of this group."""
                nodes: Nodes
                """Define variables per node."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    defaults: Defaults | UndefinedType = Undefined,
                    node_groups: NodeGroups | UndefinedType = Undefined,
                    nodes: Nodes | UndefinedType = Undefined,
                ) -> None:
                    """
                    NodeTypeKeysKey.

                    Args:
                    -----
                        _custom_data: _custom_data
                        defaults: Define variables for all nodes of this type.
                        node_groups: Define variables related to all nodes part of this group.
                        nodes: Define variables per node.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"key": {"type": str}, "value": {"type": NodeTypeKeysKey, "key": "node_type_keys_key"}}
            _required_fields: ClassVar[tuple] = ("key",)
            key: str
            """Key used as dynamic key"""
            value: NodeTypeKeysKey
            """Value of dynamic key"""

            def __init__(self, *, key: str | UndefinedType = Undefined, value: NodeTypeKeysKey | UndefinedType = Undefined) -> None:
                """
                DynamicNodeTypeKeys.

                Args:
                -----
                    key: Key used as dynamic key
                    value: Value of dynamic key

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _dynamic_key_maps: ClassVar[tuple[dict, ...]] = (
            {"dynamic_keys_path": "connected_endpoints_keys.key", "model_key": "connected_endpoints_keys"},
            {"dynamic_keys_path": "custom_node_type_keys.key", "model_key": "custom_node_type_keys"},
            {"dynamic_keys_path": "network_services_keys.name", "model_key": "network_services_keys"},
            {"dynamic_keys_path": "node_type_keys.key", "model_key": "node_type_keys"},
        )
        _fields: ClassVar[dict] = {
            "connected_endpoints_keys": {"type": list, "items": DynamicConnectedEndpointsKeys},
            "custom_node_type_keys": {"type": list, "items": DynamicCustomNodeTypeKeys},
            "network_services_keys": {"type": list, "items": DynamicNetworkServicesKeys},
            "node_type_keys": {"type": list, "items": DynamicNodeTypeKeys},
        }
        _required_fields: ClassVar[tuple] = ("connected_endpoints_keys", "custom_node_type_keys", "network_services_keys", "node_type_keys")
        connected_endpoints_keys: list[DynamicConnectedEndpointsKeys]
        """List of dynamic 'connected_endpoints_keys'."""
        custom_node_type_keys: list[DynamicCustomNodeTypeKeys]
        """List of dynamic 'custom_node_type_keys'."""
        network_services_keys: list[DynamicNetworkServicesKeys]
        """List of dynamic 'network_services_keys'."""
        node_type_keys: list[DynamicNodeTypeKeys]
        """List of dynamic 'node_type_keys'."""

        def __init__(
            self,
            *,
            connected_endpoints_keys: list[DynamicConnectedEndpointsKeys] | UndefinedType = Undefined,
            custom_node_type_keys: list[DynamicCustomNodeTypeKeys] | UndefinedType = Undefined,
            network_services_keys: list[DynamicNetworkServicesKeys] | UndefinedType = Undefined,
            node_type_keys: list[DynamicNodeTypeKeys] | UndefinedType = Undefined,
        ) -> None:
            """
            _DynamicKeys.

            Data models for dynamic keys.

            Args:
            -----
                connected_endpoints_keys: List of dynamic 'connected_endpoints_keys'.
                custom_node_type_keys: List of dynamic 'custom_node_type_keys'.
                network_services_keys: List of dynamic 'network_services_keys'.
                node_type_keys: List of dynamic 'node_type_keys'.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    _fields: ClassVar[dict] = {
        "application_classification": {"type": ApplicationClassification},
        "avd_data_validation_mode": {"type": str, "default": "error"},
        "avd_eos_designs_debug": {"type": bool, "default": False},
        "avd_eos_designs_structured_config": {"type": bool, "default": True},
        "avd_eos_designs_unset_facts": {"type": bool, "default": True},
        "bfd_multihop": {"type": BfdMultihop, "default": lambda cls: coerce_type({"interval": 300, "min_rx": 300, "multiplier": 3}, target_type=cls)},
        "bgp_as": {"type": str},
        "bgp_default_ipv4_unicast": {"type": bool, "default": False},
        "bgp_distance": {"type": BgpDistance},
        "bgp_ecmp": {"type": int},
        "bgp_graceful_restart": {"type": BgpGracefulRestart},
        "bgp_maximum_paths": {"type": int},
        "bgp_mesh_pes": {"type": bool, "default": False},
        "bgp_peer_groups": {"type": BgpPeerGroups},
        "bgp_update_wait_install": {"type": bool},
        "bgp_update_wait_for_convergence": {"type": bool},
        "connected_endpoints_keys": {
            "type": ConnectedEndpointsKeys,
            "default": lambda cls: coerce_type(
                [
                    {"key": "servers", "type": "server", "description": "Server"},
                    {"key": "firewalls", "type": "firewall", "description": "Firewall"},
                    {"key": "routers", "type": "router", "description": "Router"},
                    {"key": "load_balancers", "type": "load_balancer", "description": "Load Balancer"},
                    {"key": "storage_arrays", "type": "storage_array", "description": "Storage Array"},
                    {"key": "cpes", "type": "cpe", "description": "CPE"},
                    {"key": "workstations", "type": "workstation", "description": "Workstation"},
                    {"key": "access_points", "type": "access_point", "description": "Access Point"},
                    {"key": "phones", "type": "phone", "description": "Phone"},
                    {"key": "printers", "type": "printer", "description": "Printer"},
                    {"key": "cameras", "type": "camera", "description": "Camera"},
                    {"key": "generic_devices", "type": "generic_device", "description": "Generic Device"},
                ],
                target_type=cls,
            ),
        },
        "core_interfaces": {"type": CoreInterfaces},
        "custom_structured_configuration_list_merge": {"type": str, "default": "append_rp"},
        "custom_structured_configuration_prefix": {"type": list, "items": str, "default": ["custom_structured_configuration_"]},
        "cv_pathfinder_global_sites": {"type": CvPathfinderGlobalSites},
        "cv_pathfinder_internet_exit_policies": {"type": CvPathfinderInternetExitPolicies},
        "cv_pathfinder_regions": {"type": CvPathfinderRegions},
        "cv_server": {"type": str},
        "cv_tags_topology_type": {"type": str},
        "cv_token": {"type": str},
        "cv_topology": {"type": CvTopology},
        "cvp_ingestauth_key": {"type": str},
        "cvp_instance_ips": {"type": list, "items": str},
        "cvp_token_file": {"type": str},
        "dc_name": {"type": str},
        "default_connected_endpoints_description": {"type": str, "default": "{endpoint_type!u}_{endpoint}{endpoint_port?<_}"},
        "default_connected_endpoints_port_channel_description": {"type": str, "default": "{endpoint_type!u}_{endpoint}{endpoint_port_channel?<_}"},
        "default_igmp_snooping_enabled": {"type": bool, "default": True},
        "default_interface_mtu": {"type": int},
        "default_interfaces": {"type": list, "items": DefaultInterfacesItem},
        "default_mgmt_method": {"type": str, "default": "oob"},
        "default_network_ports_description": {"type": str, "default": "{endpoint?}"},
        "default_network_ports_port_channel_description": {"type": str, "default": "{endpoint?}{endpoint_port_channel?<_}"},
        "default_node_types": {"type": DefaultNodeTypes},
        "default_underlay_p2p_ethernet_description": {"type": str, "default": "P2P_{peer}_{peer_interface}{vrf?<_VRF_}"},
        "default_underlay_p2p_port_channel_description": {"type": str, "default": "P2P_{peer}_{peer_interface}"},
        "default_vrf_diag_loopback_description": {"type": str, "default": "DIAG_VRF_{vrf}"},
        "design": {"type": Design},
        "enable_trunk_groups": {"type": bool, "default": False},
        "eos_designs_custom_templates": {"type": list, "items": EosDesignsCustomTemplatesItem},
        "eos_designs_documentation": {"type": EosDesignsDocumentation},
        "event_handlers": {"type": EventHandlers},
        "evpn_ebgp_gateway_inter_domain": {"type": bool},
        "evpn_ebgp_gateway_multihop": {"type": int, "default": 15},
        "evpn_ebgp_multihop": {"type": int, "default": 3},
        "evpn_hostflap_detection": {"type": EvpnHostflapDetection},
        "evpn_import_pruning": {"type": bool, "default": False},
        "evpn_multicast": {"type": bool, "default": False},
        "evpn_overlay_bgp_rtc": {"type": bool, "default": False},
        "evpn_prevent_readvertise_to_server": {"type": bool, "default": False},
        "evpn_short_esi_prefix": {"type": str, "default": "0000:0000:"},
        "evpn_vlan_aware_bundles": {"type": bool, "default": False},
        "evpn_vlan_bundles": {"type": EvpnVlanBundles},
        "fabric_evpn_encapsulation": {"type": str, "default": "vxlan"},
        "fabric_flow_tracking": {"type": FabricFlowTracking},
        "fabric_ip_addressing": {"type": FabricIpAddressing},
        "fabric_name": {"type": str},
        "fabric_sflow": {"type": FabricSflow},
        "flow_tracking_settings": {"type": FlowTrackingSettings},
        "generate_cv_tags": {"type": GenerateCvTags},
        "hardware_counters": {"type": HardwareCounters},
        "internal_vlan_order": {
            "type": InternalVlanOrder,
            "default": lambda cls: coerce_type({"allocation": "ascending", "range": {"beginning": 1006, "ending": 1199}}, target_type=cls),
        },
        "ipv4_acls": {"type": Ipv4Acls},
        "ipv4_prefix_list_catalog": {"type": Ipv4PrefixListCatalog},
        "ipv6_mgmt_destination_networks": {"type": list, "items": str},
        "ipv6_mgmt_gateway": {"type": str},
        "is_deployed": {"type": bool, "default": True},
        "isis_advertise_passive_only": {"type": bool, "default": False},
        "isis_area_id": {"type": str, "default": "49.0001"},
        "isis_default_circuit_type": {"type": str, "default": "level-2"},
        "isis_default_is_type": {"type": str, "default": "level-2"},
        "isis_default_metric": {"type": int, "default": 50},
        "isis_maximum_paths": {"type": int},
        "isis_system_id_format": {"type": str, "default": "underlay_loopback"},
        "isis_ti_lfa": {"type": IsisTiLfa},
        "l3_edge": {"type": L3Edge},
        "l3_interface_profiles": {"type": L3InterfaceProfiles},
        "local_users": {"type": LocalUsers},
        "mac_address_table": {"type": MacAddressTable},
        "management_eapi": {"type": ManagementEapi},
        "mgmt_destination_networks": {"type": list, "items": str},
        "mgmt_gateway": {"type": str},
        "mgmt_interface": {"type": str, "default": "Management1"},
        "mgmt_interface_description": {"type": str, "default": "OOB_MANAGEMENT"},
        "mgmt_interface_vrf": {"type": str, "default": "MGMT"},
        "mgmt_vrf_routing": {"type": bool, "default": False},
        "mlag_bgp_peer_description": {"type": str, "default": "{mlag_peer}_{peer_interface}"},
        "mlag_bgp_peer_group_description": {"type": str, "default": "{mlag_peer}"},
        "mlag_ibgp_peering_vrfs": {"type": MlagIbgpPeeringVrfs},
        "mlag_member_description": {"type": str, "default": "MLAG_{mlag_peer}_{peer_interface}"},
        "mlag_on_orphan_port_channel_downlink": {"type": bool, "default": False},
        "mlag_peer_l3_svi_description": {"type": str, "default": "MLAG_L3"},
        "mlag_peer_l3_vlan_name": {"type": str, "default": "MLAG_L3"},
        "mlag_peer_l3_vrf_svi_description": {"type": str, "default": "MLAG_L3_VRF_{vrf}"},
        "mlag_peer_l3_vrf_vlan_name": {"type": str, "default": "MLAG_L3_VRF_{vrf}"},
        "mlag_peer_svi_description": {"type": str, "default": "MLAG"},
        "mlag_peer_vlan_name": {"type": str, "default": "MLAG"},
        "mlag_port_channel_description": {"type": str, "default": "MLAG_{mlag_peer}_{peer_interface}"},
        "name_servers": {"type": list, "items": str},
        "network_ports": {"type": list, "items": NetworkPortsItem},
        "network_services_keys": {"type": NetworkServicesKeys, "default": lambda cls: coerce_type([{"name": "tenants"}], target_type=cls)},
        "custom_node_type_keys": {"type": CustomNodeTypeKeys},
        "node_type_keys": {"type": NodeTypeKeys},
        "ntp_settings": {"type": NtpSettings},
        "only_local_vlan_trunk_groups": {"type": bool, "default": False},
        "overlay_bgp_peer_description": {"type": str, "default": "{peer}{peer_interface?<_}"},
        "overlay_cvx_servers": {"type": list, "items": str},
        "overlay_her_flood_list_per_vni": {"type": bool, "default": False},
        "overlay_her_flood_list_scope": {"type": str, "default": "fabric"},
        "overlay_loopback_description": {"type": str},
        "overlay_mlag_rfc5549": {"type": bool, "default": False},
        "overlay_rd_type": {"type": OverlayRdType},
        "overlay_routing_protocol": {"type": str, "default": "ebgp"},
        "overlay_routing_protocol_address_family": {"type": str, "default": "ipv4"},
        "overlay_rt_type": {"type": OverlayRtType},
        "p2p_uplinks_mtu": {"type": int, "default": 9214},
        "p2p_uplinks_qos_profile": {"type": str},
        "custom_platform_settings": {"type": list, "items": CustomPlatformSettingsItem},
        "platform_settings": {
            "type": list,
            "items": PlatformSettingsItem,
            "default": lambda cls: coerce_type(
                [
                    {"platforms": ["default"], "feature_support": {"queue_monitor_length_notify": False}, "reload_delay": {"mlag": 300, "non_mlag": 330}},
                    {
                        "platforms": ["7050X3"],
                        "feature_support": {"queue_monitor_length_notify": False},
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                        "trident_forwarding_table_partition": "flexible exact-match 16384 l2-shared 98304 l3-shared 131072",
                    },
                    {
                        "platforms": ["720XP"],
                        "feature_support": {"poe": True, "queue_monitor_length_notify": False},
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                        "trident_forwarding_table_partition": "flexible exact-match 16000 l2-shared 18000 l3-shared 22000",
                    },
                    {
                        "platforms": ["750", "755", "758"],
                        "management_interface": "Management0",
                        "feature_support": {"poe": True, "queue_monitor_length_notify": False},
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                    },
                    {
                        "platforms": ["720DP", "722XP", "710P"],
                        "feature_support": {"poe": True, "queue_monitor_length_notify": False},
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                    },
                    {
                        "platforms": ["7010TX"],
                        "feature_support": {"queue_monitor_length_notify": False, "per_interface_mtu": False},
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                    },
                    {
                        "platforms": ["7280R", "7280R2", "7020R"],
                        "lag_hardware_only": True,
                        "reload_delay": {"mlag": 900, "non_mlag": 1020},
                        "tcam_profile": "vxlan-routing",
                    },
                    {"platforms": ["7280R3"], "reload_delay": {"mlag": 900, "non_mlag": 1020}, "tcam_profile": "vxlan-routing"},
                    {
                        "platforms": ["7500R", "7500R2"],
                        "lag_hardware_only": True,
                        "management_interface": "Management0",
                        "reload_delay": {"mlag": 900, "non_mlag": 1020},
                        "tcam_profile": "vxlan-routing",
                    },
                    {
                        "platforms": ["7500R3", "7800R3"],
                        "management_interface": "Management0",
                        "reload_delay": {"mlag": 900, "non_mlag": 1020},
                        "tcam_profile": "vxlan-routing",
                    },
                    {
                        "platforms": ["7358X4"],
                        "management_interface": "Management1/1",
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                        "feature_support": {
                            "queue_monitor_length_notify": False,
                            "interface_storm_control": True,
                            "bgp_update_wait_for_convergence": True,
                            "bgp_update_wait_install": False,
                        },
                    },
                    {"platforms": ["7368X4"], "management_interface": "Management0", "reload_delay": {"mlag": 300, "non_mlag": 330}},
                    {
                        "platforms": ["7300X3"],
                        "management_interface": "Management0",
                        "reload_delay": {"mlag": 1200, "non_mlag": 1320},
                        "trident_forwarding_table_partition": "flexible exact-match 16384 l2-shared 98304 l3-shared 131072",
                    },
                    {
                        "platforms": ["VEOS", "VEOS-LAB", "vEOS", "vEOS-lab"],
                        "feature_support": {
                            "bgp_update_wait_for_convergence": False,
                            "bgp_update_wait_install": False,
                            "interface_storm_control": False,
                            "queue_monitor_length_notify": False,
                        },
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                    },
                    {
                        "platforms": ["CEOS", "cEOS", "ceos", "cEOSLab"],
                        "feature_support": {
                            "bgp_update_wait_for_convergence": False,
                            "bgp_update_wait_install": False,
                            "interface_storm_control": False,
                            "queue_monitor_length_notify": False,
                        },
                        "management_interface": "Management0",
                        "reload_delay": {"mlag": 300, "non_mlag": 330},
                    },
                    {
                        "platforms": ["AWE-5310", "AWE-5510", "AWE-7250R", "AWE-7230R"],
                        "feature_support": {
                            "bgp_update_wait_for_convergence": True,
                            "bgp_update_wait_install": False,
                            "interface_storm_control": False,
                            "queue_monitor_length_notify": False,
                        },
                        "management_interface": "Management1/1",
                        "p2p_uplinks_mtu": 9194,
                    },
                    {
                        "platforms": ["AWE-7220R"],
                        "feature_support": {
                            "bgp_update_wait_for_convergence": True,
                            "bgp_update_wait_install": False,
                            "interface_storm_control": False,
                            "queue_monitor_length_notify": False,
                            "poe": True,
                        },
                        "management_interface": "Management1",
                        "p2p_uplinks_mtu": 9194,
                    },
                ],
                target_type=list,
                list_items_type=cls,
            ),
        },
        "platform_speed_groups": {"type": PlatformSpeedGroups},
        "pod_name": {"type": str},
        "port_profiles": {"type": PortProfiles},
        "ptp_profiles": {
            "type": PtpProfiles,
            "default": lambda cls: coerce_type(
                [
                    {
                        "profile": "aes67-r16-2016",
                        "announce": {"interval": 0, "timeout": 3},
                        "delay_req": -3,
                        "sync_message": {"interval": -3},
                        "transport": "ipv4",
                    },
                    {
                        "profile": "smpte2059-2",
                        "announce": {"interval": -2, "timeout": 3},
                        "delay_req": -4,
                        "sync_message": {"interval": -4},
                        "transport": "ipv4",
                    },
                    {"profile": "aes67", "announce": {"interval": 2, "timeout": 3}, "delay_req": 0, "sync_message": {"interval": 0}, "transport": "ipv4"},
                ],
                target_type=cls,
            ),
        },
        "ptp_settings": {"type": PtpSettings},
        "queue_monitor_length": {"type": QueueMonitorLength},
        "redundancy": {"type": Redundancy},
        "router_id_loopback_description": {"type": str, "default": "ROUTER_ID"},
        "serial_number": {"type": str},
        "sflow_settings": {"type": SflowSettings},
        "shutdown_bgp_towards_undeployed_peers": {"type": bool, "default": True},
        "shutdown_interfaces_towards_undeployed_peers": {"type": bool, "default": True},
        "snmp_settings": {"type": SnmpSettings},
        "source_interfaces": {"type": SourceInterfaces},
        "svi_profiles": {"type": SviProfiles},
        "system_mac_address": {"type": str},
        "terminattr_disable_aaa": {"type": bool, "default": False},
        "terminattr_ingestexclude": {"type": str, "default": "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"},
        "terminattr_ingestgrpcurl_port": {"type": int, "default": 9910},
        "terminattr_smashexcludes": {"type": str, "default": "ale,flexCounter,hardware,kni,pulse,strata"},
        "timezone": {"type": str},
        "trunk_groups": {"type": TrunkGroups},
        "type": {"type": str},
        "underlay_filter_peer_as": {"type": bool, "default": False},
        "underlay_filter_redistribute_connected": {"type": bool, "default": True},
        "underlay_ipv6": {"type": bool, "default": False},
        "underlay_isis_bfd": {"type": bool, "default": False},
        "underlay_isis_instance_name": {"type": str},
        "underlay_l2_ethernet_description": {"type": str, "default": "L2_{peer}_{peer_interface}"},
        "underlay_l2_port_channel_description": {"type": str, "default": "L2_{peer_node_group_or_peer}_{peer_interface}"},
        "underlay_multicast": {"type": bool, "default": False},
        "underlay_multicast_anycast_rp": {"type": UnderlayMulticastAnycastRp},
        "underlay_multicast_rps": {"type": UnderlayMulticastRps},
        "underlay_ospf_area": {"type": str, "default": "0.0.0.0"},
        "underlay_ospf_authentication": {"type": UnderlayOspfAuthentication},
        "underlay_ospf_bfd_enable": {"type": bool, "default": False},
        "underlay_ospf_max_lsa": {"type": int, "default": 12000},
        "underlay_ospf_process_id": {"type": int, "default": 100},
        "underlay_rfc5549": {"type": bool, "default": False},
        "underlay_routing_protocol": {"type": str},
        "uplink_ptp": {"type": UplinkPtp},
        "use_cv_topology": {"type": bool},
        "vtep_loopback_description": {"type": str, "default": "VXLAN_TUNNEL_SOURCE"},
        "vtep_vvtep_ip": {"type": str},
        "wan_carriers": {"type": WanCarriers},
        "wan_encapsulation": {"type": str, "default": "path-selection"},
        "wan_ha": {"type": WanHa},
        "wan_ipsec_profiles": {"type": WanIpsecProfiles},
        "wan_mode": {"type": str, "default": "cv-pathfinder"},
        "wan_path_groups": {"type": WanPathGroups},
        "wan_route_servers": {"type": WanRouteServers},
        "wan_stun_dtls_disable": {"type": bool, "default": False},
        "wan_stun_dtls_profile_name": {"type": str, "default": "STUN-DTLS"},
        "wan_virtual_topologies": {"type": WanVirtualTopologies},
        "zscaler_endpoints": {"type": ZscalerEndpoints},
        "_custom_structured_configurations": {"type": list, "items": _CustomStructuredConfigurationsItem},
        "_dynamic_keys": {"type": _DynamicKeys},
    }
    _required_fields: ClassVar[tuple] = ("fabric_name", "_dynamic_keys")
    _allow_other_keys: ClassVar[bool] = True
    application_classification: ApplicationClassification
    avd_data_validation_mode: str | None
    """
    Validation Mode for AVD input data validation.
    Input data validation will validate the input
    variables according to the schema.
    During validation, messages will generated with information about
    the host(s) and key(s) which failed validation.
    "error" will produce error messages and fail the
    task.
    "warning" will produce warning messages.
    """
    avd_eos_designs_debug: bool | None
    """Dump all vars and facts per device after generating `avd_switch_facts`."""
    avd_eos_designs_structured_config: bool | None
    """Generate structured configuration per device."""
    avd_eos_designs_unset_facts: bool | None
    """
    Unset `avd_switch_facts` to gain a small performance improvement since Ansible needs to handle fewer
    variables.
    """
    bfd_multihop: BfdMultihop
    """BFD Multihop tuning."""
    bgp_as: str | None
    """
    BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>" to use to configure
    overlay when "overlay_routing_protocol" == ibgp.
    For asdot notation in YAML inputs, the value must
    be put in quotes, to prevent it from being interpreted as a float number.
    """
    bgp_default_ipv4_unicast: bool | None
    """
    Default activation of IPv4 unicast address-family on all IPv4 neighbors.
    It is best practice to
    disable activation.
    """
    bgp_distance: BgpDistance
    bgp_ecmp: int | None
    """
    Maximum ECMP for BGP multi-path.
    The default value is 4 except for WAN Routers where the default
    value is unset (falls back to EOS default).
    """
    bgp_graceful_restart: BgpGracefulRestart
    """
    BGP graceful-restart allows a BGP speaker with separate control plane and data plane processing to
    continue forwarding traffic during a BGP restart.
    Its neighbors (receiving speakers) may retain
    routing information from the restarting speaker while a BGP session with it is being re-established,
    reducing route flapping.
    """
    bgp_maximum_paths: int | None
    """
    Maximum Paths for BGP multi-path.
    The default value is 4 except for WAN Routers where the default
    value is 16.
    """
    bgp_mesh_pes: bool | None
    """
    Configure an iBGP full mesh between PEs, either because there is no RR used or other reasons.
    Only
    supported in combination with MPLS overlay.
    """
    bgp_peer_groups: BgpPeerGroups
    """
    Leverage an Arista EOS switch to generate the encrypted password using the correct peer group name.
    Note that the name of the peer groups use '-' instead of '_' in EOS configuration.
    """
    bgp_update_wait_install: bool | None
    bgp_update_wait_for_convergence: bool | None
    connected_endpoints_keys: ConnectedEndpointsKeys
    """
    Endpoints connecting to the fabric can be grouped by using separate keys.
    The keys can be customized
    to provide a better better organization or grouping of your data.
    `connected_endpoints_keys` should
    be defined in the top level group_vars for the fabric.
    The default values will be overridden if
    defining this key, so it is recommended to copy the defaults and modify them.
    """
    core_interfaces: CoreInterfaces
    custom_structured_configuration_list_merge: str | None
    """
    The List-merge strategy used when merging custom structured configurations.

    This applies to all
    vars prefixed by prefixes in `custom_structured_configuration_prefix`
    and all data under the various
    `structured_config` options.

    The available list merge strategies:
    - `replace`:
      - Any list will be
    replaced with the list defined in custom structured configurations.
    - `append`:
      - Existing list
    items with the same "Primary key"-value will be updated.
      - New items will be appended to the
    existing list (including duplicates).
    - `keep`:
      - Only set list if there is no existing list or
    existing list is `None`.
    - `prepend`:
      - Existing list items with the same "Primary key"-value will
    be updated.
      - New items will be prepended to the existing list (including duplicates).
    -
    `append_rp`:
      - Existing list items with the same "Primary key"-value will be updated.
      - New
    unique items will be appended to the existing list.
    - `prepend_rp`:
      - Existing list items with the
    same "Primary key"-value will be updated.
      - New unique items will be prepended to the existing
    list.
    """
    custom_structured_configuration_prefix: list[str]
    """
    Custom EOS Structured Configuration keys can be set on any group or host_var level using the name
    of
    the corresponding `eos_cli_config_gen` key prefixed with content of
    `custom_structured_configuration_prefix`.

    The content of Custom Structured Configuration variables
    will be merged with the structured config generated by the eos_designs role.

    The merge is done
    recursively, so it is possible to update a sub-key of a variable set by `eos_designs` role already.
    The merge follow these recursive merge strategies:
    - New keys will be added for all types.
    -
    Existing keys of type "List" with a "Primary key" set in the schema:
      - Strategy can be changed
    with `custom_structured_configuration_list_merge`. Default strategy:
        - Existing list items with
    the same "Primary key"-value will be updated.
        - New unique items will be appended to the
    existing list
    - Other keys of type "List" will have new unique items appended the the existing list.
    - Existing keys of type "Dictionary" will recursively merge
    - Other existing keys will be replaced.
    """
    cv_pathfinder_global_sites: CvPathfinderGlobalSites
    """
    Define sites that are outside of the CV Pathfinder hierarchy.
    This is used to arrange pathfinders in
    the CloudVision topology layout.
    """
    cv_pathfinder_internet_exit_policies: CvPathfinderInternetExitPolicies
    """
    PREVIEW: These keys are in preview mode.

    List of internet-exit policies used for the WAN
    configuration.
    """
    cv_pathfinder_regions: CvPathfinderRegions
    """Define the CV Pathfinder hierarchy."""
    cv_server: str | None
    """
    PREVIEW: These keys are in preview mode.

    Hostname or IP address of CloudVision host. Ex.
    "www.arista.io" for CVaaS.
    For `eos_designs` this variable is only used for the WAN Internet-exit
    integration with Zscaler.
    The same variable name is also used by the `cv_deploy` role, and will
    override the value of `ansible_host` on inventory 'cloudvision' host.
    Make sure to set it in a
    common group_vars file.
    """
    cv_tags_topology_type: str | None
    """
    PREVIEW: This key is currently not supported
    Device type that CloudVision should use when generating
    the Topology. Defaults to the setting under node_type_keys.
    """
    cv_token: str | None
    """
    PREVIEW: These keys are in preview mode.

    Service account token as defined on CloudVision. This
    value should be using Ansible Vault.
    For `eos_designs` this variable is only used for the WAN
    Internet-exit integration with Zscaler.
    The same variable name is also used by the `cv_deploy` role,
    and will override the value of `ansible_password` on inventory 'cloudvision' host.
    Make sure to set
    it in a common group_vars file.
    """
    cv_topology: CvTopology
    """
    Generate AVD configurations directly from the given CloudVision topology.
    Activate this feature by
    setting `use_cv_topology` to `true`.
    Requires `default_interfaces` to be set for the relevant
    platforms and node types to detect the proper interface roles automatically.
    Neighbor hostnames must
    match the inventory hostnames of the AVD inventory to be taken into consideration.
    """
    cvp_ingestauth_key: str | None
    """
    On-premise CVP ingest auth key. If set, TerminAttr will be configured with key-based authentication
    for on-premise CVP.
    If not set, TerminAttr will be configured with certificate based authentication:
    - On-premise using token onboarding. Default token path is '/tmp/token'.
    - CVaaS using token-secure
    onboarding. Default token path is '/tmp/cv-onboarding-token'.
    Token must be copied to the device
    first.
    """
    cvp_instance_ips: list[str]
    """
    List of IPv4 addresses or DNS names for CloudVision.
    For on-premise CloudVision enter all the nodes
    of the cluster.
    For CloudVision as a Service enter the DNS name of the instance.
    `eos_designs` only
    supports one CloudVision cluster.
    """
    cvp_token_file: str | None
    """
    cvp_token_file is the path to the token file on the switch.
    If not set the default locations for on-
    premise or CVaaS will be used.
    See cvp_ingestauth_key for details.
    """
    dc_name: str | None
    """
    POD Name is used in:
    - Fabric Documentation (Optional, falls back to fabric_name)
    - SNMP Location:
    `snmp_settings.location` (Optional)
    - HER Overlay DC scoped flood lists:
    `overlay_her_flood_list_scope: dc` (Required)
    """
    default_connected_endpoints_description: str | None
    """
    Default description or description template to be used on all ports to connected endpoints.
    This can
    be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `endpoint_type`: The `type` from
    `connected_endpoints_keys` like `server`, `router` etc.
      - `endpoint`: The name of the connected
    endpoint
      - `endpoint_port`: The value from `endpoint_ports` for this switch port if set.

    By
    default the description is templated from the type, name and port of the endpoint if set.
    """
    default_connected_endpoints_port_channel_description: str | None
    """
    Default description or description template to be used on all port-channels to connected endpoints.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `endpoint_type`: The `type` from
    `connected_endpoints_keys` like `server`, `router` etc.
      - `endpoint`: The name of the connected
    endpoint
      - `endpoint_port_channel`: The value of `endpoint_port_channel` if set.
      -
    `port_channel_id`: The port-channel number for the switch.
      - `adapter_description`: The adapter's
    description if set.
      - `adapter_description_or_endpoint`: Helper alias of the adapter_description
    or endpoint.

    By default the description is templated from the type, name and port-channel name of
    the endpoint if set.
    """
    default_igmp_snooping_enabled: bool | None
    """When set to false, disables IGMP snooping at fabric level and overrides per vlan settings."""
    default_interface_mtu: int | None
    """
    Default interface MTU configured on EOS under "interface defaults".
    Can be overridden per platform
    under platform settings.
    """
    default_interfaces: list[DefaultInterfacesItem]
    """
    Default uplink, downlink, and MLAG interfaces, which will be used if these interfaces are not
    defined on a device (either directly or through inheritance).
    """
    default_mgmt_method: str | None
    """
    `default_mgmt_method` controls the default VRF and source interface used for the following
    management and monitoring protocols configured with `eos_designs`:
      - `ntp_settings`
      -
    `sflow_settings`

    `oob` means the protocols will be configured with the VRF set by
    `mgmt_interface_vrf` and `mgmt_interface` as the source interface.
    `inband` means the protocols will
    be configured with the VRF set by `inband_mgmt_vrf` and `inband_mgmt_interface` as the source
    interface.
    `none` means the VRF and or interface must be manually set for each protocol.
    This can be
    overridden under the settings for each protocol.
    """
    default_network_ports_description: str | None
    """
    Default description or description template to be used on all ports defined under `network_ports`.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `endpoint_type`: Always set to
    `network_port`.
      - `endpoint`: The value of the `endpoint` key if set.

    By default the description
    is templated from the `endpoint` key if set.
    """
    default_network_ports_port_channel_description: str | None
    """
    Default description or description template to be used on all port-channels defined under
    `network_ports`.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `endpoint_type`: Always set to
    `network_port`.
      - `endpoint`: The value of the `endpoint` key if set.
      - `endpoint_port_channel`:
    The value of `endpoint_port_channel` if set.
      - `port_channel_id`: The port-channel number for the
    switch.
      - `adapter_description`: The adapter's description if set.
      -
    `adapter_description_or_endpoint`: Helper alias of the adapter_description or endpoint.

    By default
    the description is templated from the `endpoint` key if set.
    """
    default_node_types: DefaultNodeTypes
    """Uses hostname matches against a regular expression to determine the node type."""
    default_underlay_p2p_ethernet_description: str | None
    """
    The default description or description template to be used on L3 point-to-point ethernet interfaces.
    The interfaces using this are the routed uplinks and `p2p_links` defined under `l3_edge` or
    `core_interfaces`.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `peer`: The name of the peer.
      -
    `interface`: The local interface name.
      - `peer_interface`: The interface on the peer.
      - `vrf`:
    The name of the VRF if set (Only applicable for `uplink_type: p2p-vrfs`).

    By default the
    description is templated from the name and interface of the peer.
    """
    default_underlay_p2p_port_channel_description: str | None
    """
    The default description or description template to be used on L3 point-to-point port-channel
    interfaces.
    The port-channels using this are `p2p_links` defined under `l3_edge` or
    `core_interfaces`.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `peer`: The name of the peer.
      -
    `interface`: The local interface name.
      - `peer_interface`: The interface on the peer.
      -
    `port_channel_id`: The local port-channel ID.
      - `peer_port_channel_id`: The ID of the port-channel
    on the peer.

    By default the description is templated from the name and interface of the peer.
    """
    default_vrf_diag_loopback_description: str | None
    """
    The default description or description template to be used on VRF diagnostic loopback interfaces.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `interface`: The Loopback interface
    name.
      - `vrf`: The VRF name.
      - `tenant`: The tenant name.

    By default the description is
    templated from the VRF name.
    """
    design: Design
    enable_trunk_groups: bool | None
    """
    Enable Trunk Group support across eos_designs.
    Warning: Because of the nature of the EOS Trunk Group
    feature, enabling this is "all or nothing".
    *All* vlans and *all* trunks towards connected endpoints
    must be using trunk groups as well.
    If trunk groups are not assigned to a trunk, no vlans will be
    enabled on that trunk.
    See "Details on enable_trunk_groups" below before enabling this feature.
    """
    eos_designs_custom_templates: list[EosDesignsCustomTemplatesItem]
    eos_designs_documentation: EosDesignsDocumentation
    """Control fabric documentation generation."""
    event_handlers: EventHandlers
    """
    Gives the ability to monitor and react to Syslog messages.
    Event Handlers provide a powerful and
    flexible tool that can be used to apply self-healing actions,
    customize the system behavior, and
    implement workarounds to problems discovered in the field.
    """
    evpn_ebgp_gateway_inter_domain: bool | None
    evpn_ebgp_gateway_multihop: int | None
    """
    Default of 15, considering a large value to avoid BGP reachability issues in very complex DCI
    networks.
    Adapt the value for your specific topology.
    """
    evpn_ebgp_multihop: int | None
    """
    Default of 3, the recommended value for a 3 stage spine and leaf topology.
    Set to a higher value to
    allow for very large and complex topologies.
    """
    evpn_hostflap_detection: EvpnHostflapDetection
    evpn_import_pruning: bool | None
    """
    Enable VPN import pruning (Min. EOS 4.24.2F).
    The Route Target extended communities carried by
    incoming VPN paths will be examined.
    If none of those Route Targets have been configured for import,
    the path will be immediately discarded.
    """
    evpn_multicast: bool | None
    """
    General Configuration required for EVPN Multicast. "evpn_l2_multicast" or "evpn_l3_multicast" must
    also be configured under the Network Services (tenants).
    Requires "underlay_multicast: true" and
    IGMP snooping enabled globally (default).
    For MLAG devices Route Distinguisher must be unique since
    this feature will create multi-vtep configuration.
    Warning !!! For Trident3 based platforms i.e
    7050X3, 7300X3, 720XP.
      The Following default platform setting will be configured on 7050X3 and
    7300X3: "platform trident forwarding-table partition flexible exact-match 16384 l2-shared 98304
    l3-shared 131072"
      The Following default platform setting will be configured on 720XP: "flexible
    exact-match 16000 l2-shared 18000 l3-shared 22000"
      All forwarding agents will be restarted when
    this configuration is applied.
      You can tune the settings by overriding the default variable:
    "platform_settings[platforms].trident_forwarding_table_partition:"
      Please contact an Arista
    representative for help with determining the appropriate values for your environment.
    """
    evpn_overlay_bgp_rtc: bool | None
    """
    Enable Route Target Membership Constraint Address Family on EVPN overlay BGP peerings (Min. EOS
    4.25.1F).
    Requires use eBGP as overlay protocol.
    """
    evpn_prevent_readvertise_to_server: bool | None
    """
    Configure route-map on eBGP sessions towards route-servers, where prefixes with the peer's ASN in
    the AS Path are filtered away.
    This is very useful in large-scale networks, where convergence will
    be quicker by not returning all updates received
    from Route-server-1 to Router-server-2 just for
    Route-server-2 to throw them away because of AS Path loop detection.
    """
    evpn_short_esi_prefix: str | None
    """Configure prefix for "short_esi" values."""
    evpn_vlan_aware_bundles: bool | None
    """
    Enable VLAN aware bundles for every EVPN MAC-VRF.
    If set to `true` all SVIs in a VRF are configured
    in a vlan-aware-bundle using the VRF name as the bundle name. `l2vlans` are bundled in vlan-aware-
    bundles using the VLAN name as the bundle name.

    The `evpn_vlan_bundle` option under `svis` and
    `l2vlans` takes precedence and overrides this behavior. Per svi/l2vlan `evpn_vlan_bundle` also works
    when this setting is disabled which allow mixing vlan-aware-bundles with regular MAC-VRFs.
    """
    evpn_vlan_bundles: EvpnVlanBundles
    fabric_evpn_encapsulation: str | None
    """Should be set to mpls for evpn-mpls scenario."""
    fabric_flow_tracking: FabricFlowTracking
    """
    Default enabling of flow-tracking(IPFIX) for various interface types across the fabric.
    Flow
    Tracking can also be enabled/disabled under each of the specific data models.
    For general flow-
    tracking settings see `flow_tracking_settings`.
    """
    fabric_ip_addressing: FabricIpAddressing
    fabric_name: str
    """
    Fabric Name, required to match Ansible Group name covering all devices in the Fabric, **must** be an
    inventory group name.
    """
    fabric_sflow: FabricSflow
    """
    Default enabling of sFlow for various interface types across the fabric.
    sFlow can also be
    enabled/disabled under each of the specific data models.
    For general sFlow settings see
    `sflow_settings`.
    """
    flow_tracking_settings: FlowTrackingSettings
    """Define the flow tracking parameters for this topology."""
    generate_cv_tags: GenerateCvTags
    """
    PREVIEW: This key is currently not supported
    Generate CloudVision Tags based on AVD data.
    """
    hardware_counters: HardwareCounters
    internal_vlan_order: InternalVlanOrder
    """Internal vlan allocation order and range."""
    ipv4_acls: Ipv4Acls
    """
    IPv4 extended access-lists supporting substitution on certain fields.
    These access-lists can be
    referenced under node settings `l3_interfaces`, and will only be configured on devices where they
    are in use.

    The substitution is useful when assigning the same access-list on multiple interfaces,
    but where certain fields require unique values like the "interface_ip" or "peer_ip".
    When using
    substitution, the interface name will be appended to the ACL name.
    """
    ipv4_prefix_list_catalog: Ipv4PrefixListCatalog
    """IPv4 prefix-list catalog."""
    ipv6_mgmt_destination_networks: list[str]
    """
    List of IPv6 prefixes to configure as static routes towards the OOB IPv6 Management interface
    gateway.
    Replaces the default route.
    """
    ipv6_mgmt_gateway: str | None
    """
    OOB Management interface gateway in IPv6 format.
    Used as next-hop for default gateway or static
    routes defined under 'ipv6_mgmt_destination_networks'.
    """
    is_deployed: bool | None
    """
    If the device is already deployed in the fabric.
    When set to false, interfaces toward this device
    may be shutdown depending on the `shutdown_interfaces_towards_undeployed_peers` setting.
    Furthermore
    `eos_config_deploy_cvp` will not attempt to move or apply configurations to the device.
    """
    isis_advertise_passive_only: bool | None
    isis_area_id: str | None
    isis_default_circuit_type: str | None
    """
    These fabric level parameters can be used with core_interfaces running ISIS, and may be overridden
    on link profile or link level.
    """
    isis_default_is_type: str | None
    isis_default_metric: int | None
    """
    These fabric level parameters can be used with core_interfaces running ISIS, and may be overridden
    at link profile or link level.
    """
    isis_maximum_paths: int | None
    """Number of path to configure in ECMP for ISIS."""
    isis_system_id_format: str | None
    """
    Configures source for the system-id within the ISIS net id.
    If this key is set to `node_id`, the
    fields `id` and `isis_system_id_prefix` configured under the node attributes are used to generate
    the system-id.
    If `underlay_loopback` is selected then all node `isis_system_id_prefix` settings
    will be ignored and the loopback address will be used to generate the system-id.
    """
    isis_ti_lfa: IsisTiLfa
    l3_edge: L3Edge
    l3_interface_profiles: L3InterfaceProfiles
    """
    Profiles to inherit common settings for l3_interfaces defined under the node type key.
    These
    profiles will *not* work for `l3_interfaces` defined under `vrfs`.
    """
    local_users: LocalUsers
    mac_address_table: MacAddressTable
    """
    MAC address-table aging time.
    Use to change the EOS default of 300.
    """
    management_eapi: ManagementEapi
    """
    Default is HTTPS management eAPI enabled.
    The VRF is set to < mgmt_interface_vrf >.
    """
    mgmt_destination_networks: list[str]
    """
    List of IPv4 prefixes to configure as static routes towards the OOB Management interface gateway.
    Replaces the default route.
    """
    mgmt_gateway: str | None
    """
    OOB Management interface gateway in IPv4 format.
    Used as next-hop for default gateway or static
    routes defined under 'mgmt_destination_networks'.
    """
    mgmt_interface: str | None
    """OOB Management interface."""
    mgmt_interface_description: str | None
    """Management interface description."""
    mgmt_interface_vrf: str | None
    """OOB Management VRF."""
    mgmt_vrf_routing: bool | None
    """Configure IP routing for the OOB Management VRF."""
    mlag_bgp_peer_description: str | None
    """
    Description or description template to be used on the MLAG BGP peers including those in VRFs.
    This
    can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `mlag_peer`: The name of the MLAG
    peer.
      - `interface`: The local MLAG L3 VLAN interface.
      - `peer_interface`: The MLAG L3 VLAN
    interface on the MLAG peer.
      - `vrf`: The name of the VRF. Not available for the underlay peering.
    The default description is built from the name and interface of the MLAG peer and optionally the
    VRF.
    """
    mlag_bgp_peer_group_description: str | None
    """
    Description or description template to be used on the MLAG BGP peer-group.
    This can be a template
    using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
    to/custom-descriptions-names.html#avd-string-formatter-syntax.
    The available template fields are:
    - `mlag_peer`: The name of the MLAG peer.

    The default description is the name of the MLAG peers.
    """
    mlag_ibgp_peering_vrfs: MlagIbgpPeeringVrfs
    """
    On mlag leafs, an SVI interface is defined per vrf, to establish iBGP peering (required when there
    are MLAG leafs in topology).
    The SVI id will be derived from the base vlan defined:
    mlag_ibgp_peering_vrfs.base_vlan + (vrf_id or vrf_vni) - 1.
    Depending on the values of vrf_id /
    vrf_vni it may be required to adjust the base_vlan to avoid overlaps or invalid vlan ids.
    The SVI ip
    address derived from mlag_l3_peer_ipv4_pool is re-used across all iBGP peerings.
    """
    mlag_member_description: str | None
    """
    Description or description template to be used on MLAG peer-link ethernet interfaces.
    This can be a
    template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `mlag_peer`: The name of the MLAG
    peer.
      - `interface`: The local MLAG port-channel interface.
      - `peer_interface`: The port-channel
    interface on the MLAG peer.
      - `mlag_port_channel_id`: The local MLAG port-channel ID.
      -
    `mlag_peer_port_channel_id`: The port-channel ID on the MLAG peer.

    By default the description is
    templated from the name and interface of the MLAG peer.
    """
    mlag_on_orphan_port_channel_downlink: bool | None
    """
    If `true` an MLAG ID will always be configured on a Port-Channel downlink even if the downlink is
    only on one node in the MLAG pair.
    If `false` (default) an MLAG ID will only be configured on Port-
    Channel downlinks dual-homed to two MLAG switches.
    """
    mlag_peer_l3_svi_description: str | None
    """
    Description or description template to be used on MLAG L3 peering SVI (Interface Vlan4093 by
    default).
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `mlag_peer`: The name of the MLAG
    peer.
      - `interface`: The MLAG L3 peering SVI name.
      - `mlag_peer_l3_vlan`: The MLAG L3 peering
    VLAN ID.
    """
    mlag_peer_l3_vlan_name: str | None
    """
    Name or name template to be used on MLAG L3 VLAN (VLAN 4093 by default).
    This can be a template
    using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
    to/custom-descriptions-names.html#avd-string-formatter-syntax.
    The available template fields are:
    - `mlag_peer`: The name of the MLAG peer.
      - `mlag_peer_l3_vlan`: The MLAG L3 peering VLAN ID.
    """
    mlag_peer_l3_vrf_svi_description: str | None
    """
    Description or description template to be used on MLAG L3 peering SVI for VRFs.
    This can be a
    template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `mlag_peer`: The name of the MLAG
    peer.
      - `interface`: The MLAG L3 VRF peering SVI name.
      - `vlan`: The MLAG L3 VRF peering VLAN
    ID.
      - `vrf`: The VRF name.
    """
    mlag_peer_l3_vrf_vlan_name: str | None
    """
    Name or name template to be used on MLAG L3 peering VLAN for VRFs.
    This can be a template using the
    AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
    descriptions-names.html#avd-string-formatter-syntax.
    The available template fields are:
      -
    `mlag_peer`: The name of the MLAG peer.
      - `vlan`: The MLAG L3 VRF peering VLAN ID.
      - `vrf`: The
    VRF name.
    """
    mlag_peer_svi_description: str | None
    """
    Description or description template to be used on MLAG peering SVI (Interface Vlan4094 by default).
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `mlag_peer`: The name of the MLAG
    peer.
      - `interface`: The MLAG peering SVI name.
      - `mlag_peer_vlan`: The MLAG peering VLAN ID.
    """
    mlag_peer_vlan_name: str | None
    """
    Name or name template to be used on MLAG peering VLAN (VLAN 4094 by default).
    This can be a template
    using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
    to/custom-descriptions-names.html#avd-string-formatter-syntax.
    The available template fields are:
    - `mlag_peer`: The name of the MLAG peer.
      - `mlag_peer_vlan`: The MLAG peering VLAN ID.
    """
    mlag_port_channel_description: str | None
    """
    Description or description template to be used on MLAG peer-link port-channel interfaces.
    This can
    be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `mlag_peer`: The name of the MLAG
    peer.
      - `interface`: The local MLAG port-channel interface.
      - `peer_interface`: The port-channel
    interface on the MLAG peer.
      - `mlag_port_channel_id`: The local MLAG port-channel ID.
      -
    `mlag_peer_port_channel_id`: The port-channel ID on the MLAG peer.

    By default the description is
    templated from the name and port-channel interface of the MLAG peer.
    """
    name_servers: list[str]
    """List of DNS servers. The VRF is set to < mgmt_interface_vrf >."""
    network_ports: list[NetworkPortsItem]
    network_services_keys: NetworkServicesKeys
    """
    Network Services can be grouped by using separate keys.
    The keys can be customized to provide a
    better better organization or grouping of your data.
    `network_services_keys` should be defined in
    the top level group_vars for the fabric.
    The default values will be overridden if defining this key,
    so it is recommended to copy the defaults and modify them.
    """
    custom_node_type_keys: CustomNodeTypeKeys
    """
    Define Custom Node Type Keys, to specify the properties of each node type in the fabric.
    This allows
    for complete customization of the fabric layout and functionality.
    `custom_node_type_keys` should be
    defined in top level group_var for the fabric.
    These values will be combined with the defaults;
    custom node type keys named the same as a
    default node_type_key will replace the default.
    """
    node_type_keys: NodeTypeKeys
    """
    Define Node Type Keys, to specify the properties of each node type in the fabric.
    This allows for
    complete customization of the fabric layout and functionality.
    `node_type_keys` should be defined in
    top level group_var for the fabric.

    The default values will be overridden if this key is defined.
    If you need to change all the existing `node_type_keys`, it is recommended to copy the defaults and
    modify them.
    If you need to add custom `node_type_keys`, create them under `custom_node_type_keys` -
    if named identically to default `node_type_keys` entries,
    custom entries will replace the equivalent
    default entry.
    """
    ntp_settings: NtpSettings
    """NTP settings"""
    only_local_vlan_trunk_groups: bool | None
    """
    A vlan can have many trunk_groups assigned.
    To avoid unneeded configuration changes on all leaf
    switches when a new trunk group is added,
    this feature will only configure the vlan trunk groups
    matched with local connected_endpoints.
    See "Details on only_local_vlan_trunk_groups" below.
    Requires "enable_trunk_groups: true".
    """
    overlay_bgp_peer_description: str | None
    """
    Description or description template to be used on the overlay BGP peers.
    This can be a template
    using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
    to/custom-descriptions-names.html#avd-string-formatter-syntax.
    The available template fields are:
    - `peer`: The name of the BGP peer.
      - `peer_interface`: The interface on the BGP peer if
    available.

    The default description is built from the name and interface of the BGP peer.
    """
    overlay_cvx_servers: list[str]
    """
    List of CVX vxlan overlay controllers.
    Required if overlay_routing_protocol == CVX.
    CVX servers
    (VMs) are peering using their management interface, so mgmt_ip must be set for all CVX servers.
    """
    overlay_her_flood_list_per_vni: bool | None
    """
    When using Head-End Replication, configure flood-lists per VNI.
    By default HER will be configured
    with a common flood-list containing all VTEPs.
    This behavior can be changed to per-VNI flood-lists
    by setting `overlay_her_flood_list_per_vni: true`.
    This will make `eos_designs` consider configured
    VLANs per VTEP, and only include the relevant VTEPs to each VNI's flood-list.
    """
    overlay_her_flood_list_scope: str | None
    """
    When using Head-End Replication, set the scope of flood-lists to Fabric or DC.
    By default all VTEPs
    in the Fabric (part of the inventory group referenced by "fabric_name") are added to the flood-
    lists.
    This can be changed to all VTEPs in the DC (sharing the same "dc_name" value).
    This is useful
    if Border Leaf switches are dividing the VXLAN overlay into separate domains.
    """
    overlay_loopback_description: str | None
    """Customize the description on overlay interface Loopback0."""
    overlay_mlag_rfc5549: bool | None
    """
    IPv6 Unnumbered for MLAG iBGP connections.
    Requires "underlay_rfc5549: true".
    """
    overlay_rd_type: OverlayRdType
    """
    Configuration options for the Administrator subfield (first part of RD) and the Assigned Number
    subfield (second part of RD).

    By default Route Distinguishers (RD) are set to:
    -
    `<overlay_loopback>:<mac_vrf_id_base + vlan_id or mac_vrf_vni_base + vlan_id>` for VLANs and VLAN-
    Aware Bundles with L2 vlans.
    - `<overlay_loopback>:<vlan_aware_bundle_number_base + vrf_id>` for
    VLAN-Aware Bundles with SVIs.
    - `<overlay_loopback>:<vlan_aware_bundle_number_base + id>` for VLAN-
    Aware Bundles defined under 'evpn_vlan_bundles'.
    - `<overlay_loopback>:<vrf_id>` for VRFs.

    Note:
    RD
    is a 48-bit value which is split into <16-bit>:<32-bit> or <32-bit>:<16-bit>.
    When using loopback or
    32-bit ASN/number the assigned number can only be a 16-bit number. This may be a problem with large
    VNIs.
    For 16-bit ASN/number the assigned number can be a 32-bit number.
    """
    overlay_routing_protocol: str | None
    """
    - The following overlay routing protocols are supported:
      - eBGP: Configures fabric with eBGP,
    default for l3ls-evpn design.
      - iBGP: Configured fabric with iBGP, only supported with OSPF or
    ISIS variants in underlay, default for mpls design.
      - CVX: Configures fabric to leverage
    CloudVision eXchange as the overlay controller.
      - HER: Configures fabric with Head-End
    Replication, configures static VXLAN flood-lists instead of using a dynamic overlay protocol.
      -
    none: No overlay configuration will be generated, default for l2ls design.
    """
    overlay_routing_protocol_address_family: str | None
    """
    When set to `ipv6`, enable overlay EVPN peering with IPv6 addresses.
    This feature depends on
    underlay_ipv6 variable. As of today, only RFC5549 is capable to transport IPv6 in the underlay.
    """
    overlay_rt_type: OverlayRtType
    """
    Configuration options for the Administrator subfield (first part of RT) and the Assigned Number
    subfield (second part of RT).

    By default Route Targets (RT) are set to:
    - `<(mac_vrf_id_base or
    mac_vrf_vni_base) + vlan_id>:<(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id>` for VLANs and VLAN-
    Aware Bundles with L2 vlans.
    - `<vlan_aware_bundle_number_base +
    vrf_id>:<vlan_aware_bundle_number_base + vrf_id>` for VLAN-Aware Bundles with SVIs.
    -
    `<vlan_aware_bundle_number_base + id>:<vlan_aware_bundle_number_base + id>` for VLAN-Aware Bundles
    defined under 'evpn_vlan_bundles'.
    - `<vrf_id>:<vrf_id>` for VRFs.

    Notes:
    RT is a 48-bit value
    which is split into <16-bit>:<32-bit> or <32-bit>:<16-bit>.
    When using 32-bit ASN/number the VNI can
    only be a 16-bit number. Alternatively use vlan_id/vrf_id as assigned number.
    For 16-bit ASN/number
    the assigned number can be a 32-bit number.
    """
    p2p_uplinks_mtu: int | None
    """
    Point to Point Links MTU.
    Precedence: <node_type>.uplink_mtu -> platform_settings.p2p_uplinks_mtu ->
    p2p_uplinks_mtu -> 9214
    """
    p2p_uplinks_qos_profile: str | None
    """QOS Profile assigned on all infrastructure links."""
    custom_platform_settings: list[CustomPlatformSettingsItem]
    """
    Custom Platform settings to override the default `platform_settings`. This list will be prepended to
    the list of `platform_settings`. The first entry containing `platforms` matching the `platform` node
    setting will be chosen. If no matches are found, the first entry containing a platform `default`
    will be chosen.
    """
    platform_settings: list[PlatformSettingsItem]
    """
    Platform settings. The first entry containing `platforms` matching the `platform` node setting will
    be chosen. If no matches are found, the first entry containing a platform `default` will be chosen.
    The default values will be overridden if `platform_settings` is defined. If you need to replace all
    the default platforms, it is recommended to copy the defaults and modify them. If you need to add
    custom platforms, create them under `custom_platform_settings`. Entries under
    `custom_platform_settings` will be matched before the equivalent entries from `platform_settings`.
    """
    platform_speed_groups: PlatformSpeedGroups
    """Set Hardware Speed Groups per Platform."""
    pod_name: str | None
    """
    POD Name is used in:
    - Fabric Documentation (Optional, falls back to dc_name and then to
    fabric_name)
    - SNMP Location: `snmp_settings.location` (Optional)
    - VRF Loopbacks:
    `vtep_diagnostic.loopback_ip_pools.pod` (Required)

    Recommended to be common between Spines and
    Leafs within a POD (One l3ls topology).
    """
    port_profiles: PortProfiles
    """
    Optional profiles to share common settings for connected_endpoints and/or network_ports.
    Keys are
    the same used under endpoints adapters. Keys defined under endpoints adapters take precedence.
    """
    ptp_profiles: PtpProfiles
    ptp_settings: PtpSettings
    """Common PTP settings."""
    queue_monitor_length: QueueMonitorLength
    redundancy: Redundancy
    """Redundancy for chassis platforms with dual supervisors | Optional."""
    router_id_loopback_description: str | None
    """Customize the description on Router ID interface Loopback0."""
    serial_number: str | None
    """
    Serial Number of the device.
    Used for documentation purpose in the fabric documentation as can also
    be used by the 'eos_config_deploy_cvp' role.
    "serial_number" can also be set directly under node
    type settings.
    If both are set, the value under node type settings takes precedence.
    """
    sflow_settings: SflowSettings
    """
    sFlow settings.
    The sFlow process will only be configured if any interface is enabled for sFlow.
    For
    default enabling of sFlow for various interface types across the fabric see `fabric_sflow`.
    """
    shutdown_bgp_towards_undeployed_peers: bool | None
    """
    When a device is set undeployed using `is_deployed: false` and
    `shutdown_bgp_towards_undeployed_peers` key is set to true, the BGP neighborship is shutdown on the
    peer.
    """
    shutdown_interfaces_towards_undeployed_peers: bool | None
    """
    - It is possible to provision configurations for a complete topology but flag devices as undeployed
    using the host level variable `is_deployed: false`.

    ```yaml
    # Use at the host level
    is_deployed: <
    true or false or default -> true >
    ```

    - By default, this will have no impact within the
    `eos_designs` role. Configs will still be generated by the `eos_cli_config_gen` role and will still
    be pushed by the `eos_config_deploy_eapi` directly to devices if used.
    - However, if the
    `eos_config_deploy_cvp` role is used to push configurations, CloudVision will ignore the devices
    flagged  as `is_deployed: false` and not attempt to configure them.
    - If the device is not present
    in the network due to CloudVision not configuring the device, `eos_validate_state` role will fail
    tests on peers of the undeployed device trying to verify that interfaces are up.
    - To overcome this
    and shutdown interfaces towards undeployed peers, the variable
    `shutdown_interfaces_towards_undeployed_peers` can be used, satisfying the `eos_validate_state` role
    interface tests.
    - Again, this is only an issue if `eos_config_deploy_cvp` is used and the devices
    are not present in the network.
    """
    snmp_settings: SnmpSettings
    """
    SNMP settings.
    For SNMP local-interfaces see "source_interfaces.snmp".
    Configuration of remote SNMP
    engine IDs are currently only possible using `structured_config`.
    """
    source_interfaces: SourceInterfaces
    """
    Configure source-interfaces based on the management interfaces set for other `eos_designs` data
    models.
    By default, no source-interfaces will be configured. They can still be configured manually
    using `eos_cli_config_gen` and custom structured configuration.
    EOS supports a single source-
    interface per VRF, so an error will be raised in case of conflicts.
    Errors will also be raised if an
    interface is not found for a device.
    """
    svi_profiles: SviProfiles
    """
    Profiles to share common settings for SVIs under `<network_services_key>.[].vrfs.svis`.
    Keys are the
    same used under SVIs. Keys defined under SVIs take precedence.
    Note: structured configuration is not
    merged recursively and will be taken directly from the most specific level in the following order:
    1. svi.nodes[inventory_hostname].structured_config
    2.
    svi_profile.nodes[inventory_hostname].structured_config
    3.
    svi_parent_profile.nodes[inventory_hostname].structured_config
    4. svi.structured_config
    5.
    svi_profile.structured_config
    6. svi_parent_profile.structured_config
    """
    system_mac_address: str | None
    """
    Set to the same MAC address as available in "show version" on the device.
    "system_mac_address" can
    also be set under node type settings.
    If both are set, the value under node type settings takes
    precedence.
    """
    terminattr_disable_aaa: bool | None
    terminattr_ingestexclude: str | None
    terminattr_ingestgrpcurl_port: int | None
    """
    Port number used for Terminattr connection to an on-premise CloudVision cluster.
    The port number is
    always 443 when using CloudVision as a Service, so this value is ignored.
    """
    terminattr_smashexcludes: str | None
    timezone: str | None
    """Clock timezone like "CET" or "US/Pacific"."""
    trunk_groups: TrunkGroups
    type: str | None
    """
    The `type:` variable needs to be defined for each device in the fabric.
    This is leveraged to load
    the appropriate template to generate the configuration.
    """
    underlay_filter_peer_as: bool | None
    """
    Configure route-map on eBGP sessions towards underlay peers, where prefixes with the peer's ASN in
    the AS Path are filtered away.
    This is very useful in very large scale networks not using EVPN
    overlays, where convergence will be quicker by not having to return
    all updates received from
    Spine-1 to Spine-2 just for Spine-2 to throw them away because of AS Path loop detection.
    Note that
    this setting cannot be used while there are EVPN services present in the default VRF.
    """
    underlay_filter_redistribute_connected: bool | None
    """
    Filter redistribution of connected into the underlay routing protocol.
    Only applicable when
    overlay_routing_protocol != 'none' and underlay_routing_protocol == BGP.
    Creates a route-map and
    prefix-list assigned to redistribute connected permitting only loopbacks and inband management
    subnets.
    """
    underlay_ipv6: bool | None
    """
    This feature allows IPv6 underlay routing protocol with RFC5549 addresses to be used along with IPv4
    advertisements as VXLAN tunnel endpoints.
    Requires "underlay_rfc5549: true" and "loopback_ipv6_pool"
    under the node type settings.
    """
    underlay_isis_bfd: bool | None
    """Enable BFD for ISIS on all underlay links."""
    underlay_isis_instance_name: str | None
    """Default -> "EVPN_UNDERLAY" for l3ls, "CORE" for mpls."""
    underlay_l2_ethernet_description: str | None
    """
    The description or description template to be used on L2 ethernet interfaces.
    The interfaces using
    this are the member interfaces of port-channel uplinks.
    This can be a template using the AVD string
    formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-
    names.html#avd-string-formatter-syntax.
    The available template fields are:
      - `peer`: The name of
    the peer.
      - `interface`: The local interface name.
      - `peer_interface`: The interface on the
    peer.

    By default the description is templated from the hostname and interface of the peer.
    """
    underlay_l2_port_channel_description: str | None
    """
    The description or description template to be used on L2 port-channel interfaces.
    The interfaces
    using this are port-channel uplinks.
    This can be a template using the AVD string formatter syntax:
    https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
    string-formatter-syntax.
    The available template fields are:
      - `peer`: The name of the peer.
      -
    `interface`: The local interface name.
      - `peer_interface`: The interface on the peer.
      -
    `port_channel_id`: The local port-channel ID.
      - `peer_port_channel_id`: The ID of the port-channel
    on the peer.
      - `peer_node_group`: The node group of the peer if the peer is an MLAG member or
    running EVPN A/A.
      - `peer_node_group_or_peer`: Helper alias of the peer_node_group or peer.
      -
    `peer_node_group_or_uppercase_peer`: Helper alias of the peer_node_group or peer hostname in
    uppercase.

    By default the description is templated from the peer's node group (for MLAG or EVPN
    A/A) or hostname and port-channel interface of the peer.
    """
    underlay_multicast: bool | None
    """
    Enable Multicast in the underlay on all p2p uplink interfaces and mlag l3 peer interface.
    Specifically PIM Sparse-Mode will be configured on all routed underlay interfaces.
    No other
    configuration is added, so the underlay will only support Source-Specific Multicast (SSM).
    The
    configuration is intended to be used as multicast underlay for EVPN OISM overlay.
    """
    underlay_multicast_anycast_rp: UnderlayMulticastAnycastRp
    """
    If multiple nodes are configured under 'underlay_multicast_rps.[].nodes' for the same RP address,
    they will be configured
    with one of the following methods:
    - Anycast RP using PIM (RFC4610).
    -
    Anycast RP using MSDP (RFC4611).

    NOTE: When using MSDP, all nodes across all MSDP enabled RPs will
    be added to a single MSDP mesh group named "ANYCAST-RP".
    """
    underlay_multicast_rps: UnderlayMulticastRps
    """
    List of PIM Sparse-Mode Rendevouz Points configured for underlay multicast on all devices.
    The
    device(s) listed under 'nodes', will be configured as the Rendevouz point router(s).
    If multiple
    nodes are configured under 'nodes' for the same RP address, they will be configured
    according to the
    'underlay_multicast_anycast_rp.mode' setting.

    Requires 'underlay_multicast: true'.
    """
    underlay_ospf_area: str | None
    underlay_ospf_authentication: UnderlayOspfAuthentication
    underlay_ospf_bfd_enable: bool | None
    underlay_ospf_max_lsa: int | None
    underlay_ospf_process_id: int | None
    underlay_rfc5549: bool | None
    """
    Point to Point Underlay with RFC 5549(eBGP), i.e. IPv6 Unnumbered.
    Requires
    "underlay_routing_protocol: ebgp".
    """
    underlay_routing_protocol: str | None
    """
    - The following underlay routing protocols are supported:
      - EBGP (default for l3ls-evpn)
      - OSPF.
    - OSPF-LDP*.
      - ISIS.
      - ISIS-SR*.
      - ISIS-LDP*.
      - ISIS-SR-LDP*.
      - No underlay routing
    protocol (none)
    - The variables should be applied to all devices in the fabric.
    *Only supported with
    core_interfaces data model.
    """
    uplink_ptp: UplinkPtp
    """Enable PTP on all infrastructure links."""
    use_cv_topology: bool | None
    """
    Generate AVD configurations directly from a given CloudVision topology.
    See `cv_topology` for
    details.
    """
    vtep_loopback_description: str | None
    """Customize the description on the VTEP interface, typically Loopback1."""
    vtep_vvtep_ip: str | None
    """
    IP Address used as Virtual VTEP. Will be configured as secondary IP on Loopback1.
    This is only
    needed for centralized routing designs.
    """
    wan_carriers: WanCarriers
    """List of carriers used for the WAN configuration and their mapping to path-groups."""
    wan_encapsulation: str | None
    """Select the encapsulation to use for EVPN peerings for WAN BGP peers."""
    wan_ha: WanHa
    """PREVIEW: The `wan_ha` key is currently not supported."""
    wan_ipsec_profiles: WanIpsecProfiles
    """Define IPsec profiles parameters for WAN configuration."""
    wan_mode: str | None
    """Select if the WAN should be run using CV Pathfinder or Legacy AutoVPN only."""
    wan_path_groups: WanPathGroups
    """List of path-groups used for the WAN configuration."""
    wan_route_servers: WanRouteServers
    """
    List of the AutoVPN RRs when using `wan_mode: legacy-autovpn`, or the Pathfinders
    when using
    `wan_mode: cv-pathfinder`, to which the device should connect to.
    This is also used to establish
    iBGP sessions between WAN route servers.

    When the route server is part of the same inventory as the
    WAN routers,
    only the name is required.
    """
    wan_stun_dtls_disable: bool | None
    """
    WAN STUN connections are authenticated and secured with DTLS by default.
    For CV Pathfinder
    deployments CloudVision will automatically deploy certificates on the devices.
    In case of AutoVPN
    the certificates must be deployed manually to all devices.

    For LAB environments this can be
    disabled, if there are no certificates available.
    This should NOT be disabled for a WAN network
    connected to the internet, since it will leave the STUN service exposed with no authentication.
    """
    wan_stun_dtls_profile_name: str | None
    """
    Name of the SSL profile used for DTLS on WAN STUN connections.
    When using automatic ceritficate
    deployment via CloudVision this name must be the same on all WAN routers.
    """
    wan_virtual_topologies: WanVirtualTopologies
    """
    Configure Virtual Topologies for CV Pathfinder and AutoVPN.
    Auto create a control plane
    profile/policy/application and enforce it being first in the default VRF.
    """
    zscaler_endpoints: ZscalerEndpoints
    """
    PREVIEW: These keys are in preview mode.

    Special data model used for testing the WAN internet-exit
    integration with Zscaler.
    The model is supposed to be autofilled per-device by `eos_designs`.
    Manually setting this model will take precedence and prevent `eos_designs` from trying to contact
    CloudVision.
    This can be useful for offline testing or if CloudVision is not available or not
    configured for Zscaler integration.
    """
    _custom_structured_configurations: list[_CustomStructuredConfigurationsItem]
    _dynamic_keys: _DynamicKeys
    """Dynamic keys"""

    def __init__(
        self,
        *,
        application_classification: ApplicationClassification | UndefinedType = Undefined,
        avd_data_validation_mode: str | None | UndefinedType = Undefined,
        avd_eos_designs_debug: bool | None | UndefinedType = Undefined,
        avd_eos_designs_structured_config: bool | None | UndefinedType = Undefined,
        avd_eos_designs_unset_facts: bool | None | UndefinedType = Undefined,
        bfd_multihop: BfdMultihop | UndefinedType = Undefined,
        bgp_as: str | None | UndefinedType = Undefined,
        bgp_default_ipv4_unicast: bool | None | UndefinedType = Undefined,
        bgp_distance: BgpDistance | UndefinedType = Undefined,
        bgp_ecmp: int | None | UndefinedType = Undefined,
        bgp_graceful_restart: BgpGracefulRestart | UndefinedType = Undefined,
        bgp_maximum_paths: int | None | UndefinedType = Undefined,
        bgp_mesh_pes: bool | None | UndefinedType = Undefined,
        bgp_peer_groups: BgpPeerGroups | UndefinedType = Undefined,
        bgp_update_wait_install: bool | None | UndefinedType = Undefined,
        bgp_update_wait_for_convergence: bool | None | UndefinedType = Undefined,
        connected_endpoints_keys: ConnectedEndpointsKeys | UndefinedType = Undefined,
        core_interfaces: CoreInterfaces | UndefinedType = Undefined,
        custom_structured_configuration_list_merge: str | None | UndefinedType = Undefined,
        custom_structured_configuration_prefix: list[str] | UndefinedType = Undefined,
        cv_pathfinder_global_sites: CvPathfinderGlobalSites | UndefinedType = Undefined,
        cv_pathfinder_internet_exit_policies: CvPathfinderInternetExitPolicies | UndefinedType = Undefined,
        cv_pathfinder_regions: CvPathfinderRegions | UndefinedType = Undefined,
        cv_server: str | None | UndefinedType = Undefined,
        cv_tags_topology_type: str | None | UndefinedType = Undefined,
        cv_token: str | None | UndefinedType = Undefined,
        cv_topology: CvTopology | UndefinedType = Undefined,
        cvp_ingestauth_key: str | None | UndefinedType = Undefined,
        cvp_instance_ips: list[str] | UndefinedType = Undefined,
        cvp_token_file: str | None | UndefinedType = Undefined,
        dc_name: str | None | UndefinedType = Undefined,
        default_connected_endpoints_description: str | None | UndefinedType = Undefined,
        default_connected_endpoints_port_channel_description: str | None | UndefinedType = Undefined,
        default_igmp_snooping_enabled: bool | None | UndefinedType = Undefined,
        default_interface_mtu: int | None | UndefinedType = Undefined,
        default_interfaces: list[DefaultInterfacesItem] | UndefinedType = Undefined,
        default_mgmt_method: str | None | UndefinedType = Undefined,
        default_network_ports_description: str | None | UndefinedType = Undefined,
        default_network_ports_port_channel_description: str | None | UndefinedType = Undefined,
        default_node_types: DefaultNodeTypes | UndefinedType = Undefined,
        default_underlay_p2p_ethernet_description: str | None | UndefinedType = Undefined,
        default_underlay_p2p_port_channel_description: str | None | UndefinedType = Undefined,
        default_vrf_diag_loopback_description: str | None | UndefinedType = Undefined,
        design: Design | UndefinedType = Undefined,
        enable_trunk_groups: bool | None | UndefinedType = Undefined,
        eos_designs_custom_templates: list[EosDesignsCustomTemplatesItem] | UndefinedType = Undefined,
        eos_designs_documentation: EosDesignsDocumentation | UndefinedType = Undefined,
        event_handlers: EventHandlers | UndefinedType = Undefined,
        evpn_ebgp_gateway_inter_domain: bool | None | UndefinedType = Undefined,
        evpn_ebgp_gateway_multihop: int | None | UndefinedType = Undefined,
        evpn_ebgp_multihop: int | None | UndefinedType = Undefined,
        evpn_hostflap_detection: EvpnHostflapDetection | UndefinedType = Undefined,
        evpn_import_pruning: bool | None | UndefinedType = Undefined,
        evpn_multicast: bool | None | UndefinedType = Undefined,
        evpn_overlay_bgp_rtc: bool | None | UndefinedType = Undefined,
        evpn_prevent_readvertise_to_server: bool | None | UndefinedType = Undefined,
        evpn_short_esi_prefix: str | None | UndefinedType = Undefined,
        evpn_vlan_aware_bundles: bool | None | UndefinedType = Undefined,
        evpn_vlan_bundles: EvpnVlanBundles | UndefinedType = Undefined,
        fabric_evpn_encapsulation: str | None | UndefinedType = Undefined,
        fabric_flow_tracking: FabricFlowTracking | UndefinedType = Undefined,
        fabric_ip_addressing: FabricIpAddressing | UndefinedType = Undefined,
        fabric_name: str | UndefinedType = Undefined,
        fabric_sflow: FabricSflow | UndefinedType = Undefined,
        flow_tracking_settings: FlowTrackingSettings | UndefinedType = Undefined,
        generate_cv_tags: GenerateCvTags | UndefinedType = Undefined,
        hardware_counters: HardwareCounters | UndefinedType = Undefined,
        internal_vlan_order: InternalVlanOrder | UndefinedType = Undefined,
        ipv4_acls: Ipv4Acls | UndefinedType = Undefined,
        ipv4_prefix_list_catalog: Ipv4PrefixListCatalog | UndefinedType = Undefined,
        ipv6_mgmt_destination_networks: list[str] | UndefinedType = Undefined,
        ipv6_mgmt_gateway: str | None | UndefinedType = Undefined,
        is_deployed: bool | None | UndefinedType = Undefined,
        isis_advertise_passive_only: bool | None | UndefinedType = Undefined,
        isis_area_id: str | None | UndefinedType = Undefined,
        isis_default_circuit_type: str | None | UndefinedType = Undefined,
        isis_default_is_type: str | None | UndefinedType = Undefined,
        isis_default_metric: int | None | UndefinedType = Undefined,
        isis_maximum_paths: int | None | UndefinedType = Undefined,
        isis_system_id_format: str | None | UndefinedType = Undefined,
        isis_ti_lfa: IsisTiLfa | UndefinedType = Undefined,
        l3_edge: L3Edge | UndefinedType = Undefined,
        l3_interface_profiles: L3InterfaceProfiles | UndefinedType = Undefined,
        local_users: LocalUsers | UndefinedType = Undefined,
        mac_address_table: MacAddressTable | UndefinedType = Undefined,
        management_eapi: ManagementEapi | UndefinedType = Undefined,
        mgmt_destination_networks: list[str] | UndefinedType = Undefined,
        mgmt_gateway: str | None | UndefinedType = Undefined,
        mgmt_interface: str | None | UndefinedType = Undefined,
        mgmt_interface_description: str | None | UndefinedType = Undefined,
        mgmt_interface_vrf: str | None | UndefinedType = Undefined,
        mgmt_vrf_routing: bool | None | UndefinedType = Undefined,
        mlag_bgp_peer_description: str | None | UndefinedType = Undefined,
        mlag_bgp_peer_group_description: str | None | UndefinedType = Undefined,
        mlag_ibgp_peering_vrfs: MlagIbgpPeeringVrfs | UndefinedType = Undefined,
        mlag_member_description: str | None | UndefinedType = Undefined,
        mlag_on_orphan_port_channel_downlink: bool | None | UndefinedType = Undefined,
        mlag_peer_l3_svi_description: str | None | UndefinedType = Undefined,
        mlag_peer_l3_vlan_name: str | None | UndefinedType = Undefined,
        mlag_peer_l3_vrf_svi_description: str | None | UndefinedType = Undefined,
        mlag_peer_l3_vrf_vlan_name: str | None | UndefinedType = Undefined,
        mlag_peer_svi_description: str | None | UndefinedType = Undefined,
        mlag_peer_vlan_name: str | None | UndefinedType = Undefined,
        mlag_port_channel_description: str | None | UndefinedType = Undefined,
        name_servers: list[str] | UndefinedType = Undefined,
        network_ports: list[NetworkPortsItem] | UndefinedType = Undefined,
        network_services_keys: NetworkServicesKeys | UndefinedType = Undefined,
        custom_node_type_keys: CustomNodeTypeKeys | UndefinedType = Undefined,
        node_type_keys: NodeTypeKeys | UndefinedType = Undefined,
        ntp_settings: NtpSettings | UndefinedType = Undefined,
        only_local_vlan_trunk_groups: bool | None | UndefinedType = Undefined,
        overlay_bgp_peer_description: str | None | UndefinedType = Undefined,
        overlay_cvx_servers: list[str] | UndefinedType = Undefined,
        overlay_her_flood_list_per_vni: bool | None | UndefinedType = Undefined,
        overlay_her_flood_list_scope: str | None | UndefinedType = Undefined,
        overlay_loopback_description: str | None | UndefinedType = Undefined,
        overlay_mlag_rfc5549: bool | None | UndefinedType = Undefined,
        overlay_rd_type: OverlayRdType | UndefinedType = Undefined,
        overlay_routing_protocol: str | None | UndefinedType = Undefined,
        overlay_routing_protocol_address_family: str | None | UndefinedType = Undefined,
        overlay_rt_type: OverlayRtType | UndefinedType = Undefined,
        p2p_uplinks_mtu: int | None | UndefinedType = Undefined,
        p2p_uplinks_qos_profile: str | None | UndefinedType = Undefined,
        custom_platform_settings: list[CustomPlatformSettingsItem] | UndefinedType = Undefined,
        platform_settings: list[PlatformSettingsItem] | UndefinedType = Undefined,
        platform_speed_groups: PlatformSpeedGroups | UndefinedType = Undefined,
        pod_name: str | None | UndefinedType = Undefined,
        port_profiles: PortProfiles | UndefinedType = Undefined,
        ptp_profiles: PtpProfiles | UndefinedType = Undefined,
        ptp_settings: PtpSettings | UndefinedType = Undefined,
        queue_monitor_length: QueueMonitorLength | UndefinedType = Undefined,
        redundancy: Redundancy | UndefinedType = Undefined,
        router_id_loopback_description: str | None | UndefinedType = Undefined,
        serial_number: str | None | UndefinedType = Undefined,
        sflow_settings: SflowSettings | UndefinedType = Undefined,
        shutdown_bgp_towards_undeployed_peers: bool | None | UndefinedType = Undefined,
        shutdown_interfaces_towards_undeployed_peers: bool | None | UndefinedType = Undefined,
        snmp_settings: SnmpSettings | UndefinedType = Undefined,
        source_interfaces: SourceInterfaces | UndefinedType = Undefined,
        svi_profiles: SviProfiles | UndefinedType = Undefined,
        system_mac_address: str | None | UndefinedType = Undefined,
        terminattr_disable_aaa: bool | None | UndefinedType = Undefined,
        terminattr_ingestexclude: str | None | UndefinedType = Undefined,
        terminattr_ingestgrpcurl_port: int | None | UndefinedType = Undefined,
        terminattr_smashexcludes: str | None | UndefinedType = Undefined,
        timezone: str | None | UndefinedType = Undefined,
        trunk_groups: TrunkGroups | UndefinedType = Undefined,
        type: str | None | UndefinedType = Undefined,
        underlay_filter_peer_as: bool | None | UndefinedType = Undefined,
        underlay_filter_redistribute_connected: bool | None | UndefinedType = Undefined,
        underlay_ipv6: bool | None | UndefinedType = Undefined,
        underlay_isis_bfd: bool | None | UndefinedType = Undefined,
        underlay_isis_instance_name: str | None | UndefinedType = Undefined,
        underlay_l2_ethernet_description: str | None | UndefinedType = Undefined,
        underlay_l2_port_channel_description: str | None | UndefinedType = Undefined,
        underlay_multicast: bool | None | UndefinedType = Undefined,
        underlay_multicast_anycast_rp: UnderlayMulticastAnycastRp | UndefinedType = Undefined,
        underlay_multicast_rps: UnderlayMulticastRps | UndefinedType = Undefined,
        underlay_ospf_area: str | None | UndefinedType = Undefined,
        underlay_ospf_authentication: UnderlayOspfAuthentication | UndefinedType = Undefined,
        underlay_ospf_bfd_enable: bool | None | UndefinedType = Undefined,
        underlay_ospf_max_lsa: int | None | UndefinedType = Undefined,
        underlay_ospf_process_id: int | None | UndefinedType = Undefined,
        underlay_rfc5549: bool | None | UndefinedType = Undefined,
        underlay_routing_protocol: str | None | UndefinedType = Undefined,
        uplink_ptp: UplinkPtp | UndefinedType = Undefined,
        use_cv_topology: bool | None | UndefinedType = Undefined,
        vtep_loopback_description: str | None | UndefinedType = Undefined,
        vtep_vvtep_ip: str | None | UndefinedType = Undefined,
        wan_carriers: WanCarriers | UndefinedType = Undefined,
        wan_encapsulation: str | None | UndefinedType = Undefined,
        wan_ha: WanHa | UndefinedType = Undefined,
        wan_ipsec_profiles: WanIpsecProfiles | UndefinedType = Undefined,
        wan_mode: str | None | UndefinedType = Undefined,
        wan_path_groups: WanPathGroups | UndefinedType = Undefined,
        wan_route_servers: WanRouteServers | UndefinedType = Undefined,
        wan_stun_dtls_disable: bool | None | UndefinedType = Undefined,
        wan_stun_dtls_profile_name: str | None | UndefinedType = Undefined,
        wan_virtual_topologies: WanVirtualTopologies | UndefinedType = Undefined,
        zscaler_endpoints: ZscalerEndpoints | UndefinedType = Undefined,
        _custom_structured_configurations: list[_CustomStructuredConfigurationsItem] | UndefinedType = Undefined,
        _dynamic_keys: _DynamicKeys | UndefinedType = Undefined,
        **kwargs: Any,
    ) -> None:
        """
        EosDesigns.

        Args:
        -----
            application_classification: application_classification
            avd_data_validation_mode:
               Validation Mode for AVD input data validation.
               Input data validation will validate the input
               variables according to the schema.
               During validation, messages will generated with information about
               the host(s) and key(s) which failed validation.
               "error" will produce error messages and fail the
               task.
               "warning" will produce warning messages.
            avd_eos_designs_debug: Dump all vars and facts per device after generating `avd_switch_facts`.
            avd_eos_designs_structured_config: Generate structured configuration per device.
            avd_eos_designs_unset_facts:
               Unset `avd_switch_facts` to gain a small performance improvement since Ansible needs to handle fewer
               variables.
            bfd_multihop: BFD Multihop tuning.
            bgp_as:
               BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>" to use to configure
               overlay when "overlay_routing_protocol" == ibgp.
               For asdot notation in YAML inputs, the value must
               be put in quotes, to prevent it from being interpreted as a float number.
            bgp_default_ipv4_unicast:
               Default activation of IPv4 unicast address-family on all IPv4 neighbors.
               It is best practice to
               disable activation.
            bgp_distance: bgp_distance
            bgp_ecmp:
               Maximum ECMP for BGP multi-path.
               The default value is 4 except for WAN Routers where the default
               value is unset (falls back to EOS default).
            bgp_graceful_restart:
               BGP graceful-restart allows a BGP speaker with separate control plane and data plane processing to
               continue forwarding traffic during a BGP restart.
               Its neighbors (receiving speakers) may retain
               routing information from the restarting speaker while a BGP session with it is being re-established,
               reducing route flapping.
            bgp_maximum_paths:
               Maximum Paths for BGP multi-path.
               The default value is 4 except for WAN Routers where the default
               value is 16.
            bgp_mesh_pes:
               Configure an iBGP full mesh between PEs, either because there is no RR used or other reasons.
               Only
               supported in combination with MPLS overlay.
            bgp_peer_groups:
               Leverage an Arista EOS switch to generate the encrypted password using the correct peer group name.
               Note that the name of the peer groups use '-' instead of '_' in EOS configuration.
            bgp_update_wait_install: bgp_update_wait_install
            bgp_update_wait_for_convergence: bgp_update_wait_for_convergence
            connected_endpoints_keys:
               Endpoints connecting to the fabric can be grouped by using separate keys.
               The keys can be customized
               to provide a better better organization or grouping of your data.
               `connected_endpoints_keys` should
               be defined in the top level group_vars for the fabric.
               The default values will be overridden if
               defining this key, so it is recommended to copy the defaults and modify them.
            core_interfaces: core_interfaces
            custom_structured_configuration_list_merge:
               The List-merge strategy used when merging custom structured configurations.

               This applies to all
               vars prefixed by prefixes in `custom_structured_configuration_prefix`
               and all data under the various
               `structured_config` options.

               The available list merge strategies:
               - `replace`:
                 - Any list will be
               replaced with the list defined in custom structured configurations.
               - `append`:
                 - Existing list
               items with the same "Primary key"-value will be updated.
                 - New items will be appended to the
               existing list (including duplicates).
               - `keep`:
                 - Only set list if there is no existing list or
               existing list is `None`.
               - `prepend`:
                 - Existing list items with the same "Primary key"-value will
               be updated.
                 - New items will be prepended to the existing list (including duplicates).
               -
               `append_rp`:
                 - Existing list items with the same "Primary key"-value will be updated.
                 - New
               unique items will be appended to the existing list.
               - `prepend_rp`:
                 - Existing list items with the
               same "Primary key"-value will be updated.
                 - New unique items will be prepended to the existing
               list.
            custom_structured_configuration_prefix:
               Custom EOS Structured Configuration keys can be set on any group or host_var level using the name
               of
               the corresponding `eos_cli_config_gen` key prefixed with content of
               `custom_structured_configuration_prefix`.

               The content of Custom Structured Configuration variables
               will be merged with the structured config generated by the eos_designs role.

               The merge is done
               recursively, so it is possible to update a sub-key of a variable set by `eos_designs` role already.
               The merge follow these recursive merge strategies:
               - New keys will be added for all types.
               -
               Existing keys of type "List" with a "Primary key" set in the schema:
                 - Strategy can be changed
               with `custom_structured_configuration_list_merge`. Default strategy:
                   - Existing list items with
               the same "Primary key"-value will be updated.
                   - New unique items will be appended to the
               existing list
               - Other keys of type "List" will have new unique items appended the the existing list.
               - Existing keys of type "Dictionary" will recursively merge
               - Other existing keys will be replaced.
            cv_pathfinder_global_sites:
               Define sites that are outside of the CV Pathfinder hierarchy.
               This is used to arrange pathfinders in
               the CloudVision topology layout.
            cv_pathfinder_internet_exit_policies:
               PREVIEW: These keys are in preview mode.

               List of internet-exit policies used for the WAN
               configuration.
            cv_pathfinder_regions: Define the CV Pathfinder hierarchy.
            cv_server:
               PREVIEW: These keys are in preview mode.

               Hostname or IP address of CloudVision host. Ex.
               "www.arista.io" for CVaaS.
               For `eos_designs` this variable is only used for the WAN Internet-exit
               integration with Zscaler.
               The same variable name is also used by the `cv_deploy` role, and will
               override the value of `ansible_host` on inventory 'cloudvision' host.
               Make sure to set it in a
               common group_vars file.
            cv_tags_topology_type:
               PREVIEW: This key is currently not supported
               Device type that CloudVision should use when generating
               the Topology. Defaults to the setting under node_type_keys.
            cv_token:
               PREVIEW: These keys are in preview mode.

               Service account token as defined on CloudVision. This
               value should be using Ansible Vault.
               For `eos_designs` this variable is only used for the WAN
               Internet-exit integration with Zscaler.
               The same variable name is also used by the `cv_deploy` role,
               and will override the value of `ansible_password` on inventory 'cloudvision' host.
               Make sure to set
               it in a common group_vars file.
            cv_topology:
               Generate AVD configurations directly from the given CloudVision topology.
               Activate this feature by
               setting `use_cv_topology` to `true`.
               Requires `default_interfaces` to be set for the relevant
               platforms and node types to detect the proper interface roles automatically.
               Neighbor hostnames must
               match the inventory hostnames of the AVD inventory to be taken into consideration.
            cvp_ingestauth_key:
               On-premise CVP ingest auth key. If set, TerminAttr will be configured with key-based authentication
               for on-premise CVP.
               If not set, TerminAttr will be configured with certificate based authentication:
               - On-premise using token onboarding. Default token path is '/tmp/token'.
               - CVaaS using token-secure
               onboarding. Default token path is '/tmp/cv-onboarding-token'.
               Token must be copied to the device
               first.
            cvp_instance_ips:
               List of IPv4 addresses or DNS names for CloudVision.
               For on-premise CloudVision enter all the nodes
               of the cluster.
               For CloudVision as a Service enter the DNS name of the instance.
               `eos_designs` only
               supports one CloudVision cluster.
            cvp_token_file:
               cvp_token_file is the path to the token file on the switch.
               If not set the default locations for on-
               premise or CVaaS will be used.
               See cvp_ingestauth_key for details.
            dc_name:
               POD Name is used in:
               - Fabric Documentation (Optional, falls back to fabric_name)
               - SNMP Location:
               `snmp_settings.location` (Optional)
               - HER Overlay DC scoped flood lists:
               `overlay_her_flood_list_scope: dc` (Required)
            default_connected_endpoints_description:
               Default description or description template to be used on all ports to connected endpoints.
               This can
               be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `endpoint_type`: The `type` from
               `connected_endpoints_keys` like `server`, `router` etc.
                 - `endpoint`: The name of the connected
               endpoint
                 - `endpoint_port`: The value from `endpoint_ports` for this switch port if set.

               By
               default the description is templated from the type, name and port of the endpoint if set.
            default_connected_endpoints_port_channel_description:
               Default description or description template to be used on all port-channels to connected endpoints.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `endpoint_type`: The `type` from
               `connected_endpoints_keys` like `server`, `router` etc.
                 - `endpoint`: The name of the connected
               endpoint
                 - `endpoint_port_channel`: The value of `endpoint_port_channel` if set.
                 -
               `port_channel_id`: The port-channel number for the switch.
                 - `adapter_description`: The adapter's
               description if set.
                 - `adapter_description_or_endpoint`: Helper alias of the adapter_description
               or endpoint.

               By default the description is templated from the type, name and port-channel name of
               the endpoint if set.
            default_igmp_snooping_enabled: When set to false, disables IGMP snooping at fabric level and overrides per vlan settings.
            default_interface_mtu:
               Default interface MTU configured on EOS under "interface defaults".
               Can be overridden per platform
               under platform settings.
            default_interfaces:
               Default uplink, downlink, and MLAG interfaces, which will be used if these interfaces are not
               defined on a device (either directly or through inheritance).
            default_mgmt_method:
               `default_mgmt_method` controls the default VRF and source interface used for the following
               management and monitoring protocols configured with `eos_designs`:
                 - `ntp_settings`
                 -
               `sflow_settings`

               `oob` means the protocols will be configured with the VRF set by
               `mgmt_interface_vrf` and `mgmt_interface` as the source interface.
               `inband` means the protocols will
               be configured with the VRF set by `inband_mgmt_vrf` and `inband_mgmt_interface` as the source
               interface.
               `none` means the VRF and or interface must be manually set for each protocol.
               This can be
               overridden under the settings for each protocol.
            default_network_ports_description:
               Default description or description template to be used on all ports defined under `network_ports`.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `endpoint_type`: Always set to
               `network_port`.
                 - `endpoint`: The value of the `endpoint` key if set.

               By default the description
               is templated from the `endpoint` key if set.
            default_network_ports_port_channel_description:
               Default description or description template to be used on all port-channels defined under
               `network_ports`.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `endpoint_type`: Always set to
               `network_port`.
                 - `endpoint`: The value of the `endpoint` key if set.
                 - `endpoint_port_channel`:
               The value of `endpoint_port_channel` if set.
                 - `port_channel_id`: The port-channel number for the
               switch.
                 - `adapter_description`: The adapter's description if set.
                 -
               `adapter_description_or_endpoint`: Helper alias of the adapter_description or endpoint.

               By default
               the description is templated from the `endpoint` key if set.
            default_node_types: Uses hostname matches against a regular expression to determine the node type.
            default_underlay_p2p_ethernet_description:
               The default description or description template to be used on L3 point-to-point ethernet interfaces.
               The interfaces using this are the routed uplinks and `p2p_links` defined under `l3_edge` or
               `core_interfaces`.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `peer`: The name of the peer.
                 -
               `interface`: The local interface name.
                 - `peer_interface`: The interface on the peer.
                 - `vrf`:
               The name of the VRF if set (Only applicable for `uplink_type: p2p-vrfs`).

               By default the
               description is templated from the name and interface of the peer.
            default_underlay_p2p_port_channel_description:
               The default description or description template to be used on L3 point-to-point port-channel
               interfaces.
               The port-channels using this are `p2p_links` defined under `l3_edge` or
               `core_interfaces`.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `peer`: The name of the peer.
                 -
               `interface`: The local interface name.
                 - `peer_interface`: The interface on the peer.
                 -
               `port_channel_id`: The local port-channel ID.
                 - `peer_port_channel_id`: The ID of the port-channel
               on the peer.

               By default the description is templated from the name and interface of the peer.
            default_vrf_diag_loopback_description:
               The default description or description template to be used on VRF diagnostic loopback interfaces.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `interface`: The Loopback interface
               name.
                 - `vrf`: The VRF name.
                 - `tenant`: The tenant name.

               By default the description is
               templated from the VRF name.
            design: design
            enable_trunk_groups:
               Enable Trunk Group support across eos_designs.
               Warning: Because of the nature of the EOS Trunk Group
               feature, enabling this is "all or nothing".
               *All* vlans and *all* trunks towards connected endpoints
               must be using trunk groups as well.
               If trunk groups are not assigned to a trunk, no vlans will be
               enabled on that trunk.
               See "Details on enable_trunk_groups" below before enabling this feature.
            eos_designs_custom_templates: eos_designs_custom_templates
            eos_designs_documentation: Control fabric documentation generation.
            event_handlers:
               Gives the ability to monitor and react to Syslog messages.
               Event Handlers provide a powerful and
               flexible tool that can be used to apply self-healing actions,
               customize the system behavior, and
               implement workarounds to problems discovered in the field.
            evpn_ebgp_gateway_inter_domain: evpn_ebgp_gateway_inter_domain
            evpn_ebgp_gateway_multihop:
               Default of 15, considering a large value to avoid BGP reachability issues in very complex DCI
               networks.
               Adapt the value for your specific topology.
            evpn_ebgp_multihop:
               Default of 3, the recommended value for a 3 stage spine and leaf topology.
               Set to a higher value to
               allow for very large and complex topologies.
            evpn_hostflap_detection: evpn_hostflap_detection
            evpn_import_pruning:
               Enable VPN import pruning (Min. EOS 4.24.2F).
               The Route Target extended communities carried by
               incoming VPN paths will be examined.
               If none of those Route Targets have been configured for import,
               the path will be immediately discarded.
            evpn_multicast:
               General Configuration required for EVPN Multicast. "evpn_l2_multicast" or "evpn_l3_multicast" must
               also be configured under the Network Services (tenants).
               Requires "underlay_multicast: true" and
               IGMP snooping enabled globally (default).
               For MLAG devices Route Distinguisher must be unique since
               this feature will create multi-vtep configuration.
               Warning !!! For Trident3 based platforms i.e
               7050X3, 7300X3, 720XP.
                 The Following default platform setting will be configured on 7050X3 and
               7300X3: "platform trident forwarding-table partition flexible exact-match 16384 l2-shared 98304
               l3-shared 131072"
                 The Following default platform setting will be configured on 720XP: "flexible
               exact-match 16000 l2-shared 18000 l3-shared 22000"
                 All forwarding agents will be restarted when
               this configuration is applied.
                 You can tune the settings by overriding the default variable:
               "platform_settings[platforms].trident_forwarding_table_partition:"
                 Please contact an Arista
               representative for help with determining the appropriate values for your environment.
            evpn_overlay_bgp_rtc:
               Enable Route Target Membership Constraint Address Family on EVPN overlay BGP peerings (Min. EOS
               4.25.1F).
               Requires use eBGP as overlay protocol.
            evpn_prevent_readvertise_to_server:
               Configure route-map on eBGP sessions towards route-servers, where prefixes with the peer's ASN in
               the AS Path are filtered away.
               This is very useful in large-scale networks, where convergence will
               be quicker by not returning all updates received
               from Route-server-1 to Router-server-2 just for
               Route-server-2 to throw them away because of AS Path loop detection.
            evpn_short_esi_prefix: Configure prefix for "short_esi" values.
            evpn_vlan_aware_bundles:
               Enable VLAN aware bundles for every EVPN MAC-VRF.
               If set to `true` all SVIs in a VRF are configured
               in a vlan-aware-bundle using the VRF name as the bundle name. `l2vlans` are bundled in vlan-aware-
               bundles using the VLAN name as the bundle name.

               The `evpn_vlan_bundle` option under `svis` and
               `l2vlans` takes precedence and overrides this behavior. Per svi/l2vlan `evpn_vlan_bundle` also works
               when this setting is disabled which allow mixing vlan-aware-bundles with regular MAC-VRFs.
            evpn_vlan_bundles: evpn_vlan_bundles
            fabric_evpn_encapsulation: Should be set to mpls for evpn-mpls scenario.
            fabric_flow_tracking:
               Default enabling of flow-tracking(IPFIX) for various interface types across the fabric.
               Flow
               Tracking can also be enabled/disabled under each of the specific data models.
               For general flow-
               tracking settings see `flow_tracking_settings`.
            fabric_ip_addressing: fabric_ip_addressing
            fabric_name:
               Fabric Name, required to match Ansible Group name covering all devices in the Fabric, **must** be an
               inventory group name.
            fabric_sflow:
               Default enabling of sFlow for various interface types across the fabric.
               sFlow can also be
               enabled/disabled under each of the specific data models.
               For general sFlow settings see
               `sflow_settings`.
            flow_tracking_settings: Define the flow tracking parameters for this topology.
            generate_cv_tags:
               PREVIEW: This key is currently not supported
               Generate CloudVision Tags based on AVD data.
            hardware_counters: hardware_counters
            internal_vlan_order: Internal vlan allocation order and range.
            ipv4_acls:
               IPv4 extended access-lists supporting substitution on certain fields.
               These access-lists can be
               referenced under node settings `l3_interfaces`, and will only be configured on devices where they
               are in use.

               The substitution is useful when assigning the same access-list on multiple interfaces,
               but where certain fields require unique values like the "interface_ip" or "peer_ip".
               When using
               substitution, the interface name will be appended to the ACL name.
            ipv4_prefix_list_catalog: IPv4 prefix-list catalog.
            ipv6_mgmt_destination_networks:
               List of IPv6 prefixes to configure as static routes towards the OOB IPv6 Management interface
               gateway.
               Replaces the default route.
            ipv6_mgmt_gateway:
               OOB Management interface gateway in IPv6 format.
               Used as next-hop for default gateway or static
               routes defined under 'ipv6_mgmt_destination_networks'.
            is_deployed:
               If the device is already deployed in the fabric.
               When set to false, interfaces toward this device
               may be shutdown depending on the `shutdown_interfaces_towards_undeployed_peers` setting.
               Furthermore
               `eos_config_deploy_cvp` will not attempt to move or apply configurations to the device.
            isis_advertise_passive_only: isis_advertise_passive_only
            isis_area_id: isis_area_id
            isis_default_circuit_type:
               These fabric level parameters can be used with core_interfaces running ISIS, and may be overridden
               on link profile or link level.
            isis_default_is_type: isis_default_is_type
            isis_default_metric:
               These fabric level parameters can be used with core_interfaces running ISIS, and may be overridden
               at link profile or link level.
            isis_maximum_paths: Number of path to configure in ECMP for ISIS.
            isis_system_id_format:
               Configures source for the system-id within the ISIS net id.
               If this key is set to `node_id`, the
               fields `id` and `isis_system_id_prefix` configured under the node attributes are used to generate
               the system-id.
               If `underlay_loopback` is selected then all node `isis_system_id_prefix` settings
               will be ignored and the loopback address will be used to generate the system-id.
            isis_ti_lfa: isis_ti_lfa
            l3_edge: l3_edge
            l3_interface_profiles:
               Profiles to inherit common settings for l3_interfaces defined under the node type key.
               These
               profiles will *not* work for `l3_interfaces` defined under `vrfs`.
            local_users: local_users
            mac_address_table:
               MAC address-table aging time.
               Use to change the EOS default of 300.
            management_eapi:
               Default is HTTPS management eAPI enabled.
               The VRF is set to < mgmt_interface_vrf >.
            mgmt_destination_networks:
               List of IPv4 prefixes to configure as static routes towards the OOB Management interface gateway.
               Replaces the default route.
            mgmt_gateway:
               OOB Management interface gateway in IPv4 format.
               Used as next-hop for default gateway or static
               routes defined under 'mgmt_destination_networks'.
            mgmt_interface: OOB Management interface.
            mgmt_interface_description: Management interface description.
            mgmt_interface_vrf: OOB Management VRF.
            mgmt_vrf_routing: Configure IP routing for the OOB Management VRF.
            mlag_bgp_peer_description:
               Description or description template to be used on the MLAG BGP peers including those in VRFs.
               This
               can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `mlag_peer`: The name of the MLAG
               peer.
                 - `interface`: The local MLAG L3 VLAN interface.
                 - `peer_interface`: The MLAG L3 VLAN
               interface on the MLAG peer.
                 - `vrf`: The name of the VRF. Not available for the underlay peering.
               The default description is built from the name and interface of the MLAG peer and optionally the
               VRF.
            mlag_bgp_peer_group_description:
               Description or description template to be used on the MLAG BGP peer-group.
               This can be a template
               using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
               to/custom-descriptions-names.html#avd-string-formatter-syntax.
               The available template fields are:
               - `mlag_peer`: The name of the MLAG peer.

               The default description is the name of the MLAG peers.
            mlag_ibgp_peering_vrfs:
               On mlag leafs, an SVI interface is defined per vrf, to establish iBGP peering (required when there
               are MLAG leafs in topology).
               The SVI id will be derived from the base vlan defined:
               mlag_ibgp_peering_vrfs.base_vlan + (vrf_id or vrf_vni) - 1.
               Depending on the values of vrf_id /
               vrf_vni it may be required to adjust the base_vlan to avoid overlaps or invalid vlan ids.
               The SVI ip
               address derived from mlag_l3_peer_ipv4_pool is re-used across all iBGP peerings.
            mlag_member_description:
               Description or description template to be used on MLAG peer-link ethernet interfaces.
               This can be a
               template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `mlag_peer`: The name of the MLAG
               peer.
                 - `interface`: The local MLAG port-channel interface.
                 - `peer_interface`: The port-channel
               interface on the MLAG peer.
                 - `mlag_port_channel_id`: The local MLAG port-channel ID.
                 -
               `mlag_peer_port_channel_id`: The port-channel ID on the MLAG peer.

               By default the description is
               templated from the name and interface of the MLAG peer.
            mlag_on_orphan_port_channel_downlink:
               If `true` an MLAG ID will always be configured on a Port-Channel downlink even if the downlink is
               only on one node in the MLAG pair.
               If `false` (default) an MLAG ID will only be configured on Port-
               Channel downlinks dual-homed to two MLAG switches.
            mlag_peer_l3_svi_description:
               Description or description template to be used on MLAG L3 peering SVI (Interface Vlan4093 by
               default).
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `mlag_peer`: The name of the MLAG
               peer.
                 - `interface`: The MLAG L3 peering SVI name.
                 - `mlag_peer_l3_vlan`: The MLAG L3 peering
               VLAN ID.
            mlag_peer_l3_vlan_name:
               Name or name template to be used on MLAG L3 VLAN (VLAN 4093 by default).
               This can be a template
               using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
               to/custom-descriptions-names.html#avd-string-formatter-syntax.
               The available template fields are:
               - `mlag_peer`: The name of the MLAG peer.
                 - `mlag_peer_l3_vlan`: The MLAG L3 peering VLAN ID.
            mlag_peer_l3_vrf_svi_description:
               Description or description template to be used on MLAG L3 peering SVI for VRFs.
               This can be a
               template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `mlag_peer`: The name of the MLAG
               peer.
                 - `interface`: The MLAG L3 VRF peering SVI name.
                 - `vlan`: The MLAG L3 VRF peering VLAN
               ID.
                 - `vrf`: The VRF name.
            mlag_peer_l3_vrf_vlan_name:
               Name or name template to be used on MLAG L3 peering VLAN for VRFs.
               This can be a template using the
               AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-
               descriptions-names.html#avd-string-formatter-syntax.
               The available template fields are:
                 -
               `mlag_peer`: The name of the MLAG peer.
                 - `vlan`: The MLAG L3 VRF peering VLAN ID.
                 - `vrf`: The
               VRF name.
            mlag_peer_svi_description:
               Description or description template to be used on MLAG peering SVI (Interface Vlan4094 by default).
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `mlag_peer`: The name of the MLAG
               peer.
                 - `interface`: The MLAG peering SVI name.
                 - `mlag_peer_vlan`: The MLAG peering VLAN ID.
            mlag_peer_vlan_name:
               Name or name template to be used on MLAG peering VLAN (VLAN 4094 by default).
               This can be a template
               using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
               to/custom-descriptions-names.html#avd-string-formatter-syntax.
               The available template fields are:
               - `mlag_peer`: The name of the MLAG peer.
                 - `mlag_peer_vlan`: The MLAG peering VLAN ID.
            mlag_port_channel_description:
               Description or description template to be used on MLAG peer-link port-channel interfaces.
               This can
               be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `mlag_peer`: The name of the MLAG
               peer.
                 - `interface`: The local MLAG port-channel interface.
                 - `peer_interface`: The port-channel
               interface on the MLAG peer.
                 - `mlag_port_channel_id`: The local MLAG port-channel ID.
                 -
               `mlag_peer_port_channel_id`: The port-channel ID on the MLAG peer.

               By default the description is
               templated from the name and port-channel interface of the MLAG peer.
            name_servers: List of DNS servers. The VRF is set to < mgmt_interface_vrf >.
            network_ports: network_ports
            network_services_keys:
               Network Services can be grouped by using separate keys.
               The keys can be customized to provide a
               better better organization or grouping of your data.
               `network_services_keys` should be defined in
               the top level group_vars for the fabric.
               The default values will be overridden if defining this key,
               so it is recommended to copy the defaults and modify them.
            custom_node_type_keys:
               Define Custom Node Type Keys, to specify the properties of each node type in the fabric.
               This allows
               for complete customization of the fabric layout and functionality.
               `custom_node_type_keys` should be
               defined in top level group_var for the fabric.
               These values will be combined with the defaults;
               custom node type keys named the same as a
               default node_type_key will replace the default.
            node_type_keys:
               Define Node Type Keys, to specify the properties of each node type in the fabric.
               This allows for
               complete customization of the fabric layout and functionality.
               `node_type_keys` should be defined in
               top level group_var for the fabric.

               The default values will be overridden if this key is defined.
               If you need to change all the existing `node_type_keys`, it is recommended to copy the defaults and
               modify them.
               If you need to add custom `node_type_keys`, create them under `custom_node_type_keys` -
               if named identically to default `node_type_keys` entries,
               custom entries will replace the equivalent
               default entry.
            ntp_settings: NTP settings
            only_local_vlan_trunk_groups:
               A vlan can have many trunk_groups assigned.
               To avoid unneeded configuration changes on all leaf
               switches when a new trunk group is added,
               this feature will only configure the vlan trunk groups
               matched with local connected_endpoints.
               See "Details on only_local_vlan_trunk_groups" below.
               Requires "enable_trunk_groups: true".
            overlay_bgp_peer_description:
               Description or description template to be used on the overlay BGP peers.
               This can be a template
               using the AVD string formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-
               to/custom-descriptions-names.html#avd-string-formatter-syntax.
               The available template fields are:
               - `peer`: The name of the BGP peer.
                 - `peer_interface`: The interface on the BGP peer if
               available.

               The default description is built from the name and interface of the BGP peer.
            overlay_cvx_servers:
               List of CVX vxlan overlay controllers.
               Required if overlay_routing_protocol == CVX.
               CVX servers
               (VMs) are peering using their management interface, so mgmt_ip must be set for all CVX servers.
            overlay_her_flood_list_per_vni:
               When using Head-End Replication, configure flood-lists per VNI.
               By default HER will be configured
               with a common flood-list containing all VTEPs.
               This behavior can be changed to per-VNI flood-lists
               by setting `overlay_her_flood_list_per_vni: true`.
               This will make `eos_designs` consider configured
               VLANs per VTEP, and only include the relevant VTEPs to each VNI's flood-list.
            overlay_her_flood_list_scope:
               When using Head-End Replication, set the scope of flood-lists to Fabric or DC.
               By default all VTEPs
               in the Fabric (part of the inventory group referenced by "fabric_name") are added to the flood-
               lists.
               This can be changed to all VTEPs in the DC (sharing the same "dc_name" value).
               This is useful
               if Border Leaf switches are dividing the VXLAN overlay into separate domains.
            overlay_loopback_description: Customize the description on overlay interface Loopback0.
            overlay_mlag_rfc5549:
               IPv6 Unnumbered for MLAG iBGP connections.
               Requires "underlay_rfc5549: true".
            overlay_rd_type:
               Configuration options for the Administrator subfield (first part of RD) and the Assigned Number
               subfield (second part of RD).

               By default Route Distinguishers (RD) are set to:
               -
               `<overlay_loopback>:<mac_vrf_id_base + vlan_id or mac_vrf_vni_base + vlan_id>` for VLANs and VLAN-
               Aware Bundles with L2 vlans.
               - `<overlay_loopback>:<vlan_aware_bundle_number_base + vrf_id>` for
               VLAN-Aware Bundles with SVIs.
               - `<overlay_loopback>:<vlan_aware_bundle_number_base + id>` for VLAN-
               Aware Bundles defined under 'evpn_vlan_bundles'.
               - `<overlay_loopback>:<vrf_id>` for VRFs.

        Note:
               RD
               is a 48-bit value which is split into <16-bit>:<32-bit> or <32-bit>:<16-bit>.
               When using loopback or
               32-bit ASN/number the assigned number can only be a 16-bit number. This may be a problem with large
               VNIs.
               For 16-bit ASN/number the assigned number can be a 32-bit number.
            overlay_routing_protocol:
               - The following overlay routing protocols are supported:
                 - eBGP: Configures fabric with eBGP,
               default for l3ls-evpn design.
                 - iBGP: Configured fabric with iBGP, only supported with OSPF or
               ISIS variants in underlay, default for mpls design.
                 - CVX: Configures fabric to leverage
               CloudVision eXchange as the overlay controller.
                 - HER: Configures fabric with Head-End
               Replication, configures static VXLAN flood-lists instead of using a dynamic overlay protocol.
                 -
               none: No overlay configuration will be generated, default for l2ls design.
            overlay_routing_protocol_address_family:
               When set to `ipv6`, enable overlay EVPN peering with IPv6 addresses.
               This feature depends on
               underlay_ipv6 variable. As of today, only RFC5549 is capable to transport IPv6 in the underlay.
            overlay_rt_type:
               Configuration options for the Administrator subfield (first part of RT) and the Assigned Number
               subfield (second part of RT).

               By default Route Targets (RT) are set to:
               - `<(mac_vrf_id_base or
               mac_vrf_vni_base) + vlan_id>:<(mac_vrf_id_base or mac_vrf_vni_base) + vlan_id>` for VLANs and VLAN-
               Aware Bundles with L2 vlans.
               - `<vlan_aware_bundle_number_base +
               vrf_id>:<vlan_aware_bundle_number_base + vrf_id>` for VLAN-Aware Bundles with SVIs.
               -
               `<vlan_aware_bundle_number_base + id>:<vlan_aware_bundle_number_base + id>` for VLAN-Aware Bundles
               defined under 'evpn_vlan_bundles'.
               - `<vrf_id>:<vrf_id>` for VRFs.

        Notes:
               RT is a 48-bit value
               which is split into <16-bit>:<32-bit> or <32-bit>:<16-bit>.
               When using 32-bit ASN/number the VNI can
               only be a 16-bit number. Alternatively use vlan_id/vrf_id as assigned number.
               For 16-bit ASN/number
               the assigned number can be a 32-bit number.
            p2p_uplinks_mtu:
               Point to Point Links MTU.
               Precedence: <node_type>.uplink_mtu -> platform_settings.p2p_uplinks_mtu ->
               p2p_uplinks_mtu -> 9214
            p2p_uplinks_qos_profile: QOS Profile assigned on all infrastructure links.
            custom_platform_settings:
               Custom Platform settings to override the default `platform_settings`. This list will be prepended to
               the list of `platform_settings`. The first entry containing `platforms` matching the `platform` node
               setting will be chosen. If no matches are found, the first entry containing a platform `default`
               will be chosen.
            platform_settings:
               Platform settings. The first entry containing `platforms` matching the `platform` node setting will
               be chosen. If no matches are found, the first entry containing a platform `default` will be chosen.
               The default values will be overridden if `platform_settings` is defined. If you need to replace all
               the default platforms, it is recommended to copy the defaults and modify them. If you need to add
               custom platforms, create them under `custom_platform_settings`. Entries under
               `custom_platform_settings` will be matched before the equivalent entries from `platform_settings`.
            platform_speed_groups: Set Hardware Speed Groups per Platform.
            pod_name:
               POD Name is used in:
               - Fabric Documentation (Optional, falls back to dc_name and then to
               fabric_name)
               - SNMP Location: `snmp_settings.location` (Optional)
               - VRF Loopbacks:
               `vtep_diagnostic.loopback_ip_pools.pod` (Required)

               Recommended to be common between Spines and
               Leafs within a POD (One l3ls topology).
            port_profiles:
               Optional profiles to share common settings for connected_endpoints and/or network_ports.
               Keys are
               the same used under endpoints adapters. Keys defined under endpoints adapters take precedence.
            ptp_profiles: ptp_profiles
            ptp_settings: Common PTP settings.
            queue_monitor_length: queue_monitor_length
            redundancy: Redundancy for chassis platforms with dual supervisors | Optional.
            router_id_loopback_description: Customize the description on Router ID interface Loopback0.
            serial_number:
               Serial Number of the device.
               Used for documentation purpose in the fabric documentation as can also
               be used by the 'eos_config_deploy_cvp' role.
               "serial_number" can also be set directly under node
               type settings.
               If both are set, the value under node type settings takes precedence.
            sflow_settings:
               sFlow settings.
               The sFlow process will only be configured if any interface is enabled for sFlow.
               For
               default enabling of sFlow for various interface types across the fabric see `fabric_sflow`.
            shutdown_bgp_towards_undeployed_peers:
               When a device is set undeployed using `is_deployed: false` and
               `shutdown_bgp_towards_undeployed_peers` key is set to true, the BGP neighborship is shutdown on the
               peer.
            shutdown_interfaces_towards_undeployed_peers:
               - It is possible to provision configurations for a complete topology but flag devices as undeployed
               using the host level variable `is_deployed: false`.

               ```yaml
               # Use at the host level
               is_deployed: <
               true or false or default -> true >
               ```

               - By default, this will have no impact within the
               `eos_designs` role. Configs will still be generated by the `eos_cli_config_gen` role and will still
               be pushed by the `eos_config_deploy_eapi` directly to devices if used.
               - However, if the
               `eos_config_deploy_cvp` role is used to push configurations, CloudVision will ignore the devices
               flagged  as `is_deployed: false` and not attempt to configure them.
               - If the device is not present
               in the network due to CloudVision not configuring the device, `eos_validate_state` role will fail
               tests on peers of the undeployed device trying to verify that interfaces are up.
               - To overcome this
               and shutdown interfaces towards undeployed peers, the variable
               `shutdown_interfaces_towards_undeployed_peers` can be used, satisfying the `eos_validate_state` role
               interface tests.
               - Again, this is only an issue if `eos_config_deploy_cvp` is used and the devices
               are not present in the network.
            snmp_settings:
               SNMP settings.
               For SNMP local-interfaces see "source_interfaces.snmp".
               Configuration of remote SNMP
               engine IDs are currently only possible using `structured_config`.
            source_interfaces:
               Configure source-interfaces based on the management interfaces set for other `eos_designs` data
               models.
               By default, no source-interfaces will be configured. They can still be configured manually
               using `eos_cli_config_gen` and custom structured configuration.
               EOS supports a single source-
               interface per VRF, so an error will be raised in case of conflicts.
               Errors will also be raised if an
               interface is not found for a device.
            svi_profiles:
               Profiles to share common settings for SVIs under `<network_services_key>.[].vrfs.svis`.
               Keys are the
               same used under SVIs. Keys defined under SVIs take precedence.
               Note: structured configuration is not
               merged recursively and will be taken directly from the most specific level in the following order:
               1. svi.nodes[inventory_hostname].structured_config
               2.
               svi_profile.nodes[inventory_hostname].structured_config
               3.
               svi_parent_profile.nodes[inventory_hostname].structured_config
               4. svi.structured_config
               5.
               svi_profile.structured_config
               6. svi_parent_profile.structured_config
            system_mac_address:
               Set to the same MAC address as available in "show version" on the device.
               "system_mac_address" can
               also be set under node type settings.
               If both are set, the value under node type settings takes
               precedence.
            terminattr_disable_aaa: terminattr_disable_aaa
            terminattr_ingestexclude: terminattr_ingestexclude
            terminattr_ingestgrpcurl_port:
               Port number used for Terminattr connection to an on-premise CloudVision cluster.
               The port number is
               always 443 when using CloudVision as a Service, so this value is ignored.
            terminattr_smashexcludes: terminattr_smashexcludes
            timezone: Clock timezone like "CET" or "US/Pacific".
            trunk_groups: trunk_groups
            type:
               The `type:` variable needs to be defined for each device in the fabric.
               This is leveraged to load
               the appropriate template to generate the configuration.
            underlay_filter_peer_as:
               Configure route-map on eBGP sessions towards underlay peers, where prefixes with the peer's ASN in
               the AS Path are filtered away.
               This is very useful in very large scale networks not using EVPN
               overlays, where convergence will be quicker by not having to return
               all updates received from
               Spine-1 to Spine-2 just for Spine-2 to throw them away because of AS Path loop detection.
               Note that
               this setting cannot be used while there are EVPN services present in the default VRF.
            underlay_filter_redistribute_connected:
               Filter redistribution of connected into the underlay routing protocol.
               Only applicable when
               overlay_routing_protocol != 'none' and underlay_routing_protocol == BGP.
               Creates a route-map and
               prefix-list assigned to redistribute connected permitting only loopbacks and inband management
               subnets.
            underlay_ipv6:
               This feature allows IPv6 underlay routing protocol with RFC5549 addresses to be used along with IPv4
               advertisements as VXLAN tunnel endpoints.
               Requires "underlay_rfc5549: true" and "loopback_ipv6_pool"
               under the node type settings.
            underlay_isis_bfd: Enable BFD for ISIS on all underlay links.
            underlay_isis_instance_name: Default -> "EVPN_UNDERLAY" for l3ls, "CORE" for mpls.
            underlay_l2_ethernet_description:
               The description or description template to be used on L2 ethernet interfaces.
               The interfaces using
               this are the member interfaces of port-channel uplinks.
               This can be a template using the AVD string
               formatter syntax: https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-
               names.html#avd-string-formatter-syntax.
               The available template fields are:
                 - `peer`: The name of
               the peer.
                 - `interface`: The local interface name.
                 - `peer_interface`: The interface on the
               peer.

               By default the description is templated from the hostname and interface of the peer.
            underlay_l2_port_channel_description:
               The description or description template to be used on L2 port-channel interfaces.
               The interfaces
               using this are port-channel uplinks.
               This can be a template using the AVD string formatter syntax:
               https://avd.arista.com/devel/roles/eos_designs/docs/how-to/custom-descriptions-names.html#avd-
               string-formatter-syntax.
               The available template fields are:
                 - `peer`: The name of the peer.
                 -
               `interface`: The local interface name.
                 - `peer_interface`: The interface on the peer.
                 -
               `port_channel_id`: The local port-channel ID.
                 - `peer_port_channel_id`: The ID of the port-channel
               on the peer.
                 - `peer_node_group`: The node group of the peer if the peer is an MLAG member or
               running EVPN A/A.
                 - `peer_node_group_or_peer`: Helper alias of the peer_node_group or peer.
                 -
               `peer_node_group_or_uppercase_peer`: Helper alias of the peer_node_group or peer hostname in
               uppercase.

               By default the description is templated from the peer's node group (for MLAG or EVPN
               A/A) or hostname and port-channel interface of the peer.
            underlay_multicast:
               Enable Multicast in the underlay on all p2p uplink interfaces and mlag l3 peer interface.
               Specifically PIM Sparse-Mode will be configured on all routed underlay interfaces.
               No other
               configuration is added, so the underlay will only support Source-Specific Multicast (SSM).
               The
               configuration is intended to be used as multicast underlay for EVPN OISM overlay.
            underlay_multicast_anycast_rp:
               If multiple nodes are configured under 'underlay_multicast_rps.[].nodes' for the same RP address,
               they will be configured
               with one of the following methods:
               - Anycast RP using PIM (RFC4610).
               -
               Anycast RP using MSDP (RFC4611).

               NOTE: When using MSDP, all nodes across all MSDP enabled RPs will
               be added to a single MSDP mesh group named "ANYCAST-RP".
            underlay_multicast_rps:
               List of PIM Sparse-Mode Rendevouz Points configured for underlay multicast on all devices.
               The
               device(s) listed under 'nodes', will be configured as the Rendevouz point router(s).
               If multiple
               nodes are configured under 'nodes' for the same RP address, they will be configured
               according to the
               'underlay_multicast_anycast_rp.mode' setting.

               Requires 'underlay_multicast: true'.
            underlay_ospf_area: underlay_ospf_area
            underlay_ospf_authentication: underlay_ospf_authentication
            underlay_ospf_bfd_enable: underlay_ospf_bfd_enable
            underlay_ospf_max_lsa: underlay_ospf_max_lsa
            underlay_ospf_process_id: underlay_ospf_process_id
            underlay_rfc5549:
               Point to Point Underlay with RFC 5549(eBGP), i.e. IPv6 Unnumbered.
               Requires
               "underlay_routing_protocol: ebgp".
            underlay_routing_protocol:
               - The following underlay routing protocols are supported:
                 - EBGP (default for l3ls-evpn)
                 - OSPF.
               - OSPF-LDP*.
                 - ISIS.
                 - ISIS-SR*.
                 - ISIS-LDP*.
                 - ISIS-SR-LDP*.
                 - No underlay routing
               protocol (none)
               - The variables should be applied to all devices in the fabric.
               *Only supported with
               core_interfaces data model.
            uplink_ptp: Enable PTP on all infrastructure links.
            use_cv_topology:
               Generate AVD configurations directly from a given CloudVision topology.
               See `cv_topology` for
               details.
            vtep_loopback_description: Customize the description on the VTEP interface, typically Loopback1.
            vtep_vvtep_ip:
               IP Address used as Virtual VTEP. Will be configured as secondary IP on Loopback1.
               This is only
               needed for centralized routing designs.
            wan_carriers: List of carriers used for the WAN configuration and their mapping to path-groups.
            wan_encapsulation: Select the encapsulation to use for EVPN peerings for WAN BGP peers.
            wan_ha: PREVIEW: The `wan_ha` key is currently not supported.
            wan_ipsec_profiles: Define IPsec profiles parameters for WAN configuration.
            wan_mode: Select if the WAN should be run using CV Pathfinder or Legacy AutoVPN only.
            wan_path_groups: List of path-groups used for the WAN configuration.
            wan_route_servers:
               List of the AutoVPN RRs when using `wan_mode: legacy-autovpn`, or the Pathfinders
               when using
               `wan_mode: cv-pathfinder`, to which the device should connect to.
               This is also used to establish
               iBGP sessions between WAN route servers.

               When the route server is part of the same inventory as the
               WAN routers,
               only the name is required.
            wan_stun_dtls_disable:
               WAN STUN connections are authenticated and secured with DTLS by default.
               For CV Pathfinder
               deployments CloudVision will automatically deploy certificates on the devices.
               In case of AutoVPN
               the certificates must be deployed manually to all devices.

               For LAB environments this can be
               disabled, if there are no certificates available.
               This should NOT be disabled for a WAN network
               connected to the internet, since it will leave the STUN service exposed with no authentication.
            wan_stun_dtls_profile_name:
               Name of the SSL profile used for DTLS on WAN STUN connections.
               When using automatic ceritficate
               deployment via CloudVision this name must be the same on all WAN routers.
            wan_virtual_topologies:
               Configure Virtual Topologies for CV Pathfinder and AutoVPN.
               Auto create a control plane
               profile/policy/application and enforce it being first in the default VRF.
            zscaler_endpoints:
               PREVIEW: These keys are in preview mode.

               Special data model used for testing the WAN internet-exit
               integration with Zscaler.
               The model is supposed to be autofilled per-device by `eos_designs`.
               Manually setting this model will take precedence and prevent `eos_designs` from trying to contact
               CloudVision.
               This can be useful for offline testing or if CloudVision is not available or not
               configured for Zscaler integration.
            _custom_structured_configurations: _custom_structured_configurations
            _dynamic_keys: Dynamic keys

        """
        for arg, arg_value in locals().items():
            if arg_value is Undefined or arg in ("self", "kwargs"):
                continue
            setattr(self, arg, arg_value)
