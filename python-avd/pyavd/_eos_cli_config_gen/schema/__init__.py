# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.

from typing import Any, ClassVar

from pyavd._schema.models import AvdCollection, AvdModel
from pyavd._utils import Undefined, UndefinedType


class EosCliConfigGen(AvdModel):
    class AaaAccounting(AvdModel):
        class Exec(AvdModel):
            class Console(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "group": {"type": str}, "logging": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                type: str | None
                group: str | None
                """Group Name."""
                logging: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                    logging: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Console.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Default(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "group": {"type": str}, "logging": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                type: str | None
                group: str | None
                """Group Name."""
                logging: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                    logging: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "console": {"type": Console}, "default": {"type": Default}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            console: Console
            default: Default

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                console: Console | UndefinedType = Undefined,
                default: Default | UndefinedType = Undefined,
            ) -> None:
                """
                Exec.

                Args:
                -----
                    _custom_data: _custom_data
                    console: console
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class System(AvdModel):
            class Default(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "group": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                type: str | None
                group: str | None
                """Group Name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": Default}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: Default

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: Default | UndefinedType = Undefined) -> None:
                """
                System.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdModel):
            class Default(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "group": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                type: str | None
                group: str | None
                """Group Name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        group: Group Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": Default}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: Default

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: Default | UndefinedType = Undefined) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Commands(AvdModel):
            class ConsoleItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "commands": {"type": str},
                    "type": {"type": str},
                    "group": {"type": str},
                    "logging": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                commands: str | None
                """Privilege level 'all' or 0-15."""
                type: str | None
                group: str | None
                """Group Name."""
                logging: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    commands: str | None | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                    logging: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ConsoleItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        commands: Privilege level 'all' or 0-15.
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "commands": {"type": str},
                    "type": {"type": str},
                    "group": {"type": str},
                    "logging": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                commands: str | None
                """Privilege level 'all' or 0-15."""
                type: str | None
                group: str | None
                """Group Name."""
                logging: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    commands: str | None | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    group: str | None | UndefinedType = Undefined,
                    logging: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        commands: Privilege level 'all' or 0-15.
                        type: type
                        group: Group Name.
                        logging: logging

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "console": {"type": list, "items": ConsoleItem},
                "default": {"type": list, "items": DefaultItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            console: list[ConsoleItem]
            default: list[DefaultItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                console: list[ConsoleItem] | UndefinedType = Undefined,
                default: list[DefaultItem] | UndefinedType = Undefined,
            ) -> None:
                """
                Commands.

                Args:
                -----
                    _custom_data: _custom_data
                    console: console
                    default: default

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "exec": {"type": Exec},
            "system": {"type": System},
            "dot1x": {"type": Dot1x},
            "commands": {"type": Commands},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        exec: Exec
        system: System
        dot1x: Dot1x
        commands: Commands

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            exec: Exec | UndefinedType = Undefined,
            system: System | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            commands: Commands | UndefinedType = Undefined,
        ) -> None:
            """
            AaaAccounting.

            Args:
            -----
                _custom_data: _custom_data
                exec: exec
                system: system
                dot1x: dot1x
                commands: commands

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaAuthentication(AvdModel):
        class Login(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": str}, "console": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: str | None
            """
            Login authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            - "group radius group MYGROUP local"
            """
            console: str | None
            """
            Console authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                default: str | None | UndefinedType = Undefined,
                console: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Login.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       Login authentication method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP none"
                       - "group radius group MYGROUP local"
                    console:
                       Console authentication method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP
                       none"
                       - "group radius group MYGROUP local"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Enable(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: str | None
            """
            Enable authentication method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group radius group MYGROUP local"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                """
                Enable.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       Enable authentication method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP
                       none"
                       - "group radius group MYGROUP local"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: str | None
            """
            802.1x authentication method(s) as a string.
            Examples:
            - "group radius"
            - "group MYGROUP group
            radius"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       802.1x authentication method(s) as a string.

                Examples:
                       - "group radius"
                       - "group MYGROUP group
                       radius"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdModel):
            class Local(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "allow_nopassword": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                allow_nopassword: bool | None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, allow_nopassword: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Local.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allow_nopassword: allow_nopassword

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Lockout(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "failure": {"type": int}, "duration": {"type": int}, "window": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                failure: int | None
                duration: int | None
                window: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    failure: int | None | UndefinedType = Undefined,
                    duration: int | None | UndefinedType = Undefined,
                    window: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Lockout.

                    Args:
                    -----
                        _custom_data: _custom_data
                        failure: failure
                        duration: duration
                        window: window

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "on_failure_log": {"type": bool},
                "on_success_log": {"type": bool},
                "local": {"type": Local},
                "lockout": {"type": Lockout},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            on_failure_log: bool | None
            on_success_log: bool | None
            local: Local
            lockout: Lockout

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                on_failure_log: bool | None | UndefinedType = Undefined,
                on_success_log: bool | None | UndefinedType = Undefined,
                local: Local | UndefinedType = Undefined,
                lockout: Lockout | UndefinedType = Undefined,
            ) -> None:
                """
                Policies.

                Args:
                -----
                    _custom_data: _custom_data
                    on_failure_log: on_failure_log
                    on_success_log: on_success_log
                    local: local
                    lockout: lockout

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "login": {"type": Login},
            "enable": {"type": Enable},
            "dot1x": {"type": Dot1x},
            "policies": {"type": Policies},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        login: Login
        enable: Enable
        dot1x: Dot1x
        policies: Policies

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            login: Login | UndefinedType = Undefined,
            enable: Enable | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
        ) -> None:
            """
            AaaAuthentication.

            Args:
            -----
                _custom_data: _custom_data
                login: login
                enable: enable
                dot1x: dot1x
                policies: policies

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaAuthorization(AvdModel):
        class Policy(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "local_default_role": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            local_default_role: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, local_default_role: str | None | UndefinedType = Undefined) -> None:
                """
                Policy.

                Args:
                -----
                    _custom_data: _custom_data
                    local_default_role: local_default_role

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Exec(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: str | None
            """
            Exec authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP none"
            -
            "group radius group MYGROUP local"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                """
                Exec.

                Args:
                -----
                    _custom_data: _custom_data
                    default:
                       Exec authorization method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP none"
                       -
                       "group radius group MYGROUP local"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dynamic(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dot1x_additional_groups": {"type": list, "items": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            dot1x_additional_groups: list[str]

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, dot1x_additional_groups: list[str] | UndefinedType = Undefined
            ) -> None:
                """
                Dynamic.

                Args:
                -----
                    _custom_data: _custom_data
                    dot1x_additional_groups: dot1x_additional_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Commands(AvdModel):
            class PrivilegeItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "default": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Privilege level(s) 0-15."""
                default: str | None
                """
                Command authorization method(s) as a string.
                Examples:
                - "group tacacs+ local"
                - "group MYGROUP
                none"
                - "group tacacs+ group MYGROUP local"
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    default: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrivilegeItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Privilege level(s) 0-15.
                        default:
                           Command authorization method(s) as a string.

                    Examples:
                           - "group tacacs+ local"
                           - "group MYGROUP
                           none"
                           - "group tacacs+ group MYGROUP local"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "all_default": {"type": str}, "privilege": {"type": list, "items": PrivilegeItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            all_default: str | None
            """
            Command authorization method(s) as a string.
            Examples:
            - "group tacacs+ local"
            - "group MYGROUP
            none"
            - "group tacacs+ group MYGROUP local
            """
            privilege: list[PrivilegeItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                all_default: str | None | UndefinedType = Undefined,
                privilege: list[PrivilegeItem] | UndefinedType = Undefined,
            ) -> None:
                """
                Commands.

                Args:
                -----
                    _custom_data: _custom_data
                    all_default:
                       Command authorization method(s) as a string.

                Examples:
                       - "group tacacs+ local"
                       - "group MYGROUP
                       none"
                       - "group tacacs+ group MYGROUP local
                    privilege: privilege

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "policy": {"type": Policy},
            "exec": {"type": Exec},
            "config_commands": {"type": bool},
            "serial_console": {"type": bool},
            "dynamic": {"type": Dynamic},
            "commands": {"type": Commands},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        policy: Policy
        exec: Exec
        config_commands: bool | None
        serial_console: bool | None
        dynamic: Dynamic
        commands: Commands

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            policy: Policy | UndefinedType = Undefined,
            exec: Exec | UndefinedType = Undefined,
            config_commands: bool | None | UndefinedType = Undefined,
            serial_console: bool | None | UndefinedType = Undefined,
            dynamic: Dynamic | UndefinedType = Undefined,
            commands: Commands | UndefinedType = Undefined,
        ) -> None:
            """
            AaaAuthorization.

            Args:
            -----
                _custom_data: _custom_data
                policy: policy
                exec: exec
                config_commands: config_commands
                serial_console: serial_console
                dynamic: dynamic
                commands: commands

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaRoot(AvdModel):
        class Secret(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sha512_password": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sha512_password: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, sha512_password: str | None | UndefinedType = Undefined) -> None:
                """
                Secret.

                Args:
                -----
                    _custom_data: _custom_data
                    sha512_password: sha512_password

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "disabled": {"type": bool}, "secret": {"type": Secret}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        disabled: bool | None
        """Set to `true` to configure `no aaa root` which is the EOS default."""
        secret: Secret

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            secret: Secret | UndefinedType = Undefined,
        ) -> None:
            """
            AaaRoot.

            Args:
            -----
                _custom_data: _custom_data
                disabled: Set to `true` to configure `no aaa root` which is the EOS default.
                secret: secret

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaServerGroupsItem(AvdModel):
        class ServersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "server": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            server: str | None
            """Hostname or IP address."""
            vrf: str | None
            """VRF name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                server: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ServersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    server: Hostname or IP address.
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "type": {"type": str},
            "servers": {"type": list, "items": ServersItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Group name."""
        type: str | None
        servers: list[ServersItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            servers: list[ServersItem] | UndefinedType = Undefined,
        ) -> None:
            """
            AaaServerGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Group name.
                type: type
                servers: servers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AaaServerGroups(AvdCollection[str, AaaServerGroupsItem]):
        _primary_key: ClassVar[str] = "name"

    AaaServerGroups._item_type = AaaServerGroupsItem

    class AccessListsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ip any any"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ip any any"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "permit_response_traffic": {"type": str},
            "sequence_numbers": {"type": SequenceNumbers},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        permit_response_traffic: str | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            permit_response_traffic: str | None | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            AccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                permit_response_traffic:
                   Permit response traffic automatically based on NAT translations.
                   Minimum EOS version requirement
                   4.32.2F.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AccessLists(AvdCollection[str, AccessListsItem]):
        _primary_key: ClassVar[str] = "name"

    AccessLists._item_type = AccessListsItem

    class AddressLocking(AvdModel):
        class LeasesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip": {"type": str}, "mac": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip", "mac")
            _custom_data: dict[str, Any]
            ip: str
            """IP address."""
            mac: str
            """MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh)."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ip: str | UndefinedType = Undefined, mac: str | UndefinedType = Undefined
            ) -> None:
                """
                LeasesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: IP address.
                    mac: MAC address (hhhh.hhhh.hhhh or hh:hh:hh:hh:hh:hh).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LockedAddress(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "expiration_mac_disabled": {"type": bool},
                "ipv4_enforcement_disabled": {"type": bool},
                "ipv6_enforcement_disabled": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            expiration_mac_disabled: bool | None
            """Configure deauthorizing locked addresses upon MAC aging out."""
            ipv4_enforcement_disabled: bool | None
            """Configure enforcement for locked IPv4 addresses."""
            ipv6_enforcement_disabled: bool | None
            """Configure enforcement for locked IPv6 addresses."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                expiration_mac_disabled: bool | None | UndefinedType = Undefined,
                ipv4_enforcement_disabled: bool | None | UndefinedType = Undefined,
                ipv6_enforcement_disabled: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                LockedAddress.

                Args:
                -----
                    _custom_data: _custom_data
                    expiration_mac_disabled: Configure deauthorizing locked addresses upon MAC aging out.
                    ipv4_enforcement_disabled: Configure enforcement for locked IPv4 addresses.
                    ipv6_enforcement_disabled: Configure enforcement for locked IPv6 addresses.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "dhcp_servers_ipv4": {"type": list, "items": str},
            "disabled": {"type": bool},
            "leases": {"type": list, "items": LeasesItem},
            "local_interface": {"type": str},
            "locked_address": {"type": LockedAddress},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        dhcp_servers_ipv4: list[str]
        disabled: bool | None
        """Disable IP locking on configured ports."""
        leases: list[LeasesItem]
        local_interface: str | None
        locked_address: LockedAddress

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            dhcp_servers_ipv4: list[str] | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            leases: list[LeasesItem] | UndefinedType = Undefined,
            local_interface: str | None | UndefinedType = Undefined,
            locked_address: LockedAddress | UndefinedType = Undefined,
        ) -> None:
            """
            AddressLocking.

            Args:
            -----
                _custom_data: _custom_data
                dhcp_servers_ipv4: dhcp_servers_ipv4
                disabled: Disable IP locking on configured ports.
                leases: leases
                local_interface: local_interface
                locked_address: locked_address

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AgentsItem(AvdModel):
        class EnvironmentVariablesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "value": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "value")
            _custom_data: dict[str, Any]
            name: str
            """Environment variable name."""
            value: str
            """Environment variable value."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, value: str | UndefinedType = Undefined
            ) -> None:
                """
                EnvironmentVariablesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Environment variable name.
                    value: Environment variable value.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EnvironmentVariables(AvdCollection[str, EnvironmentVariablesItem]):
            _primary_key: ClassVar[str] = "name"

        EnvironmentVariables._item_type = EnvironmentVariablesItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "environment_variables": {"type": EnvironmentVariables}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Agent name."""
        environment_variables: EnvironmentVariables

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            environment_variables: EnvironmentVariables | UndefinedType = Undefined,
        ) -> None:
            """
            AgentsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Agent name.
                environment_variables: environment_variables

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Agents(AvdCollection[str, AgentsItem]):
        _primary_key: ClassVar[str] = "name"

    Agents._item_type = AgentsItem

    class ApplicationTrafficRecognition(AvdModel):
        class CategoriesItem(AvdModel):
            class ApplicationsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "service": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """Application name."""
                service: str | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    service: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application name.
                        service:
                           Service Name.
                           Specific service to target for this application.
                           If no service is specified, all
                           supported services of the application are matched.
                           Not all valid values are valid for all
                           applications, check on EOS CLI.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "applications": {"type": list, "items": ApplicationsItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Category name."""
            applications: list[ApplicationsItem]
            """List of applications."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                applications: list[ApplicationsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                CategoriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Category name.
                    applications: List of applications.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Categories(AvdCollection[str, CategoriesItem]):
            _primary_key: ClassVar[str] = "name"

        Categories._item_type = CategoriesItem

        class FieldSets(AvdModel):
            class L4PortsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "port_values": {"type": list, "items": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """L4 port field-set name."""
                port_values: list[str]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    port_values: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    L4PortsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: L4 port field-set name.
                        port_values: port_values

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class L4Ports(AvdCollection[str, L4PortsItem]):
                _primary_key: ClassVar[str] = "name"

            L4Ports._item_type = L4PortsItem

            class Ipv4PrefixesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "prefix_values": {"type": list, "items": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """IPv4 prefix field-set name."""
                prefix_values: list[str]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    prefix_values: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4PrefixesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 prefix field-set name.
                        prefix_values: prefix_values

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4Prefixes(AvdCollection[str, Ipv4PrefixesItem]):
                _primary_key: ClassVar[str] = "name"

            Ipv4Prefixes._item_type = Ipv4PrefixesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "l4_ports": {"type": L4Ports}, "ipv4_prefixes": {"type": Ipv4Prefixes}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            l4_ports: L4Ports
            """L4 port field-set."""
            ipv4_prefixes: Ipv4Prefixes
            """IPv4 prefix field set."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                l4_ports: L4Ports | UndefinedType = Undefined,
                ipv4_prefixes: Ipv4Prefixes | UndefinedType = Undefined,
            ) -> None:
                """
                FieldSets.

                Args:
                -----
                    _custom_data: _custom_data
                    l4_ports: L4 port field-set.
                    ipv4_prefixes: IPv4 prefix field set.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Applications(AvdModel):
            class Ipv4ApplicationsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "src_prefix_set_name": {"type": str},
                    "dest_prefix_set_name": {"type": str},
                    "dscp_ranges": {"type": list, "items": str},
                    "protocols": {"type": list, "items": str},
                    "protocol_ranges": {"type": list, "items": str},
                    "udp_src_port_set_name": {"type": str},
                    "tcp_src_port_set_name": {"type": str},
                    "udp_dest_port_set_name": {"type": str},
                    "tcp_dest_port_set_name": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Application name."""
                src_prefix_set_name: str | None
                """Source prefix set name."""
                dest_prefix_set_name: str | None
                """Destination prefix set name."""
                dscp_ranges: list[str]
                """
                Accept DSCP value(s) or range(s).
                DSCP values can be between 0 and 63.
                Other valid values are cs0 to
                cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                Note: The values are not sorted so the list items
                need to be supplied in the right order to match the CLI if required.
                """
                protocols: list[str]
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.
                """
                protocol_ranges: list[str]
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.
                """
                udp_src_port_set_name: str | None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    src_prefix_set_name: str | None | UndefinedType = Undefined,
                    dest_prefix_set_name: str | None | UndefinedType = Undefined,
                    dscp_ranges: list[str] | UndefinedType = Undefined,
                    protocols: list[str] | UndefinedType = Undefined,
                    protocol_ranges: list[str] | UndefinedType = Undefined,
                    udp_src_port_set_name: str | None | UndefinedType = Undefined,
                    tcp_src_port_set_name: str | None | UndefinedType = Undefined,
                    udp_dest_port_set_name: str | None | UndefinedType = Undefined,
                    tcp_dest_port_set_name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application name.
                        src_prefix_set_name: Source prefix set name.
                        dest_prefix_set_name: Destination prefix set name.
                        dscp_ranges:
                           Accept DSCP value(s) or range(s).
                           DSCP values can be between 0 and 63.
                           Other valid values are cs0 to
                           cs7, af11-13, af21-23, af31-33, af41-af43 and ef.
                           Note: The values are not sorted so the list items
                           need to be supplied in the right order to match the CLI if required.
                        protocols:
                           List of protocols to consider for this application.
                           To use port field-sets (source, destination or
                           both), the list
                           must contain only one or two protocols, either `tcp` or `udp`.
                           When using both
                           protocols, one line is rendered for each in the configuration,
                           hence the field-sets must have the
                           same value for `tcp_src_port_set_name` and
                           `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                           and `udp_dest_port_set_name`
                           if set in order to generate valid configuration in EOS.
                        protocol_ranges:
                           Accept protocol value(s) or range(s).
                           Protocol values can be between 1 and 255.
                        udp_src_port_set_name:
                           Name of field set for UDP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `tcp_src_port_set_name`.
                        tcp_src_port_set_name:
                           Name of field set for TCP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `udp_src_port_set_name`.
                        udp_dest_port_set_name:
                           Name of field set for UDP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `tcp_dest_port_set_name`.
                        tcp_dest_port_set_name:
                           Name of field set for TCP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `udp_dest_port_set_name`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4Applications(AvdCollection[str, Ipv4ApplicationsItem]):
                _primary_key: ClassVar[str] = "name"

            Ipv4Applications._item_type = Ipv4ApplicationsItem

            class L4ApplicationsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "protocols": {"type": list, "items": str},
                    "protocol_ranges": {"type": list, "items": str},
                    "udp_src_port_set_name": {"type": str},
                    "tcp_src_port_set_name": {"type": str},
                    "udp_dest_port_set_name": {"type": str},
                    "tcp_dest_port_set_name": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Application name."""
                protocols: list[str]
                """
                List of protocols to consider for this application.
                To use port field-sets (source, destination or
                both), the list
                must contain only one or two protocols, either `tcp` or `udp`.
                When using both
                protocols, one line is rendered for each in the configuration,
                hence the field-sets must have the
                same value for `tcp_src_port_set_name` and
                `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                and `udp_dest_port_set_name`
                if set in order to generate valid configuration in EOS.
                """
                protocol_ranges: list[str]
                """
                Accept protocol value(s) or range(s).
                Protocol values can be between 1 and 255.
                """
                udp_src_port_set_name: str | None
                """
                Name of field set for UDP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `tcp_src_port_set_name`.
                """
                tcp_src_port_set_name: str | None
                """
                Name of field set for TCP source ports.
                When the `protocols` list contain both `tcp` and `udp`, this
                key value
                must be the same as `udp_src_port_set_name`.
                """
                udp_dest_port_set_name: str | None
                """
                Name of field set for UDP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `tcp_dest_port_set_name`.
                """
                tcp_dest_port_set_name: str | None
                """
                Name of field set for TCP destination ports.
                When the `protocols` list contain both `tcp` and `udp`,
                this key value
                must be the same as `udp_dest_port_set_name`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    protocols: list[str] | UndefinedType = Undefined,
                    protocol_ranges: list[str] | UndefinedType = Undefined,
                    udp_src_port_set_name: str | None | UndefinedType = Undefined,
                    tcp_src_port_set_name: str | None | UndefinedType = Undefined,
                    udp_dest_port_set_name: str | None | UndefinedType = Undefined,
                    tcp_dest_port_set_name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    L4ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application name.
                        protocols:
                           List of protocols to consider for this application.
                           To use port field-sets (source, destination or
                           both), the list
                           must contain only one or two protocols, either `tcp` or `udp`.
                           When using both
                           protocols, one line is rendered for each in the configuration,
                           hence the field-sets must have the
                           same value for `tcp_src_port_set_name` and
                           `udp_src_port_set_name` and for `tcp_dest_port_set_name`
                           and `udp_dest_port_set_name`
                           if set in order to generate valid configuration in EOS.
                        protocol_ranges:
                           Accept protocol value(s) or range(s).
                           Protocol values can be between 1 and 255.
                        udp_src_port_set_name:
                           Name of field set for UDP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `tcp_src_port_set_name`.
                        tcp_src_port_set_name:
                           Name of field set for TCP source ports.
                           When the `protocols` list contain both `tcp` and `udp`, this
                           key value
                           must be the same as `udp_src_port_set_name`.
                        udp_dest_port_set_name:
                           Name of field set for UDP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `tcp_dest_port_set_name`.
                        tcp_dest_port_set_name:
                           Name of field set for TCP destination ports.
                           When the `protocols` list contain both `tcp` and `udp`,
                           this key value
                           must be the same as `udp_dest_port_set_name`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class L4Applications(AvdCollection[str, L4ApplicationsItem]):
                _primary_key: ClassVar[str] = "name"

            L4Applications._item_type = L4ApplicationsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv4_applications": {"type": Ipv4Applications},
                "l4_applications": {"type": L4Applications},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4_applications: Ipv4Applications
            """
            List of user defined IPv4 applications. The name should be unique over all defined applications
            (ipv4 and l4).
            """
            l4_applications: L4Applications
            """
            List of user defined L4 applications. The name should be unique over all defined applications (ipv4
            and l4).
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4_applications: Ipv4Applications | UndefinedType = Undefined,
                l4_applications: L4Applications | UndefinedType = Undefined,
            ) -> None:
                """
                Applications.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_applications:
                       List of user defined IPv4 applications. The name should be unique over all defined applications
                       (ipv4 and l4).
                    l4_applications:
                       List of user defined L4 applications. The name should be unique over all defined applications (ipv4
                       and l4).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ApplicationProfilesItem(AvdModel):
            class ApplicationsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "service": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """Application Name."""
                service: str | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    service: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ApplicationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Application Name.
                        service:
                           Service Name.
                           Specific service to target for this application.
                           If no service is specified, all
                           supported services of the application are matched.
                           Not all valid values are valid for all
                           applications, check on EOS CLI.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class CategoriesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "service": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """Name of a category."""
                service: str | None
                """
                Service Name.
                Specific service to target for this application.
                If no service is specified, all
                supported services of the application are matched.
                Not all valid values are valid for all
                applications, check on EOS CLI.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    service: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    CategoriesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Name of a category.
                        service:
                           Service Name.
                           Specific service to target for this application.
                           If no service is specified, all
                           supported services of the application are matched.
                           Not all valid values are valid for all
                           applications, check on EOS CLI.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "applications": {"type": list, "items": ApplicationsItem},
                "application_transports": {"type": list, "items": str},
                "categories": {"type": list, "items": CategoriesItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Application Profile name."""
            applications: list[ApplicationsItem]
            """List of applications part of the application profile."""
            application_transports: list[str]
            """List of transport protocols."""
            categories: list[CategoriesItem]
            """Categories under this application profile."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                applications: list[ApplicationsItem] | UndefinedType = Undefined,
                application_transports: list[str] | UndefinedType = Undefined,
                categories: list[CategoriesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                ApplicationProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Application Profile name.
                    applications: List of applications part of the application profile.
                    application_transports: List of transport protocols.
                    categories: Categories under this application profile.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "categories": {"type": Categories},
            "field_sets": {"type": FieldSets},
            "applications": {"type": Applications},
            "application_profiles": {"type": list, "items": ApplicationProfilesItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        categories: Categories
        """List of categories."""
        field_sets: FieldSets
        applications: Applications
        application_profiles: list[ApplicationProfilesItem]
        """Group of applications."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            categories: Categories | UndefinedType = Undefined,
            field_sets: FieldSets | UndefinedType = Undefined,
            applications: Applications | UndefinedType = Undefined,
            application_profiles: list[ApplicationProfilesItem] | UndefinedType = Undefined,
        ) -> None:
            """
            ApplicationTrafficRecognition.

            Args:
            -----
                _custom_data: _custom_data
                categories: List of categories.
                field_sets: field_sets
                applications: applications
                application_profiles: Group of applications.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Arp(AvdModel):
        class Persistent(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "refresh_delay": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            """Restore the ARP cache after reboot."""
            refresh_delay: int | None
            """Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600)."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                refresh_delay: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Persistent.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Restore the ARP cache after reboot.
                    refresh_delay: Time to wait in seconds before refreshing the ARP cache after reboot (EOS default 600).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Aging(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "timeout_default": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            timeout_default: int | None
            """Timeout in seconds."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, timeout_default: int | None | UndefinedType = Undefined) -> None:
                """
                Aging.

                Args:
                -----
                    _custom_data: _custom_data
                    timeout_default: Timeout in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StaticEntriesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_address": {"type": str}, "vrf": {"type": str}, "mac_address": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipv4_address", "mac_address")
            _custom_data: dict[str, Any]
            ipv4_address: str
            """ARP entry IPv4 address."""
            vrf: str | None
            """ARP entry VRF."""
            mac_address: str
            """ARP entry MAC address."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4_address: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                mac_address: str | UndefinedType = Undefined,
            ) -> None:
                """
                StaticEntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_address: ARP entry IPv4 address.
                    vrf: ARP entry VRF.
                    mac_address: ARP entry MAC address.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "persistent": {"type": Persistent},
            "aging": {"type": Aging},
            "static_entries": {"type": list, "items": StaticEntriesItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        persistent: Persistent
        aging: Aging
        static_entries: list[StaticEntriesItem]
        """Static ARP entries."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            persistent: Persistent | UndefinedType = Undefined,
            aging: Aging | UndefinedType = Undefined,
            static_entries: list[StaticEntriesItem] | UndefinedType = Undefined,
        ) -> None:
            """
            Arp.

            Args:
            -----
                _custom_data: _custom_data
                persistent: persistent
                aging: aging
                static_entries: Static ARP entries.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class AsPath(AvdModel):
        class AccessListsItem(AvdModel):
            class EntriesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "type": {"type": str},
                    "match": {"type": str},
                    "origin": {"type": str, "default": "any"},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                type: str | None
                match: str | None
                """Regex To Match."""
                origin: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    match: str | None | UndefinedType = Undefined,
                    origin: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EntriesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        match: Regex To Match.
                        origin: origin

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "entries": {"type": list, "items": EntriesItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Access List Name."""
            entries: list[EntriesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                entries: list[EntriesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                AccessListsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Access List Name.
                    entries: entries

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AccessLists(AvdCollection[str, AccessListsItem]):
            _primary_key: ClassVar[str] = "name"

        AccessLists._item_type = AccessListsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "regex_mode": {"type": str}, "access_lists": {"type": AccessLists}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        regex_mode: str | None
        access_lists: AccessLists

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            regex_mode: str | None | UndefinedType = Undefined,
            access_lists: AccessLists | UndefinedType = Undefined,
        ) -> None:
            """
            AsPath.

            Args:
            -----
                _custom_data: _custom_data
                regex_mode: regex_mode
                access_lists: access_lists

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Banners(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "login": {"type": str}, "motd": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        login: str | None
        """Multiline string ending with EOF on the last line."""
        motd: str | None
        """Multiline string ending with EOF on the last line."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            login: str | None | UndefinedType = Undefined,
            motd: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            Banners.

            Args:
            -----
                _custom_data: _custom_data
                login: Multiline string ending with EOF on the last line.
                motd: Multiline string ending with EOF on the last line.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class BgpGroupsItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "vrf": {"type": str},
            "neighbors": {"type": list, "items": str},
            "bgp_maintenance_profiles": {"type": list, "items": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Group Name."""
        vrf: str | None
        neighbors: list[str]
        bgp_maintenance_profiles: list[str]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            neighbors: list[str] | UndefinedType = Undefined,
            bgp_maintenance_profiles: list[str] | UndefinedType = Undefined,
        ) -> None:
            """
            BgpGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Group Name.
                vrf: vrf
                neighbors: neighbors
                bgp_maintenance_profiles: bgp_maintenance_profiles

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class BgpGroups(AvdCollection[str, BgpGroupsItem]):
        _primary_key: ClassVar[str] = "name"

    BgpGroups._item_type = BgpGroupsItem

    class Boot(AvdModel):
        class Secret(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "hash_algorithm": {"type": str, "default": "sha512"}, "key": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            hash_algorithm: str | None
            key: str | None
            """Hashed Password."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Secret.

                Args:
                -----
                    _custom_data: _custom_data
                    hash_algorithm: hash_algorithm
                    key: Hashed Password.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "secret": {"type": Secret}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        secret: Secret

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, secret: Secret | UndefinedType = Undefined) -> None:
            """
            Boot.

            Args:
            -----
                _custom_data: _custom_data
                secret: secret

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ClassMaps(AvdModel):
        class PbrItem(AvdModel):
            class Ip(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "access_group": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                access_group: str | None
                """Standard Access-List Name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, access_group: str | None | UndefinedType = Undefined) -> None:
                    """
                    Ip.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_group: Standard Access-List Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "ip": {"type": Ip}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Class-Map Name."""
            ip: Ip

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, ip: Ip | UndefinedType = Undefined
            ) -> None:
                """
                PbrItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Class-Map Name.
                    ip: ip

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Pbr(AvdCollection[str, PbrItem]):
            _primary_key: ClassVar[str] = "name"

        Pbr._item_type = PbrItem

        class QosItem(AvdModel):
            class Ip(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "access_group": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                access_group: str | None
                """IPv4 Access-List Name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, access_group: str | None | UndefinedType = Undefined) -> None:
                    """
                    Ip.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_group: IPv4 Access-List Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "access_group": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                access_group: str | None
                """IPv6 Access-List Name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, access_group: str | None | UndefinedType = Undefined) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_group: IPv6 Access-List Name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "vlan": {"type": str},
                "cos": {"type": str},
                "ip": {"type": Ip},
                "ipv6": {"type": Ipv6},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Class-Map Name."""
            vlan: str | None
            """VLAN value(s) or range(s) of VLAN values."""
            cos: str | None
            """CoS value(s) or range(s) of CoS values."""
            ip: Ip
            ipv6: Ipv6

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                vlan: str | None | UndefinedType = Undefined,
                cos: str | None | UndefinedType = Undefined,
                ip: Ip | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
            ) -> None:
                """
                QosItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Class-Map Name.
                    vlan: VLAN value(s) or range(s) of VLAN values.
                    cos: CoS value(s) or range(s) of CoS values.
                    ip: ip
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Qos(AvdCollection[str, QosItem]):
            _primary_key: ClassVar[str] = "name"

        Qos._item_type = QosItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pbr": {"type": Pbr}, "qos": {"type": Qos}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        pbr: Pbr
        qos: Qos

        def __init__(
            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined
        ) -> None:
            """
            ClassMaps.

            Args:
            -----
                _custom_data: _custom_data
                pbr: pbr
                qos: qos

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Clock(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "timezone": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        timezone: str | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, timezone: str | None | UndefinedType = Undefined) -> None:
            """
            Clock.

            Args:
            -----
                _custom_data: _custom_data
                timezone: timezone

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CommunityListsItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "action": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "action")
        _custom_data: dict[str, Any]
        name: str
        """Community-list Name."""
        action: str
        """
        Action as string.
        Example: "permit GSHUT 65123:123"
        """

        def __init__(
            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, action: str | UndefinedType = Undefined
        ) -> None:
            """
            CommunityListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Community-list Name.
                action:
                   Action as string.
                   Example: "permit GSHUT 65123:123"

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class CommunityLists(AvdCollection[str, CommunityListsItem]):
        _primary_key: ClassVar[str] = "name"

    CommunityLists._item_type = CommunityListsItem

    class Cvx(AvdModel):
        class Services(AvdModel):
            class Mcs(AvdModel):
                class Redis(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "password": {"type": str}, "password_type": {"type": str, "default": "7"}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    password: str | None
                    """Hashed password using the password_type."""
                    password_type: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        password: str | None | UndefinedType = Undefined,
                        password_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            password: Hashed password using the password_type.
                            password_type: password_type

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "redis": {"type": Redis}, "shutdown": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                redis: Redis
                shutdown: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    redis: Redis | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mcs.

                    Args:
                    -----
                        _custom_data: _custom_data
                        redis: redis
                        shutdown: shutdown

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Vxlan(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "shutdown": {"type": bool}, "vtep_mac_learning": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                shutdown: bool | None
                vtep_mac_learning: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    vtep_mac_learning: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan.

                    Args:
                    -----
                        _custom_data: _custom_data
                        shutdown: shutdown
                        vtep_mac_learning: vtep_mac_learning

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mcs": {"type": Mcs}, "vxlan": {"type": Vxlan}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mcs: Mcs
            vxlan: Vxlan
            """VXLAN Controller service."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mcs: Mcs | UndefinedType = Undefined,
                vxlan: Vxlan | UndefinedType = Undefined,
            ) -> None:
                """
                Services.

                Args:
                -----
                    _custom_data: _custom_data
                    mcs: mcs
                    vxlan: VXLAN Controller service.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "shutdown": {"type": bool},
            "peer_hosts": {"type": list, "items": str},
            "services": {"type": Services},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        shutdown: bool | None
        peer_hosts: list[str]
        services: Services

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            peer_hosts: list[str] | UndefinedType = Undefined,
            services: Services | UndefinedType = Undefined,
        ) -> None:
            """
            Cvx.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                peer_hosts: peer_hosts
                services: services

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DaemonTerminattr(AvdModel):
        class ClustersItem(AvdModel):
            class Cvauth(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "method": {"type": str},
                    "key": {"type": str},
                    "token_file": {"type": str},
                    "cert_file": {"type": str},
                    "ca_file": {"type": str},
                    "key_file": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                method: str | None
                key: str | None
                token_file: str | None
                """
                Token file path.
                e.g. "/tmp/token"
                """
                cert_file: str | None
                """
                Client certificate file path.
                e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                """
                ca_file: str | None
                """
                CA certificate file path (on-prem only).
                e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                """
                key_file: str | None
                """
                Client certificate key file path.
                e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    method: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    token_file: str | None | UndefinedType = Undefined,
                    cert_file: str | None | UndefinedType = Undefined,
                    ca_file: str | None | UndefinedType = Undefined,
                    key_file: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Cvauth.

                    Args:
                    -----
                        _custom_data: _custom_data
                        method: method
                        key: key
                        token_file:
                           Token file path.
                           e.g. "/tmp/token"
                        cert_file:
                           Client certificate file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                        ca_file:
                           CA certificate file path (on-prem only).
                           e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                        key_file:
                           Client certificate key file path.
                           e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "cvaddrs": {"type": list, "items": str},
                "cvauth": {"type": Cvauth},
                "cvobscurekeyfile": {"type": bool},
                "cvproxy": {"type": str},
                "cvsourceip": {"type": str},
                "cvsourceintf": {"type": str},
                "cvvrf": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Cluster Name."""
            cvaddrs: list[str]
            """
            Streaming address(es) for CloudVision cluster.
            - TCP 9910 is used for CV on-prem
            - TCP 443 is used
            for CV as a Service
            """
            cvauth: Cvauth
            """Authentication scheme used to connect to CloudVision."""
            cvobscurekeyfile: bool | None
            """Encrypt the private key used for authentication to CloudVision."""
            cvproxy: str | None
            """
            Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
            the cloud.
            The expected form is http://[user:password@]ip:port, e.g.:
            `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
            """
            cvsourceip: str | None
            """Set source IP address in case of in-band management."""
            cvsourceintf: str | None
            """
            Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
            The
            interface name is case sensitive and has to match the interface name in the running-config,
            e.g.:Vlan100.
            """
            cvvrf: str | None
            """The VRF to use to connect to CloudVision."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                cvaddrs: list[str] | UndefinedType = Undefined,
                cvauth: Cvauth | UndefinedType = Undefined,
                cvobscurekeyfile: bool | None | UndefinedType = Undefined,
                cvproxy: str | None | UndefinedType = Undefined,
                cvsourceip: str | None | UndefinedType = Undefined,
                cvsourceintf: str | None | UndefinedType = Undefined,
                cvvrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ClustersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Cluster Name.
                    cvaddrs:
                       Streaming address(es) for CloudVision cluster.
                       - TCP 9910 is used for CV on-prem
                       - TCP 443 is used
                       for CV as a Service
                    cvauth: Authentication scheme used to connect to CloudVision.
                    cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                    cvproxy:
                       Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                       the cloud.
                       The expected form is http://[user:password@]ip:port, e.g.:
                       `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                    cvsourceip: Set source IP address in case of in-band management.
                    cvsourceintf:
                       Set source interface in case of in-band management. Available as of TerminAttr v1.23.0.
                       The
                       interface name is case sensitive and has to match the interface name in the running-config,
                       e.g.:Vlan100.
                    cvvrf: The VRF to use to connect to CloudVision.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Clusters(AvdCollection[str, ClustersItem]):
            _primary_key: ClassVar[str] = "name"

        Clusters._item_type = ClustersItem

        class Cvauth(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "method": {"type": str},
                "key": {"type": str},
                "token_file": {"type": str},
                "cert_file": {"type": str},
                "ca_file": {"type": str},
                "key_file": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            method: str | None
            key: str | None
            token_file: str | None
            """
            Token file path.
            e.g. "/tmp/token"
            """
            cert_file: str | None
            """
            Client certificate file path.
            e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
            """
            ca_file: str | None
            """
            CA certificate file path (on-prem only).
            e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
            """
            key_file: str | None
            """
            Client certificate key file path.
            e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                method: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
                token_file: str | None | UndefinedType = Undefined,
                cert_file: str | None | UndefinedType = Undefined,
                ca_file: str | None | UndefinedType = Undefined,
                key_file: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Cvauth.

                Args:
                -----
                    _custom_data: _custom_data
                    method: method
                    key: key
                    token_file:
                       Token file path.
                       e.g. "/tmp/token"
                    cert_file:
                       Client certificate file path.
                       e.g. "/persist/secure/ssl/terminattr/primary/certs/client.crt"
                    ca_file:
                       CA certificate file path (on-prem only).
                       e.g. "/persist/secure/ssl/terminattr/primary/certs/ca.crt"
                    key_file:
                       Client certificate key file path.
                       e.g. "/persist/secure/ssl/terminattr/primary/keys/client.key"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "cvaddrs": {"type": list, "items": str},
            "clusters": {"type": Clusters},
            "cvauth": {"type": Cvauth},
            "cvobscurekeyfile": {"type": bool},
            "cvproxy": {"type": str},
            "cvsourceip": {"type": str},
            "cvsourceintf": {"type": str},
            "cvvrf": {"type": str},
            "cvgnmi": {"type": bool},
            "disable_aaa": {"type": bool},
            "grpcaddr": {"type": str},
            "grpcreadonly": {"type": bool},
            "ingestexclude": {"type": str},
            "smashexcludes": {"type": str},
            "taillogs": {"type": str},
            "ecodhcpaddr": {"type": str},
            "ipfix": {"type": bool},
            "ipfixaddr": {"type": str},
            "sflow": {"type": bool},
            "sflowaddr": {"type": str},
            "cvconfig": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        cvaddrs: list[str]
        """
        Streaming address(es) for CloudVision single cluster.
        - TCP 9910 is used for CV on-prem
        - TCP 443 is
        used for CV as a Service
        """
        clusters: Clusters
        """Multiple CloudVision clusters."""
        cvauth: Cvauth
        """Authentication scheme used to connect to CloudVision."""
        cvobscurekeyfile: bool | None
        """Encrypt the private key used for authentication to CloudVision."""
        cvproxy: str | None
        """
        Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
        the cloud.
        The expected form is http://[user:password@]ip:port, e.g.:
        `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
        """
        cvsourceip: str | None
        """Set source IP address in case of in-band management."""
        cvsourceintf: str | None
        """
        Set source interface in case of in-band management.
        The interface name is case sensitive and has to
        match the interface name in the running-config, e.g.:Vlan100.
        """
        cvvrf: str | None
        """The VRF to use to connect to CloudVision."""
        cvgnmi: bool | None
        """Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1."""
        disable_aaa: bool | None
        """
        Disable AAA authorization and accounting.
        When setting this flag, all commands pushed from
        CloudVision are applied directly to the CLI without authorization.
        """
        grpcaddr: str | None
        """
        Set the gRPC server address, the default is 127.0.0.1:6042.
        e.g. "MGMT/0.0.0.0:6042"
        """
        grpcreadonly: bool | None
        """gNMI read-only mode - Disable gnmi.Set()."""
        ingestexclude: str | None
        """
        Exclude paths from Sysdb on the ingest side.
        e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
        """
        smashexcludes: str | None
        """
        Exclude paths from the shared memory table.
        e.g. "ale,flexCounter,hardware,kni,pulse,strata"
        """
        taillogs: str | None
        """
        Enable log file collection; /var/log/messages is streamed by default if no path is set.
        e.g.
        "/var/log/messages"
        """
        ecodhcpaddr: str | None
        """
        ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
        "127.0.0.1:67").
        """
        ipfix: bool | None
        """
        Enable IPFIX provider (TerminAttr default is true).
        This flag is enabled by default and does not
        have to be added to the daemon configuration.
        """
        ipfixaddr: str | None
        """
        ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
        "127.0.0.1:4739").
        """
        sflow: bool | None
        """Enable sFlow provider (TerminAttr default is true)."""
        sflowaddr: str | None
        """
        ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
        "127.0.0.1:6343").
        """
        cvconfig: bool | None
        """Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false)."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            cvaddrs: list[str] | UndefinedType = Undefined,
            clusters: Clusters | UndefinedType = Undefined,
            cvauth: Cvauth | UndefinedType = Undefined,
            cvobscurekeyfile: bool | None | UndefinedType = Undefined,
            cvproxy: str | None | UndefinedType = Undefined,
            cvsourceip: str | None | UndefinedType = Undefined,
            cvsourceintf: str | None | UndefinedType = Undefined,
            cvvrf: str | None | UndefinedType = Undefined,
            cvgnmi: bool | None | UndefinedType = Undefined,
            disable_aaa: bool | None | UndefinedType = Undefined,
            grpcaddr: str | None | UndefinedType = Undefined,
            grpcreadonly: bool | None | UndefinedType = Undefined,
            ingestexclude: str | None | UndefinedType = Undefined,
            smashexcludes: str | None | UndefinedType = Undefined,
            taillogs: str | None | UndefinedType = Undefined,
            ecodhcpaddr: str | None | UndefinedType = Undefined,
            ipfix: bool | None | UndefinedType = Undefined,
            ipfixaddr: str | None | UndefinedType = Undefined,
            sflow: bool | None | UndefinedType = Undefined,
            sflowaddr: str | None | UndefinedType = Undefined,
            cvconfig: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            DaemonTerminattr.

            Args:
            -----
                _custom_data: _custom_data
                cvaddrs:
                   Streaming address(es) for CloudVision single cluster.
                   - TCP 9910 is used for CV on-prem
                   - TCP 443 is
                   used for CV as a Service
                clusters: Multiple CloudVision clusters.
                cvauth: Authentication scheme used to connect to CloudVision.
                cvobscurekeyfile: Encrypt the private key used for authentication to CloudVision.
                cvproxy:
                   Proxy server through which CloudVision is reachable. Useful when the CloudVision server is hosted in
                   the cloud.
                   The expected form is http://[user:password@]ip:port, e.g.:
                   `http://arista:arista@10.83.12.78:3128`. Available as of TerminAttr v1.13.0.
                cvsourceip: Set source IP address in case of in-band management.
                cvsourceintf:
                   Set source interface in case of in-band management.
                   The interface name is case sensitive and has to
                   match the interface name in the running-config, e.g.:Vlan100.
                cvvrf: The VRF to use to connect to CloudVision.
                cvgnmi: Stream states from EOS gNMI servers (Openconfig) to CloudVision. Available as of TerminAttr v1.13.1.
                disable_aaa:
                   Disable AAA authorization and accounting.
                   When setting this flag, all commands pushed from
                   CloudVision are applied directly to the CLI without authorization.
                grpcaddr:
                   Set the gRPC server address, the default is 127.0.0.1:6042.
                   e.g. "MGMT/0.0.0.0:6042"
                grpcreadonly: gNMI read-only mode - Disable gnmi.Set().
                ingestexclude:
                   Exclude paths from Sysdb on the ingest side.
                   e.g. "/Sysdb/cell/1/agent,/Sysdb/cell/2/agent"
                smashexcludes:
                   Exclude paths from the shared memory table.
                   e.g. "ale,flexCounter,hardware,kni,pulse,strata"
                taillogs:
                   Enable log file collection; /var/log/messages is streamed by default if no path is set.
                   e.g.
                   "/var/log/messages"
                ecodhcpaddr:
                   ECO DHCP Collector address or ECO DHCP Fingerprint listening address in standalone mode (default
                   "127.0.0.1:67").
                ipfix:
                   Enable IPFIX provider (TerminAttr default is true).
                   This flag is enabled by default and does not
                   have to be added to the daemon configuration.
                ipfixaddr:
                   ECO IPFIX Collector address to listen on to receive IPFIX packets (TerminAttr default
                   "127.0.0.1:4739").
                sflow: Enable sFlow provider (TerminAttr default is true).
                sflowaddr:
                   ECO sFlow Collector address to listen on to receive sFlow packets (TerminAttr default
                   "127.0.0.1:6343").
                cvconfig: Subscribe to dynamic device configuration from CloudVision (TerminAttr default is false).

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DaemonsItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "exec": {"type": str}, "enabled": {"type": bool, "default": True}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "exec")
        _custom_data: dict[str, Any]
        name: str
        """Daemon Name."""
        exec: str
        """command to run as a daemon."""
        enabled: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            exec: str | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            DaemonsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Daemon Name.
                exec: command to run as a daemon.
                enabled: enabled

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Daemons(AvdCollection[str, DaemonsItem]):
        _primary_key: ClassVar[str] = "name"

    Daemons._item_type = DaemonsItem

    class DhcpRelay(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "servers": {"type": list, "items": str},
            "tunnel_requests_disabled": {"type": bool},
            "mlag_peerlink_requests_disabled": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        servers: list[str]
        tunnel_requests_disabled: bool | None
        mlag_peerlink_requests_disabled: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            servers: list[str] | UndefinedType = Undefined,
            tunnel_requests_disabled: bool | None | UndefinedType = Undefined,
            mlag_peerlink_requests_disabled: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            DhcpRelay.

            Args:
            -----
                _custom_data: _custom_data
                servers: servers
                tunnel_requests_disabled: tunnel_requests_disabled
                mlag_peerlink_requests_disabled: mlag_peerlink_requests_disabled

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DhcpServersItem(AvdModel):
        class LeaseTimeIpv4(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "days", "hours", "minutes")
            _custom_data: dict[str, Any]
            days: int
            hours: int
            minutes: int

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                days: int | UndefinedType = Undefined,
                hours: int | UndefinedType = Undefined,
                minutes: int | UndefinedType = Undefined,
            ) -> None:
                """
                LeaseTimeIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    days: days
                    hours: hours
                    minutes: minutes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LeaseTimeIpv6(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "days", "hours", "minutes")
            _custom_data: dict[str, Any]
            days: int
            hours: int
            minutes: int

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                days: int | UndefinedType = Undefined,
                hours: int | UndefinedType = Undefined,
                minutes: int | UndefinedType = Undefined,
            ) -> None:
                """
                LeaseTimeIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    days: days
                    hours: hours
                    minutes: minutes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TftpServer(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "file_ipv4": {"type": str}, "file_ipv6": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            file_ipv4: str | None
            """Name of TFTP file for IPv4 clients."""
            file_ipv6: str | None
            """Name of TFTP file for IPv6 clients."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                file_ipv4: str | None | UndefinedType = Undefined,
                file_ipv6: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TftpServer.

                Args:
                -----
                    _custom_data: _custom_data
                    file_ipv4: Name of TFTP file for IPv4 clients.
                    file_ipv6: Name of TFTP file for IPv6 clients.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv4VendorOptionsItem(AvdModel):
            class SubOptionsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "code": {"type": int},
                    "string": {"type": str},
                    "ipv4_address": {"type": str},
                    "array_ipv4_address": {"type": list, "items": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "code")
                _custom_data: dict[str, Any]
                code: int
                string: str | None
                """
                String value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                ipv4_address: str | None
                """
                IPv4 address value for suboption data.
                Only one of `string`, `ipv4_address` and `array_ipv4_address`
                variables should be used for any one suboption.
                The order of precedence if multiple of these
                variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """
                array_ipv4_address: list[str]
                """
                Array of IPv4 addresses for suboption data.
                Only one of `string`, `ipv4_address` and
                `array_ipv4_address` variables should be used for any one suboption.
                The order of precedence if
                multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    code: int | UndefinedType = Undefined,
                    string: str | None | UndefinedType = Undefined,
                    ipv4_address: str | None | UndefinedType = Undefined,
                    array_ipv4_address: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    SubOptionsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        code: code
                        string:
                           String value for suboption data.
                           Only one of `string`, `ipv4_address` and `array_ipv4_address`
                           variables should be used for any one suboption.
                           The order of precedence if multiple of these
                           variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                        ipv4_address:
                           IPv4 address value for suboption data.
                           Only one of `string`, `ipv4_address` and `array_ipv4_address`
                           variables should be used for any one suboption.
                           The order of precedence if multiple of these
                           variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.
                        array_ipv4_address:
                           Array of IPv4 addresses for suboption data.
                           Only one of `string`, `ipv4_address` and
                           `array_ipv4_address` variables should be used for any one suboption.
                           The order of precedence if
                           multiple of these variables are defined is `string` -> `ipv4_address` -> `array_ipv4_address`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SubOptions(AvdCollection[int, SubOptionsItem]):
                _primary_key: ClassVar[str] = "code"

            SubOptions._item_type = SubOptionsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vendor_id": {"type": str}, "sub_options": {"type": SubOptions}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "vendor_id")
            _custom_data: dict[str, Any]
            vendor_id: str
            sub_options: SubOptions

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                vendor_id: str | UndefinedType = Undefined,
                sub_options: SubOptions | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv4VendorOptionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    vendor_id: vendor_id
                    sub_options: sub_options

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv4VendorOptions(AvdCollection[str, Ipv4VendorOptionsItem]):
            _primary_key: ClassVar[str] = "vendor_id"

        Ipv4VendorOptions._item_type = Ipv4VendorOptionsItem

        class SubnetsItem(AvdModel):
            class RangesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "start": {"type": str}, "end": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "start", "end")
                _custom_data: dict[str, Any]
                start: str
                end: str

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    start: str | UndefinedType = Undefined,
                    end: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    RangesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        start: start
                        end: end

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LeaseTime(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "days": {"type": int}, "hours": {"type": int}, "minutes": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "days", "hours", "minutes")
                _custom_data: dict[str, Any]
                days: int
                hours: int
                minutes: int

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    days: int | UndefinedType = Undefined,
                    hours: int | UndefinedType = Undefined,
                    minutes: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    LeaseTime.

                    Args:
                    -----
                        _custom_data: _custom_data
                        days: days
                        hours: hours
                        minutes: minutes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ReservationsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "mac_address": {"type": str},
                    "hostname": {"type": str},
                    "ipv4_address": {"type": str},
                    "ipv6_address": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "mac_address")
                _custom_data: dict[str, Any]
                mac_address: str
                """Ethernet address in format - HHHH.HHHH.HHHH"""
                hostname: str | None
                ipv4_address: str | None
                """
                Valid IPv4 address from the given subnet.
                This should only be used within an IPv4 subnet.
                """
                ipv6_address: str | None
                """
                Valid IPv6 address from the given subnet.
                This should only be used within an IPv6 subnet.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mac_address: str | UndefinedType = Undefined,
                    hostname: str | None | UndefinedType = Undefined,
                    ipv4_address: str | None | UndefinedType = Undefined,
                    ipv6_address: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ReservationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mac_address: Ethernet address in format - HHHH.HHHH.HHHH
                        hostname: hostname
                        ipv4_address:
                           Valid IPv4 address from the given subnet.
                           This should only be used within an IPv4 subnet.
                        ipv6_address:
                           Valid IPv6 address from the given subnet.
                           This should only be used within an IPv6 subnet.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Reservations(AvdCollection[str, ReservationsItem]):
                _primary_key: ClassVar[str] = "mac_address"

            Reservations._item_type = ReservationsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "subnet": {"type": str},
                "name": {"type": str},
                "default_gateway": {"type": str},
                "dns_servers": {"type": list, "items": str},
                "ranges": {"type": list, "items": RangesItem},
                "lease_time": {"type": LeaseTime},
                "reservations": {"type": Reservations},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "subnet")
            _custom_data: dict[str, Any]
            subnet: str
            """IPv4/IPv6 subnet."""
            name: str | None
            default_gateway: str | None
            dns_servers: list[str]
            ranges: list[RangesItem]
            lease_time: LeaseTime
            reservations: Reservations
            """DHCP client reservations."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                subnet: str | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                default_gateway: str | None | UndefinedType = Undefined,
                dns_servers: list[str] | UndefinedType = Undefined,
                ranges: list[RangesItem] | UndefinedType = Undefined,
                lease_time: LeaseTime | UndefinedType = Undefined,
                reservations: Reservations | UndefinedType = Undefined,
            ) -> None:
                """
                SubnetsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    subnet: IPv4/IPv6 subnet.
                    name: name
                    default_gateway: default_gateway
                    dns_servers: dns_servers
                    ranges: ranges
                    lease_time: lease_time
                    reservations: DHCP client reservations.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Subnets(AvdCollection[str, SubnetsItem]):
            _primary_key: ClassVar[str] = "subnet"

        Subnets._item_type = SubnetsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "disabled": {"type": bool},
            "vrf": {"type": str},
            "lease_time_ipv4": {"type": LeaseTimeIpv4},
            "lease_time_ipv6": {"type": LeaseTimeIpv6},
            "dns_domain_name_ipv4": {"type": str},
            "dns_domain_name_ipv6": {"type": str},
            "dns_servers_ipv4": {"type": list, "items": str},
            "dns_servers_ipv6": {"type": list, "items": str},
            "tftp_server": {"type": TftpServer},
            "ipv4_vendor_options": {"type": Ipv4VendorOptions},
            "subnets": {"type": Subnets},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "vrf")
        _custom_data: dict[str, Any]
        disabled: bool | None
        vrf: str
        """VRF in which to configure the DHCP server, use `default` to indicate default VRF."""
        lease_time_ipv4: LeaseTimeIpv4
        lease_time_ipv6: LeaseTimeIpv6
        dns_domain_name_ipv4: str | None
        dns_domain_name_ipv6: str | None
        dns_servers_ipv4: list[str]
        """List of DNS servers for IPv4 clients."""
        dns_servers_ipv6: list[str]
        """List of DNS servers for IPv6 clients."""
        tftp_server: TftpServer
        ipv4_vendor_options: Ipv4VendorOptions
        subnets: Subnets
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            vrf: str | UndefinedType = Undefined,
            lease_time_ipv4: LeaseTimeIpv4 | UndefinedType = Undefined,
            lease_time_ipv6: LeaseTimeIpv6 | UndefinedType = Undefined,
            dns_domain_name_ipv4: str | None | UndefinedType = Undefined,
            dns_domain_name_ipv6: str | None | UndefinedType = Undefined,
            dns_servers_ipv4: list[str] | UndefinedType = Undefined,
            dns_servers_ipv6: list[str] | UndefinedType = Undefined,
            tftp_server: TftpServer | UndefinedType = Undefined,
            ipv4_vendor_options: Ipv4VendorOptions | UndefinedType = Undefined,
            subnets: Subnets | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            DhcpServersItem.

            Args:
            -----
                _custom_data: _custom_data
                disabled: disabled
                vrf: VRF in which to configure the DHCP server, use `default` to indicate default VRF.
                lease_time_ipv4: lease_time_ipv4
                lease_time_ipv6: lease_time_ipv6
                dns_domain_name_ipv4: dns_domain_name_ipv4
                dns_domain_name_ipv6: dns_domain_name_ipv6
                dns_servers_ipv4: List of DNS servers for IPv4 clients.
                dns_servers_ipv6: List of DNS servers for IPv6 clients.
                tftp_server: tftp_server
                ipv4_vendor_options: ipv4_vendor_options
                subnets: subnets
                eos_cli: Multiline EOS CLI rendered directly on the dhcp server in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DhcpServers(AvdCollection[str, DhcpServersItem]):
        _primary_key: ClassVar[str] = "vrf"

    DhcpServers._item_type = DhcpServersItem

    class Dot1x(AvdModel):
        class MacBasedAuthentication(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "delay": {"type": int}, "hold_period": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            delay: int | None
            hold_period: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                delay: int | None | UndefinedType = Undefined,
                hold_period: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                MacBasedAuthentication.

                Args:
                -----
                    _custom_data: _custom_data
                    delay: delay
                    hold_period: hold_period

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RadiusAvPairUsernameFormat(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "delimiter": {"type": str}, "mac_string_case": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "delimiter", "mac_string_case")
            _custom_data: dict[str, Any]
            delimiter: str
            """Delimiter to use in MAC address string."""
            mac_string_case: str
            """MAC address string in lowercase/uppercase."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                delimiter: str | UndefinedType = Undefined,
                mac_string_case: str | UndefinedType = Undefined,
            ) -> None:
                """
                RadiusAvPairUsernameFormat.

                Args:
                -----
                    _custom_data: _custom_data
                    delimiter: Delimiter to use in MAC address string.
                    mac_string_case: MAC address string in lowercase/uppercase.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RadiusAvPair(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "service_type": {"type": bool}, "framed_mtu": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            service_type: bool | None
            framed_mtu: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                service_type: bool | None | UndefinedType = Undefined,
                framed_mtu: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                RadiusAvPair.

                Args:
                -----
                    _custom_data: _custom_data
                    service_type: service_type
                    framed_mtu: framed_mtu

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Aaa(AvdModel):
            class Unresponsive(AvdModel):
                class Action(AvdModel):
                    class CachedResultsTimeout(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "time_duration_unit")
                        _custom_data: dict[str, Any]
                        time_duration: int | None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: str

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            time_duration: int | None | UndefinedType = Undefined,
                            time_duration_unit: str | UndefinedType = Undefined,
                        ) -> None:
                            """
                            CachedResultsTimeout.

                            Args:
                            -----
                                _custom_data: _custom_data
                                time_duration:
                                   Enable caching for a specific duration -
                                   <1-10000>      duration in days
                                   <1-14400000>   duration in
                                   minutes
                                   <1-240000>     duration in hours
                                   <1-864000000>  duration in seconds
                                time_duration_unit: time_duration_unit

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "apply_cached_results": {"type": bool},
                        "cached_results_timeout": {"type": CachedResultsTimeout},
                        "apply_alternate": {"type": bool},
                        "traffic_allow": {"type": bool},
                        "traffic_allow_vlan": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    apply_cached_results: bool | None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout
                    apply_alternate: bool | None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive action apply cached-results
                    else traffic allow
                    """
                    traffic_allow: bool | None
                    """Set action for supplicant traffic when AAA times out."""
                    traffic_allow_vlan: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        apply_cached_results: bool | None | UndefinedType = Undefined,
                        cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                        apply_alternate: bool | None | UndefinedType = Undefined,
                        traffic_allow: bool | None | UndefinedType = Undefined,
                        traffic_allow_vlan: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Action.

                        Args:
                        -----
                            _custom_data: _custom_data
                            apply_cached_results: Use results from a previous AAA response.
                            cached_results_timeout: cached_results_timeout
                            apply_alternate:
                               Apply alternate action if primary action fails.
                               eg. aaa unresponsive action apply cached-results
                               else traffic allow
                            traffic_allow: Set action for supplicant traffic when AAA times out.
                            traffic_allow_vlan: traffic_allow_vlan

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PhoneAction(AvdModel):
                    class CachedResultsTimeout(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "time_duration_unit")
                        _custom_data: dict[str, Any]
                        time_duration: int | None
                        """
                        Enable caching for a specific duration -
                        <1-10000>      duration in days
                        <1-14400000>   duration in
                        minutes
                        <1-240000>     duration in hours
                        <1-864000000>  duration in seconds
                        """
                        time_duration_unit: str

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            time_duration: int | None | UndefinedType = Undefined,
                            time_duration_unit: str | UndefinedType = Undefined,
                        ) -> None:
                            """
                            CachedResultsTimeout.

                            Args:
                            -----
                                _custom_data: _custom_data
                                time_duration:
                                   Enable caching for a specific duration -
                                   <1-10000>      duration in days
                                   <1-14400000>   duration in
                                   minutes
                                   <1-240000>     duration in hours
                                   <1-864000000>  duration in seconds
                                time_duration_unit: time_duration_unit

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "apply_cached_results": {"type": bool},
                        "cached_results_timeout": {"type": CachedResultsTimeout},
                        "apply_alternate": {"type": bool},
                        "traffic_allow": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    apply_cached_results: bool | None
                    """Use results from a previous AAA response."""
                    cached_results_timeout: CachedResultsTimeout
                    apply_alternate: bool | None
                    """
                    Apply alternate action if primary action fails.
                    eg. aaa unresponsive phone action apply cached-
                    results else traffic allow
                    """
                    traffic_allow: bool | None
                    """Set action for supplicant traffic when AAA times out."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        apply_cached_results: bool | None | UndefinedType = Undefined,
                        cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                        apply_alternate: bool | None | UndefinedType = Undefined,
                        traffic_allow: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PhoneAction.

                        Args:
                        -----
                            _custom_data: _custom_data
                            apply_cached_results: Use results from a previous AAA response.
                            cached_results_timeout: cached_results_timeout
                            apply_alternate:
                               Apply alternate action if primary action fails.
                               eg. aaa unresponsive phone action apply cached-
                               results else traffic allow
                            traffic_allow: Set action for supplicant traffic when AAA times out.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "eap_response": {"type": str},
                    "action": {"type": Action},
                    "phone_action": {"type": PhoneAction},
                    "recovery_action_reauthenticate": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                eap_response: str | None
                """EAP response to send."""
                action: Action
                """Set action for supplicant when AAA times out."""
                phone_action: PhoneAction
                """Set action for supplicant when AAA times out."""
                recovery_action_reauthenticate: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    eap_response: str | None | UndefinedType = Undefined,
                    action: Action | UndefinedType = Undefined,
                    phone_action: PhoneAction | UndefinedType = Undefined,
                    recovery_action_reauthenticate: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Unresponsive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        eap_response: EAP response to send.
                        action: Set action for supplicant when AAA times out.
                        phone_action: Set action for supplicant when AAA times out.
                        recovery_action_reauthenticate: recovery_action_reauthenticate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "unresponsive": {"type": Unresponsive}, "accounting_update_interval": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            unresponsive: Unresponsive
            """Configure AAA timeout options."""
            accounting_update_interval: int | None
            """Interval period in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                unresponsive: Unresponsive | UndefinedType = Undefined,
                accounting_update_interval: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Aaa.

                Args:
                -----
                    _custom_data: _custom_data
                    unresponsive: Configure AAA timeout options.
                    accounting_update_interval: Interval period in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CaptivePortal(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "url": {"type": str},
                "ssl_profile": {"type": str},
                "start_limit_infinite": {"type": bool},
                "access_list_ipv4": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            url: str | None
            """
            Supported URL type:
              - http: http://<hostname>[:<port>]
              - https: https://<hostname>[:<port>]
            """
            ssl_profile: str | None
            start_limit_infinite: bool | None
            """Set captive-portal start limit to infinite."""
            access_list_ipv4: str | None
            """Standard access-list name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                url: str | None | UndefinedType = Undefined,
                ssl_profile: str | None | UndefinedType = Undefined,
                start_limit_infinite: bool | None | UndefinedType = Undefined,
                access_list_ipv4: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                CaptivePortal.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    url:
                       Supported URL type:
                         - http: http://<hostname>[:<port>]
                         - https: https://<hostname>[:<port>]
                    ssl_profile: ssl_profile
                    start_limit_infinite: Set captive-portal start limit to infinite.
                    access_list_ipv4: Standard access-list name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Supplicant(AvdModel):
            class ProfilesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "eap_method": {"type": str},
                    "identity": {"type": str},
                    "passphrase_type": {"type": str, "default": "7"},
                    "passphrase": {"type": str},
                    "ssl_profile": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                eap_method: str | None
                """
                Extensible Authentication Protocol method:
                  - EAP Flexible Authentication via Secure Tunneling.
                  -
                EAP with Transport Layer Security.
                """
                identity: str | None
                """User identity."""
                passphrase_type: str | None
                passphrase: str | None
                """Extensible Authentication Protocol password."""
                ssl_profile: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    eap_method: str | None | UndefinedType = Undefined,
                    identity: str | None | UndefinedType = Undefined,
                    passphrase_type: str | None | UndefinedType = Undefined,
                    passphrase: str | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        eap_method:
                           Extensible Authentication Protocol method:
                             - EAP Flexible Authentication via Secure Tunneling.
                             -
                           EAP with Transport Layer Security.
                        identity: User identity.
                        passphrase_type: passphrase_type
                        passphrase: Extensible Authentication Protocol password.
                        ssl_profile: ssl_profile

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Profiles(AvdCollection[str, ProfilesItem]):
                _primary_key: ClassVar[str] = "name"

            Profiles._item_type = ProfilesItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "profiles": {"type": Profiles},
                "logging": {"type": bool},
                "disconnect_cached_results_timeout": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            profiles: Profiles
            """Dot1x supplicant profiles."""
            logging: bool | None
            """Enable supplicant logging."""
            disconnect_cached_results_timeout: int | None
            """Timeout in seconds for removing a disconnected supplicant."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
                logging: bool | None | UndefinedType = Undefined,
                disconnect_cached_results_timeout: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Supplicant.

                Args:
                -----
                    _custom_data: _custom_data
                    profiles: Dot1x supplicant profiles.
                    logging: Enable supplicant logging.
                    disconnect_cached_results_timeout: Timeout in seconds for removing a disconnected supplicant.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "system_auth_control": {"type": bool},
            "protocol_lldp_bypass": {"type": bool},
            "protocol_bpdu_bypass": {"type": bool},
            "dynamic_authorization": {"type": bool},
            "mac_based_authentication": {"type": MacBasedAuthentication},
            "radius_av_pair_username_format": {"type": RadiusAvPairUsernameFormat},
            "radius_av_pair": {"type": RadiusAvPair},
            "aaa": {"type": Aaa},
            "captive_portal": {"type": CaptivePortal},
            "supplicant": {"type": Supplicant},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        system_auth_control: bool | None
        protocol_lldp_bypass: bool | None
        protocol_bpdu_bypass: bool | None
        dynamic_authorization: bool | None
        mac_based_authentication: MacBasedAuthentication
        radius_av_pair_username_format: RadiusAvPairUsernameFormat
        """RADIUS AV-pair username settings."""
        radius_av_pair: RadiusAvPair
        aaa: Aaa
        """Configure AAA parameters."""
        captive_portal: CaptivePortal
        """
        Web authentication feature authenticates a supplicant through a web page, referred to as a captive
        portal.
        """
        supplicant: Supplicant

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            system_auth_control: bool | None | UndefinedType = Undefined,
            protocol_lldp_bypass: bool | None | UndefinedType = Undefined,
            protocol_bpdu_bypass: bool | None | UndefinedType = Undefined,
            dynamic_authorization: bool | None | UndefinedType = Undefined,
            mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
            radius_av_pair_username_format: RadiusAvPairUsernameFormat | UndefinedType = Undefined,
            radius_av_pair: RadiusAvPair | UndefinedType = Undefined,
            aaa: Aaa | UndefinedType = Undefined,
            captive_portal: CaptivePortal | UndefinedType = Undefined,
            supplicant: Supplicant | UndefinedType = Undefined,
        ) -> None:
            """
            Dot1x.

            Args:
            -----
                _custom_data: _custom_data
                system_auth_control: system_auth_control
                protocol_lldp_bypass: protocol_lldp_bypass
                protocol_bpdu_bypass: protocol_bpdu_bypass
                dynamic_authorization: dynamic_authorization
                mac_based_authentication: mac_based_authentication
                radius_av_pair_username_format: RADIUS AV-pair username settings.
                radius_av_pair: radius_av_pair
                aaa: Configure AAA parameters.
                captive_portal:
                   Web authentication feature authenticates a supplicant through a web page, referred to as a captive
                   portal.
                supplicant: supplicant

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DpsInterfacesItem(AvdModel):
        class FlowTracker(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sampled": {"type": str}, "hardware": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name,"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sampled: str | None | UndefinedType = Undefined,
                hardware: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracker.

                Args:
                -----
                    _custom_data: _custom_data
                    sampled: Sampled flow tracker name.
                    hardware: Hardware flow tracker name,

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TcpMssCeiling(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": int}, "ipv6": {"type": int}, "direction": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: int | None
            """Segment Size for IPv4."""
            ipv6: int | None
            """Segment Size for IPv6."""
            direction: str | None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: int | None | UndefinedType = Undefined,
                ipv6: int | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Segment Size for IPv4.
                    ipv6: Segment Size for IPv6.
                    direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "mtu": {"type": int},
            "ip_address": {"type": str},
            "flow_tracker": {"type": FlowTracker},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """"Dps1" is currently the only supported interface."""
        description: str | None
        shutdown: bool | None
        mtu: int | None
        """Maximum Transmission Unit in bytes."""
        ip_address: str | None
        """IPv4 address/mask."""
        flow_tracker: FlowTracker
        tcp_mss_ceiling: TcpMssCeiling
        eos_cli: str | None
        """Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            flow_tracker: FlowTracker | UndefinedType = Undefined,
            tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            DpsInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: "Dps1" is currently the only supported interface.
                description: description
                shutdown: shutdown
                mtu: Maximum Transmission Unit in bytes.
                ip_address: IPv4 address/mask.
                flow_tracker: flow_tracker
                tcp_mss_ceiling: tcp_mss_ceiling
                eos_cli: Multiline String with EOS CLI rendered directly on the Dps interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class DpsInterfaces(AvdCollection[str, DpsInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    DpsInterfaces._item_type = DpsInterfacesItem

    class DynamicPrefixListsItem(AvdModel):
        class PrefixList(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": str}, "ipv6": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: str | None
            """Prefix-list name."""
            ipv6: str | None
            """Prefix-list name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: str | None | UndefinedType = Undefined,
                ipv6: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                PrefixList.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Prefix-list name.
                    ipv6: Prefix-list name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "match_map": {"type": str}, "prefix_list": {"type": PrefixList}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        name: str | None
        """Dynamic prefix-list name."""
        match_map: str | None
        """Route-map name."""
        prefix_list: PrefixList

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            match_map: str | None | UndefinedType = Undefined,
            prefix_list: PrefixList | UndefinedType = Undefined,
        ) -> None:
            """
            DynamicPrefixListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Dynamic prefix-list name.
                match_map: Route-map name.
                prefix_list: prefix_list

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EnablePassword(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "disabled": {"type": bool}, "hash_algorithm": {"type": str}, "key": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        disabled: bool | None
        """Set to `true` to configure `no enable password` which is the EOS default."""
        hash_algorithm: str | None
        key: str | None
        """
        Must be the hash of the password using the specified algorithm.
        By default EOS salts the password,
        so the simplest is to generate the hash on an EOS device.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            hash_algorithm: str | None | UndefinedType = Undefined,
            key: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            EnablePassword.

            Args:
            -----
                _custom_data: _custom_data
                disabled: Set to `true` to configure `no enable password` which is the EOS default.
                hash_algorithm: hash_algorithm
                key:
                   Must be the hash of the password using the specified algorithm.
                   By default EOS salts the password,
                   so the simplest is to generate the hash on an EOS device.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EosCliConfigGenConfiguration(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enable": {"type": bool, "default": True},
            "hide_passwords": {"type": bool, "default": False},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable: bool | None
        """Generate device EOS configurations."""
        hide_passwords: bool | None
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the configuration if true.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enable: bool | None | UndefinedType = Undefined,
            hide_passwords: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            EosCliConfigGenConfiguration.

            Args:
            -----
                _custom_data: _custom_data
                enable: Generate device EOS configurations.
                hide_passwords:
                   Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                   the configuration if true.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EosCliConfigGenDocumentation(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool, "default": True}, "hide_passwords": {"type": bool, "default": True}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable: bool | None
        """Generate device Markdown documentation."""
        hide_passwords: bool | None
        """
        Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
        the documentation if true.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enable: bool | None | UndefinedType = Undefined,
            hide_passwords: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            EosCliConfigGenDocumentation.

            Args:
            -----
                _custom_data: _custom_data
                enable: Generate device Markdown documentation.
                hide_passwords:
                   Replace the input data using the `hide_passwords` filter in the Jinja2 templates by '<removed>' in
                   the documentation if true.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Errdisable(AvdModel):
        class Detect(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "causes": {"type": list, "items": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            causes: list[str]

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, causes: list[str] | UndefinedType = Undefined) -> None:
                """
                Detect.

                Args:
                -----
                    _custom_data: _custom_data
                    causes: causes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Recovery(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "causes": {"type": list, "items": str}, "interval": {"type": int, "default": 300}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            causes: list[str]
            interval: int | None
            """Interval in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                causes: list[str] | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Recovery.

                Args:
                -----
                    _custom_data: _custom_data
                    causes: causes
                    interval: Interval in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "detect": {"type": Detect}, "recovery": {"type": Recovery}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        detect: Detect
        recovery: Recovery

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            detect: Detect | UndefinedType = Undefined,
            recovery: Recovery | UndefinedType = Undefined,
        ) -> None:
            """
            Errdisable.

            Args:
            -----
                _custom_data: _custom_data
                detect: detect
                recovery: recovery

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EthernetInterfacesItem(AvdModel):
        class Phone(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "trunk": {"type": str}, "vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            trunk: str | None
            vlan: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                trunk: str | None | UndefinedType = Undefined,
                vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Phone.

                Args:
                -----
                    _custom_data: _custom_data
                    trunk: trunk
                    vlan: vlan

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L2Protocol(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "encapsulation_dot1q_vlan": {"type": int}, "forwarding_profile": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            encapsulation_dot1q_vlan: int | None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None
            """L2 protocol forwarding profile."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                forwarding_profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                L2Protocol.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                    forwarding_profile: L2 protocol forwarding profile.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressLocking(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": bool}, "ipv6": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: bool | None
            """Enable address locking for IPv4."""
            ipv6: bool | None
            """Enable address locking for IPv6."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: bool | None | UndefinedType = Undefined,
                ipv6: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                AddressLocking.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Enable address locking for IPv4.
                    ipv6: Enable address locking for IPv6.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Flowcontrol(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "received": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            received: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, received: str | None | UndefinedType = Undefined) -> None:
                """
                Flowcontrol.

                Args:
                -----
                    _custom_data: _custom_data
                    received: received

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FlowTracker(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sampled": {"type": str}, "hardware": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sampled: str | None | UndefinedType = Undefined,
                hardware: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracker.

                Args:
                -----
                    _custom_data: _custom_data
                    sampled: Sampled flow tracker name.
                    hardware: Hardware flow tracker name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ErrorCorrectionEncoding(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool, "default": True},
                "fire_code": {"type": bool},
                "reed_solomon": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            fire_code: bool | None
            reed_solomon: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                fire_code: bool | None | UndefinedType = Undefined,
                reed_solomon: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                ErrorCorrectionEncoding.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    fire_code: fire_code
                    reed_solomon: reed_solomon

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTrackingGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "direction": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Group name."""
            direction: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LinkTrackingGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTrackingGroups(AvdCollection[str, LinkTrackingGroupsItem]):
            _primary_key: ClassVar[str] = "name"

        LinkTrackingGroups._item_type = LinkTrackingGroupsItem

        class EvpnEthernetSegment(AvdModel):
            class DesignatedForwarderElection(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "algorithm": {"type": str},
                    "preference_value": {"type": int},
                    "dont_preempt": {"type": bool},
                    "hold_time": {"type": int},
                    "subsequent_hold_time": {"type": int},
                    "candidate_reachability_required": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                algorithm: str | None
                preference_value: int | None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool | None
                """Dont_preempt is only used when "algorithm" is "preference"."""
                hold_time: int | None
                subsequent_hold_time: int | None
                candidate_reachability_required: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    algorithm: str | None | UndefinedType = Undefined,
                    preference_value: int | None | UndefinedType = Undefined,
                    dont_preempt: bool | None | UndefinedType = Undefined,
                    hold_time: int | None | UndefinedType = Undefined,
                    subsequent_hold_time: int | None | UndefinedType = Undefined,
                    candidate_reachability_required: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DesignatedForwarderElection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        algorithm: algorithm
                        preference_value: Preference_value is only used when "algorithm" is "preference".
                        dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                        hold_time: hold_time
                        subsequent_hold_time: subsequent_hold_time
                        candidate_reachability_required: candidate_reachability_required

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Mpls(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "shared_index": {"type": int}, "tunnel_flood_filter_time": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                shared_index: int | None
                tunnel_flood_filter_time: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    shared_index: int | None | UndefinedType = Undefined,
                    tunnel_flood_filter_time: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mpls.

                    Args:
                    -----
                        _custom_data: _custom_data
                        shared_index: shared_index
                        tunnel_flood_filter_time: tunnel_flood_filter_time

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "identifier": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_election": {"type": DesignatedForwarderElection},
                "mpls": {"type": Mpls},
                "route_target": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            identifier: str | None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: str | None
            designated_forwarder_election: DesignatedForwarderElection
            mpls: Mpls
            route_target: str | None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                identifier: str | None | UndefinedType = Undefined,
                redundancy: str | None | UndefinedType = Undefined,
                designated_forwarder_election: DesignatedForwarderElection | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                route_target: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EvpnEthernetSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                    redundancy: redundancy
                    designated_forwarder_election: designated_forwarder_election
                    mpls: mpls
                    route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationDot1q(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "inner_vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "vlan")
            _custom_data: dict[str, Any]
            vlan: int
            """VLAD ID."""
            inner_vlan: int | None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                vlan: int | UndefinedType = Undefined,
                inner_vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                EncapsulationDot1q.

                Args:
                -----
                    _custom_data: _custom_data
                    vlan: VLAD ID.
                    inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationVlan(AvdModel):
            class Client(AvdModel):
                class Dot1q(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    vlan: int | None
                    """Client VLAN ID."""
                    outer: int | None
                    """Client Outer VLAN ID."""
                    inner: int | None
                    """Client Inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer: int | None | UndefinedType = Undefined,
                        inner: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Client VLAN ID.
                            outer: Client Outer VLAN ID.
                            inner: Client Inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "dot1q": {"type": Dot1q},
                    "unmatched": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dot1q: Dot1q
                unmatched: bool | None
                encapsulation: str | None
                vlan: int | None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: int | None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: int | None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    unmatched: bool | None | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    outer_vlan: int | None | UndefinedType = Undefined,
                    inner_vlan: int | None | UndefinedType = Undefined,
                    inner_encapsulation: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Client.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        unmatched: unmatched
                        encapsulation: encapsulation
                        vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Network(AvdModel):
                class Dot1q(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    vlan: int | None
                    """Network VLAN ID."""
                    outer: int | None
                    """Network outer VLAN ID."""
                    inner: int | None
                    """Network inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer: int | None | UndefinedType = Undefined,
                        inner: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Network VLAN ID.
                            outer: Network outer VLAN ID.
                            inner: Network inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "dot1q": {"type": Dot1q},
                    "client": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dot1q: Dot1q
                client: bool | None
                encapsulation: str | None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: int | None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: int | None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: int | None
                """Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    client: bool | None | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    outer_vlan: int | None | UndefinedType = Undefined,
                    inner_vlan: int | None | UndefinedType = Undefined,
                    inner_encapsulation: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Network.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        client: client
                        encapsulation:
                           `untagged` (no encapsulation) is applicable for `untagged` client only.
                           `client` and `client inner`
                           (retain client encapsulation) is not applicable for `untagged` client.
                        vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_vlan: Network inner VLAN ID.  Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "client": {"type": Client}, "network": {"type": Network}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            client: Client
            network: Network
            """Network encapsulations are all optional and skipped if using client unmatched."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                client: Client | UndefinedType = Undefined,
                network: Network | UndefinedType = Undefined,
            ) -> None:
                """
                EncapsulationVlan.

                Args:
                -----
                    _custom_data: _custom_data
                    client: client
                    network: Network encapsulations are all optional and skipped if using client unmatched.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_helper": {"type": str}, "source_interface": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
            _custom_data: dict[str, Any]
            ip_helper: str
            source_interface: str | None
            """Source interface name."""
            vrf: str | None
            """VRF name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_helper: str | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpHelpersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_helper: ip_helper
                    source_interface: Source interface name.
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpers(AvdCollection[str, IpHelpersItem]):
            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class IpNat(AvdModel):
            class Destination(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "pool_name")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        pool_name: str | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "nat_type")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    nat_type: str
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        nat_type: str | UndefinedType = Undefined,
                        pool_name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "service_profile": {"type": str},
                "destination": {"type": Destination},
                "source": {"type": Source},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            service_profile: str | None
            """NAT interface profile."""
            destination: Destination
            source: Source

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                service_profile: str | None | UndefinedType = Undefined,
                destination: Destination | UndefinedType = Undefined,
                source: Source | UndefinedType = Undefined,
            ) -> None:
                """
                IpNat.

                Args:
                -----
                    _custom_data: _custom_data
                    service_profile: NAT interface profile.
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipv6_prefix")
            _custom_data: dict[str, Any]
            ipv6_prefix: str
            valid_lifetime: str | None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv6_prefix: str | UndefinedType = Undefined,
                valid_lifetime: str | None | UndefinedType = Undefined,
                preferred_lifetime: str | None | UndefinedType = Undefined,
                no_autoconfig_flag: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6NdPrefixesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_prefix: ipv6_prefix
                    valid_lifetime: Infinite or lifetime in seconds.
                    preferred_lifetime: Infinite or lifetime in seconds.
                    no_autoconfig_flag: no_autoconfig_flag

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixes(AvdCollection[str, Ipv6NdPrefixesItem]):
            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Ipv6DhcpRelayDestinationsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "address": {"type": str},
                "vrf": {"type": str},
                "local_interface": {"type": str},
                "source_address": {"type": str},
                "link_address": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "address")
            _custom_data: dict[str, Any]
            address: str
            """DHCP server's IPv6 address."""
            vrf: str | None
            local_interface: str | None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None
            """Override the default link address specified in the relayed DHCP packet."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                address: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                source_address: str | None | UndefinedType = Undefined,
                link_address: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6DhcpRelayDestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    address: DHCP server's IPv6 address.
                    vrf: vrf
                    local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                    source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                    link_address: Override the default link address specified in the relayed DHCP packet.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6DhcpRelayDestinations(AvdCollection[str, Ipv6DhcpRelayDestinationsItem]):
            _primary_key: ClassVar[str] = "address"

        Ipv6DhcpRelayDestinations._item_type = Ipv6DhcpRelayDestinationsItem

        class Multicast(AvdModel):
            class Ipv4(AvdModel):
                class BoundariesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "boundary": {"type": str}, "out": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    boundary: str | None
                    """ACL name or multicast IP subnet."""
                    out: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        boundary: str | None | UndefinedType = Undefined,
                        out: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: ACL name or multicast IP subnet.
                            out: out

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "boundaries": {"type": list, "items": BoundariesItem}, "static": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                boundaries: list[BoundariesItem]
                static: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    boundaries: list[BoundariesItem] | UndefinedType = Undefined,
                    static: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries: boundaries
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdModel):
                class BoundariesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "boundary": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    boundary: str | None
                    """ACL name or multicast IP subnet."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, boundary: str | None | UndefinedType = Undefined) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: ACL name or multicast IP subnet.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "boundaries": {"type": list, "items": BoundariesItem}, "static": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                boundaries: list[BoundariesItem]
                static: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    boundaries: list[BoundariesItem] | UndefinedType = Undefined,
                    static: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries: boundaries
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: Ipv4
            ipv6: Ipv6

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: Ipv4 | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
            ) -> None:
                """
                Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeysItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            hash_algorithm: str | None
            key: str | None
            """Encrypted password - only type 7 supported."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                OspfMessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key: Encrypted password - only type 7 supported.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeys(AvdCollection[int, OspfMessageDigestKeysItem]):
            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class Pim(AvdModel):
            class Ipv4(AvdModel):
                class Hello(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": str}, "interval": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: str | None | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Hello.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                            interval: PIM hello interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "hello": {"type": Hello},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                hello: Hello

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    border_router: bool | None | UndefinedType = Undefined,
                    dr_priority: int | None | UndefinedType = Undefined,
                    sparse_mode: bool | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bidirectional: bool | None | UndefinedType = Undefined,
                    hello: Hello | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        border_router: Configure PIM border router. EOS default is false.
                        dr_priority: dr_priority
                        sparse_mode: sparse_mode
                        bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                        bidirectional: bidirectional
                        hello: hello

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: Ipv4

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                """
                Pim.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MacSecurity(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            profile: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined) -> None:
                """
                MacSecurity.

                Args:
                -----
                    _custom_data: _custom_data
                    profile: profile

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TcpMssCeiling(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv4_segment_size": {"type": int},
                "ipv6_segment_size": {"type": int},
                "direction": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4_segment_size: int | None
            ipv6_segment_size: int | None
            direction: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4_segment_size: int | None | UndefinedType = Undefined,
                ipv6_segment_size: int | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_segment_size: ipv4_segment_size
                    ipv6_segment_size: ipv6_segment_size
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ChannelGroup(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "mode": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            id: int | None
            mode: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | None | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ChannelGroup.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    mode: mode

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Poe(AvdModel):
            class Reboot(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                action: str | None
                """PoE action for interface."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, action: str | None | UndefinedType = Undefined) -> None:
                    """
                    Reboot.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: PoE action for interface.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LinkDown(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}, "power_off_delay": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                action: str | None
                """PoE action for interface."""
                power_off_delay: int | None
                """
                Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                seconds in EOS.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    action: str | None | UndefinedType = Undefined,
                    power_off_delay: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkDown.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: PoE action for interface.
                        power_off_delay:
                           Number of seconds to delay shutting the power off after a link down event occurs. Default value is 5
                           seconds in EOS.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Shutdown(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                action: str | None
                """PoE action for interface."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, action: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shutdown.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: PoE action for interface.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Limit(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "field_class": {"type": int, "key": "class"},
                    "watts": {"type": str},
                    "fixed": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                field_class: int | None
                watts: str | None
                fixed: bool | None
                """Set to ignore hardware classification."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    field_class: int | None | UndefinedType = Undefined,
                    watts: str | None | UndefinedType = Undefined,
                    fixed: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Limit.

                    Args:
                    -----
                        _custom_data: _custom_data
                        field_class: field_class
                        watts: watts
                        fixed: Set to ignore hardware classification.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "disabled": {"type": bool, "default": False},
                "priority": {"type": str},
                "reboot": {"type": Reboot},
                "link_down": {"type": LinkDown},
                "shutdown": {"type": Shutdown},
                "limit": {"type": Limit},
                "negotiation_lldp": {"type": bool},
                "legacy_detect": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            disabled: bool | None
            """Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS."""
            priority: str | None
            """Prioritize a port's power in the event that one of the switch's power supplies loses power."""
            reboot: Reboot
            """Set the PoE power behavior for a PoE port when the system is rebooted."""
            link_down: LinkDown
            """Set the PoE power behavior for a PoE port when the port goes down."""
            shutdown: Shutdown
            """Set the PoE power behavior for a PoE port when the port is admin down."""
            limit: Limit
            """
            Override the hardware-negotiated power limit using either wattage or a power class. Note that if
            using a power class, AVD will automatically convert the class value to the wattage value
            corresponding to that power class.
            """
            negotiation_lldp: bool | None
            """
            Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
            EOS.
            """
            legacy_detect: bool | None
            """
            Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
            can cause false positive detections.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                disabled: bool | None | UndefinedType = Undefined,
                priority: str | None | UndefinedType = Undefined,
                reboot: Reboot | UndefinedType = Undefined,
                link_down: LinkDown | UndefinedType = Undefined,
                shutdown: Shutdown | UndefinedType = Undefined,
                limit: Limit | UndefinedType = Undefined,
                negotiation_lldp: bool | None | UndefinedType = Undefined,
                legacy_detect: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Poe.

                Args:
                -----
                    _custom_data: _custom_data
                    disabled: Disable PoE on a POE capable port. PoE is enabled on all ports that support it by default in EOS.
                    priority: Prioritize a port's power in the event that one of the switch's power supplies loses power.
                    reboot: Set the PoE power behavior for a PoE port when the system is rebooted.
                    link_down: Set the PoE power behavior for a PoE port when the port goes down.
                    shutdown: Set the PoE power behavior for a PoE port when the port is admin down.
                    limit:
                       Override the hardware-negotiated power limit using either wattage or a power class. Note that if
                       using a power class, AVD will automatically convert the class value to the wattage value
                       corresponding to that power class.
                    negotiation_lldp:
                       Disable to prevent port from negotiating power with powered devices over LLDP. Enabled by default in
                       EOS.
                    legacy_detect:
                       Allow a subset of legacy devices to work with the PoE switch. Disabled by default in EOS because it
                       can cause false positive detections.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ptp(AvdModel):
            class Announce(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "timeout": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int | None
                timeout: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Announce.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval
                        timeout: timeout

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Profile(AvdModel):
                class G82751(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination_mac_address": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    destination_mac_address: str | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, destination_mac_address: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        G82751.

                        Args:
                        -----
                            _custom_data: _custom_data
                            destination_mac_address: destination_mac_address

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "g8275_1": {"type": G82751}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                g8275_1: G82751

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, g8275_1: G82751 | UndefinedType = Undefined) -> None:
                    """
                    Profile.

                    Args:
                    -----
                        _custom_data: _custom_data
                        g8275_1: g8275_1

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SyncMessage(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                    """
                    SyncMessage.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enable": {"type": bool},
                "announce": {"type": Announce},
                "delay_req": {"type": int},
                "delay_mechanism": {"type": str},
                "profile": {"type": Profile},
                "sync_message": {"type": SyncMessage},
                "role": {"type": str},
                "vlan": {"type": str},
                "transport": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enable: bool | None
            announce: Announce
            delay_req: int | None
            delay_mechanism: str | None
            profile: Profile
            sync_message: SyncMessage
            role: str | None
            vlan: str | None
            """VLAN can be 'all' or list of vlans as string."""
            transport: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                announce: Announce | UndefinedType = Undefined,
                delay_req: int | None | UndefinedType = Undefined,
                delay_mechanism: str | None | UndefinedType = Undefined,
                profile: Profile | UndefinedType = Undefined,
                sync_message: SyncMessage | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                vlan: str | None | UndefinedType = Undefined,
                transport: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ptp.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    announce: announce
                    delay_req: delay_req
                    delay_mechanism: delay_mechanism
                    profile: profile
                    sync_message: sync_message
                    role: role
                    vlan: VLAN can be 'all' or list of vlans as string.
                    transport: transport

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StormControl(AvdModel):
            class All(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    All.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Broadcast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Broadcast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Multicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class UnknownUnicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnknownUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            all: All
            broadcast: Broadcast
            multicast: Multicast
            unknown_unicast: UnknownUnicast

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                all: All | UndefinedType = Undefined,
                broadcast: Broadcast | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
            ) -> None:
                """
                StormControl.

                Args:
                -----
                    _custom_data: _custom_data
                    all: all
                    broadcast: broadcast
                    multicast: multicast
                    unknown_unicast: unknown_unicast

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Logging(AvdModel):
            class Event(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "link_status": {"type": bool},
                    "congestion_drops": {"type": bool},
                    "spanning_tree": {"type": bool},
                    "storm_control_discards": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                link_status: bool | None
                congestion_drops: bool | None
                spanning_tree: bool | None
                storm_control_discards: bool | None
                """Discards due to storm-control."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    link_status: bool | None | UndefinedType = Undefined,
                    congestion_drops: bool | None | UndefinedType = Undefined,
                    spanning_tree: bool | None | UndefinedType = Undefined,
                    storm_control_discards: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        link_status: link_status
                        congestion_drops: congestion_drops
                        spanning_tree: spanning_tree
                        storm_control_discards: Discards due to storm-control.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "event": {"type": Event}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            event: Event

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, event: Event | UndefinedType = Undefined) -> None:
                """
                Logging.

                Args:
                -----
                    _custom_data: _custom_data
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Lldp(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "transmit": {"type": bool}, "receive": {"type": bool}, "ztp_vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            transmit: bool | None
            receive: bool | None
            ztp_vlan: int | None
            """ZTP vlan number."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                transmit: bool | None | UndefinedType = Undefined,
                receive: bool | None | UndefinedType = Undefined,
                ztp_vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Lldp.

                Args:
                -----
                    _custom_data: _custom_data
                    transmit: transmit
                    receive: receive
                    ztp_vlan: ZTP vlan number.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanTranslationsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "field_from": {"type": str, "key": "from"},
                "to": {"type": int},
                "direction": {"type": str, "default": "both"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            field_from: str | None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None
            """VLAN ID."""
            direction: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                field_from: str | None | UndefinedType = Undefined,
                to: int | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlanTranslationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    field_from: List of vlans as string (only one vlan if direction is "both").
                    to: VLAN ID.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Dot1x(AvdModel):
            class Pae(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | None | UndefinedType = Undefined) -> None:
                    """
                    Pae.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AuthenticationFailure(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}, "allow_vlan": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                action: str | None
                allow_vlan: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    action: str | None | UndefinedType = Undefined,
                    allow_vlan: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AuthenticationFailure.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: action
                        allow_vlan: allow_vlan

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HostMode(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multi_host_authenticated": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                multi_host_authenticated: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    multi_host_authenticated: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostMode.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        multi_host_authenticated: multi_host_authenticated

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MacBasedAuthentication(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "always": {"type": bool},
                    "host_mode_common": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always: bool | None
                host_mode_common: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    host_mode_common: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    MacBasedAuthentication.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        host_mode_common: host_mode_common

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timeout(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "idle_host": {"type": int},
                    "quiet_period": {"type": int},
                    "reauth_period": {"type": str},
                    "reauth_timeout_ignore": {"type": bool},
                    "tx_period": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                idle_host: int | None
                quiet_period: int | None
                reauth_period: str | None
                """Value can be 60-4294967295 or 'server'."""
                reauth_timeout_ignore: bool | None
                tx_period: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    idle_host: int | None | UndefinedType = Undefined,
                    quiet_period: int | None | UndefinedType = Undefined,
                    reauth_period: str | None | UndefinedType = Undefined,
                    reauth_timeout_ignore: bool | None | UndefinedType = Undefined,
                    tx_period: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timeout.

                    Args:
                    -----
                        _custom_data: _custom_data
                        idle_host: idle_host
                        quiet_period: quiet_period
                        reauth_period: Value can be 60-4294967295 or 'server'.
                        reauth_timeout_ignore: reauth_timeout_ignore
                        tx_period: tx_period

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Unauthorized(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "access_vlan_membership_egress": {"type": bool},
                    "native_vlan_membership_egress": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                access_vlan_membership_egress: bool | None
                native_vlan_membership_egress: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    access_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                    native_vlan_membership_egress: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Unauthorized.

                    Args:
                    -----
                        _custom_data: _custom_data
                        access_vlan_membership_egress: access_vlan_membership_egress
                        native_vlan_membership_egress: native_vlan_membership_egress

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Eapol(AvdModel):
                class AuthenticationFailureFallbackMba(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "timeout": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    timeout: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        timeout: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AuthenticationFailureFallbackMba.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            timeout: timeout

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "disabled": {"type": bool},
                    "authentication_failure_fallback_mba": {"type": AuthenticationFailureFallbackMba},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                disabled: bool | None
                authentication_failure_fallback_mba: AuthenticationFailureFallbackMba

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    disabled: bool | None | UndefinedType = Undefined,
                    authentication_failure_fallback_mba: AuthenticationFailureFallbackMba | UndefinedType = Undefined,
                ) -> None:
                    """
                    Eapol.

                    Args:
                    -----
                        _custom_data: _custom_data
                        disabled: disabled
                        authentication_failure_fallback_mba: authentication_failure_fallback_mba

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Aaa(AvdModel):
                class Unresponsive(AvdModel):
                    class Action(AvdModel):
                        class CachedResultsTimeout(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "time_duration_unit")
                            _custom_data: dict[str, Any]
                            time_duration: int | None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: str

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                time_duration: int | None | UndefinedType = Undefined,
                                time_duration_unit: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CachedResultsTimeout.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "traffic_allow_access_list": {"type": str},
                            "apply_cached_results": {"type": bool},
                            "cached_results_timeout": {"type": CachedResultsTimeout},
                            "apply_alternate": {"type": bool},
                            "traffic_allow": {"type": bool},
                            "traffic_allow_vlan": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        traffic_allow_access_list: str | None
                        """Name of standard access-list to apply when AAA times out."""
                        apply_cached_results: bool | None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout
                        apply_alternate: bool | None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive action apply cached-results
                        else traffic allow
                        """
                        traffic_allow: bool | None
                        """Set action for supplicant traffic when AAA times out."""
                        traffic_allow_vlan: int | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            traffic_allow_access_list: str | None | UndefinedType = Undefined,
                            apply_cached_results: bool | None | UndefinedType = Undefined,
                            cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                            apply_alternate: bool | None | UndefinedType = Undefined,
                            traffic_allow: bool | None | UndefinedType = Undefined,
                            traffic_allow_vlan: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Action.

                            Args:
                            -----
                                _custom_data: _custom_data
                                traffic_allow_access_list: Name of standard access-list to apply when AAA times out.
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: cached_results_timeout
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive action apply cached-results
                                   else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.
                                traffic_allow_vlan: traffic_allow_vlan

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class PhoneAction(AvdModel):
                        class CachedResultsTimeout(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "time_duration": {"type": int}, "time_duration_unit": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "time_duration_unit")
                            _custom_data: dict[str, Any]
                            time_duration: int | None
                            """
                            Enable caching for a specific duration -
                            <1-10000>      duration in days
                            <1-14400000>   duration in
                            minutes
                            <1-240000>     duration in hours
                            <1-864000000>  duration in seconds
                            """
                            time_duration_unit: str

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                time_duration: int | None | UndefinedType = Undefined,
                                time_duration_unit: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                CachedResultsTimeout.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    time_duration:
                                       Enable caching for a specific duration -
                                       <1-10000>      duration in days
                                       <1-14400000>   duration in
                                       minutes
                                       <1-240000>     duration in hours
                                       <1-864000000>  duration in seconds
                                    time_duration_unit: time_duration_unit

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "apply_cached_results": {"type": bool},
                            "cached_results_timeout": {"type": CachedResultsTimeout},
                            "apply_alternate": {"type": bool},
                            "traffic_allow": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        apply_cached_results: bool | None
                        """Use results from a previous AAA response."""
                        cached_results_timeout: CachedResultsTimeout
                        apply_alternate: bool | None
                        """
                        Apply alternate action if primary action fails.
                        eg. aaa unresponsive phone action apply cached-
                        results else traffic allow
                        """
                        traffic_allow: bool | None
                        """Set action for supplicant traffic when AAA times out."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            apply_cached_results: bool | None | UndefinedType = Undefined,
                            cached_results_timeout: CachedResultsTimeout | UndefinedType = Undefined,
                            apply_alternate: bool | None | UndefinedType = Undefined,
                            traffic_allow: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PhoneAction.

                            Args:
                            -----
                                _custom_data: _custom_data
                                apply_cached_results: Use results from a previous AAA response.
                                cached_results_timeout: cached_results_timeout
                                apply_alternate:
                                   Apply alternate action if primary action fails.
                                   eg. aaa unresponsive phone action apply cached-
                                   results else traffic allow
                                traffic_allow: Set action for supplicant traffic when AAA times out.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "eap_response": {"type": str},
                        "action": {"type": Action},
                        "phone_action": {"type": PhoneAction},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    eap_response: str | None
                    """EAP response to send. EOS default is `success`."""
                    action: Action
                    """Set action for supplicant when AAA times out."""
                    phone_action: PhoneAction
                    """Set action for supplicant when AAA times out."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        eap_response: str | None | UndefinedType = Undefined,
                        action: Action | UndefinedType = Undefined,
                        phone_action: PhoneAction | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Unresponsive.

                        Args:
                        -----
                            _custom_data: _custom_data
                            eap_response: EAP response to send. EOS default is `success`.
                            action: Set action for supplicant when AAA times out.
                            phone_action: Set action for supplicant when AAA times out.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "unresponsive": {"type": Unresponsive}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                unresponsive: Unresponsive
                """Configure AAA timeout options."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, unresponsive: Unresponsive | UndefinedType = Undefined) -> None:
                    """
                    Aaa.

                    Args:
                    -----
                        _custom_data: _custom_data
                        unresponsive: Configure AAA timeout options.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "port_control": {"type": str},
                "port_control_force_authorized_phone": {"type": bool},
                "reauthentication": {"type": bool},
                "pae": {"type": Pae},
                "authentication_failure": {"type": AuthenticationFailure},
                "host_mode": {"type": HostMode},
                "mac_based_authentication": {"type": MacBasedAuthentication},
                "mac_based_access_list": {"type": bool},
                "timeout": {"type": Timeout},
                "reauthorization_request_limit": {"type": int},
                "unauthorized": {"type": Unauthorized},
                "eapol": {"type": Eapol},
                "aaa": {"type": Aaa},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            port_control: str | None
            port_control_force_authorized_phone: bool | None
            reauthentication: bool | None
            pae: Pae
            authentication_failure: AuthenticationFailure
            host_mode: HostMode
            mac_based_authentication: MacBasedAuthentication
            mac_based_access_list: bool | None
            """Operate interface in per-mac access-list mode."""
            timeout: Timeout
            reauthorization_request_limit: int | None
            unauthorized: Unauthorized
            eapol: Eapol
            aaa: Aaa

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                port_control: str | None | UndefinedType = Undefined,
                port_control_force_authorized_phone: bool | None | UndefinedType = Undefined,
                reauthentication: bool | None | UndefinedType = Undefined,
                pae: Pae | UndefinedType = Undefined,
                authentication_failure: AuthenticationFailure | UndefinedType = Undefined,
                host_mode: HostMode | UndefinedType = Undefined,
                mac_based_authentication: MacBasedAuthentication | UndefinedType = Undefined,
                mac_based_access_list: bool | None | UndefinedType = Undefined,
                timeout: Timeout | UndefinedType = Undefined,
                reauthorization_request_limit: int | None | UndefinedType = Undefined,
                unauthorized: Unauthorized | UndefinedType = Undefined,
                eapol: Eapol | UndefinedType = Undefined,
                aaa: Aaa | UndefinedType = Undefined,
            ) -> None:
                """
                Dot1x.

                Args:
                -----
                    _custom_data: _custom_data
                    port_control: port_control
                    port_control_force_authorized_phone: port_control_force_authorized_phone
                    reauthentication: reauthentication
                    pae: pae
                    authentication_failure: authentication_failure
                    host_mode: host_mode
                    mac_based_authentication: mac_based_authentication
                    mac_based_access_list: Operate interface in per-mac access-list mode.
                    timeout: timeout
                    reauthorization_request_limit: reauthorization_request_limit
                    unauthorized: unauthorized
                    eapol: eapol
                    aaa: aaa

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Shape(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            rate: str | None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: str | None | UndefinedType = Undefined) -> None:
                """
                Shape.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Rate in kbps, pps or percent.
                       Supported options are platform dependent.

                Examples:
                       - "5000 kbps"
                       -
                       "1000 pps"
                       - "20 percent"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Qos(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "trust": {"type": str}, "dscp": {"type": int}, "cos": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            trust: str | None
            dscp: int | None
            """DSCP value."""
            cos: int | None
            """COS value."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                trust: str | None | UndefinedType = Undefined,
                dscp: int | None | UndefinedType = Undefined,
                cos: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Qos.

                Args:
                -----
                    _custom_data: _custom_data
                    trust: trust
                    dscp: DSCP value.
                    cos: COS value.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PriorityFlowControl(AvdModel):
            class PrioritiesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "priority": {"type": int}, "no_drop": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "priority")
                _custom_data: dict[str, Any]
                priority: int
                no_drop: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    priority: int | UndefinedType = Undefined,
                    no_drop: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrioritiesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        priority: priority
                        no_drop: no_drop

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Priorities(AvdCollection[int, PrioritiesItem]):
                _primary_key: ClassVar[str] = "priority"

            Priorities._item_type = PrioritiesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "priorities": {"type": Priorities}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            priorities: Priorities

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                priorities: Priorities | UndefinedType = Undefined,
            ) -> None:
                """
                PriorityFlowControl.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    priorities: priorities

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bfd(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            echo: bool | None
            interval: int | None
            """Interval in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                echo: bool | None | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                min_rx: int | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Bfd.

                Args:
                -----
                    _custom_data: _custom_data
                    echo: echo
                    interval: Interval in milliseconds.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdModel):
            class Pbr(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                input: str | None
                """Policy Based Routing Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, input: str | None | UndefinedType = Undefined) -> None:
                    """
                    Pbr.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Policy Based Routing Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Qos(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "input")
                _custom_data: dict[str, Any]
                input: str
                """Quality of Service Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, input: str | UndefinedType = Undefined) -> None:
                    """
                    Qos.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Quality of Service Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pbr": {"type": Pbr}, "qos": {"type": Qos}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            pbr: Pbr
            qos: Qos

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined
            ) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    pbr: pbr
                    qos: qos

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mpls(AvdModel):
            class Ldp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": bool}, "igp_sync": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interface: bool | None
                igp_sync: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interface: bool | None | UndefinedType = Undefined,
                    igp_sync: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ldp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface
                        igp_sync: igp_sync

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip": {"type": bool}, "ldp": {"type": Ldp}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ip: bool | None
            ldp: Ldp

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip: bool | None | UndefinedType = Undefined,
                ldp: Ldp | UndefinedType = Undefined,
            ) -> None:
                """
                Mpls.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: ip
                    ldp: ldp

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LacpTimer(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "multiplier": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mode: str | None
            multiplier: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                LacpTimer.

                Args:
                -----
                    _custom_data: _custom_data
                    mode: mode
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Transceiver(AvdModel):
            class Media(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "override": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                override: str | None
                """Transceiver type."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, override: str | None | UndefinedType = Undefined) -> None:
                    """
                    Media.

                    Args:
                    -----
                        _custom_data: _custom_data
                        override: Transceiver type.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "frequency": {"type": str}, "frequency_unit": {"type": str}, "media": {"type": Media}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            frequency: str | None
            """Transceiver Laser Frequency in GHz (min 190000, max 200000)."""
            frequency_unit: str | None
            """Unit of Transceiver Laser Frequency."""
            media: Media

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                frequency: str | None | UndefinedType = Undefined,
                frequency_unit: str | None | UndefinedType = Undefined,
                media: Media | UndefinedType = Undefined,
            ) -> None:
                """
                Transceiver.

                Args:
                -----
                    _custom_data: _custom_data
                    frequency: Transceiver Laser Frequency in GHz (min 190000, max 200000).
                    frequency_unit: Unit of Transceiver Laser Frequency.
                    media: media

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TrafficPolicy(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}, "output": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            input: str | None
            """Ingress traffic policy."""
            output: str | None
            """Egress traffic policy."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                input: str | None | UndefinedType = Undefined,
                output: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TrafficPolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    input: Ingress traffic policy.
                    output: Egress traffic policy.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "session_tracker": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            session_tracker: str | None
            """Name of session tracker."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, session_tracker: str | None | UndefinedType = Undefined) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    session_tracker: Name of session tracker.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpIgmpHostProxy(AvdModel):
            class GroupsItem(AvdModel):
                class ExcludeItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source")
                    _custom_data: dict[str, Any]
                    source: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source: str | UndefinedType = Undefined) -> None:
                        """
                        ExcludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Exclude(AvdCollection[str, ExcludeItem]):
                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source")
                    _custom_data: dict[str, Any]
                    source: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source: str | UndefinedType = Undefined) -> None:
                        """
                        IncludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Include(AvdCollection[str, IncludeItem]):
                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "group")
                _custom_data: dict[str, Any]
                group: str
                """Multicast Address."""
                exclude: Exclude
                """The same source must not be present both in `exclude` and `include` list."""
                include: Include
                """The same source must not be present both in `exclude` and `include` list."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    group: str | UndefinedType = Undefined,
                    exclude: Exclude | UndefinedType = Undefined,
                    include: Include | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        group: Multicast Address.
                        exclude: The same source must not be present both in `exclude` and `include` list.
                        include: The same source must not be present both in `exclude` and `include` list.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Groups(AvdCollection[str, GroupsItem]):
                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined) -> None:
                    """
                    AccessListsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessLists(AvdCollection[str, AccessListsItem]):
                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            groups: Groups
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """Non-standard Access List name."""
            version: int | None
            """IGMP version on IGMP host-proxy interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                groups: Groups | UndefinedType = Undefined,
                report_interval: int | None | UndefinedType = Undefined,
                access_lists: AccessLists | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpIgmpHostProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    groups: groups
                    report_interval: Time interval between unsolicited reports.
                    access_lists: Non-standard Access List name.
                    version: IGMP version on IGMP host-proxy interface.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sflow(AvdModel):
            class Egress(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "unmodified_enable": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enable: bool | None
                unmodified_enable: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enable: bool | None | UndefinedType = Undefined,
                    unmodified_enable: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Egress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enable: enable
                        unmodified_enable: unmodified_enable

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "egress": {"type": Egress}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enable: bool | None
            egress: Egress

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                egress: Egress | UndefinedType = Undefined,
            ) -> None:
                """
                Sflow.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    egress: egress

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SyncE(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "priority": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enable: bool | None
            priority: str | None
            """
            The priority is used to influence the reference clock selection. The EOS default priority is 127.
            The priority can be configured to any integer between 1-255, or set to `disabled`.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                priority: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                SyncE.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    priority:
                       The priority is used to influence the reference clock selection. The EOS default priority is 127.
                       The priority can be configured to any integer between 1-255, or set to `disabled`.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UcTxQueuesItem(AvdModel):
            class RandomDetect(AvdModel):
                class Ecn(AvdModel):
                    class Threshold(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "units", "min", "max")
                        _custom_data: dict[str, Any]
                        units: str
                        """Indicate the units to be used for the threshold values."""
                        min: int
                        """Set the random-detect ECN minimum-threshold."""
                        max: int
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Set the random-detect ECN max-mark-probability."""
                        weight: int | None
                        """Set the random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            units: str | UndefinedType = Undefined,
                            min: int | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                            max_probability: int | None | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Indicate the units to be used for the threshold values.
                                min: Set the random-detect ECN minimum-threshold.
                                max: Set the random-detect ECN maximum-threshold.
                                max_probability: Set the random-detect ECN max-mark-probability.
                                weight: Set the random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": bool}, "threshold": {"type": Threshold}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: bool | None | UndefinedType = Undefined,
                        threshold: Threshold | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ecn": {"type": Ecn}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ecn: Ecn
                """Explicit Congestion Notification."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ecn: Ecn | UndefinedType = Undefined) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "random_detect": {"type": RandomDetect}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """TX-Queue ID."""
            random_detect: RandomDetect

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                random_detect: RandomDetect | UndefinedType = Undefined,
            ) -> None:
                """
                UcTxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: TX-Queue ID.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UcTxQueues(AvdCollection[int, UcTxQueuesItem]):
            _primary_key: ClassVar[str] = "id"

        UcTxQueues._item_type = UcTxQueuesItem

        class TxQueuesItem(AvdModel):
            class RandomDetect(AvdModel):
                class Ecn(AvdModel):
                    class Threshold(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "units", "max", "max_probability")
                        _custom_data: dict[str, Any]
                        units: str
                        """Indicate the units to be used for the threshold values."""
                        min: int | None
                        """Set the random-detect ECN minimum-threshold."""
                        max: int
                        """Set the random-detect ECN maximum-threshold."""
                        max_probability: int
                        """Set the random-detect ECN max-mark-probability."""
                        weight: int | None
                        """Set the random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            units: str | UndefinedType = Undefined,
                            min: int | None | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                            max_probability: int | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Indicate the units to be used for the threshold values.
                                min: Set the random-detect ECN minimum-threshold.
                                max: Set the random-detect ECN maximum-threshold.
                                max_probability: Set the random-detect ECN max-mark-probability.
                                weight: Set the random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": bool}, "threshold": {"type": Threshold}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: bool | None | UndefinedType = Undefined,
                        threshold: Threshold | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ecn": {"type": Ecn}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ecn: Ecn
                """Explicit Congestion Notification."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ecn: Ecn | UndefinedType = Undefined) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "random_detect": {"type": RandomDetect}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """TX-Queue ID."""
            random_detect: RandomDetect

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                random_detect: RandomDetect | UndefinedType = Undefined,
            ) -> None:
                """
                TxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: TX-Queue ID.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TxQueues(AvdCollection[int, TxQueuesItem]):
            _primary_key: ClassVar[str] = "id"

        TxQueues._item_type = TxQueuesItem

        class VrrpIdsItem(AvdModel):
            class Advertisement(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int | None
                """Interval in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                    """
                    Advertisement.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Preempt(AvdModel):
                class Delay(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "minimum": {"type": int}, "reload": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        minimum: int | None | UndefinedType = Undefined,
                        reload: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            minimum: Minimum preempt delay in seconds.
                            reload: Reload preempt delay in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "delay": {"type": Delay}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                delay: Delay

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    delay: Delay | UndefinedType = Undefined,
                ) -> None:
                    """
                    Preempt.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timers(AvdModel):
                class Delay(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "reload": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    reload: int | None
                    """Delay after reload in seconds."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, reload: int | None | UndefinedType = Undefined) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            reload: Delay after reload in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "delay": {"type": Delay}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                delay: Delay

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, delay: Delay | UndefinedType = Undefined) -> None:
                    """
                    Timers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackedObjectItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    decrement: int | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrackedObjectItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Tracked object name.
                        decrement: Decrement VRRP priority by 1-254.
                        shutdown: shutdown

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackedObject(AvdCollection[str, TrackedObjectItem]):
                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}, "version": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                _custom_data: dict[str, Any]
                address: str
                """Virtual IPv4 address."""
                version: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    address: str | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv4 address.
                        version: version

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                _custom_data: dict[str, Any]
                address: str
                """Virtual IPv6 address."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, address: str | UndefinedType = Undefined) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv6 address.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            preempt: Preempt
            timers: Timers
            tracked_object: TrackedObject
            ipv4: Ipv4
            ipv6: Ipv6

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                priority_level: int | None | UndefinedType = Undefined,
                advertisement: Advertisement | UndefinedType = Undefined,
                preempt: Preempt | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                tracked_object: TrackedObject | UndefinedType = Undefined,
                ipv4: Ipv4 | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
            ) -> None:
                """
                VrrpIdsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: VRID.
                    priority_level: Instance priority.
                    advertisement: advertisement
                    preempt: preempt
                    timers: timers
                    tracked_object: tracked_object
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrrpIds(AvdCollection[int, VrrpIdsItem]):
            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class Switchport(AvdModel):
            class Trunk(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "allowed_vlan": {"type": str},
                    "native_vlan": {"type": int},
                    "native_vlan_tag": {"type": bool},
                    "private_vlan_secondary": {"type": bool},
                    "groups": {"type": list, "items": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                allowed_vlan: str | None
                """
                VLAN ID or range(s) of VLAN IDs.
                Warning: This should not be combined with
                `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                """
                native_vlan: int | None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `ethernet_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                """
                groups: list[str]
                """Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    allowed_vlan: str | None | UndefinedType = Undefined,
                    native_vlan: int | None | UndefinedType = Undefined,
                    native_vlan_tag: bool | None | UndefinedType = Undefined,
                    private_vlan_secondary: bool | None | UndefinedType = Undefined,
                    groups: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Trunk.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allowed_vlan:
                           VLAN ID or range(s) of VLAN IDs.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].mode = trunk` and `ethernet_interface[].vlans`.
                        native_vlan:
                           Set native VLAN when interface is in trunking mode.
                           Warning: This should not be combined with
                           `ethernet_interfaces[].native_vlan`.
                        native_vlan_tag:
                           If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                           Warning: This
                           should not be combined with `ethernet_interfaces[].native_vlan_tag`.
                        private_vlan_secondary:
                           Enable secondary VLAN mapping for a private vlan.
                           Warning: This should not be combined with
                           `ethernet_ineterfaces[].trunk_private_vlan_secondary`.
                        groups: Warning: This should not be combined with `ethernet_ineterfaces[].trunk_groups`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Phone(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "trunk": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                vlan: int | None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`."""
                trunk: str | None
                """Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    trunk: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.

                    Args:
                    -----
                        _custom_data: _custom_data
                        vlan: Warning: This should not be combined with `ethernet_interfaces[].phone.vlan`.
                        trunk: Warning: This should not be combined with `ethernet_interfaces[].phone.trunk`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Dot1q(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ethertype": {"type": int}, "vlan_tag": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ethertype: int | None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: str | None
                """Allow/disallow VLAN tagged frames."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ethertype: int | None | UndefinedType = Undefined,
                    vlan_tag: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dot1q.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                        vlan_tag: Allow/disallow VLAN tagged frames.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class VlanTranslations(AvdModel):
                class DirectionInItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "field_from": {"type": str, "key": "from"},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "field_from", "to")
                    _custom_data: dict[str, Any]
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | UndefinedType = Undefined,
                        to: int | UndefinedType = Undefined,
                        dot1q_tunnel: bool | None | UndefinedType = Undefined,
                        inner_vlan_from: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionInItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOutItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "field_from": {"type": str, "key": "from"},
                        "to": {"type": int},
                        "dot1q_tunnel_to": {"type": str},
                        "inner_vlan_to": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "field_from")
                    _custom_data: dict[str, Any]
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: int | None
                    """Inner VLAN ID to map to."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | UndefinedType = Undefined,
                        to: int | None | UndefinedType = Undefined,
                        dot1q_tunnel_to: str | None | UndefinedType = Undefined,
                        inner_vlan_to: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionOutItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel_to:
                               VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                               This takes precedence over `to` and
                               `inner_vlan_to`.
                            inner_vlan_to: Inner VLAN ID to map to.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionBothItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "field_from": {"type": str, "key": "from"},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "network": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "field_from", "to")
                    _custom_data: dict[str, Any]
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    network: bool | None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | UndefinedType = Undefined,
                        to: int | UndefinedType = Undefined,
                        dot1q_tunnel: bool | None | UndefinedType = Undefined,
                        inner_vlan_from: int | None | UndefinedType = Undefined,
                        network: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionBothItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.
                            network:
                               Enable use of network-side VLAN ID.
                               This setting can only be enabled when `inner_vlan_from` is
                               defined.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "in_required": {"type": bool},
                    "out_required": {"type": bool},
                    "direction_in": {"type": list, "items": DirectionInItem},
                    "direction_out": {"type": list, "items": DirectionOutItem},
                    "direction_both": {"type": list, "items": DirectionBothItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                in_required: bool | None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: list[DirectionInItem]
                """Map ingress traffic only."""
                direction_out: list[DirectionOutItem]
                """Map egress traffic only."""
                direction_both: list[DirectionBothItem]
                """Map both egress and ingress traffic."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    in_required: bool | None | UndefinedType = Undefined,
                    out_required: bool | None | UndefinedType = Undefined,
                    direction_in: list[DirectionInItem] | UndefinedType = Undefined,
                    direction_out: list[DirectionOutItem] | UndefinedType = Undefined,
                    direction_both: list[DirectionBothItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanTranslations.

                    Args:
                    -----
                        _custom_data: _custom_data
                        in_required: Drop the ingress traffic that do not match any VLAN mapping.
                        out_required: Drop the egress traffic that do not match any VLAN mapping.
                        direction_in: Map ingress traffic only.
                        direction_out: Map egress traffic only.
                        direction_both: Map both egress and ingress traffic.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BackupLink(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": str}, "prefer_vlan": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interface: str | None
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None
                """VLANs to carry on the backup interface (1-4094)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interface: str | None | UndefinedType = Undefined,
                    prefer_vlan: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    BackupLink.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                        prefer_vlan: VLANs to carry on the backup interface (1-4094).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Backup(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "dest_macaddr": {"type": str},
                    "initial_mac_move_delay": {"type": int},
                    "mac_move_burst": {"type": int},
                    "mac_move_burst_interval": {"type": int},
                    "preemption_delay": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dest_macaddr: str | None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: int | None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: int | None
                """Size of MAC move bursts."""
                mac_move_burst_interval: int | None
                """MAC move burst interval in milliseconds."""
                preemption_delay: int | None
                """Preemption delay in milliseconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dest_macaddr: str | None | UndefinedType = Undefined,
                    initial_mac_move_delay: int | None | UndefinedType = Undefined,
                    mac_move_burst: int | None | UndefinedType = Undefined,
                    mac_move_burst_interval: int | None | UndefinedType = Undefined,
                    preemption_delay: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Backup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dest_macaddr:
                           Destination MAC address for MAC move updates.
                           The mac address should be multicast or broadcast.
                           Example: 01:00:00:00:00:00
                        initial_mac_move_delay: Initial MAC move delay in milliseconds.
                        mac_move_burst: Size of MAC move bursts.
                        mac_move_burst_interval: MAC move burst interval in milliseconds.
                        preemption_delay: Preemption delay in milliseconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortSecurity(AvdModel):
                class MacAddressMaximum(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "disabled": {"type": bool}, "limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    disabled: bool | None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: int | None
                    """MAC address limit."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        disabled: bool | None | UndefinedType = Undefined,
                        limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MacAddressMaximum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                            limit: MAC address limit.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Violation(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "protect_log": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    mode: str | None
                    """Configure port security mode."""
                    protect_log: bool | None
                    """Log new addresses seen after limit is reached in protect mode."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        mode: str | None | UndefinedType = Undefined,
                        protect_log: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Violation.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: Configure port security mode.
                            protect_log: Log new addresses seen after limit is reached in protect mode.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "range": {"type": str}, "mac_address_maximum": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "range", "mac_address_maximum")
                    _custom_data: dict[str, Any]
                    range: str
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        range: str | UndefinedType = Undefined,
                        mac_address_maximum: int | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            range:
                               VLAN ID or range(s) of VLAN IDs, <1-4094>.

                        Example:
                                 - 3
                                 - 1,3
                                 - 1-10
                            mac_address_maximum: mac_address_maximum

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vlans(AvdCollection[str, VlansItem]):
                    _primary_key: ClassVar[str] = "range"

                Vlans._item_type = VlansItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "mac_address_maximum": {"type": MacAddressMaximum},
                    "violation": {"type": Violation},
                    "vlan_default_mac_address_maximum": {"type": int},
                    "vlans": {"type": Vlans},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                mac_address_maximum: MacAddressMaximum
                """Maximum number of MAC addresses allowed on the interface."""
                violation: Violation
                """Configure violation mode (shutdown or protect), EOS default is 'shutdown'."""
                vlan_default_mac_address_maximum: int | None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: Vlans

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    mac_address_maximum: MacAddressMaximum | UndefinedType = Undefined,
                    violation: Violation | UndefinedType = Undefined,
                    vlan_default_mac_address_maximum: int | None | UndefinedType = Undefined,
                    vlans: Vlans | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortSecurity.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        mac_address_maximum: Maximum number of MAC addresses allowed on the interface.
                        violation: Configure violation mode (shutdown or protect), EOS default is 'shutdown'.
                        vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                        vlans: vlans

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "mode": {"type": str},
                "access_vlan": {"type": int},
                "trunk": {"type": Trunk},
                "phone": {"type": Phone},
                "pvlan_mapping": {"type": str},
                "dot1q": {"type": Dot1q},
                "source_interface": {"type": str},
                "vlan_translations": {"type": VlanTranslations},
                "vlan_forwarding_accept_all": {"type": bool},
                "backup_link": {"type": BackupLink},
                "backup": {"type": Backup},
                "port_security": {"type": PortSecurity},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            """Warning: This should not be combined with `ethernet_interfaces[].type = routed`."""
            mode: str | None
            """Warning: This should not be combined with `ethernet_interfaces[].mode`."""
            access_vlan: int | None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
            """
            trunk: Trunk
            phone: Phone
            """Warning: This should not be combined with `ethernet_interfaces[].phone`."""
            pvlan_mapping: str | None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `ethernet_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q
            source_interface: str | None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `ethernet_interfaces[].vlan_translations`.
            """
            vlan_forwarding_accept_all: bool | None
            backup_link: BackupLink
            backup: Backup
            """The `backup_link` is required for this setting."""
            port_security: PortSecurity

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                access_vlan: int | None | UndefinedType = Undefined,
                trunk: Trunk | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                dot1q: Dot1q | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vlan_translations: VlanTranslations | UndefinedType = Undefined,
                vlan_forwarding_accept_all: bool | None | UndefinedType = Undefined,
                backup_link: BackupLink | UndefinedType = Undefined,
                backup: Backup | UndefinedType = Undefined,
                port_security: PortSecurity | UndefinedType = Undefined,
            ) -> None:
                """
                Switchport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Warning: This should not be combined with `ethernet_interfaces[].type = routed`.
                    mode: Warning: This should not be combined with `ethernet_interfaces[].mode`.
                    access_vlan:
                       Set VLAN when interface is in access mode.
                       Warning: This should not be combined with
                       `ethernet_interfaces[].mode = access/dot1q-tunnel` and `ethernet_interface[].vlans`.
                    trunk: trunk
                    phone: Warning: This should not be combined with `ethernet_interfaces[].phone`.
                    pvlan_mapping:
                       Secondary VLAN IDs of the private VLAN mapping.
                       Warning: This should not be combined with
                       `ethernet_interfaces[].pvlan_mapping`.
                    dot1q: dot1q
                    source_interface:
                       tx: Allow bridged traffic to go out of the source interface.
                       tx multicast: Allow multicast traffic
                       only to go out of the source interface.
                    vlan_translations:
                       VLAN Translation mappings.
                       Warning: This should not be combined with
                       `ethernet_interfaces[].vlan_translations`.
                    vlan_forwarding_accept_all: vlan_forwarding_accept_all
                    backup_link: backup_link
                    backup: The `backup_link` is required for this setting.
                    port_security: port_security

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "load_interval": {"type": int},
            "speed": {"type": str},
            "mtu": {"type": int},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "vlans": {"type": str},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool},
            "mode": {"type": str},
            "phone": {"type": Phone},
            "l2_protocol": {"type": L2Protocol},
            "trunk_groups": {"type": list, "items": str},
            "type": {"type": str},
            "snmp_trap_link_change": {"type": bool},
            "address_locking": {"type": AddressLocking},
            "flowcontrol": {"type": Flowcontrol},
            "vrf": {"type": str},
            "flow_tracker": {"type": FlowTracker},
            "error_correction_encoding": {"type": ErrorCorrectionEncoding},
            "link_tracking_groups": {"type": LinkTrackingGroups},
            "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
            "encapsulation_dot1q_vlan": {"type": int},
            "encapsulation_dot1q": {"type": EncapsulationDot1q},
            "encapsulation_vlan": {"type": EncapsulationVlan},
            "vlan_id": {"type": int},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": list, "items": str},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "dhcp_client_accept_default_route": {"type": bool},
            "dhcp_server_ipv4": {"type": bool},
            "dhcp_server_ipv6": {"type": bool},
            "ip_helpers": {"type": IpHelpers},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "ipv6_dhcp_relay_destinations": {"type": Ipv6DhcpRelayDestinations},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "mac_access_group_in": {"type": str},
            "mac_access_group_out": {"type": str},
            "multicast": {"type": Multicast},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "pim": {"type": Pim},
            "mac_security": {"type": MacSecurity},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "channel_group": {"type": ChannelGroup},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_circuit_type": {"type": str},
            "isis_hello_padding": {"type": bool},
            "isis_authentication_mode": {"type": str},
            "isis_authentication_key": {"type": str},
            "poe": {"type": Poe},
            "ptp": {"type": Ptp},
            "profile": {"type": str},
            "storm_control": {"type": StormControl},
            "logging": {"type": Logging},
            "lldp": {"type": Lldp},
            "trunk_private_vlan_secondary": {"type": bool},
            "pvlan_mapping": {"type": str},
            "vlan_translations": {"type": list, "items": VlanTranslationsItem},
            "dot1x": {"type": Dot1x},
            "service_profile": {"type": str},
            "shape": {"type": Shape},
            "qos": {"type": Qos},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "spanning_tree_guard": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "vmtracer": {"type": bool},
            "priority_flow_control": {"type": PriorityFlowControl},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "mpls": {"type": Mpls},
            "lacp_timer": {"type": LacpTimer},
            "lacp_port_priority": {"type": int},
            "transceiver": {"type": Transceiver},
            "ip_proxy_arp": {"type": bool},
            "traffic_policy": {"type": TrafficPolicy},
            "bgp": {"type": Bgp},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_type": {"type": str},
            "sflow": {"type": Sflow},
            "sync_e": {"type": SyncE},
            "port_profile": {"type": str},
            "uc_tx_queues": {"type": UcTxQueues},
            "tx_queues": {"type": TxQueues},
            "vrrp_ids": {"type": VrrpIds},
            "validate_state": {"type": bool},
            "switchport": {"type": Switchport},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        description: str | None
        shutdown: bool | None
        load_interval: int | None
        """Interval in seconds for updating interface counters."""
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None
        l2_mtu: int | None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: int | None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        native_vlan: int | None
        native_vlan_tag: bool | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        mode: str | None
        phone: Phone
        l2_protocol: L2Protocol
        trunk_groups: list[str]
        type: str | None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        The `type = switched/routed` should not be combined with `switchport`.
        """
        snmp_trap_link_change: bool | None
        address_locking: AddressLocking
        flowcontrol: Flowcontrol
        vrf: str | None
        """VRF name."""
        flow_tracker: FlowTracker
        error_correction_encoding: ErrorCorrectionEncoding
        link_tracking_groups: LinkTrackingGroups
        evpn_ethernet_segment: EvpnEthernetSegment
        encapsulation_dot1q_vlan: int | None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.
        """
        encapsulation_vlan: EncapsulationVlan
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        """
        vlan_id: int | None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        ip_address: str | None
        """IPv4 address/mask or "dhcp"."""
        ip_address_secondaries: list[str]
        ip_verify_unicast_source_reachable_via: str | None
        dhcp_client_accept_default_route: bool | None
        """Install default-route obtained via DHCP."""
        dhcp_server_ipv4: bool | None
        """Enable IPv4 DHCP server."""
        dhcp_server_ipv6: bool | None
        """Enable IPv6 DHCP server."""
        ip_helpers: IpHelpers
        ip_nat: IpNat
        ipv6_enable: bool | None
        ipv6_address: str | None
        ipv6_address_link_local: str | None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_prefixes: Ipv6NdPrefixes
        ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations
        access_group_in: str | None
        """Access list name."""
        access_group_out: str | None
        """Access list name."""
        ipv6_access_group_in: str | None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None
        """IPv6 access list name."""
        mac_access_group_in: str | None
        """MAC access list name."""
        mac_access_group_out: str | None
        """MAC access list name."""
        multicast: Multicast
        """
        Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
        of both.
        """
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: str | None
        ospf_authentication_key: str | None
        """Encrypted password - only type 7 supported."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        pim: Pim
        mac_security: MacSecurity
        tcp_mss_ceiling: TcpMssCeiling
        """
        The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
        of
        TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.
        """
        channel_group: ChannelGroup
        isis_enable: str | None
        """ISIS instance."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_circuit_type: str | None
        isis_hello_padding: bool | None
        isis_authentication_mode: str | None
        isis_authentication_key: str | None
        """Type-7 encrypted password."""
        poe: Poe
        ptp: Ptp
        profile: str | None
        """Interface profile."""
        storm_control: StormControl
        logging: Logging
        lldp: Lldp
        trunk_private_vlan_secondary: bool | None
        pvlan_mapping: str | None
        """List of vlans as string."""
        vlan_translations: list[VlanTranslationsItem]
        dot1x: Dot1x
        service_profile: str | None
        """QOS profile."""
        shape: Shape
        qos: Qos
        spanning_tree_bpdufilter: str | None
        spanning_tree_bpduguard: str | None
        spanning_tree_guard: str | None
        spanning_tree_portfast: str | None
        vmtracer: bool | None
        priority_flow_control: PriorityFlowControl
        bfd: Bfd
        service_policy: ServicePolicy
        mpls: Mpls
        lacp_timer: LacpTimer
        lacp_port_priority: int | None
        transceiver: Transceiver
        ip_proxy_arp: bool | None
        traffic_policy: TrafficPolicy
        bgp: Bgp
        ip_igmp_host_proxy: IpIgmpHostProxy
        peer: str | None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow
        sync_e: SyncE
        port_profile: str | None
        """Key only used for documentation or validation purposes."""
        uc_tx_queues: UcTxQueues
        tx_queues: TxQueues
        vrrp_ids: VrrpIds
        """VRRP model."""
        validate_state: bool | None
        """Set to false to disable interface validation by the `eos_validate_state` role."""
        switchport: Switchport
        """This should not be combined with `ethernet_interfaces[].type = switched/routed`."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            load_interval: int | None | UndefinedType = Undefined,
            speed: str | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            l2_mtu: int | None | UndefinedType = Undefined,
            l2_mru: int | None | UndefinedType = Undefined,
            vlans: str | None | UndefinedType = Undefined,
            native_vlan: int | None | UndefinedType = Undefined,
            native_vlan_tag: bool | None | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            phone: Phone | UndefinedType = Undefined,
            l2_protocol: L2Protocol | UndefinedType = Undefined,
            trunk_groups: list[str] | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            snmp_trap_link_change: bool | None | UndefinedType = Undefined,
            address_locking: AddressLocking | UndefinedType = Undefined,
            flowcontrol: Flowcontrol | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            flow_tracker: FlowTracker | UndefinedType = Undefined,
            error_correction_encoding: ErrorCorrectionEncoding | UndefinedType = Undefined,
            link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
            evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
            encapsulation_dot1q: EncapsulationDot1q | UndefinedType = Undefined,
            encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
            vlan_id: int | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ip_address_secondaries: list[str] | UndefinedType = Undefined,
            ip_verify_unicast_source_reachable_via: str | None | UndefinedType = Undefined,
            dhcp_client_accept_default_route: bool | None | UndefinedType = Undefined,
            dhcp_server_ipv4: bool | None | UndefinedType = Undefined,
            dhcp_server_ipv6: bool | None | UndefinedType = Undefined,
            ip_helpers: IpHelpers | UndefinedType = Undefined,
            ip_nat: IpNat | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            ipv6_address_link_local: str | None | UndefinedType = Undefined,
            ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
            ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
            ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
            ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations | UndefinedType = Undefined,
            access_group_in: str | None | UndefinedType = Undefined,
            access_group_out: str | None | UndefinedType = Undefined,
            ipv6_access_group_in: str | None | UndefinedType = Undefined,
            ipv6_access_group_out: str | None | UndefinedType = Undefined,
            mac_access_group_in: str | None | UndefinedType = Undefined,
            mac_access_group_out: str | None | UndefinedType = Undefined,
            multicast: Multicast | UndefinedType = Undefined,
            ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
            ospf_area: str | None | UndefinedType = Undefined,
            ospf_cost: int | None | UndefinedType = Undefined,
            ospf_authentication: str | None | UndefinedType = Undefined,
            ospf_authentication_key: str | None | UndefinedType = Undefined,
            ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
            pim: Pim | UndefinedType = Undefined,
            mac_security: MacSecurity | UndefinedType = Undefined,
            tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
            channel_group: ChannelGroup | UndefinedType = Undefined,
            isis_enable: str | None | UndefinedType = Undefined,
            isis_bfd: bool | None | UndefinedType = Undefined,
            isis_passive: bool | None | UndefinedType = Undefined,
            isis_metric: int | None | UndefinedType = Undefined,
            isis_network_point_to_point: bool | None | UndefinedType = Undefined,
            isis_circuit_type: str | None | UndefinedType = Undefined,
            isis_hello_padding: bool | None | UndefinedType = Undefined,
            isis_authentication_mode: str | None | UndefinedType = Undefined,
            isis_authentication_key: str | None | UndefinedType = Undefined,
            poe: Poe | UndefinedType = Undefined,
            ptp: Ptp | UndefinedType = Undefined,
            profile: str | None | UndefinedType = Undefined,
            storm_control: StormControl | UndefinedType = Undefined,
            logging: Logging | UndefinedType = Undefined,
            lldp: Lldp | UndefinedType = Undefined,
            trunk_private_vlan_secondary: bool | None | UndefinedType = Undefined,
            pvlan_mapping: str | None | UndefinedType = Undefined,
            vlan_translations: list[VlanTranslationsItem] | UndefinedType = Undefined,
            dot1x: Dot1x | UndefinedType = Undefined,
            service_profile: str | None | UndefinedType = Undefined,
            shape: Shape | UndefinedType = Undefined,
            qos: Qos | UndefinedType = Undefined,
            spanning_tree_bpdufilter: str | None | UndefinedType = Undefined,
            spanning_tree_bpduguard: str | None | UndefinedType = Undefined,
            spanning_tree_guard: str | None | UndefinedType = Undefined,
            spanning_tree_portfast: str | None | UndefinedType = Undefined,
            vmtracer: bool | None | UndefinedType = Undefined,
            priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
            bfd: Bfd | UndefinedType = Undefined,
            service_policy: ServicePolicy | UndefinedType = Undefined,
            mpls: Mpls | UndefinedType = Undefined,
            lacp_timer: LacpTimer | UndefinedType = Undefined,
            lacp_port_priority: int | None | UndefinedType = Undefined,
            transceiver: Transceiver | UndefinedType = Undefined,
            ip_proxy_arp: bool | None | UndefinedType = Undefined,
            traffic_policy: TrafficPolicy | UndefinedType = Undefined,
            bgp: Bgp | UndefinedType = Undefined,
            ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
            peer: str | None | UndefinedType = Undefined,
            peer_interface: str | None | UndefinedType = Undefined,
            peer_type: str | None | UndefinedType = Undefined,
            sflow: Sflow | UndefinedType = Undefined,
            sync_e: SyncE | UndefinedType = Undefined,
            port_profile: str | None | UndefinedType = Undefined,
            uc_tx_queues: UcTxQueues | UndefinedType = Undefined,
            tx_queues: TxQueues | UndefinedType = Undefined,
            vrrp_ids: VrrpIds | UndefinedType = Undefined,
            validate_state: bool | None | UndefinedType = Undefined,
            switchport: Switchport | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            EthernetInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                description: description
                shutdown: shutdown
                load_interval: Interval in seconds for updating interface counters.
                speed:
                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                mtu: mtu
                l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                vlans:
                   List of switchport vlans as string.
                   For a trunk port this would be a range like "1-200,300".
                   For an
                   access port this would be a single vlan "123".
                native_vlan: native_vlan
                native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                mode: mode
                phone: phone
                l2_protocol: l2_protocol
                trunk_groups: trunk_groups
                type:
                   l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                   The `type = switched/routed` should not be combined with `switchport`.
                snmp_trap_link_change: snmp_trap_link_change
                address_locking: address_locking
                flowcontrol: flowcontrol
                vrf: VRF name.
                flow_tracker: flow_tracker
                error_correction_encoding: error_correction_encoding
                link_tracking_groups: link_tracking_groups
                evpn_ethernet_segment: evpn_ethernet_segment
                encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                encapsulation_dot1q:
                   Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                   `ethernet_interfaces[].type: l2dot1q`.
                encapsulation_vlan:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `encapsulation_vlan` should not
                   be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                vlan_id:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `vlan_id` should not be combined
                   with `ethernet_interfaces[].type == l2dot1q`.
                ip_address: IPv4 address/mask or "dhcp".
                ip_address_secondaries: ip_address_secondaries
                ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                dhcp_client_accept_default_route: Install default-route obtained via DHCP.
                dhcp_server_ipv4: Enable IPv4 DHCP server.
                dhcp_server_ipv6: Enable IPv6 DHCP server.
                ip_helpers: ip_helpers
                ip_nat: ip_nat
                ipv6_enable: ipv6_enable
                ipv6_address: ipv6_address
                ipv6_address_link_local: Link local IPv6 address/mask.
                ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                ipv6_nd_prefixes: ipv6_nd_prefixes
                ipv6_dhcp_relay_destinations: ipv6_dhcp_relay_destinations
                access_group_in: Access list name.
                access_group_out: Access list name.
                ipv6_access_group_in: IPv6 access list name.
                ipv6_access_group_out: IPv6 access list name.
                mac_access_group_in: MAC access list name.
                mac_access_group_out: MAC access list name.
                multicast:
                   Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                   of both.
                ospf_network_point_to_point: ospf_network_point_to_point
                ospf_area: ospf_area
                ospf_cost: ospf_cost
                ospf_authentication: ospf_authentication
                ospf_authentication_key: Encrypted password - only type 7 supported.
                ospf_message_digest_keys: ospf_message_digest_keys
                pim: pim
                mac_security: mac_security
                tcp_mss_ceiling:
                   The TCP MSS clamping feature involves clamping the maximum segment size (MSS) in the TCP header
                   of
                   TCP SYN packets if it exceeds the configured MSS ceiling limit for the interface.
                channel_group: channel_group
                isis_enable: ISIS instance.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                isis_circuit_type: isis_circuit_type
                isis_hello_padding: isis_hello_padding
                isis_authentication_mode: isis_authentication_mode
                isis_authentication_key: Type-7 encrypted password.
                poe: poe
                ptp: ptp
                profile: Interface profile.
                storm_control: storm_control
                logging: logging
                lldp: lldp
                trunk_private_vlan_secondary: trunk_private_vlan_secondary
                pvlan_mapping: List of vlans as string.
                vlan_translations: vlan_translations
                dot1x: dot1x
                service_profile: QOS profile.
                shape: shape
                qos: qos
                spanning_tree_bpdufilter: spanning_tree_bpdufilter
                spanning_tree_bpduguard: spanning_tree_bpduguard
                spanning_tree_guard: spanning_tree_guard
                spanning_tree_portfast: spanning_tree_portfast
                vmtracer: vmtracer
                priority_flow_control: priority_flow_control
                bfd: bfd
                service_policy: service_policy
                mpls: mpls
                lacp_timer: lacp_timer
                lacp_port_priority: lacp_port_priority
                transceiver: transceiver
                ip_proxy_arp: ip_proxy_arp
                traffic_policy: traffic_policy
                bgp: bgp
                ip_igmp_host_proxy: ip_igmp_host_proxy
                peer: Key only used for documentation or validation purposes.
                peer_interface: Key only used for documentation or validation purposes.
                peer_type: Key only used for documentation or validation purposes.
                sflow: sflow
                sync_e: sync_e
                port_profile: Key only used for documentation or validation purposes.
                uc_tx_queues: uc_tx_queues
                tx_queues: tx_queues
                vrrp_ids: VRRP model.
                validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                switchport: This should not be combined with `ethernet_interfaces[].type = switched/routed`.
                eos_cli: Multiline EOS CLI rendered directly on the ethernet interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EthernetInterfaces(AvdCollection[str, EthernetInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    EthernetInterfaces._item_type = EthernetInterfacesItem

    class EventHandlersItem(AvdModel):
        class Actions(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bash_command": {"type": str},
                "log": {"type": bool},
                "increment_device_health_metric": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bash_command: str | None
            """Define BASH command action. Command could be multiline also."""
            log: bool | None
            """Log a message when the event is triggered."""
            increment_device_health_metric: str | None
            """Name of device-health metric."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bash_command: str | None | UndefinedType = Undefined,
                log: bool | None | UndefinedType = Undefined,
                increment_device_health_metric: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Actions.

                Args:
                -----
                    _custom_data: _custom_data
                    bash_command: Define BASH command action. Command could be multiline also.
                    log: Log a message when the event is triggered.
                    increment_device_health_metric: Name of device-health metric.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnCounters(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "condition": {"type": str},
                "granularity_per_source": {"type": bool},
                "poll_interval": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            condition: str | None
            """Set the logical expression to evaluate."""
            granularity_per_source: bool | None
            """
            Set the granularity of event counting for a wildcarded condition.
            Example -
              condition (
            Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
              [* wildcard is used
            here]
            """
            poll_interval: int | None
            """Set the polling interval in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                condition: str | None | UndefinedType = Undefined,
                granularity_per_source: bool | None | UndefinedType = Undefined,
                poll_interval: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnCounters.

                Args:
                -----
                    _custom_data: _custom_data
                    condition: Set the logical expression to evaluate.
                    granularity_per_source:
                       Set the granularity of event counting for a wildcarded condition.
                       Example -
                         condition (
                       Arad*.IptCrcErrCnt.delta > 100 ) and ( Arad*.UcFifoFullDrop.delta > 100 )
                         [* wildcard is used
                       here]
                    poll_interval: Set the polling interval in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnLogging(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "poll_interval": {"type": int}, "regex": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            poll_interval: int | None
            """Set the polling interval in seconds."""
            regex: str | None
            """Regular expression to use for searching log messages."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                poll_interval: int | None | UndefinedType = Undefined,
                regex: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnLogging.

                Args:
                -----
                    _custom_data: _custom_data
                    poll_interval: Set the polling interval in seconds.
                    regex: Regular expression to use for searching log messages.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnIntf(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "interface": {"type": str},
                "ip": {"type": bool},
                "ipv6": {"type": bool},
                "operstatus": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "interface")
            _custom_data: dict[str, Any]
            interface: str
            """
            Interface name.
            Example - Ethernet4
                      Loopback4-6
                      Port-channel4,7
            """
            ip: bool | None
            """Action is triggered upon changes to interface IP address assignment."""
            ipv6: bool | None
            """Action is triggered upon changes to interface ipv6 address assignment."""
            operstatus: bool | None
            """Action is triggered upon changes to interface operStatus."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interface: str | UndefinedType = Undefined,
                ip: bool | None | UndefinedType = Undefined,
                ipv6: bool | None | UndefinedType = Undefined,
                operstatus: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnIntf.

                Args:
                -----
                    _custom_data: _custom_data
                    interface:
                       Interface name.
                       Example - Ethernet4
                                 Loopback4-6
                                 Port-channel4,7
                    ip: Action is triggered upon changes to interface IP address assignment.
                    ipv6: Action is triggered upon changes to interface ipv6 address assignment.
                    operstatus: Action is triggered upon changes to interface operStatus.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TriggerOnMaintenance(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "operation": {"type": str},
                "bgp_peer": {"type": str},
                "action": {"type": str},
                "stage": {"type": str},
                "vrf": {"type": str},
                "interface": {"type": str},
                "unit": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "operation", "action")
            _custom_data: dict[str, Any]
            operation: str
            bgp_peer: str | None
            """
            Ipv4/Ipv6 address or peer group name.
            Trigger condition occurs on maintenance operation of specified
            BGP peer.
            """
            action: str
            """Action for maintenance operation."""
            stage: str | None
            """Action is triggered after/before specified stage."""
            vrf: str | None
            """VRF name. VRF can be defined for "bgp_peer" only."""
            interface: str | None
            """Trigger condition occurs on maintenance operation of specified interface."""
            unit: str | None
            """Name of unit. Trigger condition occurs on maintenance operation of specified unit"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                operation: str | UndefinedType = Undefined,
                bgp_peer: str | None | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
                stage: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                interface: str | None | UndefinedType = Undefined,
                unit: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TriggerOnMaintenance.

                Args:
                -----
                    _custom_data: _custom_data
                    operation: operation
                    bgp_peer:
                       Ipv4/Ipv6 address or peer group name.
                       Trigger condition occurs on maintenance operation of specified
                       BGP peer.
                    action: Action for maintenance operation.
                    stage: Action is triggered after/before specified stage.
                    vrf: VRF name. VRF can be defined for "bgp_peer" only.
                    interface: Trigger condition occurs on maintenance operation of specified interface.
                    unit: Name of unit. Trigger condition occurs on maintenance operation of specified unit

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "actions": {"type": Actions},
            "delay": {"type": int},
            "trigger": {"type": str},
            "trigger_on_counters": {"type": TriggerOnCounters},
            "trigger_on_logging": {"type": TriggerOnLogging},
            "trigger_on_intf": {"type": TriggerOnIntf},
            "trigger_on_maintenance": {"type": TriggerOnMaintenance},
            "asynchronous": {"type": bool, "default": False},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Event Handler Name."""
        actions: Actions
        """Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`."""
        delay: int | None
        """Event-handler delay in seconds."""
        trigger: str | None
        """Configure event trigger condition."""
        trigger_on_counters: TriggerOnCounters
        trigger_on_logging: TriggerOnLogging
        trigger_on_intf: TriggerOnIntf
        """
        Trigger condition occurs on specified interface changes.
        Note: Any one of the `ip`, `ipv6` and
        `operstatus` key needs to be defined along with the `interface`.
        """
        trigger_on_maintenance: TriggerOnMaintenance
        """Settings required for trigger 'on-maintenance'."""
        asynchronous: bool | None
        """Set the action to be non-blocking."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            actions: Actions | UndefinedType = Undefined,
            delay: int | None | UndefinedType = Undefined,
            trigger: str | None | UndefinedType = Undefined,
            trigger_on_counters: TriggerOnCounters | UndefinedType = Undefined,
            trigger_on_logging: TriggerOnLogging | UndefinedType = Undefined,
            trigger_on_intf: TriggerOnIntf | UndefinedType = Undefined,
            trigger_on_maintenance: TriggerOnMaintenance | UndefinedType = Undefined,
            asynchronous: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            EventHandlersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Event Handler Name.
                actions: Note: `bash_command` and `log` are mutually exclusive. `bash_command` takes precedence over `log`.
                delay: Event-handler delay in seconds.
                trigger: Configure event trigger condition.
                trigger_on_counters: trigger_on_counters
                trigger_on_logging: trigger_on_logging
                trigger_on_intf:
                   Trigger condition occurs on specified interface changes.
                   Note: Any one of the `ip`, `ipv6` and
                   `operstatus` key needs to be defined along with the `interface`.
                trigger_on_maintenance: Settings required for trigger 'on-maintenance'.
                asynchronous: Set the action to be non-blocking.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class EventHandlers(AvdCollection[str, EventHandlersItem]):
        _primary_key: ClassVar[str] = "name"

    EventHandlers._item_type = EventHandlersItem

    class EventMonitor(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
            """
            EventMonitor.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class FlowTracking(AvdModel):
        class Sampled(AvdModel):
            class Encapsulation(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_ipv6": {"type": bool}, "mpls": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4_ipv6: bool | None
                mpls: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4_ipv6: bool | None | UndefinedType = Undefined,
                    mpls: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Encapsulation.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_ipv6: ipv4_ipv6
                        mpls: mpls

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HardwareOffload(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": bool}, "ipv6": {"type": bool}, "threshold_minimum": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4: bool | None
                """Configure hardware offload for IPv4 traffic."""
                ipv6: bool | None
                """Configure hardware offload for IPv6 traffic."""
                threshold_minimum: int | None
                """Minimum number of samples."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4: bool | None | UndefinedType = Undefined,
                    ipv6: bool | None | UndefinedType = Undefined,
                    threshold_minimum: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HardwareOffload.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: Configure hardware offload for IPv4 traffic.
                        ipv6: Configure hardware offload for IPv6 traffic.
                        threshold_minimum: Minimum number of samples.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackersItem(AvdModel):
                class RecordExport(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "mpls": {"type": bool},
                        "on_inactive_timeout": {"type": int},
                        "on_interval": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    mpls: bool | None
                    """Export MPLS forwarding information."""
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        mpls: bool | None | UndefinedType = Undefined,
                        on_inactive_timeout: int | None | UndefinedType = Undefined,
                        on_interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RecordExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mpls: Export MPLS forwarding information.
                            on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                            on_interval: Flow record export interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportersItem(AvdModel):
                    class Collector(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "host": {"type": str}, "port": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        host: str | None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: int | None
                        """Collector Port Number."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            host: str | None | UndefinedType = Undefined,
                            port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Collector.

                            Args:
                            -----
                                _custom_data: _custom_data
                                host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                port: Collector Port Number.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Format(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipfix_version": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        ipfix_version: int | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipfix_version: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Format.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ipfix_version: ipfix_version

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "collector": {"type": Collector},
                        "format": {"type": Format},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """Exporter Name."""
                    collector: Collector
                    format: Format
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        collector: Collector | UndefinedType = Undefined,
                        format: Format | UndefinedType = Undefined,
                        local_interface: str | None | UndefinedType = Undefined,
                        template_interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ExportersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Exporter Name.
                            collector: collector
                            format: format
                            local_interface: Local Source Interface.
                            template_interval: Template interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Exporters(AvdCollection[str, ExportersItem]):
                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "table_size": {"type": int},
                    "record_export": {"type": RecordExport},
                    "name": {"type": str},
                    "exporters": {"type": Exporters},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                table_size: int | None
                """Maximum number of entries in flow table."""
                record_export: RecordExport
                name: str
                """Tracker Name."""
                exporters: Exporters

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    table_size: int | None | UndefinedType = Undefined,
                    record_export: RecordExport | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    exporters: Exporters | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrackersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        table_size: Maximum number of entries in flow table.
                        record_export: record_export
                        name: Tracker Name.
                        exporters: exporters

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Trackers(AvdCollection[str, TrackersItem]):
                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "encapsulation": {"type": Encapsulation},
                "sample": {"type": int},
                "hardware_offload": {"type": HardwareOffload},
                "trackers": {"type": Trackers},
                "shutdown": {"type": bool, "default": False},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            encapsulation: Encapsulation
            sample: int | None
            hardware_offload: HardwareOffload
            trackers: Trackers
            shutdown: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                encapsulation: Encapsulation | UndefinedType = Undefined,
                sample: int | None | UndefinedType = Undefined,
                hardware_offload: HardwareOffload | UndefinedType = Undefined,
                trackers: Trackers | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Sampled.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation: encapsulation
                    sample: sample
                    hardware_offload: hardware_offload
                    trackers: trackers
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hardware(AvdModel):
            class Record(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "format_ipfix_standard_timestamps_counters": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                format_ipfix_standard_timestamps_counters: bool | None
                """Enable software export of IPFIX data records."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    format_ipfix_standard_timestamps_counters: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Record.

                    Args:
                    -----
                        _custom_data: _custom_data
                        format_ipfix_standard_timestamps_counters: Enable software export of IPFIX data records.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackersItem(AvdModel):
                class RecordExport(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "on_inactive_timeout": {"type": int}, "on_interval": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    on_inactive_timeout: int | None
                    """Flow record inactive export timeout in milliseconds."""
                    on_interval: int | None
                    """Flow record export interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        on_inactive_timeout: int | None | UndefinedType = Undefined,
                        on_interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RecordExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            on_inactive_timeout: Flow record inactive export timeout in milliseconds.
                            on_interval: Flow record export interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportersItem(AvdModel):
                    class Collector(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "host": {"type": str}, "port": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        host: str | None
                        """Collector IPv4 address or IPv6 address or fully qualified domain name."""
                        port: int | None
                        """Collector Port Number."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            host: str | None | UndefinedType = Undefined,
                            port: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Collector.

                            Args:
                            -----
                                _custom_data: _custom_data
                                host: Collector IPv4 address or IPv6 address or fully qualified domain name.
                                port: Collector Port Number.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Format(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipfix_version": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        ipfix_version: int | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipfix_version: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            Format.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ipfix_version: ipfix_version

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "collector": {"type": Collector},
                        "format": {"type": Format},
                        "local_interface": {"type": str},
                        "template_interval": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """Exporter Name."""
                    collector: Collector
                    format: Format
                    local_interface: str | None
                    """Local Source Interface."""
                    template_interval: int | None
                    """Template interval in milliseconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        collector: Collector | UndefinedType = Undefined,
                        format: Format | UndefinedType = Undefined,
                        local_interface: str | None | UndefinedType = Undefined,
                        template_interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ExportersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Exporter Name.
                            collector: collector
                            format: format
                            local_interface: Local Source Interface.
                            template_interval: Template interval in milliseconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Exporters(AvdCollection[str, ExportersItem]):
                    _primary_key: ClassVar[str] = "name"

                Exporters._item_type = ExportersItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "record_export": {"type": RecordExport},
                    "exporters": {"type": Exporters},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Tracker Name."""
                record_export: RecordExport
                exporters: Exporters

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    record_export: RecordExport | UndefinedType = Undefined,
                    exporters: Exporters | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrackersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Tracker Name.
                        record_export: record_export
                        exporters: exporters

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Trackers(AvdCollection[str, TrackersItem]):
                _primary_key: ClassVar[str] = "name"

            Trackers._item_type = TrackersItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "record": {"type": Record},
                "trackers": {"type": Trackers},
                "shutdown": {"type": bool, "default": False},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            record: Record
            trackers: Trackers
            shutdown: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                record: Record | UndefinedType = Undefined,
                trackers: Trackers | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Hardware.

                Args:
                -----
                    _custom_data: _custom_data
                    record: record
                    trackers: trackers
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sampled": {"type": Sampled}, "hardware": {"type": Hardware}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        sampled: Sampled
        hardware: Hardware

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            sampled: Sampled | UndefinedType = Undefined,
            hardware: Hardware | UndefinedType = Undefined,
        ) -> None:
            """
            FlowTracking.

            Args:
            -----
                _custom_data: _custom_data
                sampled: sampled
                hardware: hardware

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Hardware(AvdModel):
        class AccessList(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mechanism": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            mechanism: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mechanism: str | None | UndefinedType = Undefined) -> None:
                """
                AccessList.

                Args:
                -----
                    _custom_data: _custom_data
                    mechanism: mechanism

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SpeedGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "speed_group": {"type": str}, "serdes": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "speed_group")
            _custom_data: dict[str, Any]
            speed_group: str
            serdes: str | None
            """Serdes speed like "10g" or "25g"."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                speed_group: str | UndefinedType = Undefined,
                serdes: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                SpeedGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    speed_group: speed_group
                    serdes: Serdes speed like "10g" or "25g".

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SpeedGroups(AvdCollection[str, SpeedGroupsItem]):
            _primary_key: ClassVar[str] = "speed_group"

        SpeedGroups._item_type = SpeedGroupsItem

        class PortGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "port_group": {"type": str}, "select": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "port_group")
            _custom_data: dict[str, Any]
            port_group: str
            select: str | None
            """Select Ports to activate"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                port_group: str | UndefinedType = Undefined,
                select: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                PortGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    port_group: port_group
                    select: Select Ports to activate

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PortGroups(AvdCollection[str, PortGroupsItem]):
            _primary_key: ClassVar[str] = "port_group"

        PortGroups._item_type = PortGroupsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "access_list": {"type": AccessList},
            "speed_groups": {"type": SpeedGroups},
            "port_groups": {"type": PortGroups},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        access_list: AccessList
        speed_groups: SpeedGroups
        port_groups: PortGroups

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            access_list: AccessList | UndefinedType = Undefined,
            speed_groups: SpeedGroups | UndefinedType = Undefined,
            port_groups: PortGroups | UndefinedType = Undefined,
        ) -> None:
            """
            Hardware.

            Args:
            -----
                _custom_data: _custom_data
                access_list: access_list
                speed_groups: speed_groups
                port_groups: port_groups

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class HardwareCounters(AvdModel):
        class FeaturesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "direction": {"type": str},
                "address_type": {"type": str},
                "layer3": {"type": bool},
                "vrf": {"type": str},
                "prefix": {"type": str},
                "units_packets": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            direction: str | None
            """
            Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
            Some features DO
            NOT have any direction.
            This validation IS NOT made by the schemas.
            """
            address_type: str | None
            """
            Supported only for the following features:
            - acl: [ipv4, ipv6, mac] if direction is 'out'
            -
            multicast: [ipv4, ipv6]
            - route: [ipv4, ipv6]
            This validation IS NOT made by the schemas.
            """
            layer3: bool | None
            """Supported only for the 'ip' feature."""
            vrf: str | None
            """
            Supported only for the 'route' feature.
            This validation IS NOT made by the schemas.
            """
            prefix: str | None
            """
            Supported only for the 'route' feature.
            Mandatory for the 'route' feature.
            This validation IS NOT
            made by the schemas.
            """
            units_packets: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
                address_type: str | None | UndefinedType = Undefined,
                layer3: bool | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                prefix: str | None | UndefinedType = Undefined,
                units_packets: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                FeaturesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    direction:
                       Most features support only 'in' and 'out'. Some like traffic-policy support 'cpu'.
                       Some features DO
                       NOT have any direction.
                       This validation IS NOT made by the schemas.
                    address_type:
                       Supported only for the following features:
                       - acl: [ipv4, ipv6, mac] if direction is 'out'
                       -
                       multicast: [ipv4, ipv6]
                       - route: [ipv4, ipv6]
                       This validation IS NOT made by the schemas.
                    layer3: Supported only for the 'ip' feature.
                    vrf:
                       Supported only for the 'route' feature.
                       This validation IS NOT made by the schemas.
                    prefix:
                       Supported only for the 'route' feature.
                       Mandatory for the 'route' feature.
                       This validation IS NOT
                       made by the schemas.
                    units_packets: units_packets

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "features": {"type": list, "items": FeaturesItem}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        features: list[FeaturesItem]
        """
        This data model allows to configure the list of hardware counters feature
        available on Arista
        platforms.

        The `name` key accepts a list of valid_values which MUST be updated to support
        new
        feature as they are released in EOS.

        The available values of the different keys like 'direction' or
        'address_type'
        are feature and hardware dependent and this model DOES NOT validate that the
        combinations are valid. It is the responsibility of the user of this data model
        to make sure that
        the rendered CLI is accepted by the targeted device.

        Examples:

          * Use:
            ```yaml
        hardware_counters:
              features:
                - name: ip
                  direction: out
                  layer3:
        true
                  units_packets: true
            ```

            to render:
            ```eos
            hardware counter feature
        ip out layer3 units packets
            ```
          * Use:
            ```yaml
            hardware_counters:
              features:
        - name: route
                  address_type: ipv4
                  vrf: test
                  prefix: 192.168.0.0/24
        ```

            to render:
            ```eos
            hardware counter feature route ipv4 vrf test 192.168.0.0/24
        ```
        """

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, features: list[FeaturesItem] | UndefinedType = Undefined) -> None:
            """
            HardwareCounters.

            Args:
            -----
                _custom_data: _custom_data
                features:
                   This data model allows to configure the list of hardware counters feature
                   available on Arista
                   platforms.

                   The `name` key accepts a list of valid_values which MUST be updated to support
                   new
                   feature as they are released in EOS.

                   The available values of the different keys like 'direction' or
                   'address_type'
                   are feature and hardware dependent and this model DOES NOT validate that the
                   combinations are valid. It is the responsibility of the user of this data model
                   to make sure that
                   the rendered CLI is accepted by the targeted device.

            Examples:
                     * Use:
                       ```yaml
                   hardware_counters:
                         features:
                           - name: ip
                             direction: out
                             layer3:
                   true
                             units_packets: true
                       ```

                       to render:
                       ```eos
                       hardware counter feature
                   ip out layer3 units packets
                       ```
                     * Use:
                       ```yaml
                       hardware_counters:
                         features:
                   - name: route
                             address_type: ipv4
                             vrf: test
                             prefix: 192.168.0.0/24
                   ```

                       to render:
                       ```eos
                       hardware counter feature route ipv4 vrf test 192.168.0.0/24
                   ```

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceDefaults(AvdModel):
        class Ethernet(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "shutdown": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            shutdown: bool | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, shutdown: bool | None | UndefinedType = Undefined) -> None:
                """
                Ethernet.

                Args:
                -----
                    _custom_data: _custom_data
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ethernet": {"type": Ethernet}, "mtu": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        ethernet: Ethernet
        mtu: int | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ethernet: Ethernet | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            InterfaceDefaults.

            Args:
            -----
                _custom_data: _custom_data
                ethernet: ethernet
                mtu: mtu

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceGroupsItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "interfaces": {"type": list, "items": str},
            "bgp_maintenance_profiles": {"type": list, "items": str},
            "interface_maintenance_profiles": {"type": list, "items": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Interface-Group name."""
        interfaces: list[str]
        bgp_maintenance_profiles: list[str]
        interface_maintenance_profiles: list[str]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            interfaces: list[str] | UndefinedType = Undefined,
            bgp_maintenance_profiles: list[str] | UndefinedType = Undefined,
            interface_maintenance_profiles: list[str] | UndefinedType = Undefined,
        ) -> None:
            """
            InterfaceGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface-Group name.
                interfaces: interfaces
                bgp_maintenance_profiles: bgp_maintenance_profiles
                interface_maintenance_profiles: interface_maintenance_profiles

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceGroups(AvdCollection[str, InterfaceGroupsItem]):
        _primary_key: ClassVar[str] = "name"

    InterfaceGroups._item_type = InterfaceGroupsItem

    class InterfaceProfilesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "commands": {"type": list, "items": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "commands")
        _custom_data: dict[str, Any]
        name: str
        """Interface-Profile Name."""
        commands: list[str]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            commands: list[str] | UndefinedType = Undefined,
        ) -> None:
            """
            InterfaceProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface-Profile Name.
                commands: commands

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class InterfaceProfiles(AvdCollection[str, InterfaceProfilesItem]):
        _primary_key: ClassVar[str] = "name"

    InterfaceProfiles._item_type = InterfaceProfilesItem

    class IpAccessListsItem(AvdModel):
        class EntriesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "sequence": {"type": int},
                "remark": {"type": str},
                "action": {"type": str},
                "protocol": {"type": str},
                "source": {"type": str},
                "source_ports_match": {"type": str, "default": "eq"},
                "source_ports": {"type": list, "items": str},
                "destination": {"type": str},
                "destination_ports_match": {"type": str, "default": "eq"},
                "destination_ports": {"type": list, "items": str},
                "tcp_flags": {"type": list, "items": str},
                "fragments": {"type": bool},
                "log": {"type": bool},
                "ttl": {"type": int},
                "ttl_match": {"type": str, "default": "eq"},
                "icmp_type": {"type": str},
                "icmp_code": {"type": str},
                "nexthop_group": {"type": str},
                "tracked": {"type": bool},
                "dscp": {"type": str},
                "vlan_number": {"type": int},
                "vlan_inner": {"type": bool, "default": False},
                "vlan_mask": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sequence: int | None
            """ACL entry sequence number."""
            remark: str | None
            """
            Comment up to 100 characters.
            If remark is defined, other keys in the ACL entry will be ignored.
            """
            action: str | None
            """
            ACL action.
            Required except for remarks.
            """
            protocol: str | None
            """
            "ip", "tcp", "udp", "icmp" or other protocol name or number.
            Required except for remarks.
            """
            source: str | None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            source_ports_match: str | None
            source_ports: list[str]
            destination: str | None
            """
            "any", "<ip>/<mask>" or "<ip>".
            "<ip>" without a mask means host.
            Required except for remarks.
            """
            destination_ports_match: str | None
            destination_ports: list[str]
            tcp_flags: list[str]
            fragments: bool | None
            """Match non-head fragment packets."""
            log: bool | None
            """Log matches against this rule."""
            ttl: int | None
            """TTL value."""
            ttl_match: str | None
            icmp_type: str | None
            """Message type name/number for ICMP packets."""
            icmp_code: str | None
            """Message code for ICMP packets."""
            nexthop_group: str | None
            """nexthop-group name."""
            tracked: bool | None
            """Match packets in existing ICMP/UDP/TCP connections."""
            dscp: str | None
            """DSCP value or name."""
            vlan_number: int | None
            vlan_inner: bool | None
            vlan_mask: str | None
            """0x000-0xFFF VLAN mask."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | None | UndefinedType = Undefined,
                remark: str | None | UndefinedType = Undefined,
                action: str | None | UndefinedType = Undefined,
                protocol: str | None | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
                source_ports_match: str | None | UndefinedType = Undefined,
                source_ports: list[str] | UndefinedType = Undefined,
                destination: str | None | UndefinedType = Undefined,
                destination_ports_match: str | None | UndefinedType = Undefined,
                destination_ports: list[str] | UndefinedType = Undefined,
                tcp_flags: list[str] | UndefinedType = Undefined,
                fragments: bool | None | UndefinedType = Undefined,
                log: bool | None | UndefinedType = Undefined,
                ttl: int | None | UndefinedType = Undefined,
                ttl_match: str | None | UndefinedType = Undefined,
                icmp_type: str | None | UndefinedType = Undefined,
                icmp_code: str | None | UndefinedType = Undefined,
                nexthop_group: str | None | UndefinedType = Undefined,
                tracked: bool | None | UndefinedType = Undefined,
                dscp: str | None | UndefinedType = Undefined,
                vlan_number: int | None | UndefinedType = Undefined,
                vlan_inner: bool | None | UndefinedType = Undefined,
                vlan_mask: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: ACL entry sequence number.
                    remark:
                       Comment up to 100 characters.
                       If remark is defined, other keys in the ACL entry will be ignored.
                    action:
                       ACL action.
                       Required except for remarks.
                    protocol:
                       "ip", "tcp", "udp", "icmp" or other protocol name or number.
                       Required except for remarks.
                    source:
                       "any", "<ip>/<mask>" or "<ip>".
                       "<ip>" without a mask means host.
                       Required except for remarks.
                    source_ports_match: source_ports_match
                    source_ports: source_ports
                    destination:
                       "any", "<ip>/<mask>" or "<ip>".
                       "<ip>" without a mask means host.
                       Required except for remarks.
                    destination_ports_match: destination_ports_match
                    destination_ports: destination_ports
                    tcp_flags: tcp_flags
                    fragments: Match non-head fragment packets.
                    log: Log matches against this rule.
                    ttl: TTL value.
                    ttl_match: ttl_match
                    icmp_type: Message type name/number for ICMP packets.
                    icmp_code: Message code for ICMP packets.
                    nexthop_group: nexthop-group name.
                    tracked: Match packets in existing ICMP/UDP/TCP connections.
                    dscp: DSCP value or name.
                    vlan_number: vlan_number
                    vlan_inner: vlan_inner
                    vlan_mask: 0x000-0xFFF VLAN mask.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "entries": {"type": list, "items": EntriesItem},
            "permit_response_traffic": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        entries: list[EntriesItem]
        """ACL Entries."""
        permit_response_traffic: str | None
        """
        Permit response traffic automatically based on NAT translations.
        Minimum EOS version requirement
        4.32.2F.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            entries: list[EntriesItem] | UndefinedType = Undefined,
            permit_response_traffic: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                entries: ACL Entries.
                permit_response_traffic:
                   Permit response traffic automatically based on NAT translations.
                   Minimum EOS version requirement
                   4.32.2F.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpAccessLists(AvdCollection[str, IpAccessListsItem]):
        _primary_key: ClassVar[str] = "name"

    IpAccessLists._item_type = IpAccessListsItem

    class IpCommunityListsItem(AvdModel):
        class EntriesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "action": {"type": str},
                "communities": {"type": list, "items": str},
                "regexp": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "action")
            _custom_data: dict[str, Any]
            action: str
            communities: list[str]
            """
            If defined, a standard community-list will be configured.
            Supported community strings (case
            insensitive):
            - GSHUT
            - internet
            - local-as
            - no-advertise
            - no-export
            - <1-4294967040>
            - aa:nn
            """
            regexp: str | None
            """
            Regular Expression.
            If defined, a regex community-list will be configured.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
                communities: list[str] | UndefinedType = Undefined,
                regexp: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    action: action
                    communities:
                       If defined, a standard community-list will be configured.
                       Supported community strings (case
                       insensitive):
                       - GSHUT
                       - internet
                       - local-as
                       - no-advertise
                       - no-export
                       - <1-4294967040>
                       - aa:nn
                    regexp:
                       Regular Expression.
                       If defined, a regex community-list will be configured.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "entries": {"type": list, "items": EntriesItem}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "entries")
        _custom_data: dict[str, Any]
        name: str
        """IP Community-list Name."""
        entries: list[EntriesItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            entries: list[EntriesItem] | UndefinedType = Undefined,
        ) -> None:
            """
            IpCommunityListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: IP Community-list Name.
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpCommunityLists(AvdCollection[str, IpCommunityListsItem]):
        _primary_key: ClassVar[str] = "name"

    IpCommunityLists._item_type = IpCommunityListsItem

    class IpDhcpRelay(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "always_on": {"type": bool},
            "all_subnets": {"type": bool},
            "information_option": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        always_on: bool | None
        """DhcpRelay Agent will be in always-on mode."""
        all_subnets: bool | None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        information_option: bool | None
        """Insert Option-82 information."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            always_on: bool | None | UndefinedType = Undefined,
            all_subnets: bool | None | UndefinedType = Undefined,
            information_option: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpDhcpRelay.

            Args:
            -----
                _custom_data: _custom_data
                always_on: DhcpRelay Agent will be in always-on mode.
                all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                information_option: Insert Option-82 information.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpDhcpSnooping(AvdModel):
        class InformationOption(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "circuit_id_type": {"type": str},
                "circuit_id_format": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            """Enable insertion of option-82 in DHCP request packets."""
            circuit_id_type: str | None
            """"none" or <0 - 255>."""
            circuit_id_format: str | None
            """
            Required if `circuit_id_type` is set.
            - "%h:%p" Hostname and interface name
            - "%p:%v" Interface name
            and VLAN ID
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                circuit_id_type: str | None | UndefinedType = Undefined,
                circuit_id_format: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                InformationOption.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Enable insertion of option-82 in DHCP request packets.
                    circuit_id_type: "none" or <0 - 255>.
                    circuit_id_format:
                       Required if `circuit_id_type` is set.
                       - "%h:%p" Hostname and interface name
                       - "%p:%v" Interface name
                       and VLAN ID

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool},
            "bridging": {"type": bool},
            "information_option": {"type": InformationOption},
            "vlan": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None
        bridging: bool | None
        information_option: InformationOption
        vlan: str | None
        """
        VLAN range as string.
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 15,16,17,18
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            bridging: bool | None | UndefinedType = Undefined,
            information_option: InformationOption | UndefinedType = Undefined,
            vlan: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpDhcpSnooping.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                bridging: bridging
                information_option: information_option
                vlan:
                   VLAN range as string.
                   "< vlan_id >, < vlan_id >-< vlan_id >"
                   Example: 15,16,17,18

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpDomainLookup(AvdModel):
        class SourceInterfacesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Source Interface."""
            vrf: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                SourceInterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Source Interface.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SourceInterfaces(AvdCollection[str, SourceInterfacesItem]):
            _primary_key: ClassVar[str] = "name"

        SourceInterfaces._item_type = SourceInterfacesItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source_interfaces": {"type": SourceInterfaces}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        source_interfaces: SourceInterfaces

        def __init__(
            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source_interfaces: SourceInterfaces | UndefinedType = Undefined
        ) -> None:
            """
            IpDomainLookup.

            Args:
            -----
                _custom_data: _custom_data
                source_interfaces: source_interfaces

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpExtcommunityListsItem(AvdModel):
        class EntriesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "extcommunities": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "type", "extcommunities")
            _custom_data: dict[str, Any]
            type: str
            extcommunities: str
            """
            Communities as string.
            Example: "65000:65000"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                type: str | UndefinedType = Undefined,
                extcommunities: str | UndefinedType = Undefined,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    extcommunities:
                       Communities as string.
                       Example: "65000:65000"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "entries": {"type": list, "items": EntriesItem}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "entries")
        _custom_data: dict[str, Any]
        name: str
        """Community-list Name."""
        entries: list[EntriesItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            entries: list[EntriesItem] | UndefinedType = Undefined,
        ) -> None:
            """
            IpExtcommunityListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Community-list Name.
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpExtcommunityLists(AvdCollection[str, IpExtcommunityListsItem]):
        _primary_key: ClassVar[str] = "name"

    IpExtcommunityLists._item_type = IpExtcommunityListsItem

    class IpExtcommunityListsRegexpItem(AvdModel):
        class EntriesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "regexp": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "type", "regexp")
            _custom_data: dict[str, Any]
            type: str
            regexp: str
            """Regular Expression."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                type: str | UndefinedType = Undefined,
                regexp: str | UndefinedType = Undefined,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    regexp: Regular Expression.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "entries": {"type": list, "items": EntriesItem}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "entries")
        _custom_data: dict[str, Any]
        name: str
        """Community-list Name."""
        entries: list[EntriesItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            entries: list[EntriesItem] | UndefinedType = Undefined,
        ) -> None:
            """
            IpExtcommunityListsRegexpItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Community-list Name.
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpExtcommunityListsRegexp(AvdCollection[str, IpExtcommunityListsRegexpItem]):
        _primary_key: ClassVar[str] = "name"

    IpExtcommunityListsRegexp._item_type = IpExtcommunityListsRegexpItem

    class IpFtpClientSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpFtpClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpHardware(AvdModel):
        class Fib(AvdModel):
            class Optimize(AvdModel):
                class Prefixes(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    profile: str | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined) -> None:
                        """
                        Prefixes.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefixes": {"type": Prefixes}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                prefixes: Prefixes

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefixes: Prefixes | UndefinedType = Undefined) -> None:
                    """
                    Optimize.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "optimize": {"type": Optimize}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            optimize: Optimize

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, optimize: Optimize | UndefinedType = Undefined) -> None:
                """
                Fib.

                Args:
                -----
                    _custom_data: _custom_data
                    optimize: optimize

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "fib": {"type": Fib}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        fib: Fib

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, fib: Fib | UndefinedType = Undefined) -> None:
            """
            IpHardware.

            Args:
            -----
                _custom_data: _custom_data
                fib: fib

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpHttpClientSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        name: str | None
        """Interface Name."""
        vrf: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpHttpClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpIgmpSnooping(AvdModel):
        class Querier(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "address": {"type": str},
                "query_interval": {"type": int},
                "max_response_time": {"type": int},
                "last_member_query_interval": {"type": int},
                "last_member_query_count": {"type": int},
                "startup_query_interval": {"type": int},
                "startup_query_count": {"type": int},
                "version": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            address: str | None
            """IP Address."""
            query_interval: int | None
            max_response_time: int | None
            last_member_query_interval: int | None
            last_member_query_count: int | None
            startup_query_interval: int | None
            startup_query_count: int | None
            version: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                address: str | None | UndefinedType = Undefined,
                query_interval: int | None | UndefinedType = Undefined,
                max_response_time: int | None | UndefinedType = Undefined,
                last_member_query_interval: int | None | UndefinedType = Undefined,
                last_member_query_count: int | None | UndefinedType = Undefined,
                startup_query_interval: int | None | UndefinedType = Undefined,
                startup_query_count: int | None | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Querier.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    address: IP Address.
                    query_interval: query_interval
                    max_response_time: max_response_time
                    last_member_query_interval: last_member_query_interval
                    last_member_query_count: last_member_query_count
                    startup_query_interval: startup_query_interval
                    startup_query_count: startup_query_count
                    version: version

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlansItem(AvdModel):
            class Querier(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "address": {"type": str},
                    "query_interval": {"type": int},
                    "max_response_time": {"type": int},
                    "last_member_query_interval": {"type": int},
                    "last_member_query_count": {"type": int},
                    "startup_query_interval": {"type": int},
                    "startup_query_count": {"type": int},
                    "version": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                address: str | None
                """IP Address."""
                query_interval: int | None
                max_response_time: int | None
                last_member_query_interval: int | None
                last_member_query_count: int | None
                startup_query_interval: int | None
                startup_query_count: int | None
                version: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    query_interval: int | None | UndefinedType = Undefined,
                    max_response_time: int | None | UndefinedType = Undefined,
                    last_member_query_interval: int | None | UndefinedType = Undefined,
                    last_member_query_count: int | None | UndefinedType = Undefined,
                    startup_query_interval: int | None | UndefinedType = Undefined,
                    startup_query_count: int | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Querier.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        address: IP Address.
                        query_interval: query_interval
                        max_response_time: max_response_time
                        last_member_query_interval: last_member_query_interval
                        last_member_query_count: last_member_query_count
                        startup_query_interval: startup_query_interval
                        startup_query_count: startup_query_count
                        version: version

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "enabled": {"type": bool},
                "querier": {"type": Querier},
                "max_groups": {"type": int},
                "fast_leave": {"type": bool},
                "proxy": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """VLAN ID."""
            enabled: bool | None
            querier: Querier
            max_groups: int | None
            fast_leave: bool | None
            proxy: bool | None
            """Global proxy settings should be enabled before enabling per-vlan."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                querier: Querier | UndefinedType = Undefined,
                max_groups: int | None | UndefinedType = Undefined,
                fast_leave: bool | None | UndefinedType = Undefined,
                proxy: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlansItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: VLAN ID.
                    enabled: enabled
                    querier: querier
                    max_groups: max_groups
                    fast_leave: fast_leave
                    proxy: Global proxy settings should be enabled before enabling per-vlan.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vlans(AvdCollection[int, VlansItem]):
            _primary_key: ClassVar[str] = "id"

        Vlans._item_type = VlansItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "globally_enabled": {"type": bool, "default": True},
            "robustness_variable": {"type": int},
            "restart_query_interval": {"type": int},
            "interface_restart_query": {"type": int},
            "fast_leave": {"type": bool},
            "querier": {"type": Querier},
            "proxy": {"type": bool},
            "vlans": {"type": Vlans},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        globally_enabled: bool | None
        """
        Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
        deactivate IGMP snooping per vlan.
        """
        robustness_variable: int | None
        restart_query_interval: int | None
        interface_restart_query: int | None
        fast_leave: bool | None
        querier: Querier
        proxy: bool | None
        vlans: Vlans

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            globally_enabled: bool | None | UndefinedType = Undefined,
            robustness_variable: int | None | UndefinedType = Undefined,
            restart_query_interval: int | None | UndefinedType = Undefined,
            interface_restart_query: int | None | UndefinedType = Undefined,
            fast_leave: bool | None | UndefinedType = Undefined,
            querier: Querier | UndefinedType = Undefined,
            proxy: bool | None | UndefinedType = Undefined,
            vlans: Vlans | UndefinedType = Undefined,
        ) -> None:
            """
            IpIgmpSnooping.

            Args:
            -----
                _custom_data: _custom_data
                globally_enabled:
                   Activate or deactivate IGMP snooping for all vlans where `vlans` allows user to activate /
                   deactivate IGMP snooping per vlan.
                robustness_variable: robustness_variable
                restart_query_interval: restart_query_interval
                interface_restart_query: interface_restart_query
                fast_leave: fast_leave
                querier: querier
                proxy: proxy
                vlans: vlans

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpNameServersItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "vrf": {"type": str}, "priority": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
        _custom_data: dict[str, Any]
        ip_address: str
        """IPv4 or IPv6 address for DNS server."""
        vrf: str | None
        """VRF Name."""
        priority: int | None
        """Priority value (lower is first)."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ip_address: str | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            priority: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpNameServersItem.

            Args:
            -----
                _custom_data: _custom_data
                ip_address: IPv4 or IPv6 address for DNS server.
                vrf: VRF Name.
                priority: Priority value (lower is first).

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpNat(AvdModel):
        class ProfilesItem(AvdModel):
            class Destination(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "pool_name")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        pool_name: str | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "nat_type")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    nat_type: str
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        nat_type: str | UndefinedType = Undefined,
                        pool_name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "vrf": {"type": str},
                "destination": {"type": Destination},
                "source": {"type": Source},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            vrf: str | None
            """Specify VRF for NAT profile."""
            destination: Destination
            source: Source

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                destination: Destination | UndefinedType = Undefined,
                source: Source | UndefinedType = Undefined,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    vrf: Specify VRF for NAT profile.
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Profiles(AvdCollection[str, ProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class PoolsItem(AvdModel):
            class RangesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "first_ip": {"type": str},
                    "last_ip": {"type": str},
                    "first_port": {"type": int},
                    "last_port": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                first_ip: str | None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                """
                last_ip: str | None
                """
                IPv4 address.
                Required when `type` is `ip-port` and ignored otherwise.
                `first_ip` and `last_ip` ip
                addresses should lie in same subnet.
                """
                first_port: int | None
                last_port: int | None
                """
                Required when `first_port` is set.
                `last_port` must be greater than or equal to `first_port`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    first_ip: str | None | UndefinedType = Undefined,
                    last_ip: str | None | UndefinedType = Undefined,
                    first_port: int | None | UndefinedType = Undefined,
                    last_port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RangesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        first_ip:
                           IPv4 address.
                           Required when `type` is `ip-port` and ignored otherwise.
                        last_ip:
                           IPv4 address.
                           Required when `type` is `ip-port` and ignored otherwise.
                           `first_ip` and `last_ip` ip
                           addresses should lie in same subnet.
                        first_port: first_port
                        last_port:
                           Required when `first_port` is set.
                           `last_port` must be greater than or equal to `first_port`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "type": {"type": str, "default": "ip-port"},
                "prefix_length": {"type": int},
                "ranges": {"type": list, "items": RangesItem},
                "utilization_log_threshold": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            type: str | None
            prefix_length: int | None
            """It is only used and required when `type` is `ip-port`."""
            ranges: list[RangesItem]
            utilization_log_threshold: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                type: str | None | UndefinedType = Undefined,
                prefix_length: int | None | UndefinedType = Undefined,
                ranges: list[RangesItem] | UndefinedType = Undefined,
                utilization_log_threshold: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                PoolsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    type: type
                    prefix_length: It is only used and required when `type` is `ip-port`.
                    ranges: ranges
                    utilization_log_threshold: utilization_log_threshold

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Pools(AvdCollection[str, PoolsItem]):
            _primary_key: ClassVar[str] = "name"

        Pools._item_type = PoolsItem

        class Synchronization(AvdModel):
            class PortRange(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "first_port": {"type": int},
                    "last_port": {"type": int},
                    "split_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                first_port: int | None
                last_port: int | None
                """>= first_port."""
                split_disabled: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    first_port: int | None | UndefinedType = Undefined,
                    last_port: int | None | UndefinedType = Undefined,
                    split_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortRange.

                    Args:
                    -----
                        _custom_data: _custom_data
                        first_port: first_port
                        last_port: >= first_port.
                        split_disabled: split_disabled

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "description": {"type": str},
                "expiry_interval": {"type": int},
                "local_interface": {"type": str},
                "peer_address": {"type": str},
                "port_range": {"type": PortRange},
                "shutdown": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            description: str | None
            expiry_interval: int | None
            """In seconds."""
            local_interface: str | None
            """EOS interface name."""
            peer_address: str | None
            """IPv4 address."""
            port_range: PortRange
            shutdown: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                expiry_interval: int | None | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                peer_address: str | None | UndefinedType = Undefined,
                port_range: PortRange | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Synchronization.

                Args:
                -----
                    _custom_data: _custom_data
                    description: description
                    expiry_interval: In seconds.
                    local_interface: EOS interface name.
                    peer_address: IPv4 address.
                    port_range: port_range
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Translation(AvdModel):
            class AddressSelection(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "any": {"type": bool}, "hash_field_source_ip": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                any: bool | None
                hash_field_source_ip: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    any: bool | None | UndefinedType = Undefined,
                    hash_field_source_ip: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressSelection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        any: any
                        hash_field_source_ip: hash_field_source_ip

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LowMark(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "percentage": {"type": int}, "host_percentage": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                percentage: int | None
                """Used to render 'ip nat translation low-mark <percentage>'."""
                host_percentage: int | None
                """Used to render 'ip nat translation low-mark <host_percentage> host'."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    percentage: int | None | UndefinedType = Undefined,
                    host_percentage: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LowMark.

                    Args:
                    -----
                        _custom_data: _custom_data
                        percentage: Used to render 'ip nat translation low-mark <percentage>'.
                        host_percentage: Used to render 'ip nat translation low-mark <host_percentage> host'.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MaxEntries(AvdModel):
                class IpLimitsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip": {"type": str}, "limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip", "limit")
                    _custom_data: dict[str, Any]
                    ip: str
                    """IPv4 address."""
                    limit: int

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip: str | UndefinedType = Undefined,
                        limit: int | UndefinedType = Undefined,
                    ) -> None:
                        """
                        IpLimitsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip: IPv4 address.
                            limit: limit

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class IpLimits(AvdCollection[str, IpLimitsItem]):
                    _primary_key: ClassVar[str] = "ip"

                IpLimits._item_type = IpLimitsItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "limit": {"type": int}, "host_limit": {"type": int}, "ip_limits": {"type": IpLimits}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                limit: int | None
                host_limit: int | None
                ip_limits: IpLimits

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    limit: int | None | UndefinedType = Undefined,
                    host_limit: int | None | UndefinedType = Undefined,
                    ip_limits: IpLimits | UndefinedType = Undefined,
                ) -> None:
                    """
                    MaxEntries.

                    Args:
                    -----
                        _custom_data: _custom_data
                        limit: limit
                        host_limit: host_limit
                        ip_limits: ip_limits

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TimeoutsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "protocol": {"type": str}, "timeout": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "protocol", "timeout")
                _custom_data: dict[str, Any]
                protocol: str
                timeout: int
                """In seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    protocol: str | UndefinedType = Undefined,
                    timeout: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    TimeoutsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        protocol: protocol
                        timeout: In seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timeouts(AvdCollection[str, TimeoutsItem]):
                _primary_key: ClassVar[str] = "protocol"

            Timeouts._item_type = TimeoutsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "address_selection": {"type": AddressSelection},
                "counters": {"type": bool},
                "low_mark": {"type": LowMark},
                "max_entries": {"type": MaxEntries},
                "timeouts": {"type": Timeouts},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            address_selection: AddressSelection
            counters: bool | None
            low_mark: LowMark
            max_entries: MaxEntries
            timeouts: Timeouts

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                address_selection: AddressSelection | UndefinedType = Undefined,
                counters: bool | None | UndefinedType = Undefined,
                low_mark: LowMark | UndefinedType = Undefined,
                max_entries: MaxEntries | UndefinedType = Undefined,
                timeouts: Timeouts | UndefinedType = Undefined,
            ) -> None:
                """
                Translation.

                Args:
                -----
                    _custom_data: _custom_data
                    address_selection: address_selection
                    counters: counters
                    low_mark: low_mark
                    max_entries: max_entries
                    timeouts: timeouts

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "kernel_buffer_size": {"type": int},
            "profiles": {"type": Profiles},
            "pools": {"type": Pools},
            "synchronization": {"type": Synchronization},
            "translation": {"type": Translation},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        kernel_buffer_size: int | None
        """Buffer size in MB."""
        profiles: Profiles
        pools: Pools
        synchronization: Synchronization
        translation: Translation

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            kernel_buffer_size: int | None | UndefinedType = Undefined,
            profiles: Profiles | UndefinedType = Undefined,
            pools: Pools | UndefinedType = Undefined,
            synchronization: Synchronization | UndefinedType = Undefined,
            translation: Translation | UndefinedType = Undefined,
        ) -> None:
            """
            IpNat.

            Args:
            -----
                _custom_data: _custom_data
                kernel_buffer_size: Buffer size in MB.
                profiles: profiles
                pools: pools
                synchronization: synchronization
                translation: translation

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpRadiusSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        name: str | None
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpRadiusSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpSecurity(AvdModel):
        class IkePoliciesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "local_id": {"type": str},
                "local_id_fqdn": {"type": str},
                "ike_lifetime": {"type": int},
                "encryption": {"type": str},
                "dh_group": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Policy name."""
            local_id: str | None
            """
            Local IKE identification.
            Can be an IPv4 or an IPv6 address.
            If both `local_id` and `local_id_fqdn`
            are set, `local_id_fqdn` takes precedence.
            """
            local_id_fqdn: str | None
            """
            Local FQDN or UFQDN IKE identification.
            If both `local_id` and `local_id_fqdn` are set,
            `local_id_fqdn` takes precedence.
            """
            ike_lifetime: int | None
            """IKE lifetime in hours."""
            encryption: str | None
            """IKE encryption algorithm."""
            dh_group: int | None
            """Diffie-Hellman group for the key exchange."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                local_id: str | None | UndefinedType = Undefined,
                local_id_fqdn: str | None | UndefinedType = Undefined,
                ike_lifetime: int | None | UndefinedType = Undefined,
                encryption: str | None | UndefinedType = Undefined,
                dh_group: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                IkePoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy name.
                    local_id:
                       Local IKE identification.
                       Can be an IPv4 or an IPv6 address.
                       If both `local_id` and `local_id_fqdn`
                       are set, `local_id_fqdn` takes precedence.
                    local_id_fqdn:
                       Local FQDN or UFQDN IKE identification.
                       If both `local_id` and `local_id_fqdn` are set,
                       `local_id_fqdn` takes precedence.
                    ike_lifetime: IKE lifetime in hours.
                    encryption: IKE encryption algorithm.
                    dh_group: Diffie-Hellman group for the key exchange.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IkePolicies(AvdCollection[str, IkePoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        IkePolicies._item_type = IkePoliciesItem

        class SaPoliciesItem(AvdModel):
            class SaLifetime(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "value": {"type": int}, "unit": {"type": str, "default": "hours"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                value: int | None
                """
                Lifetime value for this SA.
                Valid range depends on the unit.
                <1-24>       Lifetime in hours (
                default )
                <1-4000000>  Packet limit in thousands
                <1-6000>     Byte limit in GB ( 1024 MB )
                <1-6144000>  Byte limit in MB ( 1024 KB )
                """
                unit: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    value: int | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SaLifetime.

                    Args:
                    -----
                        _custom_data: _custom_data
                        value:
                           Lifetime value for this SA.
                           Valid range depends on the unit.
                           <1-24>       Lifetime in hours (
                           default )
                           <1-4000000>  Packet limit in thousands
                           <1-6000>     Byte limit in GB ( 1024 MB )
                           <1-6144000>  Byte limit in MB ( 1024 KB )
                        unit: unit

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Esp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "integrity": {"type": str}, "encryption": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                integrity: str | None
                encryption: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    integrity: str | None | UndefinedType = Undefined,
                    encryption: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Esp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        integrity: integrity
                        encryption: encryption

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "sa_lifetime": {"type": SaLifetime},
                "esp": {"type": Esp},
                "pfs_dh_group": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Name of the SA policy."""
            sa_lifetime: SaLifetime
            esp: Esp
            pfs_dh_group: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                sa_lifetime: SaLifetime | UndefinedType = Undefined,
                esp: Esp | UndefinedType = Undefined,
                pfs_dh_group: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                SaPoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of the SA policy.
                    sa_lifetime: sa_lifetime
                    esp: esp
                    pfs_dh_group: pfs_dh_group

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SaPolicies(AvdCollection[str, SaPoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        SaPolicies._item_type = SaPoliciesItem

        class ProfilesItem(AvdModel):
            class Dpd(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "time": {"type": int}, "action": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "time", "action")
                _custom_data: dict[str, Any]
                interval: int
                """Interval (in seconds) between keep-alive messages."""
                time: int
                """Time (in seconds) after which the action is applied."""
                action: str
                """
                Action to apply.

                * 'clear': Delete all connections
                * 'hold': Re-negotiate connection on demand
                *
                'restart': Restart connection immediately
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | UndefinedType = Undefined,
                    time: int | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dpd.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval (in seconds) between keep-alive messages.
                        time: Time (in seconds) after which the action is applied.
                        action:
                           Action to apply.

                           * 'clear': Delete all connections
                           * 'hold': Re-negotiate connection on demand
                           *
                           'restart': Restart connection immediately

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "ike_policy": {"type": str},
                "sa_policy": {"type": str},
                "connection": {"type": str},
                "shared_key": {"type": str},
                "dpd": {"type": Dpd},
                "mode": {"type": str},
                "flow_parallelization_encapsulation_udp": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Name of the IPsec profile."""
            ike_policy: str | None
            """Name of the IKE policy to use in this profile."""
            sa_policy: str | None
            """Name of the Security Association to use in this profile."""
            connection: str | None
            """IPsec connection (Initiator/Responder/Dynamic)."""
            shared_key: str | None
            """Encrypted password - only type 7 supported."""
            dpd: Dpd
            """Dead Peer Detection."""
            mode: str | None
            """Ipsec mode type."""
            flow_parallelization_encapsulation_udp: bool | None
            """
            Enable flow parallelization.
            When enabled, multiple cores are used to parallelize the IPsec
            encryption and decryption processing.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                ike_policy: str | None | UndefinedType = Undefined,
                sa_policy: str | None | UndefinedType = Undefined,
                connection: str | None | UndefinedType = Undefined,
                shared_key: str | None | UndefinedType = Undefined,
                dpd: Dpd | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                flow_parallelization_encapsulation_udp: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of the IPsec profile.
                    ike_policy: Name of the IKE policy to use in this profile.
                    sa_policy: Name of the Security Association to use in this profile.
                    connection: IPsec connection (Initiator/Responder/Dynamic).
                    shared_key: Encrypted password - only type 7 supported.
                    dpd: Dead Peer Detection.
                    mode: Ipsec mode type.
                    flow_parallelization_encapsulation_udp:
                       Enable flow parallelization.
                       When enabled, multiple cores are used to parallelize the IPsec
                       encryption and decryption processing.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Profiles(AvdCollection[str, ProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class KeyController(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            profile: str | None
            """IPsec profile name to use."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined) -> None:
                """
                KeyController.

                Args:
                -----
                    _custom_data: _custom_data
                    profile: IPsec profile name to use.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "ike_policies": {"type": IkePolicies},
            "sa_policies": {"type": SaPolicies},
            "profiles": {"type": Profiles},
            "key_controller": {"type": KeyController},
            "hardware_encryption_disabled": {"type": bool, "default": False},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        ike_policies: IkePolicies
        """Internet Security Association and Key Mgmt Protocol."""
        sa_policies: SaPolicies
        """Security Association policies."""
        profiles: Profiles
        """IPSec profiles."""
        key_controller: KeyController
        hardware_encryption_disabled: bool | None
        """
        Disable hardware encryption.
        An SFE restart is needed for this change to take effect.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ike_policies: IkePolicies | UndefinedType = Undefined,
            sa_policies: SaPolicies | UndefinedType = Undefined,
            profiles: Profiles | UndefinedType = Undefined,
            key_controller: KeyController | UndefinedType = Undefined,
            hardware_encryption_disabled: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpSecurity.

            Args:
            -----
                _custom_data: _custom_data
                ike_policies: Internet Security Association and Key Mgmt Protocol.
                sa_policies: Security Association policies.
                profiles: IPSec profiles.
                key_controller: key_controller
                hardware_encryption_disabled:
                   Disable hardware encryption.
                   An SFE restart is needed for this change to take effect.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpSshClientSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str, "default": "default"}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        name: str | None
        """Interface Name."""
        vrf: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpSshClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpTacacsSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        name: str | None
        """Interface name."""
        vrf: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpTacacsSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface name.
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpTelnetClientSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpTelnetClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class IpTftpClientSourceInterfacesItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Interface Name."""
        vrf: str | None
        """VRF Name."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            IpTftpClientSourceInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Interface Name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6AccessListsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ipv6 any any"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ipv6 any any"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "sequence_numbers": {"type": SequenceNumbers},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """IPv6 Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv6AccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: IPv6 Access-list Name.
                counters_per_entry: counters_per_entry
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6AccessLists(AvdCollection[str, Ipv6AccessListsItem]):
        _primary_key: ClassVar[str] = "name"

    Ipv6AccessLists._item_type = Ipv6AccessListsItem

    class Ipv6DhcpRelay(AvdModel):
        class Option(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "link_layer_address": {"type": bool}, "remote_id_format": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            link_layer_address: bool | None
            """Add Option 79 (Link Layer Address Option)."""
            remote_id_format: str | None
            """
            Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
            name (`%m:%p`).
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                link_layer_address: bool | None | UndefinedType = Undefined,
                remote_id_format: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Option.

                Args:
                -----
                    _custom_data: _custom_data
                    link_layer_address: Add Option 79 (Link Layer Address Option).
                    remote_id_format:
                       Add RemoteID option 37 in format MAC address and interface ID (`%m:%i`) or MAC address and interface
                       name (`%m:%p`).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "always_on": {"type": bool}, "all_subnets": {"type": bool}, "option": {"type": Option}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        always_on: bool | None
        """DhcpRelay Agent will be in always-on mode, off by default."""
        all_subnets: bool | None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        option: Option
        """Insert DHCP Option."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            always_on: bool | None | UndefinedType = Undefined,
            all_subnets: bool | None | UndefinedType = Undefined,
            option: Option | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv6DhcpRelay.

            Args:
            -----
                _custom_data: _custom_data
                always_on: DhcpRelay Agent will be in always-on mode, off by default.
                all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                option: Insert DHCP Option.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6Hardware(AvdModel):
        class Fib(AvdModel):
            class Optimize(AvdModel):
                class Prefixes(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    profile: str | None
                    """Pre-defined profile 'internet' or user-defined profile name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, profile: str | None | UndefinedType = Undefined) -> None:
                        """
                        Prefixes.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: Pre-defined profile 'internet' or user-defined profile name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefixes": {"type": Prefixes}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                prefixes: Prefixes

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefixes: Prefixes | UndefinedType = Undefined) -> None:
                    """
                    Optimize.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "optimize": {"type": Optimize}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            optimize: Optimize

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, optimize: Optimize | UndefinedType = Undefined) -> None:
                """
                Fib.

                Args:
                -----
                    _custom_data: _custom_data
                    optimize: optimize

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "fib": {"type": Fib}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        fib: Fib

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, fib: Fib | UndefinedType = Undefined) -> None:
            """
            Ipv6Hardware.

            Args:
            -----
                _custom_data: _custom_data
                fib: fib

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6Neighbor(AvdModel):
        class StaticEntriesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv6_address": {"type": str},
                "vrf": {"type": str},
                "interface": {"type": str},
                "mac_address": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipv6_address", "interface", "mac_address")
            _custom_data: dict[str, Any]
            ipv6_address: str
            """IPv6 address of neighbor."""
            vrf: str | None
            interface: str
            """Interface name."""
            mac_address: str
            """MAC address of neighbor like 'aa:af:12:34:bc:bf'"""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv6_address: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                interface: str | UndefinedType = Undefined,
                mac_address: str | UndefinedType = Undefined,
            ) -> None:
                """
                StaticEntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_address: IPv6 address of neighbor.
                    vrf: vrf
                    interface: Interface name.
                    mac_address: MAC address of neighbor like 'aa:af:12:34:bc:bf'

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Persistent(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "refresh_delay": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            """Restore the IPv6 neighbor cache after reboot."""
            refresh_delay: int | None
            """
            Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
            It
            will require setting the `enabled` key to true.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                refresh_delay: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Persistent.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Restore the IPv6 neighbor cache after reboot.
                    refresh_delay:
                       Time to wait in seconds before refreshing the IPv6 neighbor cache after reboot (EOS default 600).
                       It
                       will require setting the `enabled` key to true.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "static_entries": {"type": list, "items": StaticEntriesItem},
            "persistent": {"type": Persistent},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        static_entries: list[StaticEntriesItem]
        """Static IPv6 neighbor entries."""
        persistent: Persistent

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            static_entries: list[StaticEntriesItem] | UndefinedType = Undefined,
            persistent: Persistent | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv6Neighbor.

            Args:
            -----
                _custom_data: _custom_data
                static_entries: Static IPv6 neighbor entries.
                persistent: persistent

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6PrefixListsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "permit 1b11:3a00:22b0:0082::/64 eq 128"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv6PrefixListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Prefix-list Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6PrefixLists(AvdCollection[str, Ipv6PrefixListsItem]):
        _primary_key: ClassVar[str] = "name"

    Ipv6PrefixLists._item_type = Ipv6PrefixListsItem

    class Ipv6StandardAccessListsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ipv6 any any"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ipv6 any any"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "sequence_numbers": {"type": SequenceNumbers},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv6StandardAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ipv6StandardAccessLists(AvdCollection[str, Ipv6StandardAccessListsItem]):
        _primary_key: ClassVar[str] = "name"

    Ipv6StandardAccessLists._item_type = Ipv6StandardAccessListsItem

    class Ipv6StaticRoutesItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "vrf": {"type": str},
            "destination_address_prefix": {"type": str},
            "interface": {"type": str},
            "gateway": {"type": str},
            "track_bfd": {"type": bool},
            "distance": {"type": int},
            "tag": {"type": int},
            "name": {"type": str},
            "metric": {"type": int},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        vrf: str | None
        destination_address_prefix: str | None
        """IPv6 Network/Mask."""
        interface: str | None
        gateway: str | None
        """IPv6 Address."""
        track_bfd: bool | None
        """Track next-hop using BFD."""
        distance: int | None
        tag: int | None
        name: str | None
        """Description."""
        metric: int | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            destination_address_prefix: str | None | UndefinedType = Undefined,
            interface: str | None | UndefinedType = Undefined,
            gateway: str | None | UndefinedType = Undefined,
            track_bfd: bool | None | UndefinedType = Undefined,
            distance: int | None | UndefinedType = Undefined,
            tag: int | None | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            metric: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            Ipv6StaticRoutesItem.

            Args:
            -----
                _custom_data: _custom_data
                vrf: vrf
                destination_address_prefix: IPv6 Network/Mask.
                interface: interface
                gateway: IPv6 Address.
                track_bfd: Track next-hop using BFD.
                distance: distance
                tag: tag
                name: Description.
                metric: metric

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class L2Protocol(AvdModel):
        class ForwardingProfilesItem(AvdModel):
            class ProtocolsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "forward": {"type": bool},
                    "tagged_forward": {"type": bool},
                    "untagged_forward": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                forward: bool | None
                tagged_forward: bool | None
                untagged_forward: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    forward: bool | None | UndefinedType = Undefined,
                    tagged_forward: bool | None | UndefinedType = Undefined,
                    untagged_forward: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProtocolsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        forward: forward
                        tagged_forward: tagged_forward
                        untagged_forward: untagged_forward

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Protocols(AvdCollection[str, ProtocolsItem]):
                _primary_key: ClassVar[str] = "name"

            Protocols._item_type = ProtocolsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "protocols": {"type": Protocols}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            protocols: Protocols

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                protocols: Protocols | UndefinedType = Undefined,
            ) -> None:
                """
                ForwardingProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    protocols: protocols

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ForwardingProfiles(AvdCollection[str, ForwardingProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        ForwardingProfiles._item_type = ForwardingProfilesItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "forwarding_profiles": {"type": ForwardingProfiles}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        forwarding_profiles: ForwardingProfiles

        def __init__(
            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, forwarding_profiles: ForwardingProfiles | UndefinedType = Undefined
        ) -> None:
            """
            L2Protocol.

            Args:
            -----
                _custom_data: _custom_data
                forwarding_profiles: forwarding_profiles

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Lacp(AvdModel):
        class PortId(AvdModel):
            class Range(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "begin": {"type": int}, "end": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                begin: int | None
                """Minimum LACP port-ID range."""
                end: int | None
                """Maximum LACP port-ID range."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    begin: int | None | UndefinedType = Undefined,
                    end: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Range.

                    Args:
                    -----
                        _custom_data: _custom_data
                        begin: Minimum LACP port-ID range.
                        end: Maximum LACP port-ID range.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "range": {"type": Range}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            range: Range

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, range: Range | UndefinedType = Undefined) -> None:
                """
                PortId.

                Args:
                -----
                    _custom_data: _custom_data
                    range: range

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RateLimit(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: bool | None
            """Enable LACPDU rate limiting by default on all ports."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: bool | None | UndefinedType = Undefined) -> None:
                """
                RateLimit.

                Args:
                -----
                    _custom_data: _custom_data
                    default: Enable LACPDU rate limiting by default on all ports.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "port_id": {"type": PortId},
            "rate_limit": {"type": RateLimit},
            "system_priority": {"type": int},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        port_id: PortId
        """LACP port-ID range configuration."""
        rate_limit: RateLimit
        """Set LACPDU rate limit options."""
        system_priority: int | None
        """Set local system LACP priority."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            port_id: PortId | UndefinedType = Undefined,
            rate_limit: RateLimit | UndefinedType = Undefined,
            system_priority: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            Lacp.

            Args:
            -----
                _custom_data: _custom_data
                port_id: LACP port-ID range configuration.
                rate_limit: Set LACPDU rate limit options.
                system_priority: Set local system LACP priority.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LinkTrackingGroupsItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "links_minimum": {"type": int}, "recovery_delay": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        links_minimum: int | None
        recovery_delay: int | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            links_minimum: int | None | UndefinedType = Undefined,
            recovery_delay: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            LinkTrackingGroupsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                links_minimum: links_minimum
                recovery_delay: recovery_delay

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LinkTrackingGroups(AvdCollection[str, LinkTrackingGroupsItem]):
        _primary_key: ClassVar[str] = "name"

    LinkTrackingGroups._item_type = LinkTrackingGroupsItem

    class Lldp(AvdModel):
        class TlvsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "transmit": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            transmit: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                transmit: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                TlvsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    transmit: transmit

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Tlvs(AvdCollection[str, TlvsItem]):
            _primary_key: ClassVar[str] = "name"

        Tlvs._item_type = TlvsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "timer": {"type": int},
            "timer_reinitialization": {"type": str},
            "holdtime": {"type": int},
            "management_address": {"type": str},
            "vrf": {"type": str},
            "receive_packet_tagged_drop": {"type": str},
            "tlvs": {"type": Tlvs},
            "run": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        timer: int | None
        timer_reinitialization: str | None
        holdtime: int | None
        management_address: str | None
        vrf: str | None
        receive_packet_tagged_drop: str | None
        tlvs: Tlvs
        run: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            timer: int | None | UndefinedType = Undefined,
            timer_reinitialization: str | None | UndefinedType = Undefined,
            holdtime: int | None | UndefinedType = Undefined,
            management_address: str | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            receive_packet_tagged_drop: str | None | UndefinedType = Undefined,
            tlvs: Tlvs | UndefinedType = Undefined,
            run: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            Lldp.

            Args:
            -----
                _custom_data: _custom_data
                timer: timer
                timer_reinitialization: timer_reinitialization
                holdtime: holdtime
                management_address: management_address
                vrf: vrf
                receive_packet_tagged_drop: receive_packet_tagged_drop
                tlvs: tlvs
                run: run

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LoadInterval(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        default: int | None
        """Default load interval in seconds."""

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: int | None | UndefinedType = Undefined) -> None:
            """
            LoadInterval.

            Args:
            -----
                _custom_data: _custom_data
                default: Default load interval in seconds.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LocalUsersItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "disabled": {"type": bool},
            "privilege": {"type": int},
            "role": {"type": str},
            "sha512_password": {"type": str},
            "no_password": {"type": bool},
            "ssh_key": {"type": str},
            "secondary_ssh_key": {"type": str},
            "shell": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Username."""
        disabled: bool | None
        """
        If true, the user will be removed and all other settings are ignored.
        Useful for removing the
        default "admin" user.
        """
        privilege: int | None
        """Initial privilege level with local EXEC authorization."""
        role: str | None
        """EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator"."""
        sha512_password: str | None
        """
        SHA512 Hash of Password.
        Must be the hash of the password. By default EOS salts the password with
        the username, so the simplest is to generate the hash on an EOS device using the same username.
        """
        no_password: bool | None
        """
        If set a password will not be configured for this user. "sha512_password" MUST not be defined for
        this user.
        """
        ssh_key: str | None
        secondary_ssh_key: str | None
        shell: str | None
        """Specify shell for the user."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            privilege: int | None | UndefinedType = Undefined,
            role: str | None | UndefinedType = Undefined,
            sha512_password: str | None | UndefinedType = Undefined,
            no_password: bool | None | UndefinedType = Undefined,
            ssh_key: str | None | UndefinedType = Undefined,
            secondary_ssh_key: str | None | UndefinedType = Undefined,
            shell: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            LocalUsersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Username.
                disabled:
                   If true, the user will be removed and all other settings are ignored.
                   Useful for removing the
                   default "admin" user.
                privilege: Initial privilege level with local EXEC authorization.
                role: EOS RBAC Role to be assigned to the user such as "network-admin" or "network-operator".
                sha512_password:
                   SHA512 Hash of Password.
                   Must be the hash of the password. By default EOS salts the password with
                   the username, so the simplest is to generate the hash on an EOS device using the same username.
                no_password:
                   If set a password will not be configured for this user. "sha512_password" MUST not be defined for
                   this user.
                ssh_key: ssh_key
                secondary_ssh_key: secondary_ssh_key
                shell: Specify shell for the user.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LocalUsers(AvdCollection[str, LocalUsersItem]):
        _primary_key: ClassVar[str] = "name"

    LocalUsers._item_type = LocalUsersItem

    class Logging(AvdModel):
        class Buffered(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "size": {"type": int}, "level": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            size: int | None
            level: str | None
            """Buffer logging severity level."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                size: int | None | UndefinedType = Undefined,
                level: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Buffered.

                Args:
                -----
                    _custom_data: _custom_data
                    size: size
                    level: Buffer logging severity level.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Synchronous(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str, "default": "critical"}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            level: str | None
            """Synchronous logging severity level."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, level: str | None | UndefinedType = Undefined) -> None:
                """
                Synchronous.

                Args:
                -----
                    _custom_data: _custom_data
                    level: Synchronous logging severity level.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Format(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "timestamp": {"type": str},
                "hostname": {"type": str},
                "sequence_numbers": {"type": bool},
                "rfc5424": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            timestamp: str | None
            """Timestamp format."""
            hostname: str | None
            """Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour)."""
            sequence_numbers: bool | None
            """Add sequence numbers to log messages."""
            rfc5424: bool | None
            """Forward logs in RFC5424 format."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                timestamp: str | None | UndefinedType = Undefined,
                hostname: str | None | UndefinedType = Undefined,
                sequence_numbers: bool | None | UndefinedType = Undefined,
                rfc5424: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Format.

                Args:
                -----
                    _custom_data: _custom_data
                    timestamp: Timestamp format.
                    hostname: Hostname format in syslogs. For hostname _only_, remove the line. (default EOS CLI behaviour).
                    sequence_numbers: Add sequence numbers to log messages.
                    rfc5424: Forward logs in RFC5424 format.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            class HostsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "protocol": {"type": str, "default": "udp"},
                    "ports": {"type": list, "items": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Syslog server name."""
                protocol: str | None
                ports: list[int]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    protocol: str | None | UndefinedType = Undefined,
                    ports: list[int] | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Syslog server name.
                        protocol: protocol
                        ports: ports

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Hosts(AvdCollection[str, HostsItem]):
                _primary_key: ClassVar[str] = "name"

            Hosts._item_type = HostsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "source_interface": {"type": str}, "hosts": {"type": Hosts}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            source_interface: str | None
            """Source interface name."""
            hosts: Hosts

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    source_interface: Source interface name.
                    hosts: hosts

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class Policy(AvdModel):
            class Match(AvdModel):
                class MatchListsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """Match list."""
                    action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchListsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Match list.
                            action: action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MatchLists(AvdCollection[str, MatchListsItem]):
                    _primary_key: ClassVar[str] = "name"

                MatchLists._item_type = MatchListsItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "match_lists": {"type": MatchLists}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                match_lists: MatchLists

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, match_lists: MatchLists | UndefinedType = Undefined) -> None:
                    """
                    Match.

                    Args:
                    -----
                        _custom_data: _custom_data
                        match_lists: match_lists

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "match": {"type": Match}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            match: Match

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, match: Match | UndefinedType = Undefined) -> None:
                """
                Policy.

                Args:
                -----
                    _custom_data: _custom_data
                    match: match

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Event(AvdModel):
            class StormControl(AvdModel):
                class Discards(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "field_global": {"type": bool, "key": "global"}, "interval": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    field_global: bool | None
                    interval: int | None
                    """Logging interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_global: bool | None | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Discards.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_global: field_global
                            interval: Logging interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "discards": {"type": Discards}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                discards: Discards

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, discards: Discards | UndefinedType = Undefined) -> None:
                    """
                    StormControl.

                    Args:
                    -----
                        _custom_data: _custom_data
                        discards: discards

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "congestion_drops_interval": {"type": int},
                "global_link_status": {"type": bool},
                "storm_control": {"type": StormControl},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            congestion_drops_interval: int | None
            """Logging interval in seconds."""
            global_link_status: bool | None
            storm_control: StormControl

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                congestion_drops_interval: int | None | UndefinedType = Undefined,
                global_link_status: bool | None | UndefinedType = Undefined,
                storm_control: StormControl | UndefinedType = Undefined,
            ) -> None:
                """
                Event.

                Args:
                -----
                    _custom_data: _custom_data
                    congestion_drops_interval: Logging interval in seconds.
                    global_link_status: global_link_status
                    storm_control: storm_control

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LevelItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "facility": {"type": str}, "severity": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "facility")
            _custom_data: dict[str, Any]
            facility: str
            severity: str | None
            """
            Severity of facility. Below are the supported severities.
            emergencies    System is unusable
            (severity=0)
            alerts         Immediate action needed           (severity=1)
            critical       Critical
            conditions               (severity=2)
            errors         Error conditions                  (severity=3)
            warnings       Warning conditions                (severity=4)
            notifications  Normal but significant
            conditions (severity=5)
            informational  Informational messages            (severity=6)
            debugging
            Debugging messages                (severity=7)
            <0-7>          Severity level value
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                facility: str | UndefinedType = Undefined,
                severity: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LevelItem.

                Args:
                -----
                    _custom_data: _custom_data
                    facility: facility
                    severity:
                       Severity of facility. Below are the supported severities.
                       emergencies    System is unusable
                       (severity=0)
                       alerts         Immediate action needed           (severity=1)
                       critical       Critical
                       conditions               (severity=2)
                       errors         Error conditions                  (severity=3)
                       warnings       Warning conditions                (severity=4)
                       notifications  Normal but significant
                       conditions (severity=5)
                       informational  Informational messages            (severity=6)
                       debugging
                       Debugging messages                (severity=7)
                       <0-7>          Severity level value

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Level(AvdCollection[str, LevelItem]):
            _primary_key: ClassVar[str] = "facility"

        Level._item_type = LevelItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "console": {"type": str},
            "monitor": {"type": str},
            "buffered": {"type": Buffered},
            "repeat_messages": {"type": bool},
            "trap": {"type": str},
            "synchronous": {"type": Synchronous},
            "format": {"type": Format},
            "facility": {"type": str},
            "source_interface": {"type": str},
            "vrfs": {"type": Vrfs},
            "policy": {"type": Policy},
            "event": {"type": Event},
            "level": {"type": Level},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        console: str | None
        """Console logging severity level."""
        monitor: str | None
        """Monitor logging severity level."""
        buffered: Buffered
        repeat_messages: bool | None
        """Summarize concurrent repeat messages."""
        trap: str | None
        """Trap logging severity level."""
        synchronous: Synchronous
        format: Format
        facility: str | None
        source_interface: str | None
        """Source Interface Name."""
        vrfs: Vrfs
        policy: Policy
        event: Event
        level: Level
        """Configure logging severity."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            console: str | None | UndefinedType = Undefined,
            monitor: str | None | UndefinedType = Undefined,
            buffered: Buffered | UndefinedType = Undefined,
            repeat_messages: bool | None | UndefinedType = Undefined,
            trap: str | None | UndefinedType = Undefined,
            synchronous: Synchronous | UndefinedType = Undefined,
            format: Format | UndefinedType = Undefined,
            facility: str | None | UndefinedType = Undefined,
            source_interface: str | None | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            policy: Policy | UndefinedType = Undefined,
            event: Event | UndefinedType = Undefined,
            level: Level | UndefinedType = Undefined,
        ) -> None:
            """
            Logging.

            Args:
            -----
                _custom_data: _custom_data
                console: Console logging severity level.
                monitor: Monitor logging severity level.
                buffered: buffered
                repeat_messages: Summarize concurrent repeat messages.
                trap: Trap logging severity level.
                synchronous: synchronous
                format: format
                facility: facility
                source_interface: Source Interface Name.
                vrfs: vrfs
                policy: policy
                event: event
                level: Configure logging severity.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LoopbackInterfacesItem(AvdModel):
        class Mpls(AvdModel):
            class Ldp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interface: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interface: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ldp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ldp": {"type": Ldp}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ldp: Ldp

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ldp: Ldp | UndefinedType = Undefined) -> None:
                """
                Mpls.

                Args:
                -----
                    _custom_data: _custom_data
                    ldp: ldp

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NodeSegment(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_index": {"type": int}, "ipv6_index": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4_index: int | None
            ipv6_index: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4_index: int | None | UndefinedType = Undefined,
                ipv6_index: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                NodeSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_index: ipv4_index
                    ipv6_index: ipv6_index

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "vrf": {"type": str},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": list, "items": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ip_proxy_arp": {"type": bool},
            "ospf_area": {"type": str},
            "mpls": {"type": Mpls},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "node_segment": {"type": NodeSegment},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Loopback interface name e.g. "Loopback0"."""
        description: str | None
        shutdown: bool | None
        vrf: str | None
        """VRF name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ip_address_secondaries: list[str]
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        ip_proxy_arp: bool | None
        ospf_area: str | None
        mpls: Mpls
        isis_enable: str | None
        """ISIS instance name."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        node_segment: NodeSegment
        eos_cli: str | None
        """EOS CLI rendered directly on the loopback interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ip_address_secondaries: list[str] | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            ip_proxy_arp: bool | None | UndefinedType = Undefined,
            ospf_area: str | None | UndefinedType = Undefined,
            mpls: Mpls | UndefinedType = Undefined,
            isis_enable: str | None | UndefinedType = Undefined,
            isis_bfd: bool | None | UndefinedType = Undefined,
            isis_passive: bool | None | UndefinedType = Undefined,
            isis_metric: int | None | UndefinedType = Undefined,
            isis_network_point_to_point: bool | None | UndefinedType = Undefined,
            node_segment: NodeSegment | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            LoopbackInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Loopback interface name e.g. "Loopback0".
                description: description
                shutdown: shutdown
                vrf: VRF name.
                ip_address: IPv4_address/Mask.
                ip_address_secondaries: ip_address_secondaries
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                ip_proxy_arp: ip_proxy_arp
                ospf_area: ospf_area
                mpls: mpls
                isis_enable: ISIS instance name.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                node_segment: node_segment
                eos_cli: EOS CLI rendered directly on the loopback interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class LoopbackInterfaces(AvdCollection[str, LoopbackInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    LoopbackInterfaces._item_type = LoopbackInterfacesItem

    class MacAccessListsItem(AvdModel):
        class EntriesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sequence: int | None
            action: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | None | UndefinedType = Undefined,
                action: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EntriesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: sequence
                    action: action

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "entries": {"type": list, "items": EntriesItem},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """MAC Access-list Name."""
        counters_per_entry: bool | None
        entries: list[EntriesItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            entries: list[EntriesItem] | UndefinedType = Undefined,
        ) -> None:
            """
            MacAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: MAC Access-list Name.
                counters_per_entry: counters_per_entry
                entries: entries

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MacAccessLists(AvdCollection[str, MacAccessListsItem]):
        _primary_key: ClassVar[str] = "name"

    MacAccessLists._item_type = MacAccessListsItem

    class MacAddressTable(AvdModel):
        class NotificationHostFlap(AvdModel):
            class Detection(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "window": {"type": int}, "moves": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                window: int | None
                moves: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    window: int | None | UndefinedType = Undefined,
                    moves: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Detection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        window: window
                        moves: moves

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "logging": {"type": bool}, "detection": {"type": Detection}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            logging: bool | None
            detection: Detection

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                logging: bool | None | UndefinedType = Undefined,
                detection: Detection | UndefinedType = Undefined,
            ) -> None:
                """
                NotificationHostFlap.

                Args:
                -----
                    _custom_data: _custom_data
                    logging: logging
                    detection: detection

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "aging_time": {"type": int}, "notification_host_flap": {"type": NotificationHostFlap}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        aging_time: int | None
        """Aging time in seconds."""
        notification_host_flap: NotificationHostFlap

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            aging_time: int | None | UndefinedType = Undefined,
            notification_host_flap: NotificationHostFlap | UndefinedType = Undefined,
        ) -> None:
            """
            MacAddressTable.

            Args:
            -----
                _custom_data: _custom_data
                aging_time: Aging time in seconds.
                notification_host_flap: notification_host_flap

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MacSecurity(AvdModel):
        class License(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "license_name": {"type": str}, "license_key": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "license_name", "license_key")
            _custom_data: dict[str, Any]
            license_name: str
            license_key: str

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                license_name: str | UndefinedType = Undefined,
                license_key: str | UndefinedType = Undefined,
            ) -> None:
                """
                License.

                Args:
                -----
                    _custom_data: _custom_data
                    license_name: license_name
                    license_key: license_key

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdModel):
            class ConnectionKeysItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": str}, "encrypted_key": {"type": str}, "fallback": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                _custom_data: dict[str, Any]
                id: str
                encrypted_key: str | None
                fallback: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: str | UndefinedType = Undefined,
                    encrypted_key: str | None | UndefinedType = Undefined,
                    fallback: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ConnectionKeysItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        encrypted_key: encrypted_key
                        fallback: fallback

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ConnectionKeys(AvdCollection[str, ConnectionKeysItem]):
                _primary_key: ClassVar[str] = "id"

            ConnectionKeys._item_type = ConnectionKeysItem

            class Mka(AvdModel):
                class Session(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rekey_period": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    rekey_period: int | None
                    """Rekey period in seconds."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rekey_period: int | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Session.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rekey_period: Rekey period in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_server_priority": {"type": int}, "session": {"type": Session}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_server_priority: int | None
                session: Session

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_server_priority: int | None | UndefinedType = Undefined,
                    session: Session | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mka.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_server_priority: key_server_priority
                        session: session

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class L2Protocols(AvdModel):
                class EthernetFlowControl(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "mode")
                    _custom_data: dict[str, Any]
                    mode: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | UndefinedType = Undefined) -> None:
                        """
                        EthernetFlowControl.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: mode

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Lldp(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "mode")
                    _custom_data: dict[str, Any]
                    mode: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, mode: str | UndefinedType = Undefined) -> None:
                        """
                        Lldp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: mode

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ethernet_flow_control": {"type": EthernetFlowControl}, "lldp": {"type": Lldp}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ethernet_flow_control: EthernetFlowControl
                lldp: Lldp

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ethernet_flow_control: EthernetFlowControl | UndefinedType = Undefined,
                    lldp: Lldp | UndefinedType = Undefined,
                ) -> None:
                    """
                    L2Protocols.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ethernet_flow_control: ethernet_flow_control
                        lldp: lldp

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrafficUnprotected(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}, "allow_active_sak": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                _custom_data: dict[str, Any]
                action: str
                """Allow/drop the transmit/receive of unprotected traffic."""
                allow_active_sak: bool | None
                """Allow transmit/receive of encrypted traffic using operational SAK and block otherwise."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    allow_active_sak: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrafficUnprotected.

                    Args:
                    -----
                        _custom_data: _custom_data
                        action: Allow/drop the transmit/receive of unprotected traffic.
                        allow_active_sak: Allow transmit/receive of encrypted traffic using operational SAK and block otherwise.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "cipher": {"type": str},
                "connection_keys": {"type": ConnectionKeys},
                "mka": {"type": Mka},
                "sci": {"type": bool},
                "l2_protocols": {"type": L2Protocols},
                "traffic_unprotected": {"type": TrafficUnprotected},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Profile-Name."""
            cipher: str | None
            connection_keys: ConnectionKeys
            mka: Mka
            sci: bool | None
            l2_protocols: L2Protocols
            traffic_unprotected: TrafficUnprotected

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                cipher: str | None | UndefinedType = Undefined,
                connection_keys: ConnectionKeys | UndefinedType = Undefined,
                mka: Mka | UndefinedType = Undefined,
                sci: bool | None | UndefinedType = Undefined,
                l2_protocols: L2Protocols | UndefinedType = Undefined,
                traffic_unprotected: TrafficUnprotected | UndefinedType = Undefined,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Profile-Name.
                    cipher: cipher
                    connection_keys: connection_keys
                    mka: mka
                    sci: sci
                    l2_protocols: l2_protocols
                    traffic_unprotected: traffic_unprotected

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Profiles(AvdCollection[str, ProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "license": {"type": License},
            "fips_restrictions": {"type": bool},
            "profiles": {"type": Profiles},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        license: License
        fips_restrictions: bool | None
        profiles: Profiles

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            license: License | UndefinedType = Undefined,
            fips_restrictions: bool | None | UndefinedType = Undefined,
            profiles: Profiles | UndefinedType = Undefined,
        ) -> None:
            """
            MacSecurity.

            Args:
            -----
                _custom_data: _custom_data
                license: license
                fips_restrictions: fips_restrictions
                profiles: profiles

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Maintenance(AvdModel):
        class InterfaceProfilesItem(AvdModel):
            class RateMonitoring(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "load_interval": {"type": int}, "threshold": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                load_interval: int | None
                """Load Interval in Seconds."""
                threshold: int | None
                """Threshold in kbps."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    load_interval: int | None | UndefinedType = Undefined,
                    threshold: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RateMonitoring.

                    Args:
                    -----
                        _custom_data: _custom_data
                        load_interval: Load Interval in Seconds.
                        threshold: Threshold in kbps.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Shutdown(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "max_delay": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                max_delay: int | None
                """Max delay in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, max_delay: int | None | UndefinedType = Undefined) -> None:
                    """
                    Shutdown.

                    Args:
                    -----
                        _custom_data: _custom_data
                        max_delay: Max delay in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "rate_monitoring": {"type": RateMonitoring},
                "shutdown": {"type": Shutdown},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            rate_monitoring: RateMonitoring
            shutdown: Shutdown

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                rate_monitoring: RateMonitoring | UndefinedType = Undefined,
                shutdown: Shutdown | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    rate_monitoring: rate_monitoring
                    shutdown: shutdown

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class InterfaceProfiles(AvdCollection[str, InterfaceProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        InterfaceProfiles._item_type = InterfaceProfilesItem

        class BgpProfilesItem(AvdModel):
            class Initiator(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "route_map_inout": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                route_map_inout: str | None
                """Route Map."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, route_map_inout: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Initiator.

                    Args:
                    -----
                        _custom_data: _custom_data
                        route_map_inout: Route Map.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "initiator": {"type": Initiator}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """BGP Profile Name."""
            initiator: Initiator

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                initiator: Initiator | UndefinedType = Undefined,
            ) -> None:
                """
                BgpProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: BGP Profile Name.
                    initiator: initiator

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class BgpProfiles(AvdCollection[str, BgpProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        BgpProfiles._item_type = BgpProfilesItem

        class UnitProfilesItem(AvdModel):
            class OnBoot(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "duration": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                duration: int | None
                """On-boot in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, duration: int | None | UndefinedType = Undefined) -> None:
                    """
                    OnBoot.

                    Args:
                    -----
                        _custom_data: _custom_data
                        duration: On-boot in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "on_boot": {"type": OnBoot}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Unit Profile Name."""
            on_boot: OnBoot

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                on_boot: OnBoot | UndefinedType = Undefined,
            ) -> None:
                """
                UnitProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Unit Profile Name.
                    on_boot: on_boot

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UnitProfiles(AvdCollection[str, UnitProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        UnitProfiles._item_type = UnitProfilesItem

        class UnitsItem(AvdModel):
            class Groups(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "bgp_groups": {"type": list, "items": str},
                    "interface_groups": {"type": list, "items": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp_groups: list[str]
                interface_groups: list[str]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp_groups: list[str] | UndefinedType = Undefined,
                    interface_groups: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Groups.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp_groups: bgp_groups
                        interface_groups: interface_groups

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "quiesce": {"type": bool},
                "profile": {"type": str},
                "groups": {"type": Groups},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Unit Name."""
            quiesce: bool | None
            profile: str | None
            """Name of Unit Profile."""
            groups: Groups

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                quiesce: bool | None | UndefinedType = Undefined,
                profile: str | None | UndefinedType = Undefined,
                groups: Groups | UndefinedType = Undefined,
            ) -> None:
                """
                UnitsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Unit Name.
                    quiesce: quiesce
                    profile: Name of Unit Profile.
                    groups: groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Units(AvdCollection[str, UnitsItem]):
            _primary_key: ClassVar[str] = "name"

        Units._item_type = UnitsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "default_interface_profile": {"type": str},
            "default_bgp_profile": {"type": str},
            "default_unit_profile": {"type": str},
            "interface_profiles": {"type": InterfaceProfiles},
            "bgp_profiles": {"type": BgpProfiles},
            "unit_profiles": {"type": UnitProfiles},
            "units": {"type": Units},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        default_interface_profile: str | None
        """Name of default Interface Profile."""
        default_bgp_profile: str | None
        """Name of default BGP Profile."""
        default_unit_profile: str | None
        """Name of default Unit Profile."""
        interface_profiles: InterfaceProfiles
        bgp_profiles: BgpProfiles
        unit_profiles: UnitProfiles
        units: Units

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            default_interface_profile: str | None | UndefinedType = Undefined,
            default_bgp_profile: str | None | UndefinedType = Undefined,
            default_unit_profile: str | None | UndefinedType = Undefined,
            interface_profiles: InterfaceProfiles | UndefinedType = Undefined,
            bgp_profiles: BgpProfiles | UndefinedType = Undefined,
            unit_profiles: UnitProfiles | UndefinedType = Undefined,
            units: Units | UndefinedType = Undefined,
        ) -> None:
            """
            Maintenance.

            Args:
            -----
                _custom_data: _custom_data
                default_interface_profile: Name of default Interface Profile.
                default_bgp_profile: Name of default BGP Profile.
                default_unit_profile: Name of default Unit Profile.
                interface_profiles: interface_profiles
                bgp_profiles: bgp_profiles
                unit_profiles: unit_profiles
                units: units

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementAccounts(AvdModel):
        class Password(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policy": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            policy: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policy: str | None | UndefinedType = Undefined) -> None:
                """
                Password.

                Args:
                -----
                    _custom_data: _custom_data
                    policy: policy

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "password": {"type": Password}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        password: Password

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, password: Password | UndefinedType = Undefined) -> None:
            """
            ManagementAccounts.

            Args:
            -----
                _custom_data: _custom_data
                password: password

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementApiGnmi(AvdModel):
        class Transport(AvdModel):
            class GrpcItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "ssl_profile": {"type": str},
                    "vrf": {"type": str},
                    "notification_timestamp": {"type": str},
                    "ip_access_group": {"type": str},
                    "port": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Transport name."""
                ssl_profile: str | None
                """SSL profile name."""
                vrf: str | None
                """VRF name is optional."""
                notification_timestamp: str | None
                """
                Per the gNMI specification, the default timestamp field of a notification message is set to be
                the
                time at which the value of the underlying data source changes or when the reported event takes
                place.
                In order to facilitate integration in legacy environments oriented around polling style
                operations,
                an option to support overriding the timestamp field to the send-time is available from
                EOS 4.27.0F.
                """
                ip_access_group: str | None
                """ACL name."""
                port: int | None
                """
                GNMI port.
                Make sure to update the control-plane ACL accordingly in order for the service to be
                reachable by external applications.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    notification_timestamp: str | None | UndefinedType = Undefined,
                    ip_access_group: str | None | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    GrpcItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Transport name.
                        ssl_profile: SSL profile name.
                        vrf: VRF name is optional.
                        notification_timestamp:
                           Per the gNMI specification, the default timestamp field of a notification message is set to be
                           the
                           time at which the value of the underlying data source changes or when the reported event takes
                           place.
                           In order to facilitate integration in legacy environments oriented around polling style
                           operations,
                           an option to support overriding the timestamp field to the send-time is available from
                           EOS 4.27.0F.
                        ip_access_group: ACL name.
                        port:
                           GNMI port.
                           Make sure to update the control-plane ACL accordingly in order for the service to be
                           reachable by external applications.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Grpc(AvdCollection[str, GrpcItem]):
                _primary_key: ClassVar[str] = "name"

            Grpc._item_type = GrpcItem

            class GrpcTunnelsItem(AvdModel):
                class Destination(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}, "port": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "address", "port")
                    _custom_data: dict[str, Any]
                    address: str
                    """IP address or hostname."""
                    port: int
                    """TCP Port."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        address: str | UndefinedType = Undefined,
                        port: int | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address: IP address or hostname.
                            port: TCP Port.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class LocalInterface(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "port": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name", "port")
                    _custom_data: dict[str, Any]
                    name: str
                    """Interface name."""
                    port: int
                    """TCP Port."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        port: int | UndefinedType = Undefined,
                    ) -> None:
                        """
                        LocalInterface.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Interface name.
                            port: TCP Port.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Target(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "use_serial_number": {"type": bool}, "target_ids": {"type": list, "items": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    use_serial_number: bool | None
                    """Use serial number as the Target ID."""
                    target_ids: list[str]
                    """Target IDs as a list."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        use_serial_number: bool | None | UndefinedType = Undefined,
                        target_ids: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Target.

                        Args:
                        -----
                            _custom_data: _custom_data
                            use_serial_number: Use serial number as the Target ID.
                            target_ids: Target IDs as a list.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "shutdown": {"type": bool},
                    "tunnel_ssl_profile": {"type": str},
                    "gnmi_ssl_profile": {"type": str},
                    "vrf": {"type": str},
                    "destination": {"type": Destination},
                    "local_interface": {"type": LocalInterface},
                    "target": {"type": Target},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Transport name."""
                shutdown: bool | None
                """Operational status of the gRPC tunnel."""
                tunnel_ssl_profile: str | None
                """Tunnel SSL profile name."""
                gnmi_ssl_profile: str | None
                """gNMI SSL profile name."""
                vrf: str | None
                """VRF name."""
                destination: Destination
                local_interface: LocalInterface
                target: Target

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    tunnel_ssl_profile: str | None | UndefinedType = Undefined,
                    gnmi_ssl_profile: str | None | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    local_interface: LocalInterface | UndefinedType = Undefined,
                    target: Target | UndefinedType = Undefined,
                ) -> None:
                    """
                    GrpcTunnelsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Transport name.
                        shutdown: Operational status of the gRPC tunnel.
                        tunnel_ssl_profile: Tunnel SSL profile name.
                        gnmi_ssl_profile: gNMI SSL profile name.
                        vrf: VRF name.
                        destination: destination
                        local_interface: local_interface
                        target: target

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class GrpcTunnels(AvdCollection[str, GrpcTunnelsItem]):
                _primary_key: ClassVar[str] = "name"

            GrpcTunnels._item_type = GrpcTunnelsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "grpc": {"type": Grpc}, "grpc_tunnels": {"type": GrpcTunnels}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            grpc: Grpc
            grpc_tunnels: GrpcTunnels

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                grpc: Grpc | UndefinedType = Undefined,
                grpc_tunnels: GrpcTunnels | UndefinedType = Undefined,
            ) -> None:
                """
                Transport.

                Args:
                -----
                    _custom_data: _custom_data
                    grpc: grpc
                    grpc_tunnels: grpc_tunnels

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "provider": {"type": str, "default": "eos-native"}, "transport": {"type": Transport}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        provider: str | None
        transport: Transport

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            provider: str | None | UndefinedType = Undefined,
            transport: Transport | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementApiGnmi.

            Args:
            -----
                _custom_data: _custom_data
                provider: provider
                transport: transport

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementApiHttp(AvdModel):
        class EnableVrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "access_group": {"type": str}, "ipv6_access_group": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF Name."""
            access_group: str | None
            """Standard IPv4 ACL name."""
            ipv6_access_group: str | None
            """Standard IPv6 ACL name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                access_group: str | None | UndefinedType = Undefined,
                ipv6_access_group: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EnableVrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    access_group: Standard IPv4 ACL name.
                    ipv6_access_group: Standard IPv6 ACL name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EnableVrfs(AvdCollection[str, EnableVrfsItem]):
            _primary_key: ClassVar[str] = "name"

        EnableVrfs._item_type = EnableVrfsItem

        class ProtocolHttpsCertificate(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "certificate": {"type": str}, "private_key": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            certificate: str | None
            """Name of certificate; private key must also be specified."""
            private_key: str | None
            """Name of private key; certificate must also be specified."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                certificate: str | None | UndefinedType = Undefined,
                private_key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ProtocolHttpsCertificate.

                Args:
                -----
                    _custom_data: _custom_data
                    certificate: Name of certificate; private key must also be specified.
                    private_key: Name of private key; certificate must also be specified.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enable_http": {"type": bool},
            "enable_https": {"type": bool},
            "https_ssl_profile": {"type": str},
            "default_services": {"type": bool},
            "enable_vrfs": {"type": EnableVrfs},
            "protocol_https_certificate": {"type": ProtocolHttpsCertificate},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable_http: bool | None
        enable_https: bool | None
        https_ssl_profile: str | None
        """SSL Profile Name."""
        default_services: bool | None
        """Enable default services: capi-doc and tapagg."""
        enable_vrfs: EnableVrfs
        protocol_https_certificate: ProtocolHttpsCertificate

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enable_http: bool | None | UndefinedType = Undefined,
            enable_https: bool | None | UndefinedType = Undefined,
            https_ssl_profile: str | None | UndefinedType = Undefined,
            default_services: bool | None | UndefinedType = Undefined,
            enable_vrfs: EnableVrfs | UndefinedType = Undefined,
            protocol_https_certificate: ProtocolHttpsCertificate | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementApiHttp.

            Args:
            -----
                _custom_data: _custom_data
                enable_http: enable_http
                enable_https: enable_https
                https_ssl_profile: SSL Profile Name.
                default_services: Enable default services: capi-doc and tapagg.
                enable_vrfs: enable_vrfs
                protocol_https_certificate: protocol_https_certificate

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementApiModels(AvdModel):
        class ProvidersItem(AvdModel):
            class PathsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "path": {"type": str}, "disabled": {"type": bool, "default": False}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                path: str | None
                disabled: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    path: str | None | UndefinedType = Undefined,
                    disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PathsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        path: path
                        disabled: disabled

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "paths": {"type": list, "items": PathsItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            paths: list[PathsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                paths: list[PathsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                ProvidersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    paths: paths

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "providers": {"type": list, "items": ProvidersItem}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        providers: list[ProvidersItem]

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, providers: list[ProvidersItem] | UndefinedType = Undefined) -> None:
            """
            ManagementApiModels.

            Args:
            -----
                _custom_data: _custom_data
                providers: providers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementConsole(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "idle_timeout": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        idle_timeout: int | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, idle_timeout: int | None | UndefinedType = Undefined) -> None:
            """
            ManagementConsole.

            Args:
            -----
                _custom_data: _custom_data
                idle_timeout: idle_timeout

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementCvx(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "shutdown": {"type": bool},
            "server_hosts": {"type": list, "items": str},
            "source_interface": {"type": str},
            "vrf": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        shutdown: bool | None
        server_hosts: list[str]
        source_interface: str | None
        """Interface name."""
        vrf: str | None
        """VRF Name."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            server_hosts: list[str] | UndefinedType = Undefined,
            source_interface: str | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementCvx.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                server_hosts: server_hosts
                source_interface: Interface name.
                vrf: VRF Name.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementDefaults(AvdModel):
        class Secret(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "hash": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            hash: str | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, hash: str | None | UndefinedType = Undefined) -> None:
                """
                Secret.

                Args:
                -----
                    _custom_data: _custom_data
                    hash: hash

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "secret": {"type": Secret}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        secret: Secret

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, secret: Secret | UndefinedType = Undefined) -> None:
            """
            ManagementDefaults.

            Args:
            -----
                _custom_data: _custom_data
                secret: secret

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementInterfacesItem(AvdModel):
        class Lldp(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "transmit": {"type": bool}, "receive": {"type": bool}, "ztp_vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            transmit: bool | None
            receive: bool | None
            ztp_vlan: int | None
            """ZTP vlan number."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                transmit: bool | None | UndefinedType = Undefined,
                receive: bool | None | UndefinedType = Undefined,
                ztp_vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Lldp.

                Args:
                -----
                    _custom_data: _custom_data
                    transmit: transmit
                    receive: receive
                    ztp_vlan: ZTP vlan number.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "speed": {"type": str},
            "mtu": {"type": int},
            "vrf": {"type": str},
            "ip_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "type": {"type": str, "default": "oob"},
            "gateway": {"type": str},
            "ipv6_gateway": {"type": str},
            "mac_address": {"type": str},
            "lldp": {"type": Lldp},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Management Interface Name."""
        description: str | None
        shutdown: bool | None
        speed: str | None
        """
        Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
        <interface_speed>`.
        """
        mtu: int | None
        vrf: str | None
        """VRF Name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        type: str | None
        """For documentation purposes only."""
        gateway: str | None
        """IPv4 address of default gateway in management VRF."""
        ipv6_gateway: str | None
        """IPv6 address of default gateway in management VRF."""
        mac_address: str | None
        """MAC address."""
        lldp: Lldp
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the management interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            speed: str | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            gateway: str | None | UndefinedType = Undefined,
            ipv6_gateway: str | None | UndefinedType = Undefined,
            mac_address: str | None | UndefinedType = Undefined,
            lldp: Lldp | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Management Interface Name.
                description: description
                shutdown: shutdown
                speed:
                   Speed should be set in the format `<interface_speed>` or `forced <interface_speed>` or `auto
                   <interface_speed>`.
                mtu: mtu
                vrf: VRF Name.
                ip_address: IPv4_address/Mask.
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                type: For documentation purposes only.
                gateway: IPv4 address of default gateway in management VRF.
                ipv6_gateway: IPv6 address of default gateway in management VRF.
                mac_address: MAC address.
                lldp: lldp
                eos_cli: Multiline EOS CLI rendered directly on the management interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementInterfaces(AvdCollection[str, ManagementInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    ManagementInterfaces._item_type = ManagementInterfacesItem

    class ManagementSecurity(AvdModel):
        class EntropySources(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "hardware": {"type": bool},
                "haveged": {"type": bool},
                "cpu_jitter": {"type": bool},
                "hardware_exclusive": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            hardware: bool | None
            """Use a hardware based source."""
            haveged: bool | None
            """Use the HAVEGE algorithm."""
            cpu_jitter: bool | None
            """Use the Jitter RNG algorithm of a CPU based source."""
            hardware_exclusive: bool | None
            """Only use entropy from the hardware source."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                hardware: bool | None | UndefinedType = Undefined,
                haveged: bool | None | UndefinedType = Undefined,
                cpu_jitter: bool | None | UndefinedType = Undefined,
                hardware_exclusive: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                EntropySources.

                Args:
                -----
                    _custom_data: _custom_data
                    hardware: Use a hardware based source.
                    haveged: Use the HAVEGE algorithm.
                    cpu_jitter: Use the Jitter RNG algorithm of a CPU based source.
                    hardware_exclusive: Only use entropy from the hardware source.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Password(AvdModel):
            class PoliciesItem(AvdModel):
                class Minimum(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "digits": {"type": int},
                        "length": {"type": int},
                        "lower": {"type": int},
                        "special": {"type": int},
                        "upper": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    digits: int | None
                    length: int | None
                    lower: int | None
                    special: int | None
                    upper: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        digits: int | None | UndefinedType = Undefined,
                        length: int | None | UndefinedType = Undefined,
                        lower: int | None | UndefinedType = Undefined,
                        special: int | None | UndefinedType = Undefined,
                        upper: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Minimum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            digits: digits
                            length: length
                            lower: lower
                            special: special
                            upper: upper

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Maximum(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "repetitive": {"type": int}, "sequential": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    repetitive: int | None
                    sequential: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        repetitive: int | None | UndefinedType = Undefined,
                        sequential: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Maximum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            repetitive: repetitive
                            sequential: sequential

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "minimum": {"type": Minimum}, "maximum": {"type": Maximum}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                minimum: Minimum
                maximum: Maximum

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    minimum: Minimum | UndefinedType = Undefined,
                    maximum: Maximum | UndefinedType = Undefined,
                ) -> None:
                    """
                    PoliciesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        minimum: minimum
                        maximum: maximum

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Policies(AvdCollection[str, PoliciesItem]):
                _primary_key: ClassVar[str] = "name"

            Policies._item_type = PoliciesItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "minimum_length": {"type": int},
                "encryption_key_common": {"type": bool},
                "encryption_reversible": {"type": str},
                "policies": {"type": Policies},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            minimum_length: int | None
            encryption_key_common: bool | None
            encryption_reversible: str | None
            policies: Policies

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                minimum_length: int | None | UndefinedType = Undefined,
                encryption_key_common: bool | None | UndefinedType = Undefined,
                encryption_reversible: str | None | UndefinedType = Undefined,
                policies: Policies | UndefinedType = Undefined,
            ) -> None:
                """
                Password.

                Args:
                -----
                    _custom_data: _custom_data
                    minimum_length: minimum_length
                    encryption_key_common: encryption_key_common
                    encryption_reversible: encryption_reversible
                    policies: policies

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SslProfilesItem(AvdModel):
            class TrustCertificate(AvdModel):
                class Requirement(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "basic_constraint_ca": {"type": bool}, "hostname_fqdn": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    basic_constraint_ca: bool | None
                    hostname_fqdn: bool | None
                    """Enforce hostname to be FQDN without wildcard."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        basic_constraint_ca: bool | None | UndefinedType = Undefined,
                        hostname_fqdn: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Requirement.

                        Args:
                        -----
                            _custom_data: _custom_data
                            basic_constraint_ca: basic_constraint_ca
                            hostname_fqdn: Enforce hostname to be FQDN without wildcard.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "certificates": {"type": list, "items": str},
                    "requirement": {"type": Requirement},
                    "policy_expiry_date_ignore": {"type": bool},
                    "system": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                certificates: list[str]
                """
                List of trust certificate names.
                Examples:
                  - test1.crt
                  - test2.crt
                """
                requirement: Requirement
                policy_expiry_date_ignore: bool | None
                system: bool | None
                """Use system-supplied trust certificates."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    certificates: list[str] | UndefinedType = Undefined,
                    requirement: Requirement | UndefinedType = Undefined,
                    policy_expiry_date_ignore: bool | None | UndefinedType = Undefined,
                    system: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrustCertificate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        certificates:
                           List of trust certificate names.

                    Examples:
                             - test1.crt
                             - test2.crt
                        requirement: requirement
                        policy_expiry_date_ignore: policy_expiry_date_ignore
                        system: Use system-supplied trust certificates.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ChainCertificate(AvdModel):
                class Requirement(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "basic_constraint_ca": {"type": bool}, "include_root_ca": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    basic_constraint_ca: bool | None
                    include_root_ca: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        basic_constraint_ca: bool | None | UndefinedType = Undefined,
                        include_root_ca: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Requirement.

                        Args:
                        -----
                            _custom_data: _custom_data
                            basic_constraint_ca: basic_constraint_ca
                            include_root_ca: include_root_ca

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "certificates": {"type": list, "items": str}, "requirement": {"type": Requirement}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                certificates: list[str]
                """
                List of chain certificate names.
                Examples:
                  - chain1.crt
                  - chain2.crt
                """
                requirement: Requirement

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    certificates: list[str] | UndefinedType = Undefined,
                    requirement: Requirement | UndefinedType = Undefined,
                ) -> None:
                    """
                    ChainCertificate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        certificates:
                           List of chain certificate names.

                    Examples:
                             - chain1.crt
                             - chain2.crt
                        requirement: requirement

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Certificate(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "file": {"type": str}, "key": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                file: str | None
                key: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    file: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Certificate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        file: file
                        key: key

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "tls_versions": {"type": str},
                "cipher_list": {"type": str},
                "trust_certificate": {"type": TrustCertificate},
                "chain_certificate": {"type": ChainCertificate},
                "certificate": {"type": Certificate},
                "certificate_revocation_lists": {"type": list, "items": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            tls_versions: str | None
            """
            List of allowed TLS versions as string.
            Examples:
              - "1.0"
              - "1.0 1.1"
            """
            cipher_list: str | None
            """
            cipher_list syntax follows the openssl cipher strings format.
            Colon (:) separated list of allowed
            ciphers as a string.
            """
            trust_certificate: TrustCertificate
            chain_certificate: ChainCertificate
            certificate: Certificate
            certificate_revocation_lists: list[str]
            """
            List of CRLs (Certificate Revocation List).
            If specified, one CRL needs to be provided for every
            certificate in the chain, even if the revocation list in the CRL is empty.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                tls_versions: str | None | UndefinedType = Undefined,
                cipher_list: str | None | UndefinedType = Undefined,
                trust_certificate: TrustCertificate | UndefinedType = Undefined,
                chain_certificate: ChainCertificate | UndefinedType = Undefined,
                certificate: Certificate | UndefinedType = Undefined,
                certificate_revocation_lists: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                SslProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    tls_versions:
                       List of allowed TLS versions as string.

                Examples:
                         - "1.0"
                         - "1.0 1.1"
                    cipher_list:
                       cipher_list syntax follows the openssl cipher strings format.
                       Colon (:) separated list of allowed
                       ciphers as a string.
                    trust_certificate: trust_certificate
                    chain_certificate: chain_certificate
                    certificate: certificate
                    certificate_revocation_lists:
                       List of CRLs (Certificate Revocation List).
                       If specified, one CRL needs to be provided for every
                       certificate in the chain, even if the revocation list in the CRL is empty.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SharedSecretProfilesItem(AvdModel):
            class SecretsItem(AvdModel):
                class ReceiveLifetime(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "infinite": {"type": bool},
                        "start_date_time": {"type": str},
                        "end_date_time": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    infinite: bool | None
                    start_date_time: str | None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        infinite: bool | None | UndefinedType = Undefined,
                        start_date_time: str | None | UndefinedType = Undefined,
                        end_date_time: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ReceiveLifetime.

                        Args:
                        -----
                            _custom_data: _custom_data
                            infinite: infinite
                            start_date_time:
                               Start date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00
                            end_date_time:
                               End date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class TransmitLifetime(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "infinite": {"type": bool},
                        "start_date_time": {"type": str},
                        "end_date_time": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    infinite: bool | None
                    start_date_time: str | None
                    """
                    Start date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """
                    end_date_time: str | None
                    """
                    End date and time of lifetime of the secret. End date should be greater than start date.
                    Formats
                    supported:
                    1. mm/dd/yyyy hh:mm:ss
                    2. yyyy-mm-dd hh:mm:ss
                    e.g 2024-12-20 10:00:00
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        infinite: bool | None | UndefinedType = Undefined,
                        start_date_time: str | None | UndefinedType = Undefined,
                        end_date_time: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TransmitLifetime.

                        Args:
                        -----
                            _custom_data: _custom_data
                            infinite: infinite
                            start_date_time:
                               Start date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00
                            end_date_time:
                               End date and time of lifetime of the secret. End date should be greater than start date.
                               Formats
                               supported:
                               1. mm/dd/yyyy hh:mm:ss
                               2. yyyy-mm-dd hh:mm:ss
                               e.g 2024-12-20 10:00:00

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "secret": {"type": str},
                    "secret_type": {"type": str, "default": "7"},
                    "receive_lifetime": {"type": ReceiveLifetime},
                    "transmit_lifetime": {"type": TransmitLifetime},
                    "local_time": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name", "secret", "receive_lifetime", "transmit_lifetime")
                _custom_data: dict[str, Any]
                name: str
                secret: str
                secret_type: str | None
                receive_lifetime: ReceiveLifetime
                transmit_lifetime: TransmitLifetime
                local_time: bool | None
                """Configuring secret using the local timezone from system clock. Default is UTC."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    secret: str | UndefinedType = Undefined,
                    secret_type: str | None | UndefinedType = Undefined,
                    receive_lifetime: ReceiveLifetime | UndefinedType = Undefined,
                    transmit_lifetime: TransmitLifetime | UndefinedType = Undefined,
                    local_time: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SecretsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        secret: secret
                        secret_type: secret_type
                        receive_lifetime: receive_lifetime
                        transmit_lifetime: transmit_lifetime
                        local_time: Configuring secret using the local timezone from system clock. Default is UTC.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Secrets(AvdCollection[str, SecretsItem]):
                _primary_key: ClassVar[str] = "name"

            Secrets._item_type = SecretsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "secrets": {"type": Secrets}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "profile")
            _custom_data: dict[str, Any]
            profile: str
            secrets: Secrets

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                profile: str | UndefinedType = Undefined,
                secrets: Secrets | UndefinedType = Undefined,
            ) -> None:
                """
                SharedSecretProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    profile: profile
                    secrets: secrets

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SharedSecretProfiles(AvdCollection[str, SharedSecretProfilesItem]):
            _primary_key: ClassVar[str] = "profile"

        SharedSecretProfiles._item_type = SharedSecretProfilesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "entropy_sources": {"type": EntropySources},
            "password": {"type": Password},
            "ssl_profiles": {"type": list, "items": SslProfilesItem},
            "shared_secret_profiles": {"type": SharedSecretProfiles},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        entropy_sources: EntropySources
        """Source of entropy."""
        password: Password
        ssl_profiles: list[SslProfilesItem]
        shared_secret_profiles: SharedSecretProfiles

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            entropy_sources: EntropySources | UndefinedType = Undefined,
            password: Password | UndefinedType = Undefined,
            ssl_profiles: list[SslProfilesItem] | UndefinedType = Undefined,
            shared_secret_profiles: SharedSecretProfiles | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementSecurity.

            Args:
            -----
                _custom_data: _custom_data
                entropy_sources: Source of entropy.
                password: password
                ssl_profiles: ssl_profiles
                shared_secret_profiles: shared_secret_profiles

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementSsh(AvdModel):
        class Authentication(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "empty_passwords": {"type": str}, "protocols": {"type": list, "items": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            empty_passwords: str | None
            """Permit or deny empty passwords for SSH authentication."""
            protocols: list[str]
            """Allowed SSH authentication methods."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                empty_passwords: str | None | UndefinedType = Undefined,
                protocols: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                Authentication.

                Args:
                -----
                    _custom_data: _custom_data
                    empty_passwords: Permit or deny empty passwords for SSH authentication.
                    protocols: Allowed SSH authentication methods.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AccessGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Standard ACL Name."""
            vrf: str | None
            """VRF Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                AccessGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Standard ACL Name.
                    vrf: VRF Name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AccessGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Standard ACL Name."""
            vrf: str | None
            """VRF Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6AccessGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Standard ACL Name.
                    vrf: VRF Name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hostkey(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "server": {"type": list, "items": str},
                "server_cert": {"type": str},
                "client_strict_checking": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            server: list[str]
            """SSH host key settings."""
            server_cert: str | None
            """Configure switch's hostkey cert file."""
            client_strict_checking: bool | None
            """Enforce strict host key checking."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                server: list[str] | UndefinedType = Undefined,
                server_cert: str | None | UndefinedType = Undefined,
                client_strict_checking: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Hostkey.

                Args:
                -----
                    _custom_data: _custom_data
                    server: SSH host key settings.
                    server_cert: Configure switch's hostkey cert file.
                    client_strict_checking: Enforce strict host key checking.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Connection(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "limit": {"type": int}, "per_host": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            limit: int | None
            """Maximum total number of SSH sessions to device."""
            per_host: int | None
            """Maximum number of SSH sessions to device from a single host."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                limit: int | None | UndefinedType = Undefined,
                per_host: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Connection.

                Args:
                -----
                    _custom_data: _custom_data
                    limit: Maximum total number of SSH sessions to device.
                    per_host: Maximum number of SSH sessions to device from a single host.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enable": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF Name."""
            enable: bool | None
            """Enable SSH in VRF."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    enable: Enable SSH in VRF.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ClientAlive(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count_max": {"type": int}, "interval": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            count_max: int | None
            """
            Number of keep-alive packets that can be sent without a response before the connection is assumed
            dead.
            """
            interval: int | None
            """Time period (in seconds) to send SSH keep-alive packets."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                count_max: int | None | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                ClientAlive.

                Args:
                -----
                    _custom_data: _custom_data
                    count_max:
                       Number of keep-alive packets that can be sent without a response before the connection is assumed
                       dead.
                    interval: Time period (in seconds) to send SSH keep-alive packets.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "authentication": {"type": Authentication},
            "access_groups": {"type": list, "items": AccessGroupsItem},
            "ipv6_access_groups": {"type": list, "items": Ipv6AccessGroupsItem},
            "idle_timeout": {"type": int},
            "cipher": {"type": list, "items": str},
            "key_exchange": {"type": list, "items": str},
            "mac": {"type": list, "items": str},
            "fips_restrictions": {"type": bool},
            "hostkey": {"type": Hostkey},
            "enable": {"type": bool},
            "connection": {"type": Connection},
            "vrfs": {"type": Vrfs},
            "log_level": {"type": str},
            "client_alive": {"type": ClientAlive},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        authentication: Authentication
        access_groups: list[AccessGroupsItem]
        ipv6_access_groups: list[Ipv6AccessGroupsItem]
        idle_timeout: int | None
        """Idle timeout in minutes."""
        cipher: list[str]
        """Cryptographic ciphers for SSH to use."""
        key_exchange: list[str]
        """Cryptographic key exchange methods for SSH to use."""
        mac: list[str]
        """Cryptographic MAC algorithms for SSH to use."""
        fips_restrictions: bool | None
        """Use FIPS compliant algorithms."""
        hostkey: Hostkey
        enable: bool | None
        """Enable SSH daemon."""
        connection: Connection
        vrfs: Vrfs
        log_level: str | None
        """SSH daemon log level."""
        client_alive: ClientAlive

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            authentication: Authentication | UndefinedType = Undefined,
            access_groups: list[AccessGroupsItem] | UndefinedType = Undefined,
            ipv6_access_groups: list[Ipv6AccessGroupsItem] | UndefinedType = Undefined,
            idle_timeout: int | None | UndefinedType = Undefined,
            cipher: list[str] | UndefinedType = Undefined,
            key_exchange: list[str] | UndefinedType = Undefined,
            mac: list[str] | UndefinedType = Undefined,
            fips_restrictions: bool | None | UndefinedType = Undefined,
            hostkey: Hostkey | UndefinedType = Undefined,
            enable: bool | None | UndefinedType = Undefined,
            connection: Connection | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            log_level: str | None | UndefinedType = Undefined,
            client_alive: ClientAlive | UndefinedType = Undefined,
        ) -> None:
            """
            ManagementSsh.

            Args:
            -----
                _custom_data: _custom_data
                authentication: authentication
                access_groups: access_groups
                ipv6_access_groups: ipv6_access_groups
                idle_timeout: Idle timeout in minutes.
                cipher: Cryptographic ciphers for SSH to use.
                key_exchange: Cryptographic key exchange methods for SSH to use.
                mac: Cryptographic MAC algorithms for SSH to use.
                fips_restrictions: Use FIPS compliant algorithms.
                hostkey: hostkey
                enable: Enable SSH daemon.
                connection: connection
                vrfs: vrfs
                log_level: SSH daemon log level.
                client_alive: client_alive

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ManagementTechSupport(AvdModel):
        class PolicyShowTechSupport(AvdModel):
            class ExcludeCommandsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "command": {"type": str}, "type": {"type": str, "default": "text"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                command: str | None
                """Command to exclude from tech-support."""
                type: str | None
                """The supported values for type are platform dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    command: str | None | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ExcludeCommandsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        command: Command to exclude from tech-support.
                        type: The supported values for type are platform dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class IncludeCommandsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "command": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                command: str | None
                """Command to include in tech-support."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, command: str | None | UndefinedType = Undefined) -> None:
                    """
                    IncludeCommandsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        command: Command to include in tech-support.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "exclude_commands": {"type": list, "items": ExcludeCommandsItem},
                "include_commands": {"type": list, "items": IncludeCommandsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            exclude_commands: list[ExcludeCommandsItem]
            include_commands: list[IncludeCommandsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                exclude_commands: list[ExcludeCommandsItem] | UndefinedType = Undefined,
                include_commands: list[IncludeCommandsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                PolicyShowTechSupport.

                Args:
                -----
                    _custom_data: _custom_data
                    exclude_commands: exclude_commands
                    include_commands: include_commands

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policy_show_tech_support": {"type": PolicyShowTechSupport}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        policy_show_tech_support: PolicyShowTechSupport

        def __init__(
            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, policy_show_tech_support: PolicyShowTechSupport | UndefinedType = Undefined
        ) -> None:
            """
            ManagementTechSupport.

            Args:
            -----
                _custom_data: _custom_data
                policy_show_tech_support: policy_show_tech_support

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MatchListInput(AvdModel):
        class PrefixIpv4Item(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "prefixes": {"type": list, "items": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "prefixes")
            _custom_data: dict[str, Any]
            name: str
            """Prefix-List Name."""
            prefixes: list[str]
            """List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24)."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                prefixes: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                PrefixIpv4Item.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Prefix-List Name.
                    prefixes: List of IPv4 prefixes (with the subnet mask e.g. 192.0.2.0/24).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PrefixIpv4(AvdCollection[str, PrefixIpv4Item]):
            _primary_key: ClassVar[str] = "name"

        PrefixIpv4._item_type = PrefixIpv4Item

        class PrefixIpv6Item(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "prefixes": {"type": list, "items": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "prefixes")
            _custom_data: dict[str, Any]
            name: str
            """Prefix-List Name."""
            prefixes: list[str]
            """List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64)."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                prefixes: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                PrefixIpv6Item.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Prefix-List Name.
                    prefixes: List of IPv6 prefixes (with the subnet mask e.g. 2001:db8:abcd:0013::/64).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PrefixIpv6(AvdCollection[str, PrefixIpv6Item]):
            _primary_key: ClassVar[str] = "name"

        PrefixIpv6._item_type = PrefixIpv6Item

        class StringItem(AvdModel):
            class SequenceNumbersItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "match_regex": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "match_regex")
                _custom_data: dict[str, Any]
                sequence: int
                """Sequence ID."""
                match_regex: str
                """Regular Expression."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    sequence: int | UndefinedType = Undefined,
                    match_regex: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        sequence: Sequence ID.
                        match_regex: Regular Expression.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
                _primary_key: ClassVar[str] = "sequence"

            SequenceNumbers._item_type = SequenceNumbersItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
            _custom_data: dict[str, Any]
            name: str
            """Match-list Name."""
            sequence_numbers: SequenceNumbers

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
            ) -> None:
                """
                StringItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Match-list Name.
                    sequence_numbers: sequence_numbers

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class String(AvdCollection[str, StringItem]):
            _primary_key: ClassVar[str] = "name"

        String._item_type = StringItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "prefix_ipv4": {"type": PrefixIpv4},
            "prefix_ipv6": {"type": PrefixIpv6},
            "string": {"type": String},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        prefix_ipv4: PrefixIpv4
        prefix_ipv6: PrefixIpv6
        string: String

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            prefix_ipv4: PrefixIpv4 | UndefinedType = Undefined,
            prefix_ipv6: PrefixIpv6 | UndefinedType = Undefined,
            string: String | UndefinedType = Undefined,
        ) -> None:
            """
            MatchListInput.

            Args:
            -----
                _custom_data: _custom_data
                prefix_ipv4: prefix_ipv4
                prefix_ipv6: prefix_ipv6
                string: string

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class McsClient(AvdModel):
        class CvxSecondary(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "shutdown": {"type": bool},
                "server_hosts": {"type": list, "items": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            shutdown: bool | None
            server_hosts: list[str]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                server_hosts: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                CvxSecondary.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    shutdown: shutdown
                    server_hosts: server_hosts

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "shutdown": {"type": bool}, "cvx_secondary": {"type": CvxSecondary}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        shutdown: bool | None
        cvx_secondary: CvxSecondary

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            cvx_secondary: CvxSecondary | UndefinedType = Undefined,
        ) -> None:
            """
            McsClient.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                cvx_secondary: cvx_secondary

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Metadata(AvdModel):
        class CvTags(AvdModel):
            class DeviceTagsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "value": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name", "value")
                _custom_data: dict[str, Any]
                name: str
                value: str

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    value: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    DeviceTagsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        value: value

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InterfaceTagsItem(AvdModel):
                class TagsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "value": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name", "value")
                    _custom_data: dict[str, Any]
                    name: str
                    value: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        value: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TagsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            value: value

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": str}, "tags": {"type": list, "items": TagsItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "interface")
                _custom_data: dict[str, Any]
                interface: str
                tags: list[TagsItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interface: str | UndefinedType = Undefined,
                    tags: list[TagsItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfaceTagsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface
                        tags: tags

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "device_tags": {"type": list, "items": DeviceTagsItem},
                "interface_tags": {"type": list, "items": InterfaceTagsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            device_tags: list[DeviceTagsItem]
            interface_tags: list[InterfaceTagsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                device_tags: list[DeviceTagsItem] | UndefinedType = Undefined,
                interface_tags: list[InterfaceTagsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                CvTags.

                Args:
                -----
                    _custom_data: _custom_data
                    device_tags: device_tags
                    interface_tags: interface_tags

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CvPathfinder(AvdModel):
            class PathfindersItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vtep_ip": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "vtep_ip")
                _custom_data: dict[str, Any]
                vtep_ip: str

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, vtep_ip: str | UndefinedType = Undefined) -> None:
                    """
                    PathfindersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        vtep_ip: vtep_ip

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InterfacesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "carrier": {"type": str},
                    "circuit_id": {"type": str},
                    "pathgroup": {"type": str},
                    "public_ip": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                carrier: str | None
                circuit_id: str | None
                pathgroup: str | None
                public_ip: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    carrier: str | None | UndefinedType = Undefined,
                    circuit_id: str | None | UndefinedType = Undefined,
                    pathgroup: str | None | UndefinedType = Undefined,
                    public_ip: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        carrier: carrier
                        circuit_id: circuit_id
                        pathgroup: pathgroup
                        public_ip: public_ip

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PathgroupsItem(AvdModel):
                class CarriersItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    name: str | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                        """
                        CarriersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ImportedCarriersItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    name: str | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                        """
                        ImportedCarriersItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "carriers": {"type": list, "items": CarriersItem},
                    "imported_carriers": {"type": list, "items": ImportedCarriersItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                carriers: list[CarriersItem]
                imported_carriers: list[ImportedCarriersItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    carriers: list[CarriersItem] | UndefinedType = Undefined,
                    imported_carriers: list[ImportedCarriersItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    PathgroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        carriers: carriers
                        imported_carriers: imported_carriers

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RegionsItem(AvdModel):
                class ZonesItem(AvdModel):
                    class SitesItem(AvdModel):
                        class Location(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            address: str | None

                            def __init__(
                                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, address: str | None | UndefinedType = Undefined
                            ) -> None:
                                """
                                Location.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    address: address

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "name": {"type": str}, "location": {"type": Location}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        id: int | None
                        name: str | None
                        location: Location

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            id: int | None | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            location: Location | UndefinedType = Undefined,
                        ) -> None:
                            """
                            SitesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: id
                                name: name
                                location: location

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "name": {"type": str},
                        "sites": {"type": list, "items": SitesItem},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    id: int | None
                    name: str | None
                    sites: list[SitesItem]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        sites: list[SitesItem] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ZonesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: id
                            name: name
                            sites: sites

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "id": {"type": int},
                    "name": {"type": str},
                    "zones": {"type": list, "items": ZonesItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                id: int | None
                name: str | None
                zones: list[ZonesItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: int | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    zones: list[ZonesItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RegionsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        name: name
                        zones: zones

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class VrfsItem(AvdModel):
                class AvtsItem(AvdModel):
                    class Constraints(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "jitter": {"type": int},
                            "latency": {"type": int},
                            "lossrate": {"type": str},
                            "hop_count": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        jitter: int | None
                        latency: int | None
                        lossrate: str | None
                        hop_count: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            jitter: int | None | UndefinedType = Undefined,
                            latency: int | None | UndefinedType = Undefined,
                            lossrate: str | None | UndefinedType = Undefined,
                            hop_count: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Constraints.

                            Args:
                            -----
                                _custom_data: _custom_data
                                jitter: jitter
                                latency: latency
                                lossrate: lossrate
                                hop_count: hop_count

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class PathgroupsItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "preference": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        name: str | None
                        preference: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            preference: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PathgroupsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                preference: preference

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "constraints": {"type": Constraints},
                        "description": {"type": str},
                        "id": {"type": int},
                        "name": {"type": str},
                        "pathgroups": {"type": list, "items": PathgroupsItem},
                        "application_profiles": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    constraints: Constraints
                    description: str | None
                    id: int | None
                    name: str | None
                    pathgroups: list[PathgroupsItem]
                    application_profiles: list[str]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        constraints: Constraints | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        id: int | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        pathgroups: list[PathgroupsItem] | UndefinedType = Undefined,
                        application_profiles: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AvtsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            constraints: constraints
                            description: description
                            id: id
                            name: name
                            pathgroups: pathgroups
                            application_profiles: application_profiles

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "vni": {"type": int},
                    "avts": {"type": list, "items": AvtsItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                vni: int | None
                avts: list[AvtsItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    vni: int | None | UndefinedType = Undefined,
                    avts: list[AvtsItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VrfsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        vni: vni
                        avts: avts

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class InternetExitPoliciesItem(AvdModel):
                class VpnCredentialsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "fqdn": {"type": str},
                        "vpn_type": {"type": str},
                        "pre_shared_key": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "fqdn", "vpn_type", "pre_shared_key")
                    _custom_data: dict[str, Any]
                    fqdn: str
                    vpn_type: str
                    pre_shared_key: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        fqdn: str | UndefinedType = Undefined,
                        vpn_type: str | UndefinedType = Undefined,
                        pre_shared_key: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VpnCredentialsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            fqdn: fqdn
                            vpn_type: vpn_type
                            pre_shared_key: pre_shared_key

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class TunnelsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "preference": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name", "preference")
                    _custom_data: dict[str, Any]
                    name: str
                    preference: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        preference: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TunnelsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            preference: preference

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "type": {"type": str},
                    "city": {"type": str},
                    "country": {"type": str},
                    "upload_bandwidth": {"type": int},
                    "download_bandwidth": {"type": int},
                    "firewall": {"type": bool},
                    "ips_control": {"type": bool},
                    "acceptable_use_policy": {"type": bool},
                    "vpn_credentials": {"type": list, "items": VpnCredentialsItem},
                    "tunnels": {"type": list, "items": TunnelsItem},
                }
                _required_fields: ClassVar[tuple] = (
                    "_custom_data",
                    "name",
                    "type",
                    "city",
                    "country",
                    "firewall",
                    "ips_control",
                    "acceptable_use_policy",
                    "vpn_credentials",
                    "tunnels",
                )
                _custom_data: dict[str, Any]
                name: str
                type: str
                city: str
                country: str
                upload_bandwidth: int | None
                download_bandwidth: int | None
                firewall: bool
                ips_control: bool
                acceptable_use_policy: bool
                vpn_credentials: list[VpnCredentialsItem]
                tunnels: list[TunnelsItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    type: str | UndefinedType = Undefined,
                    city: str | UndefinedType = Undefined,
                    country: str | UndefinedType = Undefined,
                    upload_bandwidth: int | None | UndefinedType = Undefined,
                    download_bandwidth: int | None | UndefinedType = Undefined,
                    firewall: bool | UndefinedType = Undefined,
                    ips_control: bool | UndefinedType = Undefined,
                    acceptable_use_policy: bool | UndefinedType = Undefined,
                    vpn_credentials: list[VpnCredentialsItem] | UndefinedType = Undefined,
                    tunnels: list[TunnelsItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    InternetExitPoliciesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        type: type
                        city: city
                        country: country
                        upload_bandwidth: upload_bandwidth
                        download_bandwidth: download_bandwidth
                        firewall: firewall
                        ips_control: ips_control
                        acceptable_use_policy: acceptable_use_policy
                        vpn_credentials: vpn_credentials
                        tunnels: tunnels

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Applications(AvdModel):
                class ProfilesItem(AvdModel):
                    class BuiltinApplicationsItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "services": {"type": list, "items": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        name: str | None
                        services: list[str]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            services: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BuiltinApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                services: services

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UserDefinedApplicationsItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        name: str | None

                        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                            """
                            UserDefinedApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class CategoriesItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "category": {"type": str}, "services": {"type": list, "items": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        category: str | None
                        services: list[str]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            category: str | None | UndefinedType = Undefined,
                            services: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            CategoriesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                category: category
                                services: services

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "builtin_applications": {"type": list, "items": BuiltinApplicationsItem},
                        "user_defined_applications": {"type": list, "items": UserDefinedApplicationsItem},
                        "categories": {"type": list, "items": CategoriesItem},
                        "transport_protocols": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    name: str | None
                    builtin_applications: list[BuiltinApplicationsItem]
                    user_defined_applications: list[UserDefinedApplicationsItem]
                    categories: list[CategoriesItem]
                    transport_protocols: list[str]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        builtin_applications: list[BuiltinApplicationsItem] | UndefinedType = Undefined,
                        user_defined_applications: list[UserDefinedApplicationsItem] | UndefinedType = Undefined,
                        categories: list[CategoriesItem] | UndefinedType = Undefined,
                        transport_protocols: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProfilesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            builtin_applications: builtin_applications
                            user_defined_applications: user_defined_applications
                            categories: categories
                            transport_protocols: transport_protocols

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Categories(AvdModel):
                    class BuiltinApplicationsItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "name": {"type": str},
                            "category": {"type": str},
                            "services": {"type": list, "items": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        name: str | None
                        category: str | None
                        services: list[str]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            category: str | None | UndefinedType = Undefined,
                            services: list[str] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            BuiltinApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                category: category
                                services: services

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UserDefinedApplicationsItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "category": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        name: str | None
                        category: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            name: str | None | UndefinedType = Undefined,
                            category: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            UserDefinedApplicationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                name: name
                                category: category

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "builtin_applications": {"type": list, "items": BuiltinApplicationsItem},
                        "user_defined_applications": {"type": list, "items": UserDefinedApplicationsItem},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    builtin_applications: list[BuiltinApplicationsItem]
                    user_defined_applications: list[UserDefinedApplicationsItem]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        builtin_applications: list[BuiltinApplicationsItem] | UndefinedType = Undefined,
                        user_defined_applications: list[UserDefinedApplicationsItem] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Categories.

                        Args:
                        -----
                            _custom_data: _custom_data
                            builtin_applications: builtin_applications
                            user_defined_applications: user_defined_applications

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "profiles": {"type": list, "items": ProfilesItem},
                    "categories": {"type": Categories},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                profiles: list[ProfilesItem]
                categories: Categories

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    profiles: list[ProfilesItem] | UndefinedType = Undefined,
                    categories: Categories | UndefinedType = Undefined,
                ) -> None:
                    """
                    Applications.

                    Args:
                    -----
                        _custom_data: _custom_data
                        profiles: profiles
                        categories: categories

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "role": {"type": str},
                "region": {"type": str},
                "zone": {"type": str},
                "site": {"type": str},
                "vtep_ip": {"type": str},
                "ssl_profile": {"type": str},
                "address": {"type": str},
                "pathfinders": {"type": list, "items": PathfindersItem},
                "interfaces": {"type": list, "items": InterfacesItem},
                "pathgroups": {"type": list, "items": PathgroupsItem},
                "regions": {"type": list, "items": RegionsItem},
                "vrfs": {"type": list, "items": VrfsItem},
                "internet_exit_policies": {"type": list, "items": InternetExitPoliciesItem},
                "applications": {"type": Applications},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            role: str | None
            region: str | None
            zone: str | None
            site: str | None
            vtep_ip: str | None
            ssl_profile: str | None
            address: str | None
            pathfinders: list[PathfindersItem]
            interfaces: list[InterfacesItem]
            pathgroups: list[PathgroupsItem]
            regions: list[RegionsItem]
            vrfs: list[VrfsItem]
            internet_exit_policies: list[InternetExitPoliciesItem]
            applications: Applications

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                region: str | None | UndefinedType = Undefined,
                zone: str | None | UndefinedType = Undefined,
                site: str | None | UndefinedType = Undefined,
                vtep_ip: str | None | UndefinedType = Undefined,
                ssl_profile: str | None | UndefinedType = Undefined,
                address: str | None | UndefinedType = Undefined,
                pathfinders: list[PathfindersItem] | UndefinedType = Undefined,
                interfaces: list[InterfacesItem] | UndefinedType = Undefined,
                pathgroups: list[PathgroupsItem] | UndefinedType = Undefined,
                regions: list[RegionsItem] | UndefinedType = Undefined,
                vrfs: list[VrfsItem] | UndefinedType = Undefined,
                internet_exit_policies: list[InternetExitPoliciesItem] | UndefinedType = Undefined,
                applications: Applications | UndefinedType = Undefined,
            ) -> None:
                """
                CvPathfinder.

                Args:
                -----
                    _custom_data: _custom_data
                    role: role
                    region: region
                    zone: zone
                    site: site
                    vtep_ip: vtep_ip
                    ssl_profile: ssl_profile
                    address: address
                    pathfinders: pathfinders
                    interfaces: interfaces
                    pathgroups: pathgroups
                    regions: regions
                    vrfs: vrfs
                    internet_exit_policies: internet_exit_policies
                    applications: applications

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "platform": {"type": str},
            "system_mac_address": {"type": str},
            "cv_tags": {"type": CvTags},
            "cv_pathfinder": {"type": CvPathfinder},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        platform: str | None
        system_mac_address: str | None
        cv_tags: CvTags
        cv_pathfinder: CvPathfinder
        """Metadata used for CV Pathfinder visualization on CloudVision."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            platform: str | None | UndefinedType = Undefined,
            system_mac_address: str | None | UndefinedType = Undefined,
            cv_tags: CvTags | UndefinedType = Undefined,
            cv_pathfinder: CvPathfinder | UndefinedType = Undefined,
        ) -> None:
            """
            Metadata.

            Args:
            -----
                _custom_data: _custom_data
                platform: platform
                system_mac_address: system_mac_address
                cv_tags: cv_tags
                cv_pathfinder: Metadata used for CV Pathfinder visualization on CloudVision.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MlagConfiguration(AvdModel):
        class PeerAddressHeartbeat(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "peer_ip": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            peer_ip: str | None
            """IPv4 or IPv6 Address."""
            vrf: str | None
            """VRF Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                peer_ip: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                PeerAddressHeartbeat.

                Args:
                -----
                    _custom_data: _custom_data
                    peer_ip: IPv4 or IPv6 Address.
                    vrf: VRF Name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "domain_id": {"type": str},
            "heartbeat_interval": {"type": int},
            "local_interface": {"type": str},
            "peer_address": {"type": str},
            "peer_address_heartbeat": {"type": PeerAddressHeartbeat},
            "dual_primary_detection_delay": {"type": int},
            "dual_primary_recovery_delay_mlag": {"type": int},
            "dual_primary_recovery_delay_non_mlag": {"type": int},
            "peer_link": {"type": str},
            "reload_delay_mlag": {"type": str},
            "reload_delay_non_mlag": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        domain_id: str | None
        heartbeat_interval: int | None
        """Heartbeat interval in milliseconds."""
        local_interface: str | None
        """Local Interface Name."""
        peer_address: str | None
        """IPv4 or IPv6 Address."""
        peer_address_heartbeat: PeerAddressHeartbeat
        dual_primary_detection_delay: int | None
        """Delay in seconds."""
        dual_primary_recovery_delay_mlag: int | None
        """Delay in seconds."""
        dual_primary_recovery_delay_non_mlag: int | None
        """Delay in seconds."""
        peer_link: str | None
        """Port-Channel interface name."""
        reload_delay_mlag: str | None
        """Delay in seconds <0-86400> or 'infinity'."""
        reload_delay_non_mlag: str | None
        """Delay in seconds <0-86400> or 'infinity'."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            domain_id: str | None | UndefinedType = Undefined,
            heartbeat_interval: int | None | UndefinedType = Undefined,
            local_interface: str | None | UndefinedType = Undefined,
            peer_address: str | None | UndefinedType = Undefined,
            peer_address_heartbeat: PeerAddressHeartbeat | UndefinedType = Undefined,
            dual_primary_detection_delay: int | None | UndefinedType = Undefined,
            dual_primary_recovery_delay_mlag: int | None | UndefinedType = Undefined,
            dual_primary_recovery_delay_non_mlag: int | None | UndefinedType = Undefined,
            peer_link: str | None | UndefinedType = Undefined,
            reload_delay_mlag: str | None | UndefinedType = Undefined,
            reload_delay_non_mlag: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            MlagConfiguration.

            Args:
            -----
                _custom_data: _custom_data
                domain_id: domain_id
                heartbeat_interval: Heartbeat interval in milliseconds.
                local_interface: Local Interface Name.
                peer_address: IPv4 or IPv6 Address.
                peer_address_heartbeat: peer_address_heartbeat
                dual_primary_detection_delay: Delay in seconds.
                dual_primary_recovery_delay_mlag: Delay in seconds.
                dual_primary_recovery_delay_non_mlag: Delay in seconds.
                peer_link: Port-Channel interface name.
                reload_delay_mlag: Delay in seconds <0-86400> or 'infinity'.
                reload_delay_non_mlag: Delay in seconds <0-86400> or 'infinity'.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorConnectivity(AvdModel):
        class InterfaceSetsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "interfaces": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            interfaces: str | None
            """
            Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
            Multiple interface
            ranges can be specified separated by ",".
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                interfaces: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                InterfaceSetsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    interfaces:
                       Interface range(s) should be of same type, Ethernet, Loopback, Management etc.
                       Multiple interface
                       ranges can be specified separated by ",".

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "description": {"type": str},
                "ip": {"type": str},
                "local_interfaces": {"type": str},
                "address_only": {"type": bool, "default": True},
                "url": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Host Name."""
            description: str | None
            ip: str | None
            local_interfaces: str | None
            address_only: bool | None
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.
            """
            url: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                ip: str | None | UndefinedType = Undefined,
                local_interfaces: str | None | UndefinedType = Undefined,
                address_only: bool | None | UndefinedType = Undefined,
                url: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Host Name.
                    description: description
                    ip: ip
                    local_interfaces: local_interfaces
                    address_only:
                       When address-only is configured, the source IP of the packet is set to the interface
                       IP but the
                       packet may exit the device via a different interface.
                       When set to `false`, the probe uses the
                       interface to exit the device.
                    url: url

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hosts(AvdCollection[str, HostsItem]):
            _primary_key: ClassVar[str] = "name"

        Hosts._item_type = HostsItem

        class VrfsItem(AvdModel):
            class InterfaceSetsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "interfaces": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                interfaces: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    interfaces: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    InterfaceSetsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        interfaces: interfaces

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class HostsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "description": {"type": str},
                    "ip": {"type": str},
                    "local_interfaces": {"type": str},
                    "address_only": {"type": bool, "default": True},
                    "url": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Host name."""
                description: str | None
                ip: str | None
                local_interfaces: str | None
                address_only: bool | None
                """
                When address-only is configured, the source IP of the packet is set to the interface
                IP but the
                packet may exit the device via a different interface.
                When set to `false`, the probe uses the
                interface to exit the device.
                """
                url: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    ip: str | None | UndefinedType = Undefined,
                    local_interfaces: str | None | UndefinedType = Undefined,
                    address_only: bool | None | UndefinedType = Undefined,
                    url: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    HostsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Host name.
                        description: description
                        ip: ip
                        local_interfaces: local_interfaces
                        address_only:
                           When address-only is configured, the source IP of the packet is set to the interface
                           IP but the
                           packet may exit the device via a different interface.
                           When set to `false`, the probe uses the
                           interface to exit the device.
                        url: url

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Hosts(AvdCollection[str, HostsItem]):
                _primary_key: ClassVar[str] = "name"

            Hosts._item_type = HostsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "description": {"type": str},
                "interface_sets": {"type": list, "items": InterfaceSetsItem},
                "local_interfaces": {"type": str},
                "address_only": {"type": bool, "default": True},
                "hosts": {"type": Hosts},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF Name."""
            description: str | None
            interface_sets: list[InterfaceSetsItem]
            local_interfaces: str | None
            address_only: bool | None
            """
            When address-only is configured, the source IP of the packet is set to the interface
            IP but the
            packet may exit the device via a different interface.
            When set to `false`, the probe uses the
            interface to exit the device.
            """
            hosts: Hosts

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                interface_sets: list[InterfaceSetsItem] | UndefinedType = Undefined,
                local_interfaces: str | None | UndefinedType = Undefined,
                address_only: bool | None | UndefinedType = Undefined,
                hosts: Hosts | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    description: description
                    interface_sets: interface_sets
                    local_interfaces: local_interfaces
                    address_only:
                       When address-only is configured, the source IP of the packet is set to the interface
                       IP but the
                       packet may exit the device via a different interface.
                       When set to `false`, the probe uses the
                       interface to exit the device.
                    hosts: hosts

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "shutdown": {"type": bool},
            "interval": {"type": int},
            "interface_sets": {"type": list, "items": InterfaceSetsItem},
            "local_interfaces": {"type": str},
            "address_only": {"type": bool, "default": True},
            "hosts": {"type": Hosts},
            "vrfs": {"type": Vrfs},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        shutdown: bool | None
        interval: int | None
        interface_sets: list[InterfaceSetsItem]
        local_interfaces: str | None
        address_only: bool | None
        """
        When address-only is configured, the source IP of the packet is set to the interface
        IP but the
        packet may exit the device via a different interface.
        When set to `false`, the probe uses the
        interface to exit the device.
        """
        hosts: Hosts
        vrfs: Vrfs

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            interval: int | None | UndefinedType = Undefined,
            interface_sets: list[InterfaceSetsItem] | UndefinedType = Undefined,
            local_interfaces: str | None | UndefinedType = Undefined,
            address_only: bool | None | UndefinedType = Undefined,
            hosts: Hosts | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            MonitorConnectivity.

            Args:
            -----
                _custom_data: _custom_data
                shutdown: shutdown
                interval: interval
                interface_sets: interface_sets
                local_interfaces: local_interfaces
                address_only:
                   When address-only is configured, the source IP of the packet is set to the interface
                   IP but the
                   packet may exit the device via a different interface.
                   When set to `false`, the probe uses the
                   interface to exit the device.
                hosts: hosts
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorLayer1(AvdModel):
        class LoggingTransceiver(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dom": {"type": bool}, "communication": {"type": bool}, "enabled": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            dom: bool | None
            """Enable transceiver Digital Optical Monitoring (DOM) logging."""
            communication: bool | None
            """Enable transceiver SMBus fail and reset logging."""
            enabled: bool | None
            """
            Some platforms support only the `logging transceiver` command. `enabled` key configures this
            command.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                dom: bool | None | UndefinedType = Undefined,
                communication: bool | None | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                LoggingTransceiver.

                Args:
                -----
                    _custom_data: _custom_data
                    dom: Enable transceiver Digital Optical Monitoring (DOM) logging.
                    communication: Enable transceiver SMBus fail and reset logging.
                    enabled:
                       Some platforms support only the `logging transceiver` command. `enabled` key configures this
                       command.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool},
            "logging_mac_fault": {"type": bool},
            "logging_transceiver": {"type": LoggingTransceiver},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
        _custom_data: dict[str, Any]
        enabled: bool
        """Enable monitor layer1."""
        logging_mac_fault: bool | None
        """Enable MAC fault logging."""
        logging_transceiver: LoggingTransceiver
        """Configure transceiver monitoring logging."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | UndefinedType = Undefined,
            logging_mac_fault: bool | None | UndefinedType = Undefined,
            logging_transceiver: LoggingTransceiver | UndefinedType = Undefined,
        ) -> None:
            """
            MonitorLayer1.

            Args:
            -----
                _custom_data: _custom_data
                enabled: Enable monitor layer1.
                logging_mac_fault: Enable MAC fault logging.
                logging_transceiver: Configure transceiver monitoring logging.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorSessionDefaultEncapsulationGre(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "payload": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        payload: str | None
        """Mirroring GRE payload type configuration commands."""

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, payload: str | None | UndefinedType = Undefined) -> None:
            """
            MonitorSessionDefaultEncapsulationGre.

            Args:
            -----
                _custom_data: _custom_data
                payload: Mirroring GRE payload type configuration commands.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorSessionsItem(AvdModel):
        class SourcesItem(AvdModel):
            class AccessGroup(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}, "priority": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                type: str | None
                name: str | None
                """ACL Name."""
                priority: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    priority: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AccessGroup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        type: type
                        name: ACL Name.
                        priority: priority

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "direction": {"type": str}, "access_group": {"type": AccessGroup}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Interface name, range or comma separated list."""
            direction: str | None
            access_group: AccessGroup

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
                access_group: AccessGroup | UndefinedType = Undefined,
            ) -> None:
                """
                SourcesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Interface name, range or comma separated list.
                    direction: direction
                    access_group: access_group

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AccessGroup(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "name": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            type: str | None
            name: str | None
            """ACL Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                type: str | None | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                AccessGroup.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    name: ACL Name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Truncate(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "size": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            size: int | None
            """Size in bytes."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                size: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Truncate.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    size: Size in bytes.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "sources": {"type": list, "items": SourcesItem},
            "destinations": {"type": list, "items": str},
            "encapsulation_gre_metadata_tx": {"type": bool},
            "header_remove_size": {"type": int},
            "access_group": {"type": AccessGroup},
            "rate_limit_per_ingress_chip": {"type": str},
            "rate_limit_per_egress_chip": {"type": str},
            "sample": {"type": int},
            "truncate": {"type": Truncate},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Session Name."""
        sources: list[SourcesItem]
        destinations: list[str]
        encapsulation_gre_metadata_tx: bool | None
        header_remove_size: int | None
        """Number of bytes to remove from header."""
        access_group: AccessGroup
        rate_limit_per_ingress_chip: str | None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        rate_limit_per_egress_chip: str | None
        """
        Ratelimit and unit as string.
        Examples:
          "100000 bps"
          "100 kbps"
          "10 mbps"
        """
        sample: int | None
        truncate: Truncate

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sources: list[SourcesItem] | UndefinedType = Undefined,
            destinations: list[str] | UndefinedType = Undefined,
            encapsulation_gre_metadata_tx: bool | None | UndefinedType = Undefined,
            header_remove_size: int | None | UndefinedType = Undefined,
            access_group: AccessGroup | UndefinedType = Undefined,
            rate_limit_per_ingress_chip: str | None | UndefinedType = Undefined,
            rate_limit_per_egress_chip: str | None | UndefinedType = Undefined,
            sample: int | None | UndefinedType = Undefined,
            truncate: Truncate | UndefinedType = Undefined,
        ) -> None:
            """
            MonitorSessionsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Session Name.
                sources: sources
                destinations: destinations
                encapsulation_gre_metadata_tx: encapsulation_gre_metadata_tx
                header_remove_size: Number of bytes to remove from header.
                access_group: access_group
                rate_limit_per_ingress_chip:
                   Ratelimit and unit as string.

            Examples:
                     "100000 bps"
                     "100 kbps"
                     "10 mbps"
                rate_limit_per_egress_chip:
                   Ratelimit and unit as string.

            Examples:
                     "100000 bps"
                     "100 kbps"
                     "10 mbps"
                sample: sample
                truncate: truncate

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorTelemetryInflux(AvdModel):
        class DestinationsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "database": {"type": str},
                "data_retention_policy": {"type": str},
                "url": {"type": str},
                "username": {"type": str},
                "password": {"type": str},
                "password_type": {"type": str, "default": "7"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """InfluxDB connection name."""
            database: str | None
            """Set name of the database."""
            data_retention_policy: str | None
            url: str | None
            """It only accepts http(s), udp and unix domain destination URL."""
            username: str | None
            password: str | None
            password_type: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                database: str | None | UndefinedType = Undefined,
                data_retention_policy: str | None | UndefinedType = Undefined,
                url: str | None | UndefinedType = Undefined,
                username: str | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                password_type: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: InfluxDB connection name.
                    database: Set name of the database.
                    data_retention_policy: data_retention_policy
                    url: It only accepts http(s), udp and unix domain destination URL.
                    username: username
                    password: password
                    password_type: password_type

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Destinations(AvdCollection[str, DestinationsItem]):
            _primary_key: ClassVar[str] = "name"

        Destinations._item_type = DestinationsItem

        class SourceSocketsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "connection_limit": {"type": int}, "url": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Label of the socket connection."""
            connection_limit: int | None
            url: str | None
            """It only accepts http(s), udp and unix domain socket URL."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                connection_limit: int | None | UndefinedType = Undefined,
                url: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                SourceSocketsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Label of the socket connection.
                    connection_limit: connection_limit
                    url: It only accepts http(s), udp and unix domain socket URL.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SourceSockets(AvdCollection[str, SourceSocketsItem]):
            _primary_key: ClassVar[str] = "name"

        SourceSockets._item_type = SourceSocketsItem

        class TagsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "value": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "value")
            _custom_data: dict[str, Any]
            name: str
            """Key of the global tag pair."""
            value: str
            """Value of the global tag pair."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, value: str | UndefinedType = Undefined
            ) -> None:
                """
                TagsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Key of the global tag pair.
                    value: Value of the global tag pair.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Tags(AvdCollection[str, TagsItem]):
            _primary_key: ClassVar[str] = "name"

        Tags._item_type = TagsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "vrf": {"type": str},
            "destinations": {"type": Destinations},
            "source_group_standard_disabled": {"type": bool},
            "source_sockets": {"type": SourceSockets},
            "tags": {"type": Tags},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        vrf: str | None
        destinations: Destinations
        """Configure telemetry output destinations."""
        source_group_standard_disabled: bool | None
        """Disable standard set of telemetry."""
        source_sockets: SourceSockets
        tags: Tags
        """Extra tags added to the telemetry output."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            destinations: Destinations | UndefinedType = Undefined,
            source_group_standard_disabled: bool | None | UndefinedType = Undefined,
            source_sockets: SourceSockets | UndefinedType = Undefined,
            tags: Tags | UndefinedType = Undefined,
        ) -> None:
            """
            MonitorTelemetryInflux.

            Args:
            -----
                _custom_data: _custom_data
                vrf: vrf
                destinations: Configure telemetry output destinations.
                source_group_standard_disabled: Disable standard set of telemetry.
                source_sockets: source_sockets
                tags: Extra tags added to the telemetry output.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class MonitorTelemetryPostcardPolicy(AvdModel):
        class Ingress(AvdModel):
            class Collection(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}, "destination": {"type": str}, "version": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                source: str | None
                """Source IP address of GRE tunnel."""
                destination: str | None
                """Destination IP address of GRE tunnel."""
                version: int | None
                """Postcard version."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source: str | None | UndefinedType = Undefined,
                    destination: str | None | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Collection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source: Source IP address of GRE tunnel.
                        destination: Destination IP address of GRE tunnel.
                        version: Postcard version.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Sample(AvdModel):
                class TcpUdpChecksum(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "value": {"type": int}, "mask": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    value: int | None
                    """TCP/UDP checksum or IP ID value."""
                    mask: str | None
                    """16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        value: int | None | UndefinedType = Undefined,
                        mask: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        TcpUdpChecksum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            value: TCP/UDP checksum or IP ID value.
                            mask: 16 bit hexadecimal mask for TCP/UDP or IP ID with at most 2 unset bits.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": int}, "tcp_udp_checksum": {"type": TcpUdpChecksum}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                rate: int | None
                """Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined."""
                tcp_udp_checksum: TcpUdpChecksum
                """TCP/UDP parameters."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    rate: int | None | UndefinedType = Undefined,
                    tcp_udp_checksum: TcpUdpChecksum | UndefinedType = Undefined,
                ) -> None:
                    """
                    Sample.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate: Sampling rate. `rate` is preferred when both `rate` and `tcp_udp_checksum` are defined.
                        tcp_udp_checksum: TCP/UDP parameters.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "collection": {"type": Collection}, "sample": {"type": Sample}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            collection: Collection
            """Collector configuration."""
            sample: Sample
            """Sampling parameters."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                collection: Collection | UndefinedType = Undefined,
                sample: Sample | UndefinedType = Undefined,
            ) -> None:
                """
                Ingress.

                Args:
                -----
                    _custom_data: _custom_data
                    collection: Collector configuration.
                    sample: Sampling parameters.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MarkerVxlan(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "header_word_zero_bit": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            """Enable vxlan marking using default bit 0."""
            header_word_zero_bit: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                header_word_zero_bit: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                MarkerVxlan.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Enable vxlan marking using default bit 0.
                    header_word_zero_bit: header_word_zero_bit

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "ingress_sample_policy": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Profile name."""
            ingress_sample_policy: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                ingress_sample_policy: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Profile name.
                    ingress_sample_policy: ingress_sample_policy

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Profiles(AvdCollection[str, ProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class SamplePoliciesItem(AvdModel):
            class MatchRulesItem(AvdModel):
                class ProtocolsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "protocol": {"type": str},
                        "source_ports": {"type": list, "items": str},
                        "destination_ports": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "protocol")
                    _custom_data: dict[str, Any]
                    protocol: str
                    source_ports: list[str]
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      [ "12", "14-20"
                    ]
                      [ "www" ]
                    """
                    destination_ports: list[str]
                    """
                    A list of port numbers or port range or port name. Combination of port numbers or range and port
                    name is not supported on EOS. The port numbers should be in range of 0-65535.
                    e.g.
                      [ "12",
                    "14-20", "80" ]
                      [ "https" ]
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        protocol: str | UndefinedType = Undefined,
                        source_ports: list[str] | UndefinedType = Undefined,
                        destination_ports: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProtocolsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            protocol: protocol
                            source_ports:
                               A list of port numbers or port range or port name. Combination of port numbers or range and port
                               name is not supported on EOS. The port numbers should be in range of 0-65535.
                               e.g.
                                 [ "12", "14-20"
                               ]
                                 [ "www" ]
                            destination_ports:
                               A list of port numbers or port range or port name. Combination of port numbers or range and port
                               name is not supported on EOS. The port numbers should be in range of 0-65535.
                               e.g.
                                 [ "12",
                               "14-20", "80" ]
                                 [ "https" ]

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Protocols(AvdCollection[str, ProtocolsItem]):
                    _primary_key: ClassVar[str] = "protocol"

                Protocols._item_type = ProtocolsItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "type": {"type": str},
                    "destination_prefix": {"type": str},
                    "source_prefix": {"type": str},
                    "protocols": {"type": Protocols},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name", "type")
                _custom_data: dict[str, Any]
                name: str
                type: str
                """IP address version."""
                destination_prefix: str | None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                source_prefix: str | None
                """
                IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                eg. 10.3.3.0/24
                """
                protocols: Protocols

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    type: str | UndefinedType = Undefined,
                    destination_prefix: str | None | UndefinedType = Undefined,
                    source_prefix: str | None | UndefinedType = Undefined,
                    protocols: Protocols | UndefinedType = Undefined,
                ) -> None:
                    """
                    MatchRulesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        type: IP address version.
                        destination_prefix:
                           IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                           eg. 10.3.3.0/24
                        source_prefix:
                           IPv4 Network/Mask or IPv6 Network/Mask. Host part of prefix must be zero.
                           eg. 10.3.3.0/24
                        protocols: protocols

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MatchRules(AvdCollection[str, MatchRulesItem]):
                _primary_key: ClassVar[str] = "name"

            MatchRules._item_type = MatchRulesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "match_rules": {"type": MatchRules}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            match_rules: MatchRules

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                match_rules: MatchRules | UndefinedType = Undefined,
            ) -> None:
                """
                SamplePoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    match_rules: match_rules

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SamplePolicies(AvdCollection[str, SamplePoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        SamplePolicies._item_type = SamplePoliciesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "disabled": {"type": bool, "default": True},
            "ingress": {"type": Ingress},
            "marker_vxlan": {"type": MarkerVxlan},
            "profiles": {"type": Profiles},
            "sample_policies": {"type": SamplePolicies},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        disabled: bool | None
        """Enable or disable the postcard telemetry feature."""
        ingress: Ingress
        marker_vxlan: MarkerVxlan
        profiles: Profiles
        """Postcard telemetry profiles."""
        sample_policies: SamplePolicies

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            disabled: bool | None | UndefinedType = Undefined,
            ingress: Ingress | UndefinedType = Undefined,
            marker_vxlan: MarkerVxlan | UndefinedType = Undefined,
            profiles: Profiles | UndefinedType = Undefined,
            sample_policies: SamplePolicies | UndefinedType = Undefined,
        ) -> None:
            """
            MonitorTelemetryPostcardPolicy.

            Args:
            -----
                _custom_data: _custom_data
                disabled: Enable or disable the postcard telemetry feature.
                ingress: ingress
                marker_vxlan: marker_vxlan
                profiles: Postcard telemetry profiles.
                sample_policies: sample_policies

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Mpls(AvdModel):
        class Ldp(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "interface_disabled_default": {"type": bool},
                "router_id": {"type": str},
                "shutdown": {"type": bool},
                "transport_address_interface": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interface_disabled_default: bool | None
            router_id: str | None
            shutdown: bool | None
            transport_address_interface: str | None
            """Interface Name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interface_disabled_default: bool | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                transport_address_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ldp.

                Args:
                -----
                    _custom_data: _custom_data
                    interface_disabled_default: interface_disabled_default
                    router_id: router_id
                    shutdown: shutdown
                    transport_address_interface: Interface Name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Icmp(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "fragmentation_needed_tunneling": {"type": bool},
                "ttl_exceeded_tunneling": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            fragmentation_needed_tunneling: bool | None
            """Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big)."""
            ttl_exceeded_tunneling: bool | None
            """Enables the MPLS tunneling of TTL exceeded ICMP replies."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                fragmentation_needed_tunneling: bool | None | UndefinedType = Undefined,
                ttl_exceeded_tunneling: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Icmp.

                Args:
                -----
                    _custom_data: _custom_data
                    fragmentation_needed_tunneling: Enables the MPLS tunneling of MTU exceeded ICMP replies (fragmentation needed, packet too big).
                    ttl_exceeded_tunneling: Enables the MPLS tunneling of TTL exceeded ICMP replies.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip": {"type": bool}, "ldp": {"type": Ldp}, "icmp": {"type": Icmp}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        ip: bool | None
        ldp: Ldp
        icmp: Icmp
        """Enables the LSRs to generate ICMP reply messages and deliver them to the originating host."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ip: bool | None | UndefinedType = Undefined,
            ldp: Ldp | UndefinedType = Undefined,
            icmp: Icmp | UndefinedType = Undefined,
        ) -> None:
            """
            Mpls.

            Args:
            -----
                _custom_data: _custom_data
                ip: ip
                ldp: ldp
                icmp: Enables the LSRs to generate ICMP reply messages and deliver them to the originating host.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ntp(AvdModel):
        class LocalInterface(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Source interface."""
            vrf: str | None
            """VRF name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LocalInterface.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Source interface.
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServersItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "burst": {"type": bool},
                "iburst": {"type": bool},
                "key": {"type": int},
                "local_interface": {"type": str},
                "maxpoll": {"type": int},
                "minpoll": {"type": int},
                "preferred": {"type": bool},
                "version": {"type": int},
                "vrf": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org."""
            burst: bool | None
            iburst: bool | None
            key: int | None
            local_interface: str | None
            """Source interface."""
            maxpoll: int | None
            """Value of maxpoll between 3 - 17 (Logarithmic)."""
            minpoll: int | None
            """Value of minpoll between 3 - 17 (Logarithmic)."""
            preferred: bool | None
            version: int | None
            vrf: str | None
            """VRF name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                burst: bool | None | UndefinedType = Undefined,
                iburst: bool | None | UndefinedType = Undefined,
                key: int | None | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                maxpoll: int | None | UndefinedType = Undefined,
                minpoll: int | None | UndefinedType = Undefined,
                preferred: bool | None | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ServersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IP or hostname e.g., 2.2.2.55, 2001:db8::55, ie.pool.ntp.org.
                    burst: burst
                    iburst: iburst
                    key: key
                    local_interface: Source interface.
                    maxpoll: Value of maxpoll between 3 - 17 (Logarithmic).
                    minpoll: Value of minpoll between 3 - 17 (Logarithmic).
                    preferred: preferred
                    version: version
                    vrf: VRF name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AuthenticationKeysItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "hash_algorithm": {"type": str},
                "key": {"type": str},
                "key_type": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """Key identifier."""
            hash_algorithm: str | None
            key: str | None
            """Obfuscated key."""
            key_type: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
                key_type: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                AuthenticationKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: Key identifier.
                    hash_algorithm: hash_algorithm
                    key: Obfuscated key.
                    key_type: key_type

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AuthenticationKeys(AvdCollection[int, AuthenticationKeysItem]):
            _primary_key: ClassVar[str] = "id"

        AuthenticationKeys._item_type = AuthenticationKeysItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "local_interface": {"type": LocalInterface},
            "servers": {"type": list, "items": ServersItem},
            "authenticate": {"type": bool},
            "authenticate_servers_only": {"type": bool},
            "authentication_keys": {"type": AuthenticationKeys},
            "trusted_keys": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        local_interface: LocalInterface
        servers: list[ServersItem]
        authenticate: bool | None
        authenticate_servers_only: bool | None
        authentication_keys: AuthenticationKeys
        trusted_keys: str | None
        """List of trusted-keys as string ex. 10-12,15."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            local_interface: LocalInterface | UndefinedType = Undefined,
            servers: list[ServersItem] | UndefinedType = Undefined,
            authenticate: bool | None | UndefinedType = Undefined,
            authenticate_servers_only: bool | None | UndefinedType = Undefined,
            authentication_keys: AuthenticationKeys | UndefinedType = Undefined,
            trusted_keys: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            Ntp.

            Args:
            -----
                _custom_data: _custom_data
                local_interface: local_interface
                servers: servers
                authenticate: authenticate
                authenticate_servers_only: authenticate_servers_only
                authentication_keys: authentication_keys
                trusted_keys: List of trusted-keys as string ex. 10-12,15.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PatchPanel(AvdModel):
        class Connector(AvdModel):
            class Interface(AvdModel):
                class Patch(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "bgp_vpws_remote_failure_errdisable": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    bgp_vpws_remote_failure_errdisable: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        bgp_vpws_remote_failure_errdisable: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Patch.

                        Args:
                        -----
                            _custom_data: _custom_data
                            bgp_vpws_remote_failure_errdisable: bgp_vpws_remote_failure_errdisable

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Recovery(AvdModel):
                    class ReviewDelay(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "min": {"type": int}, "max": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "min", "max")
                        _custom_data: dict[str, Any]
                        min: int
                        """Minimum delay."""
                        max: int
                        """Maximum delay."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            min: int | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                        ) -> None:
                            """
                            ReviewDelay.

                            Args:
                            -----
                                _custom_data: _custom_data
                                min: Minimum delay.
                                max: Maximum delay.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "review_delay": {"type": ReviewDelay}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    review_delay: ReviewDelay

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, review_delay: ReviewDelay | UndefinedType = Undefined
                    ) -> None:
                        """
                        Recovery.

                        Args:
                        -----
                            _custom_data: _custom_data
                            review_delay: review_delay

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "patch": {"type": Patch}, "recovery": {"type": Recovery}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                patch: Patch
                recovery: Recovery

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    patch: Patch | UndefinedType = Undefined,
                    recovery: Recovery | UndefinedType = Undefined,
                ) -> None:
                    """
                    Interface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        patch: patch
                        recovery: recovery

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": Interface}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interface: Interface

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interface: Interface | UndefinedType = Undefined) -> None:
                """
                Connector.

                Args:
                -----
                    _custom_data: _custom_data
                    interface: interface

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PatchesItem(AvdModel):
            class ConnectorsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": str}, "type": {"type": str}, "endpoint": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "id", "type", "endpoint")
                _custom_data: dict[str, Any]
                id: str
                type: str
                endpoint: str
                """
                String with relevant endpoint depending on type.
                Examples:
                - "Ethernet1"
                - "Ethernet1 dot1q vlan
                123"
                - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                - "ldp LDP_PW_1"
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: str | UndefinedType = Undefined,
                    type: str | UndefinedType = Undefined,
                    endpoint: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    ConnectorsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        type: type
                        endpoint:
                           String with relevant endpoint depending on type.

                    Examples:
                           - "Ethernet1"
                           - "Ethernet1 dot1q vlan
                           123"
                           - "bgp vpws TENANT_A pseudowire VPWS_PW_1"
                           - "ldp LDP_PW_1"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Connectors(AvdCollection[str, ConnectorsItem]):
                _primary_key: ClassVar[str] = "id"

            Connectors._item_type = ConnectorsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enabled": {"type": bool}, "connectors": {"type": Connectors}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            enabled: bool | None
            connectors: Connectors
            """Must have exactly two connectors to a patch of which at least one must be of type "interface"."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                connectors: Connectors | UndefinedType = Undefined,
            ) -> None:
                """
                PatchesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    enabled: enabled
                    connectors: Must have exactly two connectors to a patch of which at least one must be of type "interface".

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Patches(AvdCollection[str, PatchesItem]):
            _primary_key: ClassVar[str] = "name"

        Patches._item_type = PatchesItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "connector": {"type": Connector}, "patches": {"type": Patches}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        connector: Connector
        patches: Patches

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            connector: Connector | UndefinedType = Undefined,
            patches: Patches | UndefinedType = Undefined,
        ) -> None:
            """
            PatchPanel.

            Args:
            -----
                _custom_data: _custom_data
                connector: connector
                patches: patches

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PeerFiltersItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "match": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "match")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            match: str
            """
            Match as string.
            Example: "as-range 1-100 result accept"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                match: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    match:
                       Match as string.
                       Example: "as-range 1-100 result accept"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Peer-filter Name."""
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            PeerFiltersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Peer-filter Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PeerFilters(AvdCollection[str, PeerFiltersItem]):
        _primary_key: ClassVar[str] = "name"

    PeerFilters._item_type = PeerFiltersItem

    class Platform(AvdModel):
        class Trident(AvdModel):
            class L3(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "routing_mac_address_per_vlan": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                routing_mac_address_per_vlan: bool | None
                """Enable bridging of packets with destination MAC being a Router MAC in VLANs without routing."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, routing_mac_address_per_vlan: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    L3.

                    Args:
                    -----
                        _custom_data: _custom_data
                        routing_mac_address_per_vlan: Enable bridging of packets with destination MAC being a Router MAC in VLANs without routing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Mmu(AvdModel):
                class QueueProfilesItem(AvdModel):
                    class MulticastQueuesItem(AvdModel):
                        class Drop(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "precedence": {"type": int}, "threshold": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "precedence", "threshold")
                            _custom_data: dict[str, Any]
                            precedence: int
                            threshold: str
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                precedence: int | UndefinedType = Undefined,
                                threshold: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Drop.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    precedence: precedence
                                    threshold:
                                       Drop Threshold. This value may also be fractions.
                                       Example: 7/8 or 3/4 or 1/2

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "id": {"type": int},
                            "unit": {"type": str},
                            "reserved": {"type": int},
                            "threshold": {"type": str},
                            "drop": {"type": Drop},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                        _custom_data: dict[str, Any]
                        id: int
                        unit: str | None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: str | None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            id: int | UndefinedType = Undefined,
                            unit: str | None | UndefinedType = Undefined,
                            reserved: int | None | UndefinedType = Undefined,
                            threshold: str | None | UndefinedType = Undefined,
                            drop: Drop | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MulticastQueuesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: id
                                unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                reserved:
                                   Amount of memory that should be reserved for this
                                   queue.
                                threshold: Dynamic Shared Memory threshold.
                                drop: drop

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MulticastQueues(AvdCollection[int, MulticastQueuesItem]):
                        _primary_key: ClassVar[str] = "id"

                    MulticastQueues._item_type = MulticastQueuesItem

                    class UnicastQueuesItem(AvdModel):
                        class Drop(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "precedence": {"type": int}, "threshold": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "precedence", "threshold")
                            _custom_data: dict[str, Any]
                            precedence: int
                            threshold: str
                            """
                            Drop Threshold. This value may also be fractions.
                            Example: 7/8 or 3/4 or 1/2
                            """

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                precedence: int | UndefinedType = Undefined,
                                threshold: str | UndefinedType = Undefined,
                            ) -> None:
                                """
                                Drop.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    precedence: precedence
                                    threshold:
                                       Drop Threshold. This value may also be fractions.
                                       Example: 7/8 or 3/4 or 1/2

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "id": {"type": int},
                            "unit": {"type": str},
                            "reserved": {"type": int},
                            "threshold": {"type": str},
                            "drop": {"type": Drop},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                        _custom_data: dict[str, Any]
                        id: int
                        unit: str | None
                        """Unit to be used for the reservation value. If not specified, default is bytes."""
                        reserved: int | None
                        """
                        Amount of memory that should be reserved for this
                        queue.
                        """
                        threshold: str | None
                        """Dynamic Shared Memory threshold."""
                        drop: Drop

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            id: int | UndefinedType = Undefined,
                            unit: str | None | UndefinedType = Undefined,
                            reserved: int | None | UndefinedType = Undefined,
                            threshold: str | None | UndefinedType = Undefined,
                            drop: Drop | UndefinedType = Undefined,
                        ) -> None:
                            """
                            UnicastQueuesItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                id: id
                                unit: Unit to be used for the reservation value. If not specified, default is bytes.
                                reserved:
                                   Amount of memory that should be reserved for this
                                   queue.
                                threshold: Dynamic Shared Memory threshold.
                                drop: drop

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class UnicastQueues(AvdCollection[int, UnicastQueuesItem]):
                        _primary_key: ClassVar[str] = "id"

                    UnicastQueues._item_type = UnicastQueuesItem

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "name": {"type": str},
                        "multicast_queues": {"type": MulticastQueues},
                        "unicast_queues": {"type": UnicastQueues},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    multicast_queues: MulticastQueues
                    unicast_queues: UnicastQueues

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        multicast_queues: MulticastQueues | UndefinedType = Undefined,
                        unicast_queues: UnicastQueues | UndefinedType = Undefined,
                    ) -> None:
                        """
                        QueueProfilesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: name
                            multicast_queues: multicast_queues
                            unicast_queues: unicast_queues

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class QueueProfiles(AvdCollection[str, QueueProfilesItem]):
                    _primary_key: ClassVar[str] = "name"

                QueueProfiles._item_type = QueueProfilesItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "active_profile": {"type": str}, "queue_profiles": {"type": QueueProfiles}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                active_profile: str | None
                """The queue profile to be applied to the platform."""
                queue_profiles: QueueProfiles

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    active_profile: str | None | UndefinedType = Undefined,
                    queue_profiles: QueueProfiles | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mmu.

                    Args:
                    -----
                        _custom_data: _custom_data
                        active_profile: The queue profile to be applied to the platform.
                        queue_profiles: queue_profiles

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "forwarding_table_partition": {"type": str}, "l3": {"type": L3}, "mmu": {"type": Mmu}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            forwarding_table_partition: str | None
            l3: L3
            mmu: Mmu
            """Memory Management Unit settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                forwarding_table_partition: str | None | UndefinedType = Undefined,
                l3: L3 | UndefinedType = Undefined,
                mmu: Mmu | UndefinedType = Undefined,
            ) -> None:
                """
                Trident.

                Args:
                -----
                    _custom_data: _custom_data
                    forwarding_table_partition: forwarding_table_partition
                    l3: l3
                    mmu: Memory Management Unit settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sand(AvdModel):
            class QosMapsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "traffic_class": {"type": int}, "to_network_qos": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                traffic_class: int | None
                to_network_qos: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    traffic_class: int | None | UndefinedType = Undefined,
                    to_network_qos: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    QosMapsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        traffic_class: traffic_class
                        to_network_qos: to_network_qos

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Lag(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "hardware_only": {"type": bool}, "mode": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                hardware_only: bool | None
                mode: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    hardware_only: bool | None | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Lag.

                    Args:
                    -----
                        _custom_data: _custom_data
                        hardware_only: hardware_only
                        mode: mode

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MulticastReplication(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                default: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: str | None | UndefinedType = Undefined) -> None:
                    """
                    MulticastReplication.

                    Args:
                    -----
                        _custom_data: _custom_data
                        default: default

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "qos_maps": {"type": list, "items": QosMapsItem},
                "lag": {"type": Lag},
                "forwarding_mode": {"type": str},
                "multicast_replication": {"type": MulticastReplication},
                "mdb_profile": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            qos_maps: list[QosMapsItem]
            lag: Lag
            forwarding_mode: str | None
            multicast_replication: MulticastReplication
            mdb_profile: str | None
            """Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                qos_maps: list[QosMapsItem] | UndefinedType = Undefined,
                lag: Lag | UndefinedType = Undefined,
                forwarding_mode: str | None | UndefinedType = Undefined,
                multicast_replication: MulticastReplication | UndefinedType = Undefined,
                mdb_profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Sand.

                Args:
                -----
                    _custom_data: _custom_data
                    qos_maps: qos_maps
                    lag: lag
                    forwarding_mode: forwarding_mode
                    multicast_replication: multicast_replication
                    mdb_profile: Sand platforms MDB Profile configuration. Note: l3-xxxl does not support MLAG.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sfe(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "data_plane_cpu_allocation_max": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            data_plane_cpu_allocation_max: int | None
            """Maximum number of CPUs used for data plane traffic forwarding."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, data_plane_cpu_allocation_max: int | None | UndefinedType = Undefined
            ) -> None:
                """
                Sfe.

                Args:
                -----
                    _custom_data: _custom_data
                    data_plane_cpu_allocation_max: Maximum number of CPUs used for data plane traffic forwarding.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "trident": {"type": Trident}, "sand": {"type": Sand}, "sfe": {"type": Sfe}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        trident: Trident
        sand: Sand
        """Most of the platform sand options are hardware dependent and optional."""
        sfe: Sfe
        """Sfe (Software Forwarding Engine) settings."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            trident: Trident | UndefinedType = Undefined,
            sand: Sand | UndefinedType = Undefined,
            sfe: Sfe | UndefinedType = Undefined,
        ) -> None:
            """
            Platform.

            Args:
            -----
                _custom_data: _custom_data
                trident: trident
                sand: Most of the platform sand options are hardware dependent and optional.
                sfe: Sfe (Software Forwarding Engine) settings.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Poe(AvdModel):
        class Reboot(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            action: str | None
            """PoE action for interface. By default in EOS, reboot action is set to power-off."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, action: str | None | UndefinedType = Undefined) -> None:
                """
                Reboot.

                Args:
                -----
                    _custom_data: _custom_data
                    action: PoE action for interface. By default in EOS, reboot action is set to power-off.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class InterfaceShutdown(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            action: str | None
            """PoE action for interface. By default in EOS, interface shutdown action is set to maintain."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, action: str | None | UndefinedType = Undefined) -> None:
                """
                InterfaceShutdown.

                Args:
                -----
                    _custom_data: _custom_data
                    action: PoE action for interface. By default in EOS, interface shutdown action is set to maintain.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "reboot": {"type": Reboot}, "interface_shutdown": {"type": InterfaceShutdown}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        reboot: Reboot
        """Set the global PoE power behavior for PoE ports when the system is rebooted."""
        interface_shutdown: InterfaceShutdown
        """Set the global PoE power behavior for PoE ports when ports are admin down."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            reboot: Reboot | UndefinedType = Undefined,
            interface_shutdown: InterfaceShutdown | UndefinedType = Undefined,
        ) -> None:
            """
            Poe.

            Args:
            -----
                _custom_data: _custom_data
                reboot: Set the global PoE power behavior for PoE ports when the system is rebooted.
                interface_shutdown: Set the global PoE power behavior for PoE ports when ports are admin down.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PolicyMaps(AvdModel):
        class PbrItem(AvdModel):
            class ClassesItem(AvdModel):
                class Set(AvdModel):
                    class Nexthop(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "recursive": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        ip_address: str | None
                        """IPv4 or IPv6 Address."""
                        recursive: bool | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            ip_address: str | None | UndefinedType = Undefined,
                            recursive: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Nexthop.

                            Args:
                            -----
                                _custom_data: _custom_data
                                ip_address: IPv4 or IPv6 Address.
                                recursive: recursive

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "nexthop": {"type": Nexthop}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    nexthop: Nexthop

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, nexthop: Nexthop | UndefinedType = Undefined) -> None:
                        """
                        Set.

                        Args:
                        -----
                            _custom_data: _custom_data
                            nexthop: nexthop

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "index": {"type": int},
                    "drop": {"type": bool},
                    "set": {"type": Set},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Class Name."""
                index: int | None
                drop: bool | None
                """'drop' and 'set' are mutually exclusive."""
                set: Set
                """
                Set Nexthop
                'drop' and 'set' are mutually exclusive.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    index: int | None | UndefinedType = Undefined,
                    drop: bool | None | UndefinedType = Undefined,
                    set: Set | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClassesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Class Name.
                        index: index
                        drop: 'drop' and 'set' are mutually exclusive.
                        set:
                           Set Nexthop
                           'drop' and 'set' are mutually exclusive.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Classes(AvdCollection[str, ClassesItem]):
                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "classes": {"type": Classes}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Policy-Map Name."""
            classes: Classes

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                classes: Classes | UndefinedType = Undefined,
            ) -> None:
                """
                PbrItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy-Map Name.
                    classes: classes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Pbr(AvdCollection[str, PbrItem]):
            _primary_key: ClassVar[str] = "name"

        Pbr._item_type = PbrItem

        class QosItem(AvdModel):
            class ClassesItem(AvdModel):
                class Set(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "cos": {"type": int},
                        "dscp": {"type": str},
                        "traffic_class": {"type": int},
                        "drop_precedence": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    cos: int | None
                    dscp: str | None
                    traffic_class: int | None
                    drop_precedence: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        cos: int | None | UndefinedType = Undefined,
                        dscp: str | None | UndefinedType = Undefined,
                        traffic_class: int | None | UndefinedType = Undefined,
                        drop_precedence: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Set.

                        Args:
                        -----
                            _custom_data: _custom_data
                            cos: cos
                            dscp: dscp
                            traffic_class: traffic_class
                            drop_precedence: drop_precedence

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Police(AvdModel):
                    class Action(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "dscp_value": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        type: str | None
                        """Set action for policed traffic."""
                        dscp_value: str | None
                        """Set when action.type is set to "dscp"."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            type: str | None | UndefinedType = Undefined,
                            dscp_value: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Action.

                            Args:
                            -----
                                _custom_data: _custom_data
                                type: Set action for policed traffic.
                                dscp_value: Set when action.type is set to "dscp".

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "rate": {"type": int},
                        "rate_unit": {"type": str, "default": "bps"},
                        "rate_burst_size": {"type": int},
                        "rate_burst_size_unit": {"type": str, "default": "bytes"},
                        "action": {"type": Action},
                        "higher_rate": {"type": int},
                        "higher_rate_unit": {"type": str, "default": "bps"},
                        "higher_rate_burst_size": {"type": int},
                        "higher_rate_burst_size_unit": {"type": str, "default": "bytes"},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    rate: int | None
                    """
                    Specify rate.
                    Range in kbps <8-200000000>.
                    """
                    rate_unit: str | None
                    rate_burst_size: int | None
                    """Range in bytes <256-128000000>."""
                    rate_burst_size_unit: str | None
                    action: Action
                    higher_rate: int | None
                    """
                    Specify higher rate.
                    Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                    """
                    higher_rate_unit: str | None
                    higher_rate_burst_size: int | None
                    """Range in bytes <256-128000000>."""
                    higher_rate_burst_size_unit: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        rate: int | None | UndefinedType = Undefined,
                        rate_unit: str | None | UndefinedType = Undefined,
                        rate_burst_size: int | None | UndefinedType = Undefined,
                        rate_burst_size_unit: str | None | UndefinedType = Undefined,
                        action: Action | UndefinedType = Undefined,
                        higher_rate: int | None | UndefinedType = Undefined,
                        higher_rate_unit: str | None | UndefinedType = Undefined,
                        higher_rate_burst_size: int | None | UndefinedType = Undefined,
                        higher_rate_burst_size_unit: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Police.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rate:
                               Specify rate.
                               Range in kbps <8-200000000>.
                            rate_unit: rate_unit
                            rate_burst_size: Range in bytes <256-128000000>.
                            rate_burst_size_unit: rate_burst_size_unit
                            action: action
                            higher_rate:
                               Specify higher rate.
                               Range in kbps <lower_rate in kbps + 8 - lower_rate in kbps + 200000000>.
                            higher_rate_unit: higher_rate_unit
                            higher_rate_burst_size: Range in bytes <256-128000000>.
                            higher_rate_burst_size_unit: higher_rate_burst_size_unit

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "set": {"type": Set}, "police": {"type": Police}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Class Name."""
                set: Set
                police: Police

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    set: Set | UndefinedType = Undefined,
                    police: Police | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClassesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Class Name.
                        set: set
                        police: police

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Classes(AvdCollection[str, ClassesItem]):
                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "classes": {"type": Classes}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Policy-Map Name."""
            classes: Classes

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                classes: Classes | UndefinedType = Undefined,
            ) -> None:
                """
                QosItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy-Map Name.
                    classes: classes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Qos(AvdCollection[str, QosItem]):
            _primary_key: ClassVar[str] = "name"

        Qos._item_type = QosItem

        class CoppSystemPolicy(AvdModel):
            class ClassesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "shape": {"type": int},
                    "bandwidth": {"type": int},
                    "rate_unit": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                shape: int | None
                """Maximum rate limit."""
                bandwidth: int | None
                """Minimum bandwidth."""
                rate_unit: str | None
                """The `rate_unit` must be defined for `shape` and `bandwidth`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    shape: int | None | UndefinedType = Undefined,
                    bandwidth: int | None | UndefinedType = Undefined,
                    rate_unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ClassesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        shape: Maximum rate limit.
                        bandwidth: Minimum bandwidth.
                        rate_unit: The `rate_unit` must be defined for `shape` and `bandwidth`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Classes(AvdCollection[str, ClassesItem]):
                _primary_key: ClassVar[str] = "name"

            Classes._item_type = ClassesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "classes": {"type": Classes}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            classes: Classes

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, classes: Classes | UndefinedType = Undefined) -> None:
                """
                CoppSystemPolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    classes: classes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pbr": {"type": Pbr}, "qos": {"type": Qos}, "copp_system_policy": {"type": CoppSystemPolicy}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        pbr: Pbr
        """PBR Policy-Maps."""
        qos: Qos
        """QOS Policy-Maps."""
        copp_system_policy: CoppSystemPolicy
        """Control-plane policy configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            pbr: Pbr | UndefinedType = Undefined,
            qos: Qos | UndefinedType = Undefined,
            copp_system_policy: CoppSystemPolicy | UndefinedType = Undefined,
        ) -> None:
            """
            PolicyMaps.

            Args:
            -----
                _custom_data: _custom_data
                pbr: PBR Policy-Maps.
                qos: QOS Policy-Maps.
                copp_system_policy: Control-plane policy configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PortChannelInterfacesItem(AvdModel):
        class Logging(AvdModel):
            class Event(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "link_status": {"type": bool}, "storm_control_discards": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                link_status: bool | None
                storm_control_discards: bool | None
                """Discards due to storm-control."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    link_status: bool | None | UndefinedType = Undefined,
                    storm_control_discards: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        link_status: link_status
                        storm_control_discards: Discards due to storm-control.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "event": {"type": Event}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            event: Event

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, event: Event | UndefinedType = Undefined) -> None:
                """
                Logging.

                Args:
                -----
                    _custom_data: _custom_data
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationDot1q(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "inner_vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "vlan")
            _custom_data: dict[str, Any]
            vlan: int
            """VLAD ID."""
            inner_vlan: int | None
            """Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                vlan: int | UndefinedType = Undefined,
                inner_vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                EncapsulationDot1q.

                Args:
                -----
                    _custom_data: _custom_data
                    vlan: VLAD ID.
                    inner_vlan: Inner VLAN ID. This setting can only be applied to sub-interfaces on EOS.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EncapsulationVlan(AvdModel):
            class Client(AvdModel):
                class Dot1q(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    vlan: int | None
                    """Client VLAN ID."""
                    outer: int | None
                    """Client Outer VLAN ID."""
                    inner: int | None
                    """Client Inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer: int | None | UndefinedType = Undefined,
                        inner: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Client VLAN ID.
                            outer: Client Outer VLAN ID.
                            inner: Client Inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "dot1q": {"type": Dot1q},
                    "unmatched": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dot1q: Dot1q
                unmatched: bool | None
                encapsulation: str | None
                vlan: int | None
                """Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                outer_vlan: int | None
                """Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_vlan: int | None
                """Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`."""
                inner_encapsulation: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    unmatched: bool | None | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    outer_vlan: int | None | UndefinedType = Undefined,
                    inner_vlan: int | None | UndefinedType = Undefined,
                    inner_encapsulation: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Client.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        unmatched: unmatched
                        encapsulation: encapsulation
                        vlan: Client VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        outer_vlan: Client Outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_vlan: Client Inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: unmatched`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Network(AvdModel):
                class Dot1q(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "outer": {"type": int}, "inner": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    vlan: int | None
                    """Network VLAN ID."""
                    outer: int | None
                    """Network Outer VLAN ID."""
                    inner: int | None
                    """Network Inner VLAN ID."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        vlan: int | None | UndefinedType = Undefined,
                        outer: int | None | UndefinedType = Undefined,
                        inner: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dot1q.

                        Args:
                        -----
                            _custom_data: _custom_data
                            vlan: Network VLAN ID.
                            outer: Network Outer VLAN ID.
                            inner: Network Inner VLAN ID.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "dot1q": {"type": Dot1q},
                    "client": {"type": bool},
                    "encapsulation": {"type": str},
                    "vlan": {"type": int},
                    "outer_vlan": {"type": int},
                    "inner_vlan": {"type": int},
                    "inner_encapsulation": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dot1q: Dot1q
                client: bool | None
                encapsulation: str | None
                """
                `untagged` (no encapsulation) is applicable for `untagged` client only.
                `client` and `client inner`
                (retain client encapsulation) is not applicable for `untagged` client.
                """
                vlan: int | None
                """Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                outer_vlan: int | None
                """Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_vlan: int | None
                """Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`."""
                inner_encapsulation: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dot1q: Dot1q | UndefinedType = Undefined,
                    client: bool | None | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    outer_vlan: int | None | UndefinedType = Undefined,
                    inner_vlan: int | None | UndefinedType = Undefined,
                    inner_encapsulation: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Network.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dot1q: dot1q
                        client: client
                        encapsulation:
                           `untagged` (no encapsulation) is applicable for `untagged` client only.
                           `client` and `client inner`
                           (retain client encapsulation) is not applicable for `untagged` client.
                        vlan: Network VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        outer_vlan: Network outer VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_vlan: Network inner VLAN ID. Not applicable for `encapsulation: untagged` or `encapsulation: client`.
                        inner_encapsulation: inner_encapsulation

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "client": {"type": Client}, "network": {"type": Network}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            client: Client
            network: Network
            """Network encapsulation are all optional, and skipped if using client unmatched."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                client: Client | UndefinedType = Undefined,
                network: Network | UndefinedType = Undefined,
            ) -> None:
                """
                EncapsulationVlan.

                Args:
                -----
                    _custom_data: _custom_data
                    client: client
                    network: Network encapsulation are all optional, and skipped if using client unmatched.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTrackingGroupsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "direction": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Group name."""
            direction: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LinkTrackingGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LinkTrackingGroups(AvdCollection[str, LinkTrackingGroupsItem]):
            _primary_key: ClassVar[str] = "name"

        LinkTrackingGroups._item_type = LinkTrackingGroupsItem

        class Phone(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "trunk": {"type": str}, "vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            trunk: str | None
            vlan: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                trunk: str | None | UndefinedType = Undefined,
                vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Phone.

                Args:
                -----
                    _custom_data: _custom_data
                    trunk: trunk
                    vlan: vlan

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L2Protocol(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "encapsulation_dot1q_vlan": {"type": int}, "forwarding_profile": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            encapsulation_dot1q_vlan: int | None
            """Vlan tag to configure on sub-interface."""
            forwarding_profile: str | None
            """L2 protocol forwarding profile."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
                forwarding_profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                L2Protocol.

                Args:
                -----
                    _custom_data: _custom_data
                    encapsulation_dot1q_vlan: Vlan tag to configure on sub-interface.
                    forwarding_profile: L2 protocol forwarding profile.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Qos(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "trust": {"type": str}, "dscp": {"type": int}, "cos": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            trust: str | None
            dscp: int | None
            """DSCP value."""
            cos: int | None
            """COS value."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                trust: str | None | UndefinedType = Undefined,
                dscp: int | None | UndefinedType = Undefined,
                cos: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Qos.

                Args:
                -----
                    _custom_data: _custom_data
                    trust: trust
                    dscp: DSCP value.
                    cos: COS value.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bfd(AvdModel):
            class PerLink(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rfc_7130": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                rfc_7130: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    rfc_7130: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PerLink.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        rfc_7130: rfc_7130

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
                "neighbor": {"type": str},
                "per_link": {"type": PerLink},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            echo: bool | None
            interval: int | None
            """Interval in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None
            neighbor: str | None
            """
            IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
            (router_bfd.local_address) has to be defined globally on the switch.
            """
            per_link: PerLink

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                echo: bool | None | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                min_rx: int | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
                neighbor: str | None | UndefinedType = Undefined,
                per_link: PerLink | UndefinedType = Undefined,
            ) -> None:
                """
                Bfd.

                Args:
                -----
                    _custom_data: _custom_data
                    echo: echo
                    interval: Interval in milliseconds.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier
                    neighbor:
                       IPv4 or IPv6 address. When the Port-channel is a L2 interface, a local L3 BFD address
                       (router_bfd.local_address) has to be defined globally on the switch.
                    per_link: per_link

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdModel):
            class Pbr(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                input: str | None
                """Policy Based Routing Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, input: str | None | UndefinedType = Undefined) -> None:
                    """
                    Pbr.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Policy Based Routing Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Qos(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "input")
                _custom_data: dict[str, Any]
                input: str
                """Quality of Service Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, input: str | UndefinedType = Undefined) -> None:
                    """
                    Qos.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Quality of Service Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pbr": {"type": Pbr}, "qos": {"type": Qos}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            pbr: Pbr
            qos: Qos

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, pbr: Pbr | UndefinedType = Undefined, qos: Qos | UndefinedType = Undefined
            ) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    pbr: pbr
                    qos: qos

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mpls(AvdModel):
            class Ldp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": bool}, "igp_sync": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interface: bool | None
                igp_sync: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interface: bool | None | UndefinedType = Undefined,
                    igp_sync: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ldp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: interface
                        igp_sync: igp_sync

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip": {"type": bool}, "ldp": {"type": Ldp}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ip: bool | None
            ldp: Ldp

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip: bool | None | UndefinedType = Undefined,
                ldp: Ldp | UndefinedType = Undefined,
            ) -> None:
                """
                Mpls.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: ip
                    ldp: ldp

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanTranslationsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "field_from": {"type": str, "key": "from"},
                "to": {"type": int},
                "direction": {"type": str, "default": "both"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            field_from: str | None
            """List of vlans as string (only one vlan if direction is "both")."""
            to: int | None
            """VLAN ID."""
            direction: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                field_from: str | None | UndefinedType = Undefined,
                to: int | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlanTranslationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    field_from: List of vlans as string (only one vlan if direction is "both").
                    to: VLAN ID.
                    direction: direction

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Shape(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            rate: str | None
            """
            Rate in kbps, pps or percent.
            Supported options are platform dependent.
            Examples:
            - "5000 kbps"
            -
            "1000 pps"
            - "20 percent"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: str | None | UndefinedType = Undefined) -> None:
                """
                Shape.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Rate in kbps, pps or percent.
                       Supported options are platform dependent.

                Examples:
                       - "5000 kbps"
                       -
                       "1000 pps"
                       - "20 percent"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class StormControl(AvdModel):
            class All(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    All.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Broadcast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Broadcast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Multicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class UnknownUnicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level": {"type": str}, "unit": {"type": str, "default": "percent"}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level: str | None
                """Configure maximum storm-control level."""
                unit: str | None
                """Optional field and is hardware dependent."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    unit: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UnknownUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level: Configure maximum storm-control level.
                        unit: Optional field and is hardware dependent.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "all": {"type": All},
                "broadcast": {"type": Broadcast},
                "multicast": {"type": Multicast},
                "unknown_unicast": {"type": UnknownUnicast},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            all: All
            broadcast: Broadcast
            multicast: Multicast
            unknown_unicast: UnknownUnicast

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                all: All | UndefinedType = Undefined,
                broadcast: Broadcast | UndefinedType = Undefined,
                multicast: Multicast | UndefinedType = Undefined,
                unknown_unicast: UnknownUnicast | UndefinedType = Undefined,
            ) -> None:
                """
                StormControl.

                Args:
                -----
                    _custom_data: _custom_data
                    all: all
                    broadcast: broadcast
                    multicast: multicast
                    unknown_unicast: unknown_unicast

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TrafficPolicy(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}, "output": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            input: str | None
            """Ingress traffic policy."""
            output: str | None
            """Egress traffic policy."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                input: str | None | UndefinedType = Undefined,
                output: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TrafficPolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    input: Ingress traffic policy.
                    output: Egress traffic policy.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class EvpnEthernetSegment(AvdModel):
            class DesignatedForwarderElection(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "algorithm": {"type": str},
                    "preference_value": {"type": int},
                    "dont_preempt": {"type": bool, "default": False},
                    "hold_time": {"type": int},
                    "subsequent_hold_time": {"type": int},
                    "candidate_reachability_required": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                algorithm: str | None
                preference_value: int | None
                """Preference_value is only used when "algorithm" is "preference"."""
                dont_preempt: bool | None
                """Dont_preempt is only used when "algorithm" is "preference"."""
                hold_time: int | None
                subsequent_hold_time: int | None
                candidate_reachability_required: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    algorithm: str | None | UndefinedType = Undefined,
                    preference_value: int | None | UndefinedType = Undefined,
                    dont_preempt: bool | None | UndefinedType = Undefined,
                    hold_time: int | None | UndefinedType = Undefined,
                    subsequent_hold_time: int | None | UndefinedType = Undefined,
                    candidate_reachability_required: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DesignatedForwarderElection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        algorithm: algorithm
                        preference_value: Preference_value is only used when "algorithm" is "preference".
                        dont_preempt: Dont_preempt is only used when "algorithm" is "preference".
                        hold_time: hold_time
                        subsequent_hold_time: subsequent_hold_time
                        candidate_reachability_required: candidate_reachability_required

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Mpls(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "shared_index": {"type": int}, "tunnel_flood_filter_time": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                shared_index: int | None
                tunnel_flood_filter_time: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    shared_index: int | None | UndefinedType = Undefined,
                    tunnel_flood_filter_time: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Mpls.

                    Args:
                    -----
                        _custom_data: _custom_data
                        shared_index: shared_index
                        tunnel_flood_filter_time: tunnel_flood_filter_time

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "identifier": {"type": str},
                "redundancy": {"type": str},
                "designated_forwarder_election": {"type": DesignatedForwarderElection},
                "mpls": {"type": Mpls},
                "route_target": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            identifier: str | None
            """EVPN Ethernet Segment Identifier (Type 1 format)."""
            redundancy: str | None
            designated_forwarder_election: DesignatedForwarderElection
            mpls: Mpls
            route_target: str | None
            """EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                identifier: str | None | UndefinedType = Undefined,
                redundancy: str | None | UndefinedType = Undefined,
                designated_forwarder_election: DesignatedForwarderElection | UndefinedType = Undefined,
                mpls: Mpls | UndefinedType = Undefined,
                route_target: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                EvpnEthernetSegment.

                Args:
                -----
                    _custom_data: _custom_data
                    identifier: EVPN Ethernet Segment Identifier (Type 1 format).
                    redundancy: redundancy
                    designated_forwarder_election: designated_forwarder_election
                    mpls: mpls
                    route_target: EVPN Route Target for ESI with format xx:xx:xx:xx:xx:xx.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ptp(AvdModel):
            class Announce(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "timeout": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int | None
                timeout: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Announce.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval
                        timeout: timeout

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Profile(AvdModel):
                class G82751(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination_mac_address": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    destination_mac_address: str | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, destination_mac_address: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        G82751.

                        Args:
                        -----
                            _custom_data: _custom_data
                            destination_mac_address: destination_mac_address

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "g8275_1": {"type": G82751}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                g8275_1: G82751

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, g8275_1: G82751 | UndefinedType = Undefined) -> None:
                    """
                    Profile.

                    Args:
                    -----
                        _custom_data: _custom_data
                        g8275_1: g8275_1

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SyncMessage(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                    """
                    SyncMessage.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: interval

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enable": {"type": bool},
                "announce": {"type": Announce},
                "delay_req": {"type": int},
                "delay_mechanism": {"type": str},
                "profile": {"type": Profile},
                "sync_message": {"type": SyncMessage},
                "role": {"type": str},
                "vlan": {"type": str},
                "transport": {"type": str},
                "mpass": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enable: bool | None
            announce: Announce
            delay_req: int | None
            delay_mechanism: str | None
            profile: Profile
            sync_message: SyncMessage
            role: str | None
            vlan: str | None
            """VLAN can be 'all' or list of vlans as string."""
            transport: str | None
            mpass: bool | None
            """
            When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
            logical device.
            Arista PTP enabled devices always place PTP messages on the same physical link
            within the port-channel.
            Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
            devices.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                announce: Announce | UndefinedType = Undefined,
                delay_req: int | None | UndefinedType = Undefined,
                delay_mechanism: str | None | UndefinedType = Undefined,
                profile: Profile | UndefinedType = Undefined,
                sync_message: SyncMessage | UndefinedType = Undefined,
                role: str | None | UndefinedType = Undefined,
                vlan: str | None | UndefinedType = Undefined,
                transport: str | None | UndefinedType = Undefined,
                mpass: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ptp.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    announce: announce
                    delay_req: delay_req
                    delay_mechanism: delay_mechanism
                    profile: profile
                    sync_message: sync_message
                    role: role
                    vlan: VLAN can be 'all' or list of vlans as string.
                    transport: transport
                    mpass:
                       When MPASS is enabled on an MLAG port-channel, MLAG peers coordinate to function as a single PTP
                       logical device.
                       Arista PTP enabled devices always place PTP messages on the same physical link
                       within the port-channel.
                       Hence, MPASS is needed only on MLAG port-channels connected to non-Arista
                       devices.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpNat(AvdModel):
            class Destination(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "pool_name")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        pool_name: str | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "nat_type")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    nat_type: str
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        nat_type: str | UndefinedType = Undefined,
                        pool_name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination": {"type": Destination}, "source": {"type": Source}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            destination: Destination
            source: Source

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                destination: Destination | UndefinedType = Undefined,
                source: Source | UndefinedType = Undefined,
            ) -> None:
                """
                IpNat.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipv6_prefix")
            _custom_data: dict[str, Any]
            ipv6_prefix: str
            valid_lifetime: str | None
            """Infinite or lifetime in seconds."""
            preferred_lifetime: str | None
            """Infinite or lifetime in seconds."""
            no_autoconfig_flag: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv6_prefix: str | UndefinedType = Undefined,
                valid_lifetime: str | None | UndefinedType = Undefined,
                preferred_lifetime: str | None | UndefinedType = Undefined,
                no_autoconfig_flag: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6NdPrefixesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_prefix: ipv6_prefix
                    valid_lifetime: Infinite or lifetime in seconds.
                    preferred_lifetime: Infinite or lifetime in seconds.
                    no_autoconfig_flag: no_autoconfig_flag

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixes(AvdCollection[str, Ipv6NdPrefixesItem]):
            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Pim(AvdModel):
            class Ipv4(AvdModel):
                class Hello(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": str}, "interval": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: str | None | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Hello.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                            interval: PIM hello interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "hello": {"type": Hello},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                hello: Hello

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    border_router: bool | None | UndefinedType = Undefined,
                    dr_priority: int | None | UndefinedType = Undefined,
                    sparse_mode: bool | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bidirectional: bool | None | UndefinedType = Undefined,
                    hello: Hello | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        border_router: Configure PIM border router. EOS default is false.
                        dr_priority: dr_priority
                        sparse_mode: sparse_mode
                        bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                        bidirectional: bidirectional
                        hello: hello

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: Ipv4

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                """
                Pim.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeysItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            hash_algorithm: str | None
            key: str | None
            """Encrypted password."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                OspfMessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key: Encrypted password.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeys(AvdCollection[int, OspfMessageDigestKeysItem]):
            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class FlowTracker(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sampled": {"type": str}, "hardware": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sampled: str | None
            """Sampled flow tracker name."""
            hardware: str | None
            """Hardware flow tracker name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sampled: str | None | UndefinedType = Undefined,
                hardware: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                FlowTracker.

                Args:
                -----
                    _custom_data: _custom_data
                    sampled: Sampled flow tracker name.
                    hardware: Hardware flow tracker name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "session_tracker": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            session_tracker: str | None
            """Name of session tracker."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, session_tracker: str | None | UndefinedType = Undefined) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    session_tracker: Name of session tracker.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpIgmpHostProxy(AvdModel):
            class GroupsItem(AvdModel):
                class ExcludeItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source")
                    _custom_data: dict[str, Any]
                    source: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source: str | UndefinedType = Undefined) -> None:
                        """
                        ExcludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Exclude(AvdCollection[str, ExcludeItem]):
                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source")
                    _custom_data: dict[str, Any]
                    source: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source: str | UndefinedType = Undefined) -> None:
                        """
                        IncludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Include(AvdCollection[str, IncludeItem]):
                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "group")
                _custom_data: dict[str, Any]
                group: str
                """Multicast Address."""
                exclude: Exclude
                """The same source must not be present both in `exclude` and `include` list."""
                include: Include
                """The same source must not be present both in `exclude` and `include` list."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    group: str | UndefinedType = Undefined,
                    exclude: Exclude | UndefinedType = Undefined,
                    include: Include | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        group: Multicast Address.
                        exclude: The same source must not be present both in `exclude` and `include` list.
                        include: The same source must not be present both in `exclude` and `include` list.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Groups(AvdCollection[str, GroupsItem]):
                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined) -> None:
                    """
                    AccessListsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessLists(AvdCollection[str, AccessListsItem]):
                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            groups: Groups
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """Non-standard Access List name."""
            version: int | None
            """IGMP version on IGMP host-proxy interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                groups: Groups | UndefinedType = Undefined,
                report_interval: int | None | UndefinedType = Undefined,
                access_lists: AccessLists | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpIgmpHostProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    groups: groups
                    report_interval: Time interval between unsolicited reports.
                    access_lists: Non-standard Access List name.
                    version: IGMP version on IGMP host-proxy interface.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sflow(AvdModel):
            class Egress(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "unmodified_enable": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enable: bool | None
                unmodified_enable: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enable: bool | None | UndefinedType = Undefined,
                    unmodified_enable: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Egress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enable: enable
                        unmodified_enable: unmodified_enable

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "egress": {"type": Egress}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enable: bool | None
            egress: Egress

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                egress: Egress | UndefinedType = Undefined,
            ) -> None:
                """
                Sflow.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: enable
                    egress: egress

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Switchport(AvdModel):
            class Trunk(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "allowed_vlan": {"type": str},
                    "native_vlan": {"type": int},
                    "native_vlan_tag": {"type": bool},
                    "private_vlan_secondary": {"type": bool},
                    "groups": {"type": list, "items": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                allowed_vlan: str | None
                """
                VLAN ID or range(s) of VLAN IDs (1-4094).
                Warning: This should not be combined with
                `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                """
                native_vlan: int | None
                """
                Set native VLAN when interface is in trunking mode.
                Warning: This should not be combined with
                `port_channel_interfaces[].native_vlan`.
                """
                native_vlan_tag: bool | None
                """
                If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                Warning: This
                should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                """
                private_vlan_secondary: bool | None
                """
                Enable secondary VLAN mapping for a private vlan.
                Warning: This should not be combined with
                `port_channel_interfaces[].trunk_private_vlan_secondary`.
                """
                groups: list[str]
                """Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    allowed_vlan: str | None | UndefinedType = Undefined,
                    native_vlan: int | None | UndefinedType = Undefined,
                    native_vlan_tag: bool | None | UndefinedType = Undefined,
                    private_vlan_secondary: bool | None | UndefinedType = Undefined,
                    groups: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Trunk.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allowed_vlan:
                           VLAN ID or range(s) of VLAN IDs (1-4094).
                           Warning: This should not be combined with
                           `port_channel_interfaces[].mode = trunk` and `port_channel_interfaces[].vlans`.
                        native_vlan:
                           Set native VLAN when interface is in trunking mode.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].native_vlan`.
                        native_vlan_tag:
                           If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                           Warning: This
                           should not be combined with `port_channel_interfaces[].native_vlan_tag`.
                        private_vlan_secondary:
                           Enable secondary VLAN mapping for a private vlan.
                           Warning: This should not be combined with
                           `port_channel_interfaces[].trunk_private_vlan_secondary`.
                        groups: Warning: This should not be combined with `port_channel_interfaces[].trunk_groups`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Phone(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vlan": {"type": int}, "trunk": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                vlan: int | None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`."""
                trunk: str | None
                """Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    vlan: int | None | UndefinedType = Undefined,
                    trunk: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Phone.

                    Args:
                    -----
                        _custom_data: _custom_data
                        vlan: Warning: This should not be combined with `port_channel_interfaces[].phone.vlan`.
                        trunk: Warning: This should not be combined with `port_channel_interfaces[].phone.trunk`

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Dot1q(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ethertype": {"type": int}, "vlan_tag": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ethertype: int | None
                """Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames."""
                vlan_tag: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ethertype: int | None | UndefinedType = Undefined,
                    vlan_tag: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dot1q.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ethertype: Ethertype/TPID (Tag Protocol IDentifier) for VLAN tagged frames.
                        vlan_tag: vlan_tag

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class VlanTranslations(AvdModel):
                class DirectionInItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "field_from": {"type": str, "key": "from"},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    field_from: str | None
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | None | UndefinedType = Undefined,
                        to: int | None | UndefinedType = Undefined,
                        dot1q_tunnel: bool | None | UndefinedType = Undefined,
                        inner_vlan_from: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionInItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOutItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "field_from": {"type": str, "key": "from"},
                        "to": {"type": int},
                        "dot1q_tunnel_to": {"type": str},
                        "inner_vlan_to": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "field_from")
                    _custom_data: dict[str, Any]
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int | None
                    """VLAN ID to map to."""
                    dot1q_tunnel_to: str | None
                    """
                    VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                    This takes precedence over `to` and
                    `inner_vlan_to`.
                    """
                    inner_vlan_to: int | None
                    """Inner VLAN ID to map to."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | UndefinedType = Undefined,
                        to: int | None | UndefinedType = Undefined,
                        dot1q_tunnel_to: str | None | UndefinedType = Undefined,
                        inner_vlan_to: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionOutItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel_to:
                               VLAN ID or range of VLAN IDs or "all". Range 1-4094.
                               This takes precedence over `to` and
                               `inner_vlan_to`.
                            inner_vlan_to: Inner VLAN ID to map to.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionBothItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "field_from": {"type": str, "key": "from"},
                        "to": {"type": int},
                        "dot1q_tunnel": {"type": bool},
                        "inner_vlan_from": {"type": int},
                        "network": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "field_from", "to")
                    _custom_data: dict[str, Any]
                    field_from: str
                    """VLAN ID or range of VLAN IDs to map from. Range 1-4094."""
                    to: int
                    """VLAN ID to map to."""
                    dot1q_tunnel: bool | None
                    inner_vlan_from: int | None
                    """Inner VLAN ID to map from."""
                    network: bool | None
                    """
                    Enable use of network-side VLAN ID.
                    This setting can only be enabled when `inner_vlan_from` is
                    defined.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | UndefinedType = Undefined,
                        to: int | UndefinedType = Undefined,
                        dot1q_tunnel: bool | None | UndefinedType = Undefined,
                        inner_vlan_from: int | None | UndefinedType = Undefined,
                        network: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionBothItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: VLAN ID or range of VLAN IDs to map from. Range 1-4094.
                            to: VLAN ID to map to.
                            dot1q_tunnel: dot1q_tunnel
                            inner_vlan_from: Inner VLAN ID to map from.
                            network:
                               Enable use of network-side VLAN ID.
                               This setting can only be enabled when `inner_vlan_from` is
                               defined.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "in_required": {"type": bool},
                    "out_required": {"type": bool},
                    "direction_in": {"type": list, "items": DirectionInItem},
                    "direction_out": {"type": list, "items": DirectionOutItem},
                    "direction_both": {"type": list, "items": DirectionBothItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                in_required: bool | None
                """Drop the ingress traffic that do not match any VLAN mapping."""
                out_required: bool | None
                """Drop the egress traffic that do not match any VLAN mapping."""
                direction_in: list[DirectionInItem]
                """Map ingress traffic only."""
                direction_out: list[DirectionOutItem]
                """Map egress traffic only."""
                direction_both: list[DirectionBothItem]
                """Map both egress and ingress traffic."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    in_required: bool | None | UndefinedType = Undefined,
                    out_required: bool | None | UndefinedType = Undefined,
                    direction_in: list[DirectionInItem] | UndefinedType = Undefined,
                    direction_out: list[DirectionOutItem] | UndefinedType = Undefined,
                    direction_both: list[DirectionBothItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    VlanTranslations.

                    Args:
                    -----
                        _custom_data: _custom_data
                        in_required: Drop the ingress traffic that do not match any VLAN mapping.
                        out_required: Drop the egress traffic that do not match any VLAN mapping.
                        direction_in: Map ingress traffic only.
                        direction_out: Map egress traffic only.
                        direction_both: Map both egress and ingress traffic.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BackupLink(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interface": {"type": str}, "prefer_vlan": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "interface")
                _custom_data: dict[str, Any]
                interface: str
                """Backup interface. Example - Ethernet4, Vlan10 etc."""
                prefer_vlan: str | None
                """VLANs to carry on the backup interface (1-4094)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interface: str | UndefinedType = Undefined,
                    prefer_vlan: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    BackupLink.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interface: Backup interface. Example - Ethernet4, Vlan10 etc.
                        prefer_vlan: VLANs to carry on the backup interface (1-4094).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Backup(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "dest_macaddr": {"type": str},
                    "initial_mac_move_delay": {"type": int},
                    "mac_move_burst": {"type": int},
                    "mac_move_burst_interval": {"type": int},
                    "preemption_delay": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dest_macaddr: str | None
                """
                Destination MAC address for MAC move updates.
                The mac address should be multicast or broadcast.
                Example: 01:00:00:00:00:00
                """
                initial_mac_move_delay: int | None
                """Initial MAC move delay in milliseconds."""
                mac_move_burst: int | None
                """Size of MAC move bursts."""
                mac_move_burst_interval: int | None
                """MAC move burst interval in milliseconds."""
                preemption_delay: int | None
                """Preemption delay in milliseconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dest_macaddr: str | None | UndefinedType = Undefined,
                    initial_mac_move_delay: int | None | UndefinedType = Undefined,
                    mac_move_burst: int | None | UndefinedType = Undefined,
                    mac_move_burst_interval: int | None | UndefinedType = Undefined,
                    preemption_delay: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Backup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dest_macaddr:
                           Destination MAC address for MAC move updates.
                           The mac address should be multicast or broadcast.
                           Example: 01:00:00:00:00:00
                        initial_mac_move_delay: Initial MAC move delay in milliseconds.
                        mac_move_burst: Size of MAC move bursts.
                        mac_move_burst_interval: MAC move burst interval in milliseconds.
                        preemption_delay: Preemption delay in milliseconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PortSecurity(AvdModel):
                class MacAddressMaximum(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "disabled": {"type": bool}, "limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    disabled: bool | None
                    """Disable port level check for port security (only in violation 'shutdown' mode)."""
                    limit: int | None
                    """MAC address limit."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        disabled: bool | None | UndefinedType = Undefined,
                        limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MacAddressMaximum.

                        Args:
                        -----
                            _custom_data: _custom_data
                            disabled: Disable port level check for port security (only in violation 'shutdown' mode).
                            limit: MAC address limit.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Violation(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "protect_log": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    mode: str | None
                    """Configure port security mode."""
                    protect_log: bool | None
                    """Log new addresses seen after limit is reached in protect mode."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        mode: str | None | UndefinedType = Undefined,
                        protect_log: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Violation.

                        Args:
                        -----
                            _custom_data: _custom_data
                            mode: Configure port security mode.
                            protect_log: Log new addresses seen after limit is reached in protect mode.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "range": {"type": str}, "mac_address_maximum": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "range")
                    _custom_data: dict[str, Any]
                    range: str
                    """
                    VLAN ID or range(s) of VLAN IDs, <1-4094>.
                    Example:
                      - 3
                      - 1,3
                      - 1-10
                    """
                    mac_address_maximum: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        range: str | UndefinedType = Undefined,
                        mac_address_maximum: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            range:
                               VLAN ID or range(s) of VLAN IDs, <1-4094>.

                        Example:
                                 - 3
                                 - 1,3
                                 - 1-10
                            mac_address_maximum: mac_address_maximum

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vlans(AvdCollection[str, VlansItem]):
                    _primary_key: ClassVar[str] = "range"

                Vlans._item_type = VlansItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "mac_address_maximum": {"type": MacAddressMaximum},
                    "violation": {"type": Violation},
                    "vlan_default_mac_address_maximum": {"type": int},
                    "vlans": {"type": Vlans},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                mac_address_maximum: MacAddressMaximum
                """Maximum number of MAC addresses allowed on the interface."""
                violation: Violation
                """Configure violation mode (shutdown or protect), EOS default is 'shutdown'."""
                vlan_default_mac_address_maximum: int | None
                """Default maximum MAC addresses for all VLANs on this interface."""
                vlans: Vlans

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    mac_address_maximum: MacAddressMaximum | UndefinedType = Undefined,
                    violation: Violation | UndefinedType = Undefined,
                    vlan_default_mac_address_maximum: int | None | UndefinedType = Undefined,
                    vlans: Vlans | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortSecurity.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        mac_address_maximum: Maximum number of MAC addresses allowed on the interface.
                        violation: Configure violation mode (shutdown or protect), EOS default is 'shutdown'.
                        vlan_default_mac_address_maximum: Default maximum MAC addresses for all VLANs on this interface.
                        vlans: vlans

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "mode": {"type": str},
                "access_vlan": {"type": int},
                "trunk": {"type": Trunk},
                "phone": {"type": Phone},
                "pvlan_mapping": {"type": str},
                "dot1q": {"type": Dot1q},
                "source_interface": {"type": str},
                "vlan_translations": {"type": VlanTranslations},
                "vlan_forwarding_accept_all": {"type": bool},
                "backup_link": {"type": BackupLink},
                "backup": {"type": Backup},
                "port_security": {"type": PortSecurity},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            """Warning: This should not be combined with `port_channel_interfaces[].type = routed`."""
            mode: str | None
            """Warning: This should not be combined with `port_channel_interfaces[].mode`"""
            access_vlan: int | None
            """
            Set VLAN when interface is in access mode.
            Warning: This should not be combined with
            `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
            """
            trunk: Trunk
            phone: Phone
            pvlan_mapping: str | None
            """
            Secondary VLAN IDs of the private VLAN mapping.
            Warning: This should not be combined with
            `port_channel_interfaces[].pvlan_mapping`.
            """
            dot1q: Dot1q
            source_interface: str | None
            """
            tx: Allow bridged traffic to go out of the source interface.
            tx multicast: Allow multicast traffic
            only to go out of the source interface.
            """
            vlan_translations: VlanTranslations
            """
            VLAN Translation mappings.
            Warning: This should not be combined with
            `port_channel_interfaces[].vlan_translations`.
            """
            vlan_forwarding_accept_all: bool | None
            backup_link: BackupLink
            backup: Backup
            """The `backup_link` is required for this setting."""
            port_security: PortSecurity

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                access_vlan: int | None | UndefinedType = Undefined,
                trunk: Trunk | UndefinedType = Undefined,
                phone: Phone | UndefinedType = Undefined,
                pvlan_mapping: str | None | UndefinedType = Undefined,
                dot1q: Dot1q | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vlan_translations: VlanTranslations | UndefinedType = Undefined,
                vlan_forwarding_accept_all: bool | None | UndefinedType = Undefined,
                backup_link: BackupLink | UndefinedType = Undefined,
                backup: Backup | UndefinedType = Undefined,
                port_security: PortSecurity | UndefinedType = Undefined,
            ) -> None:
                """
                Switchport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Warning: This should not be combined with `port_channel_interfaces[].type = routed`.
                    mode: Warning: This should not be combined with `port_channel_interfaces[].mode`
                    access_vlan:
                       Set VLAN when interface is in access mode.
                       Warning: This should not be combined with
                       `port_channel_interfaces[].mode = access/dot1q-tunnel` and `port_channel_interface.vlans`.
                    trunk: trunk
                    phone: phone
                    pvlan_mapping:
                       Secondary VLAN IDs of the private VLAN mapping.
                       Warning: This should not be combined with
                       `port_channel_interfaces[].pvlan_mapping`.
                    dot1q: dot1q
                    source_interface:
                       tx: Allow bridged traffic to go out of the source interface.
                       tx multicast: Allow multicast traffic
                       only to go out of the source interface.
                    vlan_translations:
                       VLAN Translation mappings.
                       Warning: This should not be combined with
                       `port_channel_interfaces[].vlan_translations`.
                    vlan_forwarding_accept_all: vlan_forwarding_accept_all
                    backup_link: backup_link
                    backup: The `backup_link` is required for this setting.
                    port_security: port_security

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "logging": {"type": Logging},
            "shutdown": {"type": bool},
            "l2_mtu": {"type": int},
            "l2_mru": {"type": int},
            "vlans": {"type": str},
            "snmp_trap_link_change": {"type": bool},
            "type": {"type": str},
            "encapsulation_dot1q_vlan": {"type": int},
            "encapsulation_dot1q": {"type": EncapsulationDot1q},
            "vrf": {"type": str},
            "encapsulation_vlan": {"type": EncapsulationVlan},
            "vlan_id": {"type": int},
            "mode": {"type": str},
            "native_vlan": {"type": int},
            "native_vlan_tag": {"type": bool, "default": False},
            "link_tracking_groups": {"type": LinkTrackingGroups},
            "phone": {"type": Phone},
            "l2_protocol": {"type": L2Protocol},
            "mtu": {"type": int},
            "mlag": {"type": int},
            "trunk_groups": {"type": list, "items": str},
            "lacp_fallback_timeout": {"type": int, "default": 90},
            "lacp_fallback_mode": {"type": str},
            "qos": {"type": Qos},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "mpls": {"type": Mpls},
            "trunk_private_vlan_secondary": {"type": bool},
            "pvlan_mapping": {"type": str},
            "vlan_translations": {"type": list, "items": VlanTranslationsItem},
            "shape": {"type": Shape},
            "storm_control": {"type": StormControl},
            "ip_proxy_arp": {"type": bool},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_circuit_type": {"type": str},
            "isis_hello_padding": {"type": bool},
            "isis_authentication_mode": {"type": str},
            "isis_authentication_key": {"type": str},
            "traffic_policy": {"type": TrafficPolicy},
            "evpn_ethernet_segment": {"type": EvpnEthernetSegment},
            "lacp_id": {"type": str},
            "spanning_tree_bpdufilter": {"type": str},
            "spanning_tree_bpduguard": {"type": str},
            "spanning_tree_guard": {"type": str},
            "spanning_tree_portfast": {"type": str},
            "vmtracer": {"type": bool},
            "ptp": {"type": Ptp},
            "ip_address": {"type": str},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "mac_access_group_in": {"type": str},
            "mac_access_group_out": {"type": str},
            "pim": {"type": Pim},
            "service_profile": {"type": str},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "flow_tracker": {"type": FlowTracker},
            "bgp": {"type": Bgp},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "peer": {"type": str},
            "peer_interface": {"type": str},
            "peer_type": {"type": str},
            "sflow": {"type": Sflow},
            "switchport": {"type": Switchport},
            "validate_state": {"type": bool},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        description: str | None
        logging: Logging
        shutdown: bool | None
        l2_mtu: int | None
        """"l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI."""
        l2_mru: int | None
        """"l2_mru" should only be defined for platforms supporting the "l2 mru" CLI."""
        vlans: str | None
        """
        List of switchport vlans as string.
        For a trunk port this would be a range like "1-200,300".
        For an
        access port this would be a single vlan "123".
        """
        snmp_trap_link_change: bool | None
        type: str | None
        """
        l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
        Interface will not be listed in device documentation, unless "type" is set.
        """
        encapsulation_dot1q_vlan: int | None
        """VLAN tag to configure on sub-interface."""
        encapsulation_dot1q: EncapsulationDot1q
        """
        Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
        `ethernet_interfaces[].type: l2dot1q`.
        """
        vrf: str | None
        """VRF name."""
        encapsulation_vlan: EncapsulationVlan
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `encapsulation_vlan` should not
        be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
        """
        vlan_id: int | None
        """
        This setting can only be applied to sub-interfaces on EOS.
        Warning: `vlan_id` should not be combined
        with `ethernet_interfaces[].type == l2dot1q`.
        """
        mode: str | None
        native_vlan: int | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        native_vlan_tag: bool | None
        """If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence."""
        link_tracking_groups: LinkTrackingGroups
        phone: Phone
        l2_protocol: L2Protocol
        mtu: int | None
        mlag: int | None
        """MLAG ID."""
        trunk_groups: list[str]
        lacp_fallback_timeout: int | None
        """Timeout in seconds."""
        lacp_fallback_mode: str | None
        qos: Qos
        bfd: Bfd
        service_policy: ServicePolicy
        mpls: Mpls
        trunk_private_vlan_secondary: bool | None
        pvlan_mapping: str | None
        """List of vlans as string."""
        vlan_translations: list[VlanTranslationsItem]
        shape: Shape
        storm_control: StormControl
        ip_proxy_arp: bool | None
        isis_enable: str | None
        """ISIS instance."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_circuit_type: str | None
        isis_hello_padding: bool | None
        isis_authentication_mode: str | None
        isis_authentication_key: str | None
        """Type-7 encrypted password."""
        traffic_policy: TrafficPolicy
        evpn_ethernet_segment: EvpnEthernetSegment
        lacp_id: str | None
        """LACP ID with format xxxx.xxxx.xxxx."""
        spanning_tree_bpdufilter: str | None
        spanning_tree_bpduguard: str | None
        spanning_tree_guard: str | None
        spanning_tree_portfast: str | None
        vmtracer: bool | None
        ptp: Ptp
        ip_address: str | None
        """IPv4 address/mask."""
        ip_verify_unicast_source_reachable_via: str | None
        ip_nat: IpNat
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6 address/mask."""
        ipv6_address_link_local: str | None
        """Link local IPv6 address/mask."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_prefixes: Ipv6NdPrefixes
        access_group_in: str | None
        """Access list name."""
        access_group_out: str | None
        """Access list name."""
        ipv6_access_group_in: str | None
        """IPv6 access list name."""
        ipv6_access_group_out: str | None
        """IPv6 access list name."""
        mac_access_group_in: str | None
        """MAC access list name."""
        mac_access_group_out: str | None
        """MAC access list name."""
        pim: Pim
        service_profile: str | None
        """QOS profile."""
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: str | None
        ospf_authentication_key: str | None
        """Encrypted password."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        flow_tracker: FlowTracker
        bgp: Bgp
        ip_igmp_host_proxy: IpIgmpHostProxy
        peer: str | None
        """Key only used for documentation or validation purposes."""
        peer_interface: str | None
        """Key only used for documentation or validation purposes."""
        peer_type: str | None
        """Key only used for documentation or validation purposes."""
        sflow: Sflow
        switchport: Switchport
        validate_state: bool | None
        """Set to false to disable interface validation by the `eos_validate_state` role."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            logging: Logging | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            l2_mtu: int | None | UndefinedType = Undefined,
            l2_mru: int | None | UndefinedType = Undefined,
            vlans: str | None | UndefinedType = Undefined,
            snmp_trap_link_change: bool | None | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            encapsulation_dot1q_vlan: int | None | UndefinedType = Undefined,
            encapsulation_dot1q: EncapsulationDot1q | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            encapsulation_vlan: EncapsulationVlan | UndefinedType = Undefined,
            vlan_id: int | None | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            native_vlan: int | None | UndefinedType = Undefined,
            native_vlan_tag: bool | None | UndefinedType = Undefined,
            link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
            phone: Phone | UndefinedType = Undefined,
            l2_protocol: L2Protocol | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            mlag: int | None | UndefinedType = Undefined,
            trunk_groups: list[str] | UndefinedType = Undefined,
            lacp_fallback_timeout: int | None | UndefinedType = Undefined,
            lacp_fallback_mode: str | None | UndefinedType = Undefined,
            qos: Qos | UndefinedType = Undefined,
            bfd: Bfd | UndefinedType = Undefined,
            service_policy: ServicePolicy | UndefinedType = Undefined,
            mpls: Mpls | UndefinedType = Undefined,
            trunk_private_vlan_secondary: bool | None | UndefinedType = Undefined,
            pvlan_mapping: str | None | UndefinedType = Undefined,
            vlan_translations: list[VlanTranslationsItem] | UndefinedType = Undefined,
            shape: Shape | UndefinedType = Undefined,
            storm_control: StormControl | UndefinedType = Undefined,
            ip_proxy_arp: bool | None | UndefinedType = Undefined,
            isis_enable: str | None | UndefinedType = Undefined,
            isis_bfd: bool | None | UndefinedType = Undefined,
            isis_passive: bool | None | UndefinedType = Undefined,
            isis_metric: int | None | UndefinedType = Undefined,
            isis_network_point_to_point: bool | None | UndefinedType = Undefined,
            isis_circuit_type: str | None | UndefinedType = Undefined,
            isis_hello_padding: bool | None | UndefinedType = Undefined,
            isis_authentication_mode: str | None | UndefinedType = Undefined,
            isis_authentication_key: str | None | UndefinedType = Undefined,
            traffic_policy: TrafficPolicy | UndefinedType = Undefined,
            evpn_ethernet_segment: EvpnEthernetSegment | UndefinedType = Undefined,
            lacp_id: str | None | UndefinedType = Undefined,
            spanning_tree_bpdufilter: str | None | UndefinedType = Undefined,
            spanning_tree_bpduguard: str | None | UndefinedType = Undefined,
            spanning_tree_guard: str | None | UndefinedType = Undefined,
            spanning_tree_portfast: str | None | UndefinedType = Undefined,
            vmtracer: bool | None | UndefinedType = Undefined,
            ptp: Ptp | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ip_verify_unicast_source_reachable_via: str | None | UndefinedType = Undefined,
            ip_nat: IpNat | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            ipv6_address_link_local: str | None | UndefinedType = Undefined,
            ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
            ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
            ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
            access_group_in: str | None | UndefinedType = Undefined,
            access_group_out: str | None | UndefinedType = Undefined,
            ipv6_access_group_in: str | None | UndefinedType = Undefined,
            ipv6_access_group_out: str | None | UndefinedType = Undefined,
            mac_access_group_in: str | None | UndefinedType = Undefined,
            mac_access_group_out: str | None | UndefinedType = Undefined,
            pim: Pim | UndefinedType = Undefined,
            service_profile: str | None | UndefinedType = Undefined,
            ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
            ospf_area: str | None | UndefinedType = Undefined,
            ospf_cost: int | None | UndefinedType = Undefined,
            ospf_authentication: str | None | UndefinedType = Undefined,
            ospf_authentication_key: str | None | UndefinedType = Undefined,
            ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
            flow_tracker: FlowTracker | UndefinedType = Undefined,
            bgp: Bgp | UndefinedType = Undefined,
            ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
            peer: str | None | UndefinedType = Undefined,
            peer_interface: str | None | UndefinedType = Undefined,
            peer_type: str | None | UndefinedType = Undefined,
            sflow: Sflow | UndefinedType = Undefined,
            switchport: Switchport | UndefinedType = Undefined,
            validate_state: bool | None | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            PortChannelInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: name
                description: description
                logging: logging
                shutdown: shutdown
                l2_mtu: "l2_mtu" should only be defined for platforms supporting the "l2 mtu" CLI.
                l2_mru: "l2_mru" should only be defined for platforms supporting the "l2 mru" CLI.
                vlans:
                   List of switchport vlans as string.
                   For a trunk port this would be a range like "1-200,300".
                   For an
                   access port this would be a single vlan "123".
                snmp_trap_link_change: snmp_trap_link_change
                type:
                   l3dot1q and l2dot1q are used for sub-interfaces. The parent interface should be defined as routed.
                   Interface will not be listed in device documentation, unless "type" is set.
                encapsulation_dot1q_vlan: VLAN tag to configure on sub-interface.
                encapsulation_dot1q:
                   Warning: `encapsulation_dot1q` should not be combined with `ethernet_interfaces[].type: l3dot1q` or
                   `ethernet_interfaces[].type: l2dot1q`.
                vrf: VRF name.
                encapsulation_vlan:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `encapsulation_vlan` should not
                   be combined with `ethernet_interfaces[].type: l3dot1q` or `ethernet_interfaces[].type: l2dot1q`.
                vlan_id:
                   This setting can only be applied to sub-interfaces on EOS.
                   Warning: `vlan_id` should not be combined
                   with `ethernet_interfaces[].type == l2dot1q`.
                mode: mode
                native_vlan: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                native_vlan_tag: If setting both native_vlan and native_vlan_tag, native_vlan_tag takes precedence.
                link_tracking_groups: link_tracking_groups
                phone: phone
                l2_protocol: l2_protocol
                mtu: mtu
                mlag: MLAG ID.
                trunk_groups: trunk_groups
                lacp_fallback_timeout: Timeout in seconds.
                lacp_fallback_mode: lacp_fallback_mode
                qos: qos
                bfd: bfd
                service_policy: service_policy
                mpls: mpls
                trunk_private_vlan_secondary: trunk_private_vlan_secondary
                pvlan_mapping: List of vlans as string.
                vlan_translations: vlan_translations
                shape: shape
                storm_control: storm_control
                ip_proxy_arp: ip_proxy_arp
                isis_enable: ISIS instance.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                isis_circuit_type: isis_circuit_type
                isis_hello_padding: isis_hello_padding
                isis_authentication_mode: isis_authentication_mode
                isis_authentication_key: Type-7 encrypted password.
                traffic_policy: traffic_policy
                evpn_ethernet_segment: evpn_ethernet_segment
                lacp_id: LACP ID with format xxxx.xxxx.xxxx.
                spanning_tree_bpdufilter: spanning_tree_bpdufilter
                spanning_tree_bpduguard: spanning_tree_bpduguard
                spanning_tree_guard: spanning_tree_guard
                spanning_tree_portfast: spanning_tree_portfast
                vmtracer: vmtracer
                ptp: ptp
                ip_address: IPv4 address/mask.
                ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                ip_nat: ip_nat
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6 address/mask.
                ipv6_address_link_local: Link local IPv6 address/mask.
                ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                ipv6_nd_prefixes: ipv6_nd_prefixes
                access_group_in: Access list name.
                access_group_out: Access list name.
                ipv6_access_group_in: IPv6 access list name.
                ipv6_access_group_out: IPv6 access list name.
                mac_access_group_in: MAC access list name.
                mac_access_group_out: MAC access list name.
                pim: pim
                service_profile: QOS profile.
                ospf_network_point_to_point: ospf_network_point_to_point
                ospf_area: ospf_area
                ospf_cost: ospf_cost
                ospf_authentication: ospf_authentication
                ospf_authentication_key: Encrypted password.
                ospf_message_digest_keys: ospf_message_digest_keys
                flow_tracker: flow_tracker
                bgp: bgp
                ip_igmp_host_proxy: ip_igmp_host_proxy
                peer: Key only used for documentation or validation purposes.
                peer_interface: Key only used for documentation or validation purposes.
                peer_type: Key only used for documentation or validation purposes.
                sflow: sflow
                switchport: switchport
                validate_state: Set to false to disable interface validation by the `eos_validate_state` role.
                eos_cli: Multiline EOS CLI rendered directly on the port-channel interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PortChannelInterfaces(AvdCollection[str, PortChannelInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    PortChannelInterfaces._item_type = PortChannelInterfacesItem

    class PrefixListsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "permit 10.255.0.0/27 eq 32"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "permit 10.255.0.0/27 eq 32"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Prefix-list Name."""
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            PrefixListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Prefix-list Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class PrefixLists(AvdCollection[str, PrefixListsItem]):
        _primary_key: ClassVar[str] = "name"

    PrefixLists._item_type = PrefixListsItem

    class PriorityFlowControl(AvdModel):
        class Watchdog(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "action": {"type": str},
                "timeout": {"type": str},
                "polling_interval": {"type": str},
                "recovery_time": {"type": str},
                "override_action_drop": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            action: str | None
            """Action on stuck queue."""
            timeout: str | None
            """
            Timeout in seconds after which port should be errdisabled or
            should start dropping on congested
            priorities.
            This should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            polling_interval: str | None
            """
            Time interval in seconds at which the watchdog should poll the queues.
            This should be decimal with
            up to 3 decimal point.
            Example: 0.005 or 60
            """
            recovery_time: str | None
            """
            Recovery-time in seconds after which stuck queue should
            recover and start forwarding again.
            This
            should be decimal with up to 2 decimal point.
            Example: 0.01 or 60
            """
            override_action_drop: bool | None
            """Override configured action on stuck queue to drop."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                action: str | None | UndefinedType = Undefined,
                timeout: str | None | UndefinedType = Undefined,
                polling_interval: str | None | UndefinedType = Undefined,
                recovery_time: str | None | UndefinedType = Undefined,
                override_action_drop: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Watchdog.

                Args:
                -----
                    _custom_data: _custom_data
                    action: Action on stuck queue.
                    timeout:
                       Timeout in seconds after which port should be errdisabled or
                       should start dropping on congested
                       priorities.
                       This should be decimal with up to 2 decimal point.
                       Example: 0.01 or 60
                    polling_interval:
                       Time interval in seconds at which the watchdog should poll the queues.
                       This should be decimal with
                       up to 3 decimal point.
                       Example: 0.005 or 60
                    recovery_time:
                       Recovery-time in seconds after which stuck queue should
                       recover and start forwarding again.
                       This
                       should be decimal with up to 2 decimal point.
                       Example: 0.01 or 60
                    override_action_drop: Override configured action on stuck queue to drop.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "all_off": {"type": bool}, "watchdog": {"type": Watchdog}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        all_off: bool | None
        """Disable PFC on all interfaces."""
        watchdog: Watchdog

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            all_off: bool | None | UndefinedType = Undefined,
            watchdog: Watchdog | UndefinedType = Undefined,
        ) -> None:
            """
            PriorityFlowControl.

            Args:
            -----
                _custom_data: _custom_data
                all_off: Disable PFC on all interfaces.
                watchdog: watchdog

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Ptp(AvdModel):
        class Source(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ip: str | None
            """Source IP."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ip: str | None | UndefinedType = Undefined) -> None:
                """
                Source.

                Args:
                -----
                    _custom_data: _custom_data
                    ip: Source IP.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MessageType(AvdModel):
            class General(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dscp": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dscp: int | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, dscp: int | None | UndefinedType = Undefined) -> None:
                    """
                    General.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dscp: dscp

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Event(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dscp": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dscp: int | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, dscp: int | None | UndefinedType = Undefined) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dscp: dscp

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "general": {"type": General}, "event": {"type": Event}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            general: General
            event: Event

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                general: General | UndefinedType = Undefined,
                event: Event | UndefinedType = Undefined,
            ) -> None:
                """
                MessageType.

                Args:
                -----
                    _custom_data: _custom_data
                    general: general
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Monitor(AvdModel):
            class Threshold(AvdModel):
                class Drop(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "offset_from_master": {"type": int}, "mean_path_delay": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    offset_from_master: int | None
                    mean_path_delay: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        offset_from_master: int | None | UndefinedType = Undefined,
                        mean_path_delay: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Drop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            offset_from_master: offset_from_master
                            mean_path_delay: mean_path_delay

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "offset_from_master": {"type": int},
                    "mean_path_delay": {"type": int},
                    "drop": {"type": Drop},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                offset_from_master: int | None
                mean_path_delay: int | None
                drop: Drop

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    offset_from_master: int | None | UndefinedType = Undefined,
                    mean_path_delay: int | None | UndefinedType = Undefined,
                    drop: Drop | UndefinedType = Undefined,
                ) -> None:
                    """
                    Threshold.

                    Args:
                    -----
                        _custom_data: _custom_data
                        offset_from_master: offset_from_master
                        mean_path_delay: mean_path_delay
                        drop: drop

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MissingMessage(AvdModel):
                class Intervals(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "announce": {"type": int}, "follow_up": {"type": int}, "sync": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    announce: int | None
                    follow_up: int | None
                    sync: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        announce: int | None | UndefinedType = Undefined,
                        follow_up: int | None | UndefinedType = Undefined,
                        sync: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Intervals.

                        Args:
                        -----
                            _custom_data: _custom_data
                            announce: announce
                            follow_up: follow_up
                            sync: sync

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SequenceIds(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "announce": {"type": int},
                        "delay_resp": {"type": int},
                        "follow_up": {"type": int},
                        "sync": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    announce: int | None
                    delay_resp: int | None
                    follow_up: int | None
                    sync: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        announce: int | None | UndefinedType = Undefined,
                        delay_resp: int | None | UndefinedType = Undefined,
                        follow_up: int | None | UndefinedType = Undefined,
                        sync: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SequenceIds.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            announce: announce
                            delay_resp: delay_resp
                            follow_up: follow_up
                            sync: sync

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "intervals": {"type": Intervals}, "sequence_ids": {"type": SequenceIds}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                intervals: Intervals
                sequence_ids: SequenceIds

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    intervals: Intervals | UndefinedType = Undefined,
                    sequence_ids: SequenceIds | UndefinedType = Undefined,
                ) -> None:
                    """
                    MissingMessage.

                    Args:
                    -----
                        _custom_data: _custom_data
                        intervals: intervals
                        sequence_ids: sequence_ids

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool, "default": True},
                "threshold": {"type": Threshold},
                "missing_message": {"type": MissingMessage},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            threshold: Threshold
            missing_message: MissingMessage

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                threshold: Threshold | UndefinedType = Undefined,
                missing_message: MissingMessage | UndefinedType = Undefined,
            ) -> None:
                """
                Monitor.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    threshold: threshold
                    missing_message: missing_message

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "mode": {"type": str},
            "profile": {"type": str},
            "mode_one_step": {"type": bool},
            "forward_unicast": {"type": bool},
            "clock_identity": {"type": str},
            "source": {"type": Source},
            "priority1": {"type": int},
            "priority2": {"type": int},
            "ttl": {"type": int},
            "domain": {"type": int},
            "message_type": {"type": MessageType},
            "monitor": {"type": Monitor},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mode: str | None
        profile: str | None
        mode_one_step: bool | None
        forward_unicast: bool | None
        clock_identity: str | None
        """The clock-id in xx:xx:xx:xx:xx:xx format."""
        source: Source
        priority1: int | None
        priority2: int | None
        ttl: int | None
        domain: int | None
        message_type: MessageType
        monitor: Monitor

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            profile: str | None | UndefinedType = Undefined,
            mode_one_step: bool | None | UndefinedType = Undefined,
            forward_unicast: bool | None | UndefinedType = Undefined,
            clock_identity: str | None | UndefinedType = Undefined,
            source: Source | UndefinedType = Undefined,
            priority1: int | None | UndefinedType = Undefined,
            priority2: int | None | UndefinedType = Undefined,
            ttl: int | None | UndefinedType = Undefined,
            domain: int | None | UndefinedType = Undefined,
            message_type: MessageType | UndefinedType = Undefined,
            monitor: Monitor | UndefinedType = Undefined,
        ) -> None:
            """
            Ptp.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode
                profile: profile
                mode_one_step: mode_one_step
                forward_unicast: forward_unicast
                clock_identity: The clock-id in xx:xx:xx:xx:xx:xx format.
                source: source
                priority1: priority1
                priority2: priority2
                ttl: ttl
                domain: domain
                message_type: message_type
                monitor: monitor

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Qos(AvdModel):
        class Map(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "cos": {"type": list, "items": str},
                "dscp": {"type": list, "items": str},
                "exp": {"type": list, "items": str},
                "traffic_class": {"type": list, "items": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            cos: list[str]
            dscp: list[str]
            exp: list[str]
            traffic_class: list[str]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                cos: list[str] | UndefinedType = Undefined,
                dscp: list[str] | UndefinedType = Undefined,
                exp: list[str] | UndefinedType = Undefined,
                traffic_class: list[str] | UndefinedType = Undefined,
            ) -> None:
                """
                Map.

                Args:
                -----
                    _custom_data: _custom_data
                    cos: cos
                    dscp: dscp
                    exp: exp
                    traffic_class: traffic_class

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RandomDetect(AvdModel):
            class Ecn(AvdModel):
                class AllowNonEct(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "chip_based": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """
                    Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                    Check which command is
                    required for your platform.
                    """
                    chip_based: bool | None
                    """Allow non-ect chip-based."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        chip_based: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AllowNonEct.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled:
                               Allow non-ect and set drop-precedence 1 in a policy map simultaneously.
                               Check which command is
                               required for your platform.
                            chip_based: Allow non-ect chip-based.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "allow_non_ect": {"type": AllowNonEct}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                allow_non_ect: AllowNonEct

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, allow_non_ect: AllowNonEct | UndefinedType = Undefined) -> None:
                    """
                    Ecn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        allow_non_ect: allow_non_ect

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ecn": {"type": Ecn}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ecn: Ecn
            """Global ECN Configuration."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ecn: Ecn | UndefinedType = Undefined) -> None:
                """
                RandomDetect.

                Args:
                -----
                    _custom_data: _custom_data
                    ecn: Global ECN Configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "map": {"type": Map},
            "rewrite_dscp": {"type": bool},
            "random_detect": {"type": RandomDetect},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        map: Map
        rewrite_dscp: bool | None
        random_detect: RandomDetect
        """Global random-detect settings."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            map: Map | UndefinedType = Undefined,
            rewrite_dscp: bool | None | UndefinedType = Undefined,
            random_detect: RandomDetect | UndefinedType = Undefined,
        ) -> None:
            """
            Qos.

            Args:
            -----
                _custom_data: _custom_data
                map: map
                rewrite_dscp: rewrite_dscp
                random_detect: Global random-detect settings.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QosProfilesItem(AvdModel):
        class Shape(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            rate: str | None
            """
            Supported options are platform dependent.
            Example: "< rate > kbps", "1-100 percent", "< rate > pps"
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: str | None | UndefinedType = Undefined) -> None:
                """
                Shape.

                Args:
                -----
                    _custom_data: _custom_data
                    rate:
                       Supported options are platform dependent.
                       Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdModel):
            class Type(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "qos_input": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                qos_input: str | None
                """Policy-map name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, qos_input: str | None | UndefinedType = Undefined) -> None:
                    """
                    Type.

                    Args:
                    -----
                        _custom_data: _custom_data
                        qos_input: Policy-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": Type}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            type: Type

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, type: Type | UndefinedType = Undefined) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TxQueuesItem(AvdModel):
            class Shape(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shape.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RandomDetect(AvdModel):
                class Ecn(AvdModel):
                    class Threshold(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "units", "min", "max")
                        _custom_data: dict[str, Any]
                        units: str
                        """
                        Units to be used for the threshold values.
                        This should be one of segments, byte, kbytes, mbytes.
                        """
                        min: int
                        """Random-detect ECN minimum-threshold."""
                        max: int
                        """Random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Random-detect ECN maximum mark probability."""
                        weight: int | None
                        """Random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            units: str | UndefinedType = Undefined,
                            min: int | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                            max_probability: int | None | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units:
                                   Units to be used for the threshold values.
                                   This should be one of segments, byte, kbytes, mbytes.
                                min: Random-detect ECN minimum-threshold.
                                max: Random-detect ECN maximum-threshold.
                                max_probability: Random-detect ECN maximum mark probability.
                                weight: Random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": bool}, "threshold": {"type": Threshold}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: bool | None | UndefinedType = Undefined,
                        threshold: Threshold | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Drop(AvdModel):
                    class Threshold(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "units": {"type": str},
                            "drop_precedence": {"type": int},
                            "min": {"type": int},
                            "max": {"type": int},
                            "drop_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "units", "min", "max", "drop_probability")
                        _custom_data: dict[str, Any]
                        units: str
                        """Units to be used for the threshold values."""
                        drop_precedence: int | None
                        """Specify Drop Precedence value."""
                        min: int
                        """WRED minimum-threshold."""
                        max: int
                        """WRED maximum-threshold."""
                        drop_probability: int
                        """WRED drop probability."""
                        weight: int | None
                        """WRED weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            units: str | UndefinedType = Undefined,
                            drop_precedence: int | None | UndefinedType = Undefined,
                            min: int | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                            drop_probability: int | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Units to be used for the threshold values.
                                drop_precedence: Specify Drop Precedence value.
                                min: WRED minimum-threshold.
                                max: WRED maximum-threshold.
                                drop_probability: WRED drop probability.
                                weight: WRED weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "threshold": {"type": Threshold}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    threshold: Threshold

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                        """
                        Drop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ecn": {"type": Ecn}, "drop": {"type": Drop}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ecn: Ecn
                """Explicit Congestion Notification."""
                drop: Drop
                """Set WRED parameters."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ecn: Ecn | UndefinedType = Undefined,
                    drop: Drop | UndefinedType = Undefined,
                ) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.
                        drop: Set WRED parameters.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "random_detect": {"type": RandomDetect},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """TX-Queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: str | None
            shape: Shape
            comment: str | None
            """Text comment added to queue."""
            random_detect: RandomDetect

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                bandwidth_percent: int | None | UndefinedType = Undefined,
                bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                priority: str | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                comment: str | None | UndefinedType = Undefined,
                random_detect: RandomDetect | UndefinedType = Undefined,
            ) -> None:
                """
                TxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: TX-Queue ID.
                    bandwidth_percent: bandwidth_percent
                    bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                    priority: priority
                    shape: shape
                    comment: Text comment added to queue.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class TxQueues(AvdCollection[int, TxQueuesItem]):
            _primary_key: ClassVar[str] = "id"

        TxQueues._item_type = TxQueuesItem

        class UcTxQueuesItem(AvdModel):
            class Shape(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shape.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RandomDetect(AvdModel):
                class Ecn(AvdModel):
                    class Threshold(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "units": {"type": str},
                            "min": {"type": int},
                            "max": {"type": int},
                            "max_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "units", "min", "max")
                        _custom_data: dict[str, Any]
                        units: str
                        """Unit to be used for the threshold values."""
                        min: int
                        """Random-detect ECN minimum-threshold."""
                        max: int
                        """Random-detect ECN maximum-threshold."""
                        max_probability: int | None
                        """Random-detect ECN maximum mark probability."""
                        weight: int | None
                        """Random-detect ECN weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            units: str | UndefinedType = Undefined,
                            min: int | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                            max_probability: int | None | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Unit to be used for the threshold values.
                                min: Random-detect ECN minimum-threshold.
                                max: Random-detect ECN maximum-threshold.
                                max_probability: Random-detect ECN maximum mark probability.
                                weight: Random-detect ECN weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": bool}, "threshold": {"type": Threshold}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: bool | None
                    """Enable counter for random-detect ECNs."""
                    threshold: Threshold

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: bool | None | UndefinedType = Undefined,
                        threshold: Threshold | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ecn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Enable counter for random-detect ECNs.
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Drop(AvdModel):
                    class Threshold(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "units": {"type": str},
                            "drop_precedence": {"type": int},
                            "min": {"type": int},
                            "max": {"type": int},
                            "drop_probability": {"type": int},
                            "weight": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "units", "min", "max", "drop_probability")
                        _custom_data: dict[str, Any]
                        units: str
                        """Units to be used for the threshold values."""
                        drop_precedence: int | None
                        """Specify Drop Precedence value."""
                        min: int
                        """WRED minimum-threshold."""
                        max: int
                        """WRED maximum-threshold."""
                        drop_probability: int
                        """WRED drop probability."""
                        weight: int | None
                        """WRED weight."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            units: str | UndefinedType = Undefined,
                            drop_precedence: int | None | UndefinedType = Undefined,
                            min: int | UndefinedType = Undefined,
                            max: int | UndefinedType = Undefined,
                            drop_probability: int | UndefinedType = Undefined,
                            weight: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Threshold.

                            Args:
                            -----
                                _custom_data: _custom_data
                                units: Units to be used for the threshold values.
                                drop_precedence: Specify Drop Precedence value.
                                min: WRED minimum-threshold.
                                max: WRED maximum-threshold.
                                drop_probability: WRED drop probability.
                                weight: WRED weight.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "threshold": {"type": Threshold}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    threshold: Threshold

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, threshold: Threshold | UndefinedType = Undefined) -> None:
                        """
                        Drop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            threshold: threshold

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ecn": {"type": Ecn}, "drop": {"type": Drop}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ecn: Ecn
                """Explicit Congestion Notification."""
                drop: Drop
                """Set WRED parameters."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ecn: Ecn | UndefinedType = Undefined,
                    drop: Drop | UndefinedType = Undefined,
                ) -> None:
                    """
                    RandomDetect.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ecn: Explicit Congestion Notification.
                        drop: Set WRED parameters.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
                "random_detect": {"type": RandomDetect},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """UC TX queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: str | None
            shape: Shape
            comment: str | None
            """Text comment added to queue."""
            random_detect: RandomDetect

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                bandwidth_percent: int | None | UndefinedType = Undefined,
                bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                priority: str | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                comment: str | None | UndefinedType = Undefined,
                random_detect: RandomDetect | UndefinedType = Undefined,
            ) -> None:
                """
                UcTxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: UC TX queue ID.
                    bandwidth_percent: bandwidth_percent
                    bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                    priority: priority
                    shape: shape
                    comment: Text comment added to queue.
                    random_detect: random_detect

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UcTxQueues(AvdCollection[int, UcTxQueuesItem]):
            _primary_key: ClassVar[str] = "id"

        UcTxQueues._item_type = UcTxQueuesItem

        class McTxQueuesItem(AvdModel):
            class Shape(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                rate: str | None
                """
                Supported options are platform dependent.
                Example: "< rate > kbps", "1-100 percent", "< rate > pps"
                """

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate: str | None | UndefinedType = Undefined) -> None:
                    """
                    Shape.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate:
                           Supported options are platform dependent.
                           Example: "< rate > kbps", "1-100 percent", "< rate > pps"

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "bandwidth_percent": {"type": int},
                "bandwidth_guaranteed_percent": {"type": int},
                "priority": {"type": str},
                "shape": {"type": Shape},
                "comment": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """MC TX queue ID."""
            bandwidth_percent: int | None
            bandwidth_guaranteed_percent: int | None
            priority: str | None
            shape: Shape
            comment: str | None
            """Text comment added to queue."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                bandwidth_percent: int | None | UndefinedType = Undefined,
                bandwidth_guaranteed_percent: int | None | UndefinedType = Undefined,
                priority: str | None | UndefinedType = Undefined,
                shape: Shape | UndefinedType = Undefined,
                comment: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                McTxQueuesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: MC TX queue ID.
                    bandwidth_percent: bandwidth_percent
                    bandwidth_guaranteed_percent: bandwidth_guaranteed_percent
                    priority: priority
                    shape: shape
                    comment: Text comment added to queue.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class McTxQueues(AvdCollection[int, McTxQueuesItem]):
            _primary_key: ClassVar[str] = "id"

        McTxQueues._item_type = McTxQueuesItem

        class PriorityFlowControl(AvdModel):
            class Watchdog(AvdModel):
                class Timer(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "timeout": {"type": str},
                        "polling_interval": {"type": str},
                        "recovery_time": {"type": str},
                        "forced": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "timeout", "polling_interval", "recovery_time")
                    _custom_data: dict[str, Any]
                    timeout: str
                    """
                    Timeout in seconds after which port should be errdisabled or
                    should start dropping on congested
                    priorities.
                    This should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    polling_interval: str
                    """
                    Time interval in seconds at which the watchdog should poll the queues.
                    This should be decimal with
                    up to 3 decimal point or set
                    to 'auto' based on recovery_time and timeout values.
                    Example: 0.005 or
                    60
                    """
                    recovery_time: str
                    """
                    Recovery-time in seconds after which stuck queue should
                    recover and start forwarding again.
                    This
                    should be decimal with up to 2 decimal point.
                    Example: 0.01 or 60
                    """
                    forced: bool | None
                    """
                    Force recover any stuck queue(s) after the duration,
                    irrespective of whether PFC frames are being
                    received or not.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        timeout: str | UndefinedType = Undefined,
                        polling_interval: str | UndefinedType = Undefined,
                        recovery_time: str | UndefinedType = Undefined,
                        forced: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Timer.

                        Args:
                        -----
                            _custom_data: _custom_data
                            timeout:
                               Timeout in seconds after which port should be errdisabled or
                               should start dropping on congested
                               priorities.
                               This should be decimal with up to 2 decimal point.
                               Example: 0.01 or 60
                            polling_interval:
                               Time interval in seconds at which the watchdog should poll the queues.
                               This should be decimal with
                               up to 3 decimal point or set
                               to 'auto' based on recovery_time and timeout values.
                               Example: 0.005 or
                               60
                            recovery_time:
                               Recovery-time in seconds after which stuck queue should
                               recover and start forwarding again.
                               This
                               should be decimal with up to 2 decimal point.
                               Example: 0.01 or 60
                            forced:
                               Force recover any stuck queue(s) after the duration,
                               irrespective of whether PFC frames are being
                               received or not.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "action": {"type": str}, "timer": {"type": Timer}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                """Enable the watchdog on stuck transmit queues."""
                action: str | None
                """
                Override the default error-disable action to either drop
                traffic on the stuck queue or notify-only
                without making any actions on the stuck queue.
                """
                timer: Timer
                """Timer thresholds whilst monitoring queues."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    action: str | None | UndefinedType = Undefined,
                    timer: Timer | UndefinedType = Undefined,
                ) -> None:
                    """
                    Watchdog.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable the watchdog on stuck transmit queues.
                        action:
                           Override the default error-disable action to either drop
                           traffic on the stuck queue or notify-only
                           without making any actions on the stuck queue.
                        timer: Timer thresholds whilst monitoring queues.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PrioritiesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "priority": {"type": int}, "no_drop": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "priority", "no_drop")
                _custom_data: dict[str, Any]
                priority: int
                """Priority queue number (COS value)."""
                no_drop: bool
                """Enable Priority Flow Control frames on this queue."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    priority: int | UndefinedType = Undefined,
                    no_drop: bool | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrioritiesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        priority: Priority queue number (COS value).
                        no_drop: Enable Priority Flow Control frames on this queue.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Priorities(AvdCollection[int, PrioritiesItem]):
                _primary_key: ClassVar[str] = "priority"

            Priorities._item_type = PrioritiesItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "watchdog": {"type": Watchdog},
                "priorities": {"type": Priorities},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            """Enable Priority Flow control."""
            watchdog: Watchdog
            """Watchdog can detect stuck transmit queues."""
            priorities: Priorities
            """Set the drop/no_drop on each queue."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                watchdog: Watchdog | UndefinedType = Undefined,
                priorities: Priorities | UndefinedType = Undefined,
            ) -> None:
                """
                PriorityFlowControl.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: Enable Priority Flow control.
                    watchdog: Watchdog can detect stuck transmit queues.
                    priorities: Set the drop/no_drop on each queue.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "trust": {"type": str},
            "cos": {"type": int},
            "dscp": {"type": int},
            "shape": {"type": Shape},
            "service_policy": {"type": ServicePolicy},
            "tx_queues": {"type": TxQueues},
            "uc_tx_queues": {"type": UcTxQueues},
            "mc_tx_queues": {"type": McTxQueues},
            "priority_flow_control": {"type": PriorityFlowControl},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Profile-Name."""
        trust: str | None
        cos: int | None
        dscp: int | None
        shape: Shape
        service_policy: ServicePolicy
        tx_queues: TxQueues
        uc_tx_queues: UcTxQueues
        mc_tx_queues: McTxQueues
        priority_flow_control: PriorityFlowControl
        """Priority Flow Control settings."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            trust: str | None | UndefinedType = Undefined,
            cos: int | None | UndefinedType = Undefined,
            dscp: int | None | UndefinedType = Undefined,
            shape: Shape | UndefinedType = Undefined,
            service_policy: ServicePolicy | UndefinedType = Undefined,
            tx_queues: TxQueues | UndefinedType = Undefined,
            uc_tx_queues: UcTxQueues | UndefinedType = Undefined,
            mc_tx_queues: McTxQueues | UndefinedType = Undefined,
            priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
        ) -> None:
            """
            QosProfilesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Profile-Name.
                trust: trust
                cos: cos
                dscp: dscp
                shape: shape
                service_policy: service_policy
                tx_queues: tx_queues
                uc_tx_queues: uc_tx_queues
                mc_tx_queues: mc_tx_queues
                priority_flow_control: Priority Flow Control settings.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QosProfiles(AvdCollection[str, QosProfilesItem]):
        _primary_key: ClassVar[str] = "name"

    QosProfiles._item_type = QosProfilesItem

    class QueueMonitorLength(AvdModel):
        class DefaultThresholds(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "high": {"type": int}, "low": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "high")
            _custom_data: dict[str, Any]
            high: int
            """Default high threshold for Ethernet Interfaces."""
            low: int | None
            """
            Default low threshold for Ethernet Interfaces.
            Low threshold support is platform dependent.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                high: int | UndefinedType = Undefined,
                low: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                DefaultThresholds.

                Args:
                -----
                    _custom_data: _custom_data
                    high: Default high threshold for Ethernet Interfaces.
                    low:
                       Default low threshold for Ethernet Interfaces.
                       Low threshold support is platform dependent.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Cpu(AvdModel):
            class Thresholds(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "high": {"type": int}, "low": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "high")
                _custom_data: dict[str, Any]
                high: int
                low: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    high: int | UndefinedType = Undefined,
                    low: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Thresholds.

                    Args:
                    -----
                        _custom_data: _custom_data
                        high: high
                        low: low

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "thresholds": {"type": Thresholds}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            thresholds: Thresholds

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, thresholds: Thresholds | UndefinedType = Undefined) -> None:
                """
                Cpu.

                Args:
                -----
                    _custom_data: _custom_data
                    thresholds: thresholds

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool},
            "default_thresholds": {"type": DefaultThresholds},
            "log": {"type": int},
            "notifying": {"type": bool},
            "cpu": {"type": Cpu},
            "tx_latency": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
        _custom_data: dict[str, Any]
        enabled: bool
        default_thresholds: DefaultThresholds
        log: int | None
        """Logging interval in seconds."""
        notifying: bool | None
        """Should only be used for platforms supporting the "queue-monitor length notifying" CLI."""
        cpu: Cpu
        tx_latency: bool | None
        """Enable tx-latency mode."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | UndefinedType = Undefined,
            default_thresholds: DefaultThresholds | UndefinedType = Undefined,
            log: int | None | UndefinedType = Undefined,
            notifying: bool | None | UndefinedType = Undefined,
            cpu: Cpu | UndefinedType = Undefined,
            tx_latency: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            QueueMonitorLength.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                default_thresholds: default_thresholds
                log: Logging interval in seconds.
                notifying: Should only be used for platforms supporting the "queue-monitor length notifying" CLI.
                cpu: cpu
                tx_latency: Enable tx-latency mode.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class QueueMonitorStreaming(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enable": {"type": bool},
            "ip_access_group": {"type": str},
            "ipv6_access_group": {"type": str},
            "max_connections": {"type": int},
            "vrf": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enable: bool | None
        ip_access_group: str | None
        """Name of IP ACL."""
        ipv6_access_group: str | None
        """Name of IPv6 ACL."""
        max_connections: int | None
        vrf: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enable: bool | None | UndefinedType = Undefined,
            ip_access_group: str | None | UndefinedType = Undefined,
            ipv6_access_group: str | None | UndefinedType = Undefined,
            max_connections: int | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            QueueMonitorStreaming.

            Args:
            -----
                _custom_data: _custom_data
                enable: enable
                ip_access_group: Name of IP ACL.
                ipv6_access_group: Name of IPv6 ACL.
                max_connections: max_connections
                vrf: vrf

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RadiusServer(AvdModel):
        class Attribute32IncludeInAccessReq(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "hostname": {"type": bool}, "format": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            hostname: bool | None
            format: str | None
            """Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                hostname: bool | None | UndefinedType = Undefined,
                format: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Attribute32IncludeInAccessReq.

                Args:
                -----
                    _custom_data: _custom_data
                    hostname: hostname
                    format: Specify the format of the NAS-Identifier. If 'hostname' is set, this is ignored.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class DynamicAuthorization(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "port": {"type": int}, "tls_ssl_profile": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            port: int | None
            """TCP Port."""
            tls_ssl_profile: str | None
            """Name of TLS profile."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                port: int | None | UndefinedType = Undefined,
                tls_ssl_profile: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                DynamicAuthorization.

                Args:
                -----
                    _custom_data: _custom_data
                    port: TCP Port.
                    tls_ssl_profile: Name of TLS profile.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdModel):
            class Tls(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "ssl_profile": {"type": str}, "port": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enable TLS for radius-server."""
                ssl_profile: str | None
                """Name of TLS profile."""
                port: int | None
                """TCP Port used for TLS. EOS default is 2083."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Tls.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable TLS for radius-server.
                        ssl_profile: Name of TLS profile.
                        port: TCP Port used for TLS. EOS default is 2083.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "host": {"type": str},
                "vrf": {"type": str},
                "tls": {"type": Tls},
                "timeout": {"type": int},
                "retransmit": {"type": int},
                "key": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "host")
            _custom_data: dict[str, Any]
            host: str
            """Host IP address or name."""
            vrf: str | None
            tls: Tls
            """When TLS is configured, `key` is ignored.."""
            timeout: int | None
            retransmit: int | None
            key: str | None
            """
            Encrypted key - only type 7 supported.
            When TLS is configured, `key` is ignored.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                host: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                tls: Tls | UndefinedType = Undefined,
                timeout: int | None | UndefinedType = Undefined,
                retransmit: int | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf: vrf
                    tls: When TLS is configured, `key` is ignored..
                    timeout: timeout
                    retransmit: retransmit
                    key:
                       Encrypted key - only type 7 supported.
                       When TLS is configured, `key` is ignored.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Hosts(AvdCollection[str, HostsItem]):
            _primary_key: ClassVar[str] = "host"

        Hosts._item_type = HostsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "attribute_32_include_in_access_req": {"type": Attribute32IncludeInAccessReq},
            "dynamic_authorization": {"type": DynamicAuthorization},
            "hosts": {"type": Hosts},
            "tls_ssl_profile": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        attribute_32_include_in_access_req: Attribute32IncludeInAccessReq
        dynamic_authorization: DynamicAuthorization
        hosts: Hosts
        tls_ssl_profile: str | None
        """Name of global TLS profile."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            attribute_32_include_in_access_req: Attribute32IncludeInAccessReq | UndefinedType = Undefined,
            dynamic_authorization: DynamicAuthorization | UndefinedType = Undefined,
            hosts: Hosts | UndefinedType = Undefined,
            tls_ssl_profile: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            RadiusServer.

            Args:
            -----
                _custom_data: _custom_data
                attribute_32_include_in_access_req: attribute_32_include_in_access_req
                dynamic_authorization: dynamic_authorization
                hosts: hosts
                tls_ssl_profile: Name of global TLS profile.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Redundancy(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "protocol": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        protocol: str | None
        """Redundancy Protocol."""

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, protocol: str | None | UndefinedType = Undefined) -> None:
            """
            Redundancy.

            Args:
            -----
                _custom_data: _custom_data
                protocol: Redundancy Protocol.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RolesItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "sequence": {"type": int},
                "action": {"type": str},
                "mode": {"type": str},
                "command": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            sequence: int | None
            """Sequence number."""
            action: str | None
            mode: str | None
            """"config", "config-all", "exec" or mode key as string."""
            command: str | None
            """Command as string."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | None | UndefinedType = Undefined,
                action: str | None | UndefinedType = Undefined,
                mode: str | None | UndefinedType = Undefined,
                command: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence number.
                    action: action
                    mode: "config", "config-all", "exec" or mode key as string.
                    command: Command as string.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": list, "items": SequenceNumbersItem}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Role name."""
        sequence_numbers: list[SequenceNumbersItem]

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sequence_numbers: list[SequenceNumbersItem] | UndefinedType = Undefined,
        ) -> None:
            """
            RolesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Role name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Roles(AvdCollection[str, RolesItem]):
        _primary_key: ClassVar[str] = "name"

    Roles._item_type = RolesItem

    class RouteMapsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            class Continue(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "sequence_number": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                sequence_number: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    sequence_number: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Continue.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        sequence_number: sequence_number

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "sequence": {"type": int},
                "type": {"type": str},
                "description": {"type": str},
                "match": {"type": list, "items": str},
                "set": {"type": list, "items": str},
                "sub_route_map": {"type": str},
                "field_continue": {"type": Continue, "key": "continue"},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "type")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            type: str
            description: str | None
            match: list[str]
            """List of "match" statements."""
            set: list[str]
            """List of "set" statements."""
            sub_route_map: str | None
            """Name of Sub-Route-map."""
            field_continue: Continue

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                type: str | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                match: list[str] | UndefinedType = Undefined,
                set: list[str] | UndefinedType = Undefined,
                sub_route_map: str | None | UndefinedType = Undefined,
                field_continue: Continue | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    type: type
                    description: description
                    match: List of "match" statements.
                    set: List of "set" statements.
                    sub_route_map: Name of Sub-Route-map.
                    field_continue: field_continue

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Route-map Name."""
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            RouteMapsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Route-map Name.
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouteMaps(AvdCollection[str, RouteMapsItem]):
        _primary_key: ClassVar[str] = "name"

    RouteMaps._item_type = RouteMapsItem

    class RouterAdaptiveVirtualTopology(AvdModel):
        class Region(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "id": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
            _custom_data: dict[str, Any]
            name: str
            id: int

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, id: int | UndefinedType = Undefined
            ) -> None:
                """
                Region.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    id: id

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Zone(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "id": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
            _custom_data: dict[str, Any]
            name: str
            id: int

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, id: int | UndefinedType = Undefined
            ) -> None:
                """
                Zone.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    id: id

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Site(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "id": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "id")
            _custom_data: dict[str, Any]
            name: str
            id: int

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, id: int | UndefinedType = Undefined
            ) -> None:
                """
                Site.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    id: id

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProfilesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "load_balance_policy": {"type": str},
                "internet_exit_policy": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """AVT Name."""
            load_balance_policy: str | None
            """Name of the load-balance policy."""
            internet_exit_policy: str | None
            """Name of the internet exit policy."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                load_balance_policy: str | None | UndefinedType = Undefined,
                internet_exit_policy: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: AVT Name.
                    load_balance_policy: Name of the load-balance policy.
                    internet_exit_policy: Name of the internet exit policy.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Profiles(AvdCollection[str, ProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        class PoliciesItem(AvdModel):
            class MatchesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "application_profile": {"type": str},
                    "avt_profile": {"type": str},
                    "dscp": {"type": int},
                    "traffic_class": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                application_profile: str | None
                """Application profile name."""
                avt_profile: str | None
                """AVT Profile name."""
                dscp: int | None
                """Set DSCP for matched traffic."""
                traffic_class: int | None
                """Set traffic-class for matched traffic."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    application_profile: str | None | UndefinedType = Undefined,
                    avt_profile: str | None | UndefinedType = Undefined,
                    dscp: int | None | UndefinedType = Undefined,
                    traffic_class: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    MatchesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        application_profile: Application profile name.
                        avt_profile: AVT Profile name.
                        dscp: Set DSCP for matched traffic.
                        traffic_class: Set traffic-class for matched traffic.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "matches": {"type": list, "items": MatchesItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Policy name."""
            matches: list[MatchesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                matches: list[MatchesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy name.
                    matches: matches

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdCollection[str, PoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            class ProfilesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "id": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                _custom_data: dict[str, Any]
                name: str | None
                """AVT profile name."""
                id: int
                """Unique ID for this AVT (per VRF)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    id: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    ProfilesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: AVT profile name.
                        id: Unique ID for this AVT (per VRF).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Profiles(AvdCollection[int, ProfilesItem]):
                _primary_key: ClassVar[str] = "id"

            Profiles._item_type = ProfilesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "policy": {"type": str}, "profiles": {"type": Profiles}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            policy: str | None
            """AVT Policy name."""
            profiles: Profiles
            """AVT profiles in this VRF."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                policy: str | None | UndefinedType = Undefined,
                profiles: Profiles | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    policy: AVT Policy name.
                    profiles: AVT profiles in this VRF.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "topology_role": {"type": str},
            "gateway_vxlan": {"type": bool},
            "region": {"type": Region},
            "zone": {"type": Zone},
            "site": {"type": Site},
            "profiles": {"type": Profiles},
            "policies": {"type": Policies},
            "vrfs": {"type": Vrfs},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        topology_role: str | None
        """Role name."""
        gateway_vxlan: bool | None
        """
        Enables VXLAN gateway router profile.
        Only applicable for `topology_role: edge`, `topology_role:
        transit region` or `topology_role: transit zone`.
        """
        region: Region
        """Region name and ID."""
        zone: Zone
        """Zone name and ID."""
        site: Site
        """Site name and ID."""
        profiles: Profiles
        policies: Policies
        """A sequence of application profiles mapped to some virtual topologies."""
        vrfs: Vrfs

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            topology_role: str | None | UndefinedType = Undefined,
            gateway_vxlan: bool | None | UndefinedType = Undefined,
            region: Region | UndefinedType = Undefined,
            zone: Zone | UndefinedType = Undefined,
            site: Site | UndefinedType = Undefined,
            profiles: Profiles | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            RouterAdaptiveVirtualTopology.

            Args:
            -----
                _custom_data: _custom_data
                topology_role: Role name.
                gateway_vxlan:
                   Enables VXLAN gateway router profile.
                   Only applicable for `topology_role: edge`, `topology_role:
                   transit region` or `topology_role: transit zone`.
                region: Region name and ID.
                zone: Zone name and ID.
                site: Site name and ID.
                profiles: profiles
                policies: A sequence of application profiles mapped to some virtual topologies.
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterBfd(AvdModel):
        class Multihop(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interval: int | None
            """Rate in milliseconds."""
            min_rx: int | None
            """Rate in milliseconds."""
            multiplier: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                min_rx: int | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Multihop.

                Args:
                -----
                    _custom_data: _custom_data
                    interval: Rate in milliseconds.
                    min_rx: Rate in milliseconds.
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Sbfd(AvdModel):
            class LocalInterface(AvdModel):
                class Protocols(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": bool}, "ipv6": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    ipv4: bool | None
                    ipv6: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ipv4: bool | None | UndefinedType = Undefined,
                        ipv6: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Protocols.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ipv4: ipv4
                            ipv6: ipv6

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "protocols": {"type": Protocols}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """Interface Name."""
                protocols: Protocols

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    protocols: Protocols | UndefinedType = Undefined,
                ) -> None:
                    """
                    LocalInterface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Interface Name.
                        protocols: protocols

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Reflector(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "min_rx": {"type": int}, "local_discriminator": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                min_rx: int | None
                """Rate in milliseconds."""
                local_discriminator: str | None
                """IPv4 address or 32 bit integer."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    min_rx: int | None | UndefinedType = Undefined,
                    local_discriminator: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Reflector.

                    Args:
                    -----
                        _custom_data: _custom_data
                        min_rx: Rate in milliseconds.
                        local_discriminator: IPv4 address or 32 bit integer.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "local_interface": {"type": LocalInterface},
                "initiator_interval": {"type": int},
                "initiator_multiplier": {"type": int},
                "initiator_measurement_round_trip": {"type": bool},
                "reflector": {"type": Reflector},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            local_interface: LocalInterface
            initiator_interval: int | None
            """Rate in milliseconds."""
            initiator_multiplier: int | None
            initiator_measurement_round_trip: bool | None
            """Enable round-trip delay measurement."""
            reflector: Reflector

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                local_interface: LocalInterface | UndefinedType = Undefined,
                initiator_interval: int | None | UndefinedType = Undefined,
                initiator_multiplier: int | None | UndefinedType = Undefined,
                initiator_measurement_round_trip: bool | None | UndefinedType = Undefined,
                reflector: Reflector | UndefinedType = Undefined,
            ) -> None:
                """
                Sbfd.

                Args:
                -----
                    _custom_data: _custom_data
                    local_interface: local_interface
                    initiator_interval: Rate in milliseconds.
                    initiator_multiplier: initiator_multiplier
                    initiator_measurement_round_trip: Enable round-trip delay measurement.
                    reflector: reflector

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "interval": {"type": int},
            "local_address": {"type": str},
            "min_rx": {"type": int},
            "multiplier": {"type": int},
            "multihop": {"type": Multihop},
            "session_snapshot_interval": {"type": int},
            "session_snapshot_interval_dangerous": {"type": bool},
            "sbfd": {"type": Sbfd},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        interval: int | None
        """Rate in milliseconds."""
        local_address: str | None
        """Configure BFD local IP/IPv6 address."""
        min_rx: int | None
        """Rate in milliseconds."""
        multiplier: int | None
        multihop: Multihop
        session_snapshot_interval: int | None
        """
        Interval in seconds.
        Intervals below 10 are considered "dangerous" on EOS and must have
        `session_snapshot_interval_dangerous` set to `true`.
        """
        session_snapshot_interval_dangerous: bool | None
        sbfd: Sbfd

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            interval: int | None | UndefinedType = Undefined,
            local_address: str | None | UndefinedType = Undefined,
            min_rx: int | None | UndefinedType = Undefined,
            multiplier: int | None | UndefinedType = Undefined,
            multihop: Multihop | UndefinedType = Undefined,
            session_snapshot_interval: int | None | UndefinedType = Undefined,
            session_snapshot_interval_dangerous: bool | None | UndefinedType = Undefined,
            sbfd: Sbfd | UndefinedType = Undefined,
        ) -> None:
            """
            RouterBfd.

            Args:
            -----
                _custom_data: _custom_data
                interval: Rate in milliseconds.
                local_address: Configure BFD local IP/IPv6 address.
                min_rx: Rate in milliseconds.
                multiplier: multiplier
                multihop: multihop
                session_snapshot_interval:
                   Interval in seconds.
                   Intervals below 10 are considered "dangerous" on EOS and must have
                   `session_snapshot_interval_dangerous` set to `true`.
                session_snapshot_interval_dangerous: session_snapshot_interval_dangerous
                sbfd: sbfd

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterBgp(AvdModel):
        class Distance(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "external_routes": {"type": int},
                "internal_routes": {"type": int},
                "local_routes": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "external_routes", "internal_routes", "local_routes")
            _custom_data: dict[str, Any]
            external_routes: int
            internal_routes: int
            local_routes: int

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                external_routes: int | UndefinedType = Undefined,
                internal_routes: int | UndefinedType = Undefined,
                local_routes: int | UndefinedType = Undefined,
            ) -> None:
                """
                Distance.

                Args:
                -----
                    _custom_data: _custom_data
                    external_routes: external_routes
                    internal_routes: internal_routes
                    local_routes: local_routes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GracefulRestart(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "restart_time": {"type": int},
                "stalepath_time": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            restart_time: int | None
            """Number of seconds."""
            stalepath_time: int | None
            """Number of seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                restart_time: int | None | UndefinedType = Undefined,
                stalepath_time: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                GracefulRestart.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    restart_time: Number of seconds.
                    stalepath_time: Number of seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GracefulRestartHelper(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "restart_time": {"type": int}, "long_lived": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            restart_time: int | None
            """
            Number of seconds
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will take precedence if both are configured.
            """
            long_lived: bool | None
            """
            graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
            restart-time will
            take precedence if both are configured.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                restart_time: int | None | UndefinedType = Undefined,
                long_lived: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                GracefulRestartHelper.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    restart_time:
                       Number of seconds
                       graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                       restart-time will take precedence if both are configured.
                    long_lived:
                       graceful-restart-help long-lived and restart-time are mutually exclusive in CLI.
                       restart-time will
                       take precedence if both are configured.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MaximumPaths(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "paths": {"type": int}, "ecmp": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "paths")
            _custom_data: dict[str, Any]
            paths: int
            ecmp: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                paths: int | UndefinedType = Undefined,
                ecmp: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                MaximumPaths.

                Args:
                -----
                    _custom_data: _custom_data
                    paths: paths
                    ecmp: ecmp

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Updates(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "wait_for_convergence": {"type": bool}, "wait_install": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            wait_for_convergence: bool | None
            """
            Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
            convergence state is reached.
            """
            wait_install: bool | None
            """
            Do not advertise reachability to a prefix until that prefix has been installed in hardware.
            This
            will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
            that may not yet be installed into the forwarding plane.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                wait_for_convergence: bool | None | UndefinedType = Undefined,
                wait_install: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Updates.

                Args:
                -----
                    _custom_data: _custom_data
                    wait_for_convergence:
                       Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                       convergence state is reached.
                    wait_install:
                       Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                       This
                       will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                       that may not yet be installed into the forwarding plane.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bgp(AvdModel):
            class Default(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_unicast": {"type": bool}, "ipv4_unicast_transport_ipv6": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4_unicast: bool | None
                """Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True)."""
                ipv4_unicast_transport_ipv6: bool | None
                """Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4_unicast: bool | None | UndefinedType = Undefined,
                    ipv4_unicast_transport_ipv6: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Default.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_unicast: Default activation of IPv4 unicast address-family on all IPv4 neighbors (EOS default = True).
                        ipv4_unicast_transport_ipv6: Default activation of IPv4 unicast address-family on all IPv6 neighbors (EOS default == False).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteReflectorPreserveAttributes(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RouteReflectorPreserveAttributes.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bestpath(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "d_path": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                d_path: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, d_path: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Bestpath.

                    Args:
                    -----
                        _custom_data: _custom_data
                        d_path: d_path

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AdditionalPaths(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                receive: bool | None
                """Enable or disable reception of additional-paths."""
                send: str | None
                """
                Select an option to send multiple paths for same prefix through bgp updates.
                any: Send any eligible
                path.
                backup: Best path and installed backup path.
                ecmp: All paths in best path ECMP group.
                limit:
                Limit to n eligible paths.
                disabled: Disable sending any paths.
                """
                send_limit: int | None
                """
                Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                `ecmp`.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    receive: bool | None | UndefinedType = Undefined,
                    send: str | None | UndefinedType = Undefined,
                    send_limit: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AdditionalPaths.

                    Args:
                    -----
                        _custom_data: _custom_data
                        receive: Enable or disable reception of additional-paths.
                        send:
                           Select an option to send multiple paths for same prefix through bgp updates.
                           any: Send any eligible
                           path.
                           backup: Best path and installed backup path.
                           ecmp: All paths in best path ECMP group.
                           limit:
                           Limit to n eligible paths.
                           disabled: Disable sending any paths.
                        send_limit:
                           Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                           `ecmp`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "default": {"type": Default},
                "route_reflector_preserve_attributes": {"type": RouteReflectorPreserveAttributes},
                "bestpath": {"type": Bestpath},
                "additional_paths": {"type": AdditionalPaths},
                "redistribute_internal": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: Default
            route_reflector_preserve_attributes: RouteReflectorPreserveAttributes
            bestpath: Bestpath
            additional_paths: AdditionalPaths
            redistribute_internal: bool | None
            """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                default: Default | UndefinedType = Undefined,
                route_reflector_preserve_attributes: RouteReflectorPreserveAttributes | UndefinedType = Undefined,
                bestpath: Bestpath | UndefinedType = Undefined,
                additional_paths: AdditionalPaths | UndefinedType = Undefined,
                redistribute_internal: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Bgp.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default
                    route_reflector_preserve_attributes: route_reflector_preserve_attributes
                    bestpath: bestpath
                    additional_paths: additional_paths
                    redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ListenRangesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "prefix": {"type": str},
                "peer_id_include_router_id": {"type": bool},
                "peer_group": {"type": str},
                "peer_filter": {"type": str},
                "remote_as": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            prefix: str | None
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            peer_id_include_router_id: bool | None
            """Include router ID as part of peer filter."""
            peer_group: str | None
            """Peer group name."""
            peer_filter: str | None
            """
            Peer-filter name.
            note: `peer_filter` or `remote_as` is required but mutually exclusive.
            If both are
            defined, `peer_filter` takes precedence
            """
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                prefix: str | None | UndefinedType = Undefined,
                peer_id_include_router_id: bool | None | UndefinedType = Undefined,
                peer_group: str | None | UndefinedType = Undefined,
                peer_filter: str | None | UndefinedType = Undefined,
                remote_as: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ListenRangesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                    peer_id_include_router_id: Include router ID as part of peer filter.
                    peer_group: Peer group name.
                    peer_filter:
                       Peer-filter name.
                       note: `peer_filter` or `remote_as` is required but mutually exclusive.
                       If both are
                       defined, `peer_filter` takes precedence
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PeerGroupsItem(AvdModel):
            class AsPath(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                remote_as_replace_out: bool | None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None
                """Disable prepending own AS number to AS path."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    remote_as_replace_out: bool | None | UndefinedType = Undefined,
                    prepend_own_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AsPath.

                    Args:
                    -----
                        _custom_data: _custom_data
                        remote_as_replace_out: Replace AS number with local AS number.
                        prepend_own_disabled: Disable prepending own AS number to AS path.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAs(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                all: bool | None
                replace_as: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    all: bool | None | UndefinedType = Undefined,
                    replace_as: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RemovePrivateAs.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAsIngress(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "replace_as": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                replace_as: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    replace_as: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RemovePrivateAsIngress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BfdTimers(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "min_rx", "multiplier")
                _custom_data: dict[str, Any]
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | UndefinedType = Undefined,
                    min_rx: int | UndefinedType = Undefined,
                    multiplier: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    BfdTimers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultOriginate(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always: bool | None
                route_map: str | None
                """Route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultOriginate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MissingPolicy(AvdModel):
                class DirectionIn(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                    _custom_data: dict[str, Any]
                    action: str
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        action: str | UndefinedType = Undefined,
                        include_community_list: bool | None | UndefinedType = Undefined,
                        include_prefix_list: bool | None | UndefinedType = Undefined,
                        include_sub_route_map: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionIn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOut(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                    _custom_data: dict[str, Any]
                    action: str
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        action: str | UndefinedType = Undefined,
                        include_community_list: bool | None | UndefinedType = Undefined,
                        include_prefix_list: bool | None | UndefinedType = Undefined,
                        include_sub_route_map: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionOut.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                direction_in: DirectionIn
                """Missing policy inbound direction."""
                direction_out: DirectionOut
                """Missing policy outbound direction."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    direction_in: DirectionIn | UndefinedType = Undefined,
                    direction_out: DirectionOut | UndefinedType = Undefined,
                ) -> None:
                    """
                    MissingPolicy.

                    Args:
                    -----
                        _custom_data: _custom_data
                        direction_in: Missing policy inbound direction.
                        direction_out: Missing policy outbound direction.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LinkBandwidth(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "default": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                default: str | None
                """nn.nn(K|M|G) link speed in bits/second."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    default: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkBandwidth.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        default: nn.nn(K|M|G) link speed in bits/second.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AllowasIn(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "times": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                times: int | None
                """Number of local ASNs allowed in a BGP update."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    times: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AllowasIn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        times: Number of local ASNs allowed in a BGP update.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RibInPrePolicyRetain(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                all: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    all: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RibInPrePolicyRetain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SharedSecret(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "hash_algorithm": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "hash_algorithm")
                _custom_data: dict[str, Any]
                profile: str
                """Name of profile defined under `management_security`."""
                hash_algorithm: str
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    profile: str | UndefinedType = Undefined,
                    hash_algorithm: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    SharedSecret.

                    Args:
                    -----
                        _custom_data: _custom_data
                        profile: Name of profile defined under `management_security`.
                        hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "type": {"type": str},
                "remote_as": {"type": str},
                "local_as": {"type": str},
                "description": {"type": str},
                "shutdown": {"type": bool},
                "as_path": {"type": AsPath},
                "remove_private_as": {"type": RemovePrivateAs},
                "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                "next_hop_unchanged": {"type": bool},
                "update_source": {"type": str},
                "route_reflector_client": {"type": bool},
                "bfd": {"type": bool},
                "bfd_timers": {"type": BfdTimers},
                "ebgp_multihop": {"type": int},
                "next_hop_self": {"type": bool},
                "password": {"type": str},
                "passive": {"type": bool},
                "default_originate": {"type": DefaultOriginate},
                "send_community": {"type": str},
                "maximum_routes": {"type": int},
                "maximum_routes_warning_limit": {"type": str},
                "maximum_routes_warning_only": {"type": bool},
                "missing_policy": {"type": MissingPolicy},
                "link_bandwidth": {"type": LinkBandwidth},
                "allowas_in": {"type": AllowasIn},
                "weight": {"type": int},
                "timers": {"type": str},
                "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                "route_map_in": {"type": str},
                "route_map_out": {"type": str},
                "session_tracker": {"type": str},
                "shared_secret": {"type": SharedSecret},
                "ttl_maximum_hops": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Peer-group name."""
            type: str | None
            """Key only used for documentation or validation purposes."""
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            description: str | None
            shutdown: bool | None
            as_path: AsPath
            """BGP AS-PATH options."""
            remove_private_as: RemovePrivateAs
            """Remove private AS numbers in outbound AS path."""
            remove_private_as_ingress: RemovePrivateAsIngress
            next_hop_unchanged: bool | None
            update_source: str | None
            """IP address or interface name."""
            route_reflector_client: bool | None
            bfd: bool | None
            """Enable BFD."""
            bfd_timers: BfdTimers
            """Override default BFD timers. BFD must be enabled with `bfd: true`."""
            ebgp_multihop: int | None
            """Time-to-live in range of hops."""
            next_hop_self: bool | None
            password: str | None
            passive: bool | None
            default_originate: DefaultOriginate
            send_community: str | None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: int | None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None
            missing_policy: MissingPolicy
            """Missing policy configuration for all address-families."""
            link_bandwidth: LinkBandwidth
            allowas_in: AllowasIn
            weight: int | None
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            rib_in_pre_policy_retain: RibInPrePolicyRetain
            route_map_in: str | None
            """Inbound route-map name."""
            route_map_out: str | None
            """Outbound route-map name."""
            session_tracker: str | None
            shared_secret: SharedSecret
            ttl_maximum_hops: int | None
            """Maximum number of hops."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                type: str | None | UndefinedType = Undefined,
                remote_as: str | None | UndefinedType = Undefined,
                local_as: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                as_path: AsPath | UndefinedType = Undefined,
                remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                next_hop_unchanged: bool | None | UndefinedType = Undefined,
                update_source: str | None | UndefinedType = Undefined,
                route_reflector_client: bool | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                bfd_timers: BfdTimers | UndefinedType = Undefined,
                ebgp_multihop: int | None | UndefinedType = Undefined,
                next_hop_self: bool | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                passive: bool | None | UndefinedType = Undefined,
                default_originate: DefaultOriginate | UndefinedType = Undefined,
                send_community: str | None | UndefinedType = Undefined,
                maximum_routes: int | None | UndefinedType = Undefined,
                maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                missing_policy: MissingPolicy | UndefinedType = Undefined,
                link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                allowas_in: AllowasIn | UndefinedType = Undefined,
                weight: int | None | UndefinedType = Undefined,
                timers: str | None | UndefinedType = Undefined,
                rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                route_map_in: str | None | UndefinedType = Undefined,
                route_map_out: str | None | UndefinedType = Undefined,
                session_tracker: str | None | UndefinedType = Undefined,
                shared_secret: SharedSecret | UndefinedType = Undefined,
                ttl_maximum_hops: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                PeerGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Peer-group name.
                    type: Key only used for documentation or validation purposes.
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    local_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    description: description
                    shutdown: shutdown
                    as_path: BGP AS-PATH options.
                    remove_private_as: Remove private AS numbers in outbound AS path.
                    remove_private_as_ingress: remove_private_as_ingress
                    next_hop_unchanged: next_hop_unchanged
                    update_source: IP address or interface name.
                    route_reflector_client: route_reflector_client
                    bfd: Enable BFD.
                    bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                    ebgp_multihop: Time-to-live in range of hops.
                    next_hop_self: next_hop_self
                    password: password
                    passive: passive
                    default_originate: default_originate
                    send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                    maximum_routes: Maximum number of routes (0 means unlimited).
                    maximum_routes_warning_limit:
                       Maximum number of routes after which a warning is issued (0 means never warn) or
                       Percentage of
                       maximum number of routes at which to warn ("<1-100> percent").
                    maximum_routes_warning_only: maximum_routes_warning_only
                    missing_policy: Missing policy configuration for all address-families.
                    link_bandwidth: link_bandwidth
                    allowas_in: allowas_in
                    weight: weight
                    timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                    rib_in_pre_policy_retain: rib_in_pre_policy_retain
                    route_map_in: Inbound route-map name.
                    route_map_out: Outbound route-map name.
                    session_tracker: session_tracker
                    shared_secret: shared_secret
                    ttl_maximum_hops: Maximum number of hops.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PeerGroups(AvdCollection[str, PeerGroupsItem]):
            _primary_key: ClassVar[str] = "name"

        PeerGroups._item_type = PeerGroupsItem

        class NeighborsItem(AvdModel):
            class AsPath(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                remote_as_replace_out: bool | None
                """Replace AS number with local AS number."""
                prepend_own_disabled: bool | None
                """Disable prepending own AS number to AS path."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    remote_as_replace_out: bool | None | UndefinedType = Undefined,
                    prepend_own_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AsPath.

                    Args:
                    -----
                        _custom_data: _custom_data
                        remote_as_replace_out: Replace AS number with local AS number.
                        prepend_own_disabled: Disable prepending own AS number to AS path.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BfdTimers(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "min_rx", "multiplier")
                _custom_data: dict[str, Any]
                interval: int
                """Interval in milliseconds."""
                min_rx: int
                """Rate in milliseconds."""
                multiplier: int

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    interval: int | UndefinedType = Undefined,
                    min_rx: int | UndefinedType = Undefined,
                    multiplier: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    BfdTimers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in milliseconds.
                        min_rx: Rate in milliseconds.
                        multiplier: multiplier

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultOriginate(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                always: bool | None
                route_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultOriginate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        always: always
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MissingPolicy(AvdModel):
                class DirectionIn(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                    _custom_data: dict[str, Any]
                    action: str
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        action: str | UndefinedType = Undefined,
                        include_community_list: bool | None | UndefinedType = Undefined,
                        include_prefix_list: bool | None | UndefinedType = Undefined,
                        include_sub_route_map: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionIn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DirectionOut(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "action": {"type": str},
                        "include_community_list": {"type": bool},
                        "include_prefix_list": {"type": bool},
                        "include_sub_route_map": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                    _custom_data: dict[str, Any]
                    action: str
                    """Missing policy action."""
                    include_community_list: bool | None
                    """Include community-list references in missing policy decision."""
                    include_prefix_list: bool | None
                    """Include prefix-list references in missing policy decision."""
                    include_sub_route_map: bool | None
                    """Include sub-route-map references in missing policy decision."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        action: str | UndefinedType = Undefined,
                        include_community_list: bool | None | UndefinedType = Undefined,
                        include_prefix_list: bool | None | UndefinedType = Undefined,
                        include_sub_route_map: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DirectionOut.

                        Args:
                        -----
                            _custom_data: _custom_data
                            action: Missing policy action.
                            include_community_list: Include community-list references in missing policy decision.
                            include_prefix_list: Include prefix-list references in missing policy decision.
                            include_sub_route_map: Include sub-route-map references in missing policy decision.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                direction_in: DirectionIn
                """Missing policy inbound direction."""
                direction_out: DirectionOut
                """Missing policy outbound direction."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    direction_in: DirectionIn | UndefinedType = Undefined,
                    direction_out: DirectionOut | UndefinedType = Undefined,
                ) -> None:
                    """
                    MissingPolicy.

                    Args:
                    -----
                        _custom_data: _custom_data
                        direction_in: Missing policy inbound direction.
                        direction_out: Missing policy outbound direction.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AllowasIn(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "times": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                times: int | None
                """Number of local ASNs allowed in a BGP update."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    times: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AllowasIn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        times: Number of local ASNs allowed in a BGP update.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LinkBandwidth(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "default": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                default: str | None
                """nn.nn(K|M|G) link speed in bits/second."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    default: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LinkBandwidth.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        default: nn.nn(K|M|G) link speed in bits/second.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RibInPrePolicyRetain(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                all: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    all: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RibInPrePolicyRetain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAs(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                all: bool | None
                replace_as: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    all: bool | None | UndefinedType = Undefined,
                    replace_as: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RemovePrivateAs.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        all: all
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RemovePrivateAsIngress(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "replace_as": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                replace_as: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    replace_as: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RemovePrivateAsIngress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        replace_as: replace_as

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SharedSecret(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "hash_algorithm": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "hash_algorithm")
                _custom_data: dict[str, Any]
                profile: str
                """Name of profile defined under `management_security`."""
                hash_algorithm: str
                """Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    profile: str | UndefinedType = Undefined,
                    hash_algorithm: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    SharedSecret.

                    Args:
                    -----
                        _custom_data: _custom_data
                        profile: Name of profile defined under `management_security`.
                        hash_algorithm: Note: Algorithm hmac-sha-256 requires EOS version 4.31.1F and above.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ip_address": {"type": str},
                "peer_group": {"type": str},
                "remote_as": {"type": str},
                "local_as": {"type": str},
                "as_path": {"type": AsPath},
                "peer": {"type": str},
                "description": {"type": str},
                "route_reflector_client": {"type": bool},
                "password": {"type": str},
                "passive": {"type": bool},
                "shutdown": {"type": bool},
                "update_source": {"type": str},
                "bfd": {"type": bool},
                "bfd_timers": {"type": BfdTimers},
                "weight": {"type": int},
                "timers": {"type": str},
                "route_map_in": {"type": str},
                "route_map_out": {"type": str},
                "default_originate": {"type": DefaultOriginate},
                "send_community": {"type": str},
                "maximum_routes": {"type": int},
                "maximum_routes_warning_limit": {"type": str},
                "maximum_routes_warning_only": {"type": bool},
                "missing_policy": {"type": MissingPolicy},
                "allowas_in": {"type": AllowasIn},
                "ebgp_multihop": {"type": int},
                "next_hop_self": {"type": bool},
                "link_bandwidth": {"type": LinkBandwidth},
                "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                "remove_private_as": {"type": RemovePrivateAs},
                "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                "session_tracker": {"type": str},
                "shared_secret": {"type": SharedSecret},
                "ttl_maximum_hops": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
            _custom_data: dict[str, Any]
            ip_address: str
            peer_group: str | None
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            local_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            as_path: AsPath
            """BGP AS-PATH options."""
            peer: str | None
            """Key only used for documentation or validation purposes."""
            description: str | None
            route_reflector_client: bool | None
            password: str | None
            passive: bool | None
            shutdown: bool | None
            update_source: str | None
            """Source Interface."""
            bfd: bool | None
            """Enable BFD."""
            bfd_timers: BfdTimers
            """Override default BFD timers. BFD must be enabled with `bfd: true`."""
            weight: int | None
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            route_map_in: str | None
            """Inbound route-map name."""
            route_map_out: str | None
            """Outbound route-map name."""
            default_originate: DefaultOriginate
            send_community: str | None
            """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
            maximum_routes: int | None
            """Maximum number of routes (0 means unlimited)."""
            maximum_routes_warning_limit: str | None
            """
            Maximum number of routes after which a warning is issued (0 means never warn) or
            Percentage of
            maximum number of routes at which to warn ("<1-100> percent").
            """
            maximum_routes_warning_only: bool | None
            missing_policy: MissingPolicy
            """Missing policy configuration for all address-families."""
            allowas_in: AllowasIn
            ebgp_multihop: int | None
            """Time-to-live in range of hops."""
            next_hop_self: bool | None
            link_bandwidth: LinkBandwidth
            rib_in_pre_policy_retain: RibInPrePolicyRetain
            remove_private_as: RemovePrivateAs
            """Remove private AS numbers in outbound AS path."""
            remove_private_as_ingress: RemovePrivateAsIngress
            session_tracker: str | None
            shared_secret: SharedSecret
            ttl_maximum_hops: int | None
            """Maximum number of hops."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_address: str | UndefinedType = Undefined,
                peer_group: str | None | UndefinedType = Undefined,
                remote_as: str | None | UndefinedType = Undefined,
                local_as: str | None | UndefinedType = Undefined,
                as_path: AsPath | UndefinedType = Undefined,
                peer: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                route_reflector_client: bool | None | UndefinedType = Undefined,
                password: str | None | UndefinedType = Undefined,
                passive: bool | None | UndefinedType = Undefined,
                shutdown: bool | None | UndefinedType = Undefined,
                update_source: str | None | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                bfd_timers: BfdTimers | UndefinedType = Undefined,
                weight: int | None | UndefinedType = Undefined,
                timers: str | None | UndefinedType = Undefined,
                route_map_in: str | None | UndefinedType = Undefined,
                route_map_out: str | None | UndefinedType = Undefined,
                default_originate: DefaultOriginate | UndefinedType = Undefined,
                send_community: str | None | UndefinedType = Undefined,
                maximum_routes: int | None | UndefinedType = Undefined,
                maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                missing_policy: MissingPolicy | UndefinedType = Undefined,
                allowas_in: AllowasIn | UndefinedType = Undefined,
                ebgp_multihop: int | None | UndefinedType = Undefined,
                next_hop_self: bool | None | UndefinedType = Undefined,
                link_bandwidth: LinkBandwidth | UndefinedType = Undefined,
                rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                session_tracker: str | None | UndefinedType = Undefined,
                shared_secret: SharedSecret | UndefinedType = Undefined,
                ttl_maximum_hops: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                NeighborsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_address: ip_address
                    peer_group: peer_group
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    local_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    as_path: BGP AS-PATH options.
                    peer: Key only used for documentation or validation purposes.
                    description: description
                    route_reflector_client: route_reflector_client
                    password: password
                    passive: passive
                    shutdown: shutdown
                    update_source: Source Interface.
                    bfd: Enable BFD.
                    bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                    weight: weight
                    timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                    route_map_in: Inbound route-map name.
                    route_map_out: Outbound route-map name.
                    default_originate: default_originate
                    send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                    maximum_routes: Maximum number of routes (0 means unlimited).
                    maximum_routes_warning_limit:
                       Maximum number of routes after which a warning is issued (0 means never warn) or
                       Percentage of
                       maximum number of routes at which to warn ("<1-100> percent").
                    maximum_routes_warning_only: maximum_routes_warning_only
                    missing_policy: Missing policy configuration for all address-families.
                    allowas_in: allowas_in
                    ebgp_multihop: Time-to-live in range of hops.
                    next_hop_self: next_hop_self
                    link_bandwidth: link_bandwidth
                    rib_in_pre_policy_retain: rib_in_pre_policy_retain
                    remove_private_as: Remove private AS numbers in outbound AS path.
                    remove_private_as_ingress: remove_private_as_ingress
                    session_tracker: session_tracker
                    shared_secret: shared_secret
                    ttl_maximum_hops: Maximum number of hops.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Neighbors(AvdCollection[str, NeighborsItem]):
            _primary_key: ClassVar[str] = "ip_address"

        Neighbors._item_type = NeighborsItem

        class NeighborInterfacesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "remote_as": {"type": str},
                "peer": {"type": str},
                "peer_group": {"type": str, "default": "Peer-group name"},
                "description": {"type": str},
                "peer_filter": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Interface name."""
            remote_as: str | None
            """
            BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
            For asdot notation in
            YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
            number.
            """
            peer: str | None
            """Key only used for documentation or validation purposes."""
            peer_group: str | None
            description: str | None
            peer_filter: str | None
            """Peer-filter name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                remote_as: str | None | UndefinedType = Undefined,
                peer: str | None | UndefinedType = Undefined,
                peer_group: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                peer_filter: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                NeighborInterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Interface name.
                    remote_as:
                       BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                       For asdot notation in
                       YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                       number.
                    peer: Key only used for documentation or validation purposes.
                    peer_group: peer_group
                    description: description
                    peer_filter: Peer-filter name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NeighborInterfaces(AvdCollection[str, NeighborInterfacesItem]):
            _primary_key: ClassVar[str] = "name"

        NeighborInterfaces._item_type = NeighborInterfacesItem

        class AggregateAddressesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "prefix": {"type": str},
                "advertise_only": {"type": bool},
                "as_set": {"type": bool},
                "summary_only": {"type": bool},
                "attribute_map": {"type": str},
                "match_map": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
            _custom_data: dict[str, Any]
            prefix: str
            """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
            advertise_only: bool | None
            as_set: bool | None
            summary_only: bool | None
            attribute_map: str | None
            """Route-map name."""
            match_map: str | None
            """Route-map name."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                prefix: str | UndefinedType = Undefined,
                advertise_only: bool | None | UndefinedType = Undefined,
                as_set: bool | None | UndefinedType = Undefined,
                summary_only: bool | None | UndefinedType = Undefined,
                attribute_map: str | None | UndefinedType = Undefined,
                match_map: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                AggregateAddressesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                    advertise_only: advertise_only
                    as_set: as_set
                    summary_only: summary_only
                    attribute_map: Route-map name.
                    match_map: Route-map name.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AggregateAddresses(AvdCollection[str, AggregateAddressesItem]):
            _primary_key: ClassVar[str] = "prefix"

        AggregateAddresses._item_type = AggregateAddressesItem

        class Redistribute(AvdModel):
            class AttachedHost(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                route_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AttachedHost.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                route_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Connected(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Connected.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                        include_leaked: Include following routes while redistributing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Dynamic(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Dynamic.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Isis(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "isis_level": {"type": str},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                isis_level: str | None
                """Redistribute IS-IS route level."""
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    isis_level: str | None | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Isis.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        isis_level: Redistribute IS-IS route level.
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                        include_leaked: Include following routes while redistributing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ospf(AvdModel):
                class MatchExternal(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchExternal.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MatchInternal(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchInternal.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MatchNssaExternal(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "nssa_type": {"type": int},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    nssa_type: int | None
                    """NSSA External Type Number."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        nssa_type: int | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchNssaExternal.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            nssa_type: NSSA External Type Number.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "match_external": {"type": MatchExternal},
                    "match_internal": {"type": MatchInternal},
                    "match_nssa_external": {"type": MatchNssaExternal},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Redistribute OSPF routes."""
                match_external: MatchExternal
                """Redistribute OSPF routes learned from external sources."""
                match_internal: MatchInternal
                """Redistribute OSPF routes learned from internal sources."""
                match_nssa_external: MatchNssaExternal
                """Redistribute OSPF routes learned from external NSSA sources."""
                route_map: str | None
                include_leaked: bool | None
                """Include following routes while redistributing."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    match_external: MatchExternal | UndefinedType = Undefined,
                    match_internal: MatchInternal | UndefinedType = Undefined,
                    match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ospf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Redistribute OSPF routes.
                        match_external: Redistribute OSPF routes learned from external sources.
                        match_internal: Redistribute OSPF routes learned from internal sources.
                        match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                        route_map: route_map
                        include_leaked: Include following routes while redistributing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ospfv3(AvdModel):
                class MatchExternal(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchExternal.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MatchInternal(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchInternal.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MatchNssaExternal(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "nssa_type": {"type": int},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    nssa_type: int | None
                    """NSSA External Type Number."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        nssa_type: int | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MatchNssaExternal.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            nssa_type: NSSA External Type Number.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "match_external": {"type": MatchExternal},
                    "match_internal": {"type": MatchInternal},
                    "match_nssa_external": {"type": MatchNssaExternal},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Redistribute OSPFv3 routes."""
                match_external: MatchExternal
                """Redistribute OSPFv3 routes learned from external sources."""
                match_internal: MatchInternal
                """Redistribute OSPFv3 routes learned from internal sources."""
                match_nssa_external: MatchNssaExternal
                """Redistribute OSPFv3 routes learned from external NSSA sources."""
                route_map: str | None
                include_leaked: bool | None
                """Include following routes while redistributing."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    match_external: MatchExternal | UndefinedType = Undefined,
                    match_internal: MatchInternal | UndefinedType = Undefined,
                    match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ospfv3.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Redistribute OSPFv3 routes.
                        match_external: Redistribute OSPFv3 routes learned from external sources.
                        match_internal: Redistribute OSPFv3 routes learned from internal sources.
                        match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                        route_map: route_map
                        include_leaked: Include following routes while redistributing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Rip(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                route_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Rip.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Static(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "include_leaked": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """
                include_leaked: bool | None
                """Include following routes while redistributing."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Static.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                        include_leaked: Include following routes while redistributing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class User(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    User.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "attached_host": {"type": AttachedHost},
                "bgp": {"type": Bgp},
                "connected": {"type": Connected},
                "dynamic": {"type": Dynamic},
                "isis": {"type": Isis},
                "ospf": {"type": Ospf},
                "ospfv3": {"type": Ospfv3},
                "rip": {"type": Rip},
                "static": {"type": Static},
                "user": {"type": User},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            attached_host: AttachedHost
            bgp: Bgp
            connected: Connected
            dynamic: Dynamic
            isis: Isis
            ospf: Ospf
            ospfv3: Ospfv3
            rip: Rip
            static: Static
            user: User

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                attached_host: AttachedHost | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                connected: Connected | UndefinedType = Undefined,
                dynamic: Dynamic | UndefinedType = Undefined,
                isis: Isis | UndefinedType = Undefined,
                ospf: Ospf | UndefinedType = Undefined,
                ospfv3: Ospfv3 | UndefinedType = Undefined,
                rip: Rip | UndefinedType = Undefined,
                static: Static | UndefinedType = Undefined,
                user: User | UndefinedType = Undefined,
            ) -> None:
                """
                Redistribute.

                Args:
                -----
                    _custom_data: _custom_data
                    attached_host: attached_host
                    bgp: bgp
                    connected: connected
                    dynamic: dynamic
                    isis: isis
                    ospf: ospf
                    ospfv3: ospfv3
                    rip: rip
                    static: static
                    user: user

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RedistributeRoutesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "source_protocol": {"type": str},
                "route_map": {"type": str},
                "rcf": {"type": str},
                "include_leaked": {"type": bool},
                "ospf_route_type": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
            _custom_data: dict[str, Any]
            source_protocol: str
            route_map: str | None
            rcf: str | None
            """
            RCF function name with parenthesis.
            Example: MyFunction(myarg).
            `route_map` and `rcf` are mutually
            exclusive. `route_map` takes precedence.
            Only applicable if `source_protocol` is one of `connected`,
            `static`, `isis`, `user`, `dynamic`.
            """
            include_leaked: bool | None
            ospf_route_type: str | None
            """
            Routes learned by the OSPF protocol.
            The `ospf_route_type` is valid for source_protocols 'ospf' and
            'ospfv3'.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                source_protocol: str | UndefinedType = Undefined,
                route_map: str | None | UndefinedType = Undefined,
                rcf: str | None | UndefinedType = Undefined,
                include_leaked: bool | None | UndefinedType = Undefined,
                ospf_route_type: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RedistributeRoutesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source_protocol: source_protocol
                    route_map: route_map
                    rcf:
                       RCF function name with parenthesis.
                       Example: MyFunction(myarg).
                       `route_map` and `rcf` are mutually
                       exclusive. `route_map` takes precedence.
                       Only applicable if `source_protocol` is one of `connected`,
                       `static`, `isis`, `user`, `dynamic`.
                    include_leaked: include_leaked
                    ospf_route_type:
                       Routes learned by the OSPF protocol.
                       The `ospf_route_type` is valid for source_protocols 'ospf' and
                       'ospfv3'.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanAwareBundlesItem(AvdModel):
            class RdEvpnDomain(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "rd": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                domain: str | None
                rd: str | None
                """Route distinguisher."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    domain: str | None | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RdEvpnDomain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        domain: domain
                        rd: Route distinguisher.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteTargets(AvdModel):
                class ImportEvpnDomainsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "route_target": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    domain: str | None
                    route_target: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        domain: str | None | UndefinedType = Undefined,
                        route_target: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ImportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportEvpnDomainsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "route_target": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    domain: str | None
                    route_target: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        domain: str | None | UndefinedType = Undefined,
                        route_target: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ImportExportEvpnDomainsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "route_target": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    domain: str | None
                    route_target: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        domain: str | None | UndefinedType = Undefined,
                        route_target: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ImportExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "both": {"type": list, "items": str},
                    "field_import": {"type": list, "key": "import", "items": str},
                    "export": {"type": list, "items": str},
                    "import_evpn_domains": {"type": list, "items": ImportEvpnDomainsItem},
                    "export_evpn_domains": {"type": list, "items": ExportEvpnDomainsItem},
                    "import_export_evpn_domains": {"type": list, "items": ImportExportEvpnDomainsItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                both: list[str]
                field_import: list[str]
                export: list[str]
                import_evpn_domains: list[ImportEvpnDomainsItem]
                export_evpn_domains: list[ExportEvpnDomainsItem]
                import_export_evpn_domains: list[ImportExportEvpnDomainsItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    both: list[str] | UndefinedType = Undefined,
                    field_import: list[str] | UndefinedType = Undefined,
                    export: list[str] | UndefinedType = Undefined,
                    import_evpn_domains: list[ImportEvpnDomainsItem] | UndefinedType = Undefined,
                    export_evpn_domains: list[ExportEvpnDomainsItem] | UndefinedType = Undefined,
                    import_export_evpn_domains: list[ImportExportEvpnDomainsItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        both: both
                        field_import: field_import
                        export: export
                        import_evpn_domains: import_evpn_domains
                        export_evpn_domains: export_evpn_domains
                        import_export_evpn_domains: import_export_evpn_domains

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "tenant": {"type": str},
                "description": {"type": str},
                "rd": {"type": str},
                "rd_evpn_domain": {"type": RdEvpnDomain},
                "route_targets": {"type": RouteTargets},
                "redistribute_routes": {"type": list, "items": str},
                "no_redistribute_routes": {"type": list, "items": str},
                "vlan": {"type": str},
                "eos_cli": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VLAN aware bundle name."""
            tenant: str | None
            """Key only used for documentation or validation purposes."""
            description: str | None
            """Key only used for documentation or validation purposes."""
            rd: str | None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain
            route_targets: RouteTargets
            redistribute_routes: list[str]
            no_redistribute_routes: list[str]
            vlan: str | None
            """VLAN range as string. Example "100-200,300"."""
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                rd: str | None | UndefinedType = Undefined,
                rd_evpn_domain: RdEvpnDomain | UndefinedType = Undefined,
                route_targets: RouteTargets | UndefinedType = Undefined,
                redistribute_routes: list[str] | UndefinedType = Undefined,
                no_redistribute_routes: list[str] | UndefinedType = Undefined,
                vlan: str | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlanAwareBundlesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VLAN aware bundle name.
                    tenant: Key only used for documentation or validation purposes.
                    description: Key only used for documentation or validation purposes.
                    rd: Route distinguisher.
                    rd_evpn_domain: rd_evpn_domain
                    route_targets: route_targets
                    redistribute_routes: redistribute_routes
                    no_redistribute_routes: no_redistribute_routes
                    vlan: VLAN range as string. Example "100-200,300".
                    eos_cli:
                       Multiline EOS CLI rendered directly on the Router BGP, VLAN-aware-bundle definition in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VlanAwareBundles(AvdCollection[str, VlanAwareBundlesItem]):
            _primary_key: ClassVar[str] = "name"

        VlanAwareBundles._item_type = VlanAwareBundlesItem

        class VlansItem(AvdModel):
            class RdEvpnDomain(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "rd": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                domain: str | None
                rd: str | None
                """Route distinguisher."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    domain: str | None | UndefinedType = Undefined,
                    rd: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RdEvpnDomain.

                    Args:
                    -----
                        _custom_data: _custom_data
                        domain: domain
                        rd: Route distinguisher.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RouteTargets(AvdModel):
                class ImportEvpnDomainsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "route_target": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    domain: str | None
                    route_target: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        domain: str | None | UndefinedType = Undefined,
                        route_target: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ImportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ExportEvpnDomainsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "route_target": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    domain: str | None
                    route_target: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        domain: str | None | UndefinedType = Undefined,
                        route_target: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ImportExportEvpnDomainsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "domain": {"type": str}, "route_target": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    domain: str | None
                    route_target: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        domain: str | None | UndefinedType = Undefined,
                        route_target: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ImportExportEvpnDomainsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            domain: domain
                            route_target: route_target

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "both": {"type": list, "items": str},
                    "field_import": {"type": list, "key": "import", "items": str},
                    "export": {"type": list, "items": str},
                    "import_evpn_domains": {"type": list, "items": ImportEvpnDomainsItem},
                    "export_evpn_domains": {"type": list, "items": ExportEvpnDomainsItem},
                    "import_export_evpn_domains": {"type": list, "items": ImportExportEvpnDomainsItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                both: list[str]
                field_import: list[str]
                export: list[str]
                import_evpn_domains: list[ImportEvpnDomainsItem]
                export_evpn_domains: list[ExportEvpnDomainsItem]
                import_export_evpn_domains: list[ImportExportEvpnDomainsItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    both: list[str] | UndefinedType = Undefined,
                    field_import: list[str] | UndefinedType = Undefined,
                    export: list[str] | UndefinedType = Undefined,
                    import_evpn_domains: list[ImportEvpnDomainsItem] | UndefinedType = Undefined,
                    export_evpn_domains: list[ExportEvpnDomainsItem] | UndefinedType = Undefined,
                    import_export_evpn_domains: list[ImportExportEvpnDomainsItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        both: both
                        field_import: field_import
                        export: export
                        import_evpn_domains: import_evpn_domains
                        export_evpn_domains: export_evpn_domains
                        import_export_evpn_domains: import_export_evpn_domains

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "tenant": {"type": str},
                "rd": {"type": str},
                "rd_evpn_domain": {"type": RdEvpnDomain},
                "route_targets": {"type": RouteTargets},
                "redistribute_routes": {"type": list, "items": str},
                "no_redistribute_routes": {"type": list, "items": str},
                "eos_cli": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            tenant: str | None
            """Key only used for documentation or validation purposes."""
            rd: str | None
            """Route distinguisher."""
            rd_evpn_domain: RdEvpnDomain
            route_targets: RouteTargets
            redistribute_routes: list[str]
            no_redistribute_routes: list[str]
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                tenant: str | None | UndefinedType = Undefined,
                rd: str | None | UndefinedType = Undefined,
                rd_evpn_domain: RdEvpnDomain | UndefinedType = Undefined,
                route_targets: RouteTargets | UndefinedType = Undefined,
                redistribute_routes: list[str] | UndefinedType = Undefined,
                no_redistribute_routes: list[str] | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VlansItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    tenant: Key only used for documentation or validation purposes.
                    rd: Route distinguisher.
                    rd_evpn_domain: rd_evpn_domain
                    route_targets: route_targets
                    redistribute_routes: redistribute_routes
                    no_redistribute_routes: no_redistribute_routes
                    eos_cli:
                       Multiline EOS CLI rendered directly on the Router BGP, VLAN definition in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vlans(AvdCollection[int, VlansItem]):
            _primary_key: ClassVar[str] = "id"

        Vlans._item_type = VlansItem

        class VpwsItem(AvdModel):
            class RouteTargets(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "import_export": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                import_export: str | None
                """Route Target."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, import_export: str | None | UndefinedType = Undefined) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_export: Route Target.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PseudowiresItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "id_local": {"type": int}, "id_remote": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Pseudowire name."""
                id_local: int | None
                """Must match id_remote on other pe."""
                id_remote: int | None
                """Must match id_local on other pe."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    id_local: int | None | UndefinedType = Undefined,
                    id_remote: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PseudowiresItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Pseudowire name.
                        id_local: Must match id_remote on other pe.
                        id_remote: Must match id_local on other pe.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Pseudowires(AvdCollection[str, PseudowiresItem]):
                _primary_key: ClassVar[str] = "name"

            Pseudowires._item_type = PseudowiresItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "rd": {"type": str},
                "route_targets": {"type": RouteTargets},
                "mpls_control_word": {"type": bool},
                "label_flow": {"type": bool},
                "mtu": {"type": int},
                "pseudowires": {"type": Pseudowires},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VPWS instance name."""
            rd: str | None
            """Route distinguisher."""
            route_targets: RouteTargets
            mpls_control_word: bool | None
            label_flow: bool | None
            mtu: int | None
            pseudowires: Pseudowires

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                rd: str | None | UndefinedType = Undefined,
                route_targets: RouteTargets | UndefinedType = Undefined,
                mpls_control_word: bool | None | UndefinedType = Undefined,
                label_flow: bool | None | UndefinedType = Undefined,
                mtu: int | None | UndefinedType = Undefined,
                pseudowires: Pseudowires | UndefinedType = Undefined,
            ) -> None:
                """
                VpwsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VPWS instance name.
                    rd: Route distinguisher.
                    route_targets: route_targets
                    mpls_control_word: mpls_control_word
                    label_flow: label_flow
                    mtu: mtu
                    pseudowires: pseudowires

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vpws(AvdCollection[str, VpwsItem]):
            _primary_key: ClassVar[str] = "name"

        Vpws._item_type = VpwsItem

        class AddressFamilyEvpn(AvdModel):
            class NeighborDefault(AvdModel):
                class NextHopSelfReceivedEvpnRoutes(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "inter_domain": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enable: bool | None
                    inter_domain: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enable: bool | None | UndefinedType = Undefined,
                        inter_domain: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NextHopSelfReceivedEvpnRoutes.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enable: enable
                            inter_domain: inter_domain

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "encapsulation": {"type": str},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_received_evpn_routes": {"type": NextHopSelfReceivedEvpnRoutes},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                encapsulation: str | None
                """Transport encapsulation for neighbor."""
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                    next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                    next_hop_self_received_evpn_routes: NextHopSelfReceivedEvpnRoutes | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborDefault.

                    Args:
                    -----
                        _custom_data: _custom_data
                        encapsulation: Transport encapsulation for neighbor.
                        next_hop_self_source_interface: Source interface name.
                        next_hop_self_received_evpn_routes: next_hop_self_received_evpn_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHopMplsResolutionRibsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rib_type": {"type": str}, "rib_name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "rib_type")
                _custom_data: dict[str, Any]
                rib_type: str
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    rib_type: str | UndefinedType = Undefined,
                    rib_name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NextHopMplsResolutionRibsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                        rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                class DefaultRoute(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "additional_paths": {"type": AdditionalPaths},
                    "encapsulation": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                additional_paths: AdditionalPaths
                encapsulation: str | None
                """Transport encapsulation for the neighbor."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_route: DefaultRoute | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route
                        additional_paths: additional_paths
                        encapsulation: Transport encapsulation for the neighbor.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                class DefaultRoute(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                    "domain_remote": {"type": bool},
                    "encapsulation": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute
                domain_remote: bool | None
                encapsulation: str | None
                """Transport encapsulation for the peer-group."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_route: DefaultRoute | UndefinedType = Undefined,
                    domain_remote: bool | None | UndefinedType = Undefined,
                    encapsulation: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route
                        domain_remote: domain_remote
                        encapsulation: Transport encapsulation for the peer-group.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class EvpnHostflapDetection(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "window": {"type": int},
                    "threshold": {"type": int},
                    "expiry_timeout": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                window: int | None
                """Time (in seconds) to detect a MAC duplication issue."""
                threshold: int | None
                """Minimum number of MAC moves that indicate a MAC Duplication issue."""
                expiry_timeout: int | None
                """Time (in seconds) to purge a MAC duplication issue."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    window: int | None | UndefinedType = Undefined,
                    threshold: int | None | UndefinedType = Undefined,
                    expiry_timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnHostflapDetection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        window: Time (in seconds) to detect a MAC duplication issue.
                        threshold: Minimum number of MAC moves that indicate a MAC Duplication issue.
                        expiry_timeout: Time (in seconds) to purge a MAC duplication issue.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHop(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "resolution_disabled": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                resolution_disabled: bool | None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, resolution_disabled: bool | None | UndefinedType = Undefined
                ) -> None:
                    """
                    NextHop.

                    Args:
                    -----
                        _custom_data: _custom_data
                        resolution_disabled: resolution_disabled

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Route(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "import_match_failure_action": {"type": str},
                    "import_ethernet_segment_ip_mass_withdraw": {"type": bool},
                    "import_overlay_index_gateway": {"type": bool},
                    "export_ethernet_segment_ip_mass_withdraw": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                import_match_failure_action: str | None
                import_ethernet_segment_ip_mass_withdraw: bool | None
                import_overlay_index_gateway: bool | None
                export_ethernet_segment_ip_mass_withdraw: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    import_match_failure_action: str | None | UndefinedType = Undefined,
                    import_ethernet_segment_ip_mass_withdraw: bool | None | UndefinedType = Undefined,
                    import_overlay_index_gateway: bool | None | UndefinedType = Undefined,
                    export_ethernet_segment_ip_mass_withdraw: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Route.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_match_failure_action: import_match_failure_action
                        import_ethernet_segment_ip_mass_withdraw: import_ethernet_segment_ip_mass_withdraw
                        import_overlay_index_gateway: import_overlay_index_gateway
                        export_ethernet_segment_ip_mass_withdraw: export_ethernet_segment_ip_mass_withdraw

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "additional_paths": {"type": AdditionalPaths}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                additional_paths: AdditionalPaths

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Layer2FecInPlaceUpdate(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "timeout": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                timeout: int | None
                """In-place FEC update tracking timeout in seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    timeout: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Layer2FecInPlaceUpdate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        timeout: In-place FEC update tracking timeout in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class BgpAdditionalPaths(AvdModel):
                class Send(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "any": {"type": bool},
                        "backup": {"type": bool},
                        "ecmp": {"type": bool},
                        "ecmp_limit": {"type": int},
                        "limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    any: bool | None
                    """Any eligible path."""
                    backup: bool | None
                    """Best path and installed backup path."""
                    ecmp: bool | None
                    """All paths in best path ECMP group."""
                    ecmp_limit: int | None
                    """Amount of ECMP paths to send."""
                    limit: int | None
                    """Amount of paths to send."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        any: bool | None | UndefinedType = Undefined,
                        backup: bool | None | UndefinedType = Undefined,
                        ecmp: bool | None | UndefinedType = Undefined,
                        ecmp_limit: int | None | UndefinedType = Undefined,
                        limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Send.

                        Args:
                        -----
                            _custom_data: _custom_data
                            any: Any eligible path.
                            backup: Best path and installed backup path.
                            ecmp: All paths in best path ECMP group.
                            ecmp_limit: Amount of ECMP paths to send.
                            limit: Amount of paths to send.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": Send}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                receive: bool | None
                """Receive multiple paths."""
                send: Send
                """Send multiple paths."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    receive: bool | None | UndefinedType = Undefined,
                    send: Send | UndefinedType = Undefined,
                ) -> None:
                    """
                    BgpAdditionalPaths.

                    Args:
                    -----
                        _custom_data: _custom_data
                        receive: Receive multiple paths.
                        send: Send multiple paths.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "domain_identifier": {"type": str},
                "neighbor_default": {"type": NeighborDefault},
                "next_hop_mpls_resolution_ribs": {"type": list, "items": NextHopMplsResolutionRibsItem},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "evpn_hostflap_detection": {"type": EvpnHostflapDetection},
                "next_hop": {"type": NextHop},
                "route": {"type": Route},
                "next_hop_unchanged": {"type": bool},
                "bgp": {"type": Bgp},
                "layer_2_fec_in_place_update": {"type": Layer2FecInPlaceUpdate},
                "bgp_additional_paths": {"type": BgpAdditionalPaths},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            domain_identifier: str | None
            neighbor_default: NeighborDefault
            next_hop_mpls_resolution_ribs: list[NextHopMplsResolutionRibsItem]
            """
            Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
            lookups.
            """
            neighbors: Neighbors
            peer_groups: PeerGroups
            evpn_hostflap_detection: EvpnHostflapDetection
            next_hop: NextHop
            route: Route
            next_hop_unchanged: bool | None
            bgp: Bgp
            layer_2_fec_in_place_update: Layer2FecInPlaceUpdate
            """BGP layer-2 in-place FEC operation."""
            bgp_additional_paths: BgpAdditionalPaths
            """BGP additional-paths commands."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                domain_identifier: str | None | UndefinedType = Undefined,
                neighbor_default: NeighborDefault | UndefinedType = Undefined,
                next_hop_mpls_resolution_ribs: list[NextHopMplsResolutionRibsItem] | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                evpn_hostflap_detection: EvpnHostflapDetection | UndefinedType = Undefined,
                next_hop: NextHop | UndefinedType = Undefined,
                route: Route | UndefinedType = Undefined,
                next_hop_unchanged: bool | None | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                layer_2_fec_in_place_update: Layer2FecInPlaceUpdate | UndefinedType = Undefined,
                bgp_additional_paths: BgpAdditionalPaths | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyEvpn.

                Args:
                -----
                    _custom_data: _custom_data
                    domain_identifier: domain_identifier
                    neighbor_default: neighbor_default
                    next_hop_mpls_resolution_ribs:
                       Specify the RIBs used to resolve MPLS next-hops. The order of this list determines the order of RIB
                       lookups.
                    neighbors: neighbors
                    peer_groups: peer_groups
                    evpn_hostflap_detection: evpn_hostflap_detection
                    next_hop: next_hop
                    route: route
                    next_hop_unchanged: next_hop_unchanged
                    bgp: bgp
                    layer_2_fec_in_place_update: BGP layer-2 in-place FEC operation.
                    bgp_additional_paths: BGP additional-paths commands.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyRtc(AvdModel):
            class PeerGroupsItem(AvdModel):
                class DefaultRouteTarget(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "only": {"type": bool}, "encoding_origin_as_omit": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    only: bool | None
                    encoding_origin_as_omit: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        only: bool | None | UndefinedType = Undefined,
                        encoding_origin_as_omit: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRouteTarget.

                        Args:
                        -----
                            _custom_data: _custom_data
                            only: only
                            encoding_origin_as_omit: encoding_origin_as_omit

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "default_route_target": {"type": DefaultRouteTarget},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                default_route_target: DefaultRouteTarget

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    default_route_target: DefaultRouteTarget | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        default_route_target: default_route_target

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "peer_groups": {"type": PeerGroups}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            peer_groups: PeerGroups

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, peer_groups: PeerGroups | UndefinedType = Undefined) -> None:
                """
                AddressFamilyRtc.

                Args:
                -----
                    _custom_data: _custom_data
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4(AvdModel):
            class NetworksItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Networks(AvdCollection[str, NetworksItem]):
                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        install: bool | None | UndefinedType = Undefined,
                        install_ecmp_primary: bool | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            install: Install BGP backup path.
                            install_ecmp_primary: Allow additional path with ECMP primary path.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "additional_paths": {"type": AdditionalPaths},
                    "redistribute_internal": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                additional_paths: AdditionalPaths
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    redistribute_internal: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdModel):
                class DefaultOriginate(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "always": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    always: bool | None
                    route_map: str | None
                    """Route-map name."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            always: always
                            route_map: Route-map name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NextHop(AvdModel):
                    class AddressFamilyIpv6(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "originate": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        originate: bool | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            originate: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AddressFamilyIpv6.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                originate: originate

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address_family_ipv6": {"type": AddressFamilyIpv6}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    address_family_ipv6: AddressFamilyIpv6

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined
                    ) -> None:
                        """
                        NextHop.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address_family_ipv6: address_family_ipv6

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_originate": {"type": DefaultOriginate},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                    "next_hop": {"type": NextHop},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_originate: DefaultOriginate
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths
                next_hop: NextHop

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    prefix_list_in: str | None | UndefinedType = Undefined,
                    prefix_list_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    next_hop: NextHop | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_originate: default_originate
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Outbound prefix-list name.
                        additional_paths: additional_paths
                        next_hop: next_hop

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                class DefaultOriginate(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "always": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    always: bool | None
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            always: always
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "default_originate": {"type": DefaultOriginate},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Prefix-list name."""
                default_originate: DefaultOriginate
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    prefix_list_in: str | None | UndefinedType = Undefined,
                    prefix_list_out: str | None | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Prefix-list name.
                        default_originate: default_originate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                class AttachedHost(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dynamic.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    isis_level: str | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospf(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """Redistribute OSPF routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPF routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPF routes learned from external NSSA sources."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospf.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPF routes.
                            match_external: Redistribute OSPF routes learned from external sources.
                            match_internal: Redistribute OSPF routes learned from internal sources.
                            match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Rip(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Rip.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class User(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        User.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "rip": {"type": Rip},
                    "static": {"type": Static},
                    "user": {"type": User},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                attached_host: AttachedHost
                bgp: Bgp
                connected: Connected
                dynamic: Dynamic
                isis: Isis
                ospf: Ospf
                ospfv3: Ospfv3
                rip: Rip
                static: Static
                user: User

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    attached_host: AttachedHost | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospf: Ospf | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    rip: Rip | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                    user: User | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        bgp: bgp
                        connected: connected
                        dynamic: dynamic
                        isis: isis
                        ospf: ospf
                        ospfv3: ospfv3
                        rip: rip
                        static: static
                        user: user

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                _custom_data: dict[str, Any]
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                """Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`."""
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: str | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_protocol: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    ospf_route_type: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: Only applicable if `source_protocol` is one of `connected`, `static`, `isis`, `ospf`, `ospfv3`.
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is one of `connected`,
                           `static`, `isis`, `user`, `dynamic`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "networks": {"type": Networks},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            networks: Networks
            bgp: Bgp
            peer_groups: PeerGroups
            neighbors: Neighbors
            redistribute: Redistribute
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                networks: Networks | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    networks: networks
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4LabeledUnicast(AvdModel):
            class AigpSession(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "confederation": {"type": bool}, "ebgp": {"type": bool}, "ibgp": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                confederation: bool | None
                ebgp: bool | None
                ibgp: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    confederation: bool | None | UndefinedType = Undefined,
                    ebgp: bool | None | UndefinedType = Undefined,
                    ibgp: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AigpSession.

                    Args:
                    -----
                        _custom_data: _custom_data
                        confederation: confederation
                        ebgp: ebgp
                        ibgp: ibgp

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MissingPolicy(AvdModel):
                    class DirectionIn(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                        _custom_data: dict[str, Any]
                        action: str
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            action: str | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DirectionOut(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                        _custom_data: dict[str, Any]
                        action: str
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            action: str | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in: DirectionIn
                    """Missing policy inbound direction."""
                    direction_out: DirectionOut
                    """Missing policy outbound direction."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in: Missing policy inbound direction.
                            direction_out: Missing policy outbound direction.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "additional_paths": {"type": AdditionalPaths},
                    "missing_policy": {"type": MissingPolicy},
                    "next_hop_unchanged": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                additional_paths: AdditionalPaths
                missing_policy: MissingPolicy
                """Missing policy configuration for all address-families."""
                next_hop_unchanged: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths
                        missing_policy: Missing policy configuration for all address-families.
                        next_hop_unchanged: next_hop_unchanged

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborDefault(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "next_hop_self": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                next_hop_self: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, next_hop_self: bool | None | UndefinedType = Undefined) -> None:
                    """
                    NeighborDefault.

                    Args:
                    -----
                        _custom_data: _custom_data
                        next_hop_self: next_hop_self

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class GracefulRestartHelper(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "stale_route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    stale_route_map: str | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, stale_route_map: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        GracefulRestartHelper.

                        Args:
                        -----
                            _custom_data: _custom_data
                            stale_route_map: stale_route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MissingPolicy(AvdModel):
                    class DirectionIn(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                        _custom_data: dict[str, Any]
                        action: str
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            action: str | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DirectionOut(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                        _custom_data: dict[str, Any]
                        action: str
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            action: str | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in: DirectionIn
                    """Missing policy inbound direction."""
                    direction_out: DirectionOut
                    """Missing policy outbound direction."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in: Missing policy inbound direction.
                            direction_out: Missing policy outbound direction.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "aigp_session": {"type": bool},
                    "graceful_restart": {"type": bool},
                    "graceful_restart_helper": {"type": GracefulRestartHelper},
                    "maximum_advertised_routes": {"type": int},
                    "maximum_advertised_routes_warning_limit": {"type": str},
                    "missing_policy": {"type": MissingPolicy},
                    "multi_path": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_v4_mapped_v6_source_interface": {"type": str},
                    "next_hop_unchanged": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths
                aigp_session: bool | None
                graceful_restart: bool | None
                graceful_restart_helper: GracefulRestartHelper
                maximum_advertised_routes: int | None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy
                """Missing policy configuration for BGP Labeled-Unicast neighbor."""
                multi_path: bool | None
                next_hop_self: bool | None
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    aigp_session: bool | None | UndefinedType = Undefined,
                    graceful_restart: bool | None | UndefinedType = Undefined,
                    graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                    maximum_advertised_routes: int | None | UndefinedType = Undefined,
                    maximum_advertised_routes_warning_limit: str | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    multi_path: bool | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                    next_hop_self_v4_mapped_v6_source_interface: str | None | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        additional_paths: additional_paths
                        aigp_session: aigp_session
                        graceful_restart: graceful_restart
                        graceful_restart_helper: graceful_restart_helper
                        maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                        maximum_advertised_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        missing_policy: Missing policy configuration for BGP Labeled-Unicast neighbor.
                        multi_path: multi_path
                        next_hop_self: next_hop_self
                        next_hop_self_source_interface: Source interface name.
                        next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                        next_hop_unchanged: next_hop_unchanged
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class GracefulRestartHelper(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "stale_route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    stale_route_map: str | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, stale_route_map: str | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        GracefulRestartHelper.

                        Args:
                        -----
                            _custom_data: _custom_data
                            stale_route_map: stale_route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MissingPolicy(AvdModel):
                    class DirectionIn(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                        _custom_data: dict[str, Any]
                        action: str
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            action: str | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionIn.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class DirectionOut(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "action": {"type": str},
                            "include_community_list": {"type": bool},
                            "include_prefix_list": {"type": bool},
                            "include_sub_route_map": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "action")
                        _custom_data: dict[str, Any]
                        action: str
                        """Missing policy action."""
                        include_community_list: bool | None
                        """Include community-list references in missing policy decision."""
                        include_prefix_list: bool | None
                        """Include prefix-list references in missing policy decision."""
                        include_sub_route_map: bool | None
                        """Include sub-route-map references in missing policy decision."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            action: str | UndefinedType = Undefined,
                            include_community_list: bool | None | UndefinedType = Undefined,
                            include_prefix_list: bool | None | UndefinedType = Undefined,
                            include_sub_route_map: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DirectionOut.

                            Args:
                            -----
                                _custom_data: _custom_data
                                action: Missing policy action.
                                include_community_list: Include community-list references in missing policy decision.
                                include_prefix_list: Include prefix-list references in missing policy decision.
                                include_sub_route_map: Include sub-route-map references in missing policy decision.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in": {"type": DirectionIn}, "direction_out": {"type": DirectionOut}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in: DirectionIn
                    """Missing policy inbound direction."""
                    direction_out: DirectionOut
                    """Missing policy outbound direction."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in: DirectionIn | UndefinedType = Undefined,
                        direction_out: DirectionOut | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in: Missing policy inbound direction.
                            direction_out: Missing policy outbound direction.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                    "aigp_session": {"type": bool},
                    "graceful_restart": {"type": bool},
                    "graceful_restart_helper": {"type": GracefulRestartHelper},
                    "maximum_advertised_routes": {"type": int},
                    "maximum_advertised_routes_warning_limit": {"type": str},
                    "missing_policy": {"type": MissingPolicy},
                    "multi_path": {"type": bool},
                    "next_hop_self": {"type": bool},
                    "next_hop_self_source_interface": {"type": str},
                    "next_hop_self_v4_mapped_v6_source_interface": {"type": str},
                    "next_hop_unchanged": {"type": bool},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                additional_paths: AdditionalPaths
                aigp_session: bool | None
                graceful_restart: bool | None
                graceful_restart_helper: GracefulRestartHelper
                maximum_advertised_routes: int | None
                """Maximum number of routes (0 means unlimited)."""
                maximum_advertised_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                missing_policy: MissingPolicy
                """Missing policy configuration for BGP Labeled-Unicast neighbor."""
                multi_path: bool | None
                next_hop_self: bool | None
                next_hop_self_source_interface: str | None
                """Source interface name."""
                next_hop_self_v4_mapped_v6_source_interface: str | None
                """v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface."""
                next_hop_unchanged: bool | None
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    aigp_session: bool | None | UndefinedType = Undefined,
                    graceful_restart: bool | None | UndefinedType = Undefined,
                    graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
                    maximum_advertised_routes: int | None | UndefinedType = Undefined,
                    maximum_advertised_routes_warning_limit: str | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    multi_path: bool | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    next_hop_self_source_interface: str | None | UndefinedType = Undefined,
                    next_hop_self_v4_mapped_v6_source_interface: str | None | UndefinedType = Undefined,
                    next_hop_unchanged: bool | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        additional_paths: additional_paths
                        aigp_session: aigp_session
                        graceful_restart: graceful_restart
                        graceful_restart_helper: graceful_restart_helper
                        maximum_advertised_routes: Maximum number of routes (0 means unlimited).
                        maximum_advertised_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        missing_policy: Missing policy configuration for BGP Labeled-Unicast neighbor.
                        multi_path: multi_path
                        next_hop_self: next_hop_self
                        next_hop_self_source_interface: Source interface name.
                        next_hop_self_v4_mapped_v6_source_interface: v4-mapped-v6 source interface name. Takes precedence over the next_hop_self_source_interface.
                        next_hop_unchanged: next_hop_unchanged
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NetworksItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Networks(AvdCollection[str, NetworksItem]):
                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class NextHopsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "lfib_backup_ip_forwarding": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                lfib_backup_ip_forwarding: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    lfib_backup_ip_forwarding: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NextHopsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        lfib_backup_ip_forwarding: lfib_backup_ip_forwarding

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NextHops(AvdCollection[str, NextHopsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            NextHops._item_type = NextHopsItem

            class NextHopResolutionRibsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rib_type": {"type": str}, "rib_name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "rib_type")
                _custom_data: dict[str, Any]
                rib_type: str
                """Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use."""
                rib_name: str | None
                """The name of the tunnel-rib to use when using 'tunnel-rib' type."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    rib_type: str | UndefinedType = Undefined,
                    rib_name: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NextHopResolutionRibsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rib_type: Type of RIB. For 'tunnel-rib', use 'rib_name' to specify the name of the Tunnel-RIB to use.
                        rib_name: The name of the tunnel-rib to use when using 'tunnel-rib' type.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelSourceProtocolsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "protocol": {"type": str}, "rcf": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "protocol")
                _custom_data: dict[str, Any]
                protocol: str
                rcf: str | None
                """
                Optional RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    protocol: str | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TunnelSourceProtocolsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        protocol: protocol
                        rcf:
                           Optional RCF function name with parenthesis.
                           Example: MyFunction(myarg).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelSourceProtocols(AvdCollection[str, TunnelSourceProtocolsItem]):
                _primary_key: ClassVar[str] = "protocol"

            TunnelSourceProtocols._item_type = TunnelSourceProtocolsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "aigp_session": {"type": AigpSession},
                "bgp": {"type": Bgp},
                "graceful_restart": {"type": bool},
                "label_local_termination": {"type": str},
                "lfib_entry_installation_skipped": {"type": bool},
                "neighbor_default": {"type": NeighborDefault},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "networks": {"type": Networks},
                "next_hops": {"type": NextHops},
                "next_hop_resolution_ribs": {"type": list, "items": NextHopResolutionRibsItem},
                "tunnel_source_protocols": {"type": TunnelSourceProtocols},
                "update_wait_for_convergence": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            aigp_session: AigpSession
            bgp: Bgp
            graceful_restart: bool | None
            label_local_termination: str | None
            lfib_entry_installation_skipped: bool | None
            """Skip LFIB entry installation and next hop self route advertisements."""
            neighbor_default: NeighborDefault
            peer_groups: PeerGroups
            neighbors: Neighbors
            networks: Networks
            next_hops: NextHops
            next_hop_resolution_ribs: list[NextHopResolutionRibsItem]
            """
            Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
            lookups.
            """
            tunnel_source_protocols: TunnelSourceProtocols
            update_wait_for_convergence: bool | None
            """Wait for BGP to converge before sending out any route updates."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                aigp_session: AigpSession | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                graceful_restart: bool | None | UndefinedType = Undefined,
                label_local_termination: str | None | UndefinedType = Undefined,
                lfib_entry_installation_skipped: bool | None | UndefinedType = Undefined,
                neighbor_default: NeighborDefault | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                networks: Networks | UndefinedType = Undefined,
                next_hops: NextHops | UndefinedType = Undefined,
                next_hop_resolution_ribs: list[NextHopResolutionRibsItem] | UndefinedType = Undefined,
                tunnel_source_protocols: TunnelSourceProtocols | UndefinedType = Undefined,
                update_wait_for_convergence: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv4LabeledUnicast.

                Args:
                -----
                    _custom_data: _custom_data
                    aigp_session: aigp_session
                    bgp: bgp
                    graceful_restart: graceful_restart
                    label_local_termination: label_local_termination
                    lfib_entry_installation_skipped: Skip LFIB entry installation and next hop self route advertisements.
                    neighbor_default: neighbor_default
                    peer_groups: peer_groups
                    neighbors: neighbors
                    networks: networks
                    next_hops: next_hops
                    next_hop_resolution_ribs:
                       Specify the RIBs used to resolve next-hops. The order of this list determines the order of RIB
                       lookups.
                    tunnel_source_protocols: tunnel_source_protocols
                    update_wait_for_convergence: Wait for BGP to converge before sending out any route updates.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4Multicast(AvdModel):
            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "additional_paths": {"type": AdditionalPaths}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                additional_paths: AdditionalPaths

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                class AttachedHost(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    isis_level: str | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospf(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """Redistribute OSPF routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPF routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPF routes learned from external NSSA sources."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospf.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPF routes.
                            match_external: Redistribute OSPF routes learned from external sources.
                            match_internal: Redistribute OSPF routes learned from internal sources.
                            match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "attached_host": {"type": AttachedHost},
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                attached_host: AttachedHost
                connected: Connected
                isis: Isis
                ospf: Ospf
                ospfv3: Ospfv3
                static: Static

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    attached_host: AttachedHost | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospf: Ospf | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        connected: connected
                        isis: isis
                        ospf: ospf
                        ospfv3: ospfv3
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                _custom_data: dict[str, Any]
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                """Only applicable if `source_protocol` is `isis`."""
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: str | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_protocol: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    ospf_route_type: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: Only applicable if `source_protocol` is `isis`.
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is `isis`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bgp: Bgp
            peer_groups: PeerGroups
            neighbors: Neighbors
            redistribute: Redistribute
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv4Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4SrTe(AvdModel):
            class NeighborsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            neighbors: Neighbors
            peer_groups: PeerGroups

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv4SrTe.

                Args:
                -----
                    _custom_data: _custom_data
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6(AvdModel):
            class NetworksItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None
                """Route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: Route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Networks(AvdCollection[str, NetworksItem]):
                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        install: bool | None | UndefinedType = Undefined,
                        install_ecmp_primary: bool | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            install: Install BGP backup path.
                            install_ecmp_primary: Allow additional path with ECMP primary path.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "redistribute_internal": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    redistribute_internal: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    prefix_list_in: str | None | UndefinedType = Undefined,
                    prefix_list_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Outbound prefix-list name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "prefix_list": {"type": str},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    prefix_list: str | None
                    """Apply the configurations only to the routes matching the prefix list."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix_list: Apply the configurations only to the routes matching the prefix list.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "prefix_list_in": {"type": str},
                    "prefix_list_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                prefix_list_in: str | None
                """Inbound prefix-list name."""
                prefix_list_out: str | None
                """Outbound prefix-list name."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    prefix_list_in: str | None | UndefinedType = Undefined,
                    prefix_list_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        prefix_list_in: Inbound prefix-list name.
                        prefix_list_out: Outbound prefix-list name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class Redistribute(AvdModel):
                class AttachedHost(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dhcp(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dhcp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dynamic.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    isis_level: str | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class User(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        User.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dhcp": {"type": Dhcp},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                    "user": {"type": User},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                attached_host: AttachedHost
                bgp: Bgp
                connected: Connected
                dhcp: Dhcp
                dynamic: Dynamic
                isis: Isis
                ospfv3: Ospfv3
                static: Static
                user: User

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    attached_host: AttachedHost | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    dhcp: Dhcp | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                    user: User | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        bgp: bgp
                        connected: connected
                        dhcp: dhcp
                        dynamic: dynamic
                        isis: isis
                        ospfv3: ospfv3
                        static: static
                        user: user

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                _custom_data: dict[str, Any]
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only used if `source_protocol` is one of `connected`,
                `static`, `isis`, `user`, `dynamic`.
                """
                ospf_route_type: str | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_protocol: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    ospf_route_type: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: include_leaked
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only used if `source_protocol` is one of `connected`,
                           `static`, `isis`, `user`, `dynamic`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "networks": {"type": Networks},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            networks: Networks
            bgp: Bgp
            peer_groups: PeerGroups
            neighbors: Neighbors
            redistribute: Redistribute
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                networks: Networks | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    networks: networks
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6Multicast(AvdModel):
            class Bgp(AvdModel):
                class MissingPolicy(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in_action: str | None
                    direction_out_action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in_action: str | None | UndefinedType = Undefined,
                        direction_out_action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "missing_policy": {"type": MissingPolicy},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                missing_policy: MissingPolicy
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: receive

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NetworksItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Networks(AvdCollection[str, NetworksItem]):
                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Redistribute(AvdModel):
                class Connected(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    isis_level: str | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospf(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """Redistribute OSPF routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPF routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPF routes learned from external NSSA sources."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospf.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPF routes.
                            match_external: Redistribute OSPF routes learned from external sources.
                            match_internal: Redistribute OSPF routes learned from internal sources.
                            match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "connected": {"type": Connected},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "static": {"type": Static},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                connected: Connected
                isis: Isis
                ospf: Ospf
                ospfv3: Ospfv3
                static: Static

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospf: Ospf | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        connected: connected
                        isis: isis
                        ospf: ospf
                        ospfv3: ospfv3
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_protocol": {"type": str},
                    "include_leaked": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                _custom_data: dict[str, Any]
                source_protocol: str
                include_leaked: bool | None
                """Only applicable if `source_protocol` is `isis`."""
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is `isis`.
                """
                ospf_route_type: str | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_protocol: str | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    ospf_route_type: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        include_leaked: Only applicable if `source_protocol` is `isis`.
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is `isis`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
                "networks": {"type": Networks},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bgp: Bgp
            neighbors: Neighbors
            peer_groups: PeerGroups
            networks: Networks
            redistribute: Redistribute
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                networks: Networks | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv6Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups
                    networks: networks
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6SrTe(AvdModel):
            class NeighborsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "neighbors": {"type": Neighbors}, "peer_groups": {"type": PeerGroups}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            neighbors: Neighbors
            peer_groups: PeerGroups

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv6SrTe.

                Args:
                -----
                    _custom_data: _custom_data
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyLinkState(AvdModel):
            class Bgp(AvdModel):
                class MissingPolicy(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in_action: str | None
                    direction_out_action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in_action: str | None | UndefinedType = Undefined,
                        direction_out_action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "missing_policy": {"type": MissingPolicy}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                missing_policy: MissingPolicy

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, missing_policy: MissingPolicy | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroupsItem(AvdModel):
                class MissingPolicy(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in_action: str | None
                    direction_out_action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in_action: str | None | UndefinedType = Undefined,
                        direction_out_action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "missing_policy": {"type": MissingPolicy},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                missing_policy: MissingPolicy

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class NeighborsItem(AvdModel):
                class MissingPolicy(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in_action: str | None
                    direction_out_action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in_action: str | None | UndefinedType = Undefined,
                        direction_out_action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "missing_policy": {"type": MissingPolicy},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                missing_policy: MissingPolicy

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    missing_policy: MissingPolicy | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PathSelection(AvdModel):
                class Roles(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "producer": {"type": bool},
                        "consumer": {"type": bool},
                        "propagator": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    producer: bool | None
                    consumer: bool | None
                    propagator: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        producer: bool | None | UndefinedType = Undefined,
                        consumer: bool | None | UndefinedType = Undefined,
                        propagator: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Roles.

                        Args:
                        -----
                            _custom_data: _custom_data
                            producer: producer
                            consumer: consumer
                            propagator: propagator

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "roles": {"type": Roles}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                roles: Roles

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, roles: Roles | UndefinedType = Undefined) -> None:
                    """
                    PathSelection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        roles: roles

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bgp": {"type": Bgp},
                "peer_groups": {"type": PeerGroups},
                "neighbors": {"type": Neighbors},
                "path_selection": {"type": PathSelection},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bgp: Bgp
            peer_groups: PeerGroups
            neighbors: Neighbors
            path_selection: PathSelection

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                path_selection: PathSelection | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyLinkState.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    peer_groups: peer_groups
                    neighbors: neighbors
                    path_selection: path_selection

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyFlowSpecIpv4(AvdModel):
            class Bgp(AvdModel):
                class MissingPolicy(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in_action: str | None
                    direction_out_action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in_action: str | None | UndefinedType = Undefined,
                        direction_out_action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "missing_policy": {"type": MissingPolicy}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                missing_policy: MissingPolicy

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, missing_policy: MissingPolicy | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "activate": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "activate": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bgp: Bgp
            neighbors: Neighbors
            peer_groups: PeerGroups

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyFlowSpecIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyFlowSpecIpv6(AvdModel):
            class Bgp(AvdModel):
                class MissingPolicy(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    direction_in_action: str | None
                    direction_out_action: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        direction_in_action: str | None | UndefinedType = Undefined,
                        direction_out_action: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        MissingPolicy.

                        Args:
                        -----
                            _custom_data: _custom_data
                            direction_in_action: direction_in_action
                            direction_out_action: direction_out_action

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "missing_policy": {"type": MissingPolicy}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                missing_policy: MissingPolicy

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, missing_policy: MissingPolicy | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        missing_policy: missing_policy

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "activate": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "activate": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bgp: Bgp
            neighbors: Neighbors
            peer_groups: PeerGroups

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyFlowSpecIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyPathSelection(AvdModel):
            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "additional_paths": {"type": AdditionalPaths}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                additional_paths: AdditionalPaths

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, additional_paths: AdditionalPaths | UndefinedType = Undefined
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class PeerGroupsItem(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bgp": {"type": Bgp},
                "neighbors": {"type": Neighbors},
                "peer_groups": {"type": PeerGroups},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bgp: Bgp
            neighbors: Neighbors
            peer_groups: PeerGroups

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyPathSelection.

                Args:
                -----
                    _custom_data: _custom_data
                    bgp: bgp
                    neighbors: neighbors
                    peer_groups: peer_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyVpnIpv4(AvdModel):
            class PeerGroupsItem(AvdModel):
                class DefaultRoute(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_route: DefaultRoute | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class Route(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "import_match_failure_action": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                import_match_failure_action: str | None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, import_match_failure_action: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Route.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_match_failure_action: import_match_failure_action

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                class DefaultRoute(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_route: DefaultRoute | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source_interface": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                source_interface: str | None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source_interface: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    NeighborDefaultEncapsulationMplsNextHopSelf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: source_interface

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "domain_identifier": {"type": str},
                "peer_groups": {"type": PeerGroups},
                "route": {"type": Route},
                "neighbors": {"type": Neighbors},
                "neighbor_default_encapsulation_mpls_next_hop_self": {"type": NeighborDefaultEncapsulationMplsNextHopSelf},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            domain_identifier: str | None
            peer_groups: PeerGroups
            route: Route
            neighbors: Neighbors
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                domain_identifier: str | None | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                route: Route | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyVpnIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    domain_identifier: domain_identifier
                    peer_groups: peer_groups
                    route: route
                    neighbors: neighbors
                    neighbor_default_encapsulation_mpls_next_hop_self: neighbor_default_encapsulation_mpls_next_hop_self

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyVpnIpv6(AvdModel):
            class PeerGroupsItem(AvdModel):
                class DefaultRoute(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Peer-group name."""
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_route: DefaultRoute | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeerGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Peer-group name.
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PeerGroups(AvdCollection[str, PeerGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PeerGroups._item_type = PeerGroupsItem

            class Route(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "import_match_failure_action": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                import_match_failure_action: str | None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, import_match_failure_action: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Route.

                    Args:
                    -----
                        _custom_data: _custom_data
                        import_match_failure_action: import_match_failure_action

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                class DefaultRoute(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultRoute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "activate": {"type": bool},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "rcf_in": {"type": str},
                    "rcf_out": {"type": str},
                    "default_route": {"type": DefaultRoute},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                activate: bool | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                rcf_in: str | None
                """
                Inbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                rcf_out: str | None
                """
                Outbound RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """
                default_route: DefaultRoute

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    activate: bool | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    rcf_in: str | None | UndefinedType = Undefined,
                    rcf_out: str | None | UndefinedType = Undefined,
                    default_route: DefaultRoute | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        activate: activate
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        rcf_in:
                           Inbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        rcf_out:
                           Outbound RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                        default_route: default_route

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborDefaultEncapsulationMplsNextHopSelf(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source_interface": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                source_interface: str | None

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source_interface: str | None | UndefinedType = Undefined
                ) -> None:
                    """
                    NeighborDefaultEncapsulationMplsNextHopSelf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: source_interface

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "domain_identifier": {"type": str},
                "peer_groups": {"type": PeerGroups},
                "route": {"type": Route},
                "neighbors": {"type": Neighbors},
                "neighbor_default_encapsulation_mpls_next_hop_self": {"type": NeighborDefaultEncapsulationMplsNextHopSelf},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            domain_identifier: str | None
            peer_groups: PeerGroups
            route: Route
            neighbors: Neighbors
            neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                domain_identifier: str | None | UndefinedType = Undefined,
                peer_groups: PeerGroups | UndefinedType = Undefined,
                route: Route | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                neighbor_default_encapsulation_mpls_next_hop_self: NeighborDefaultEncapsulationMplsNextHopSelf | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyVpnIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    domain_identifier: domain_identifier
                    peer_groups: peer_groups
                    route: route
                    neighbors: neighbors
                    neighbor_default_encapsulation_mpls_next_hop_self: neighbor_default_encapsulation_mpls_next_hop_self

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            class Bgp(AvdModel):
                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "install": {"type": bool},
                        "install_ecmp_primary": {"type": bool},
                        "receive": {"type": bool},
                        "send": {"type": str},
                        "send_limit": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    install: bool | None
                    """Install BGP backup path."""
                    install_ecmp_primary: bool | None
                    """Allow additional path with ECMP primary path."""
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        install: bool | None | UndefinedType = Undefined,
                        install_ecmp_primary: bool | None | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            install: Install BGP backup path.
                            install_ecmp_primary: Allow additional path with ECMP primary path.
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "redistribute_internal": {"type": bool},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                redistribute_internal: bool | None
                """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    redistribute_internal: bool | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    Bgp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class EvpnMulticastAddressFamily(AvdModel):
                class Ipv4(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "transit": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    transit: bool | None
                    """Enable EVPN multicast transit mode."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, transit: bool | None | UndefinedType = Undefined) -> None:
                        """
                        Ipv4.

                        Args:
                        -----
                            _custom_data: _custom_data
                            transit: Enable EVPN multicast transit mode.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4: Ipv4

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                    """
                    EvpnMulticastAddressFamily.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: ipv4

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class EvpnMulticastGatewayDrElection(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "algorithm": {"type": str}, "preference_value": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "algorithm")
                _custom_data: dict[str, Any]
                algorithm: str
                """
                DR election algorithms:
                  hrw: Default selection based on highest random weight.
                  modulus:
                Selection based on VLAN ID modulo number of candidates.
                  preference: Selection based on a
                configured preference value.
                """
                preference_value: int | None
                """Required when `algorithm` is `preference`."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    algorithm: str | UndefinedType = Undefined,
                    preference_value: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    EvpnMulticastGatewayDrElection.

                    Args:
                    -----
                        _custom_data: _custom_data
                        algorithm:
                           DR election algorithms:
                             hrw: Default selection based on highest random weight.
                             modulus:
                           Selection based on VLAN ID modulo number of candidates.
                             preference: Selection based on a
                           configured preference value.
                        preference_value: Required when `algorithm` is `preference`.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultRouteExportsItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "address_family": {"type": str},
                    "always": {"type": bool},
                    "route_map": {"type": str},
                    "rcf": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "address_family")
                _custom_data: dict[str, Any]
                address_family: str
                always: bool | None
                route_map: str | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    address_family: str | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultRouteExportsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address_family: address_family
                        always: always
                        route_map: route_map
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultRouteExports(AvdCollection[str, DefaultRouteExportsItem]):
                _primary_key: ClassVar[str] = "address_family"

            DefaultRouteExports._item_type = DefaultRouteExportsItem

            class RouteTargets(AvdModel):
                class ImportItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "address_family": {"type": str},
                        "route_targets": {"type": list, "items": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "vpn_route_filter_rcf": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "address_family")
                    _custom_data: dict[str, Any]
                    address_family: str
                    route_targets: list[str]
                    route_map: str | None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vpn_route_filter_rcf: str | None
                    """
                    RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        address_family: str | UndefinedType = Undefined,
                        route_targets: list[str] | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        vpn_route_filter_rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ImportItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address_family: address_family
                            route_targets: route_targets
                            route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               Only applicable if `address_family`
                               is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            vpn_route_filter_rcf:
                               RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.

                        Example:
                               MyFunction(myarg).
                               Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Import(AvdCollection[str, ImportItem]):
                    _primary_key: ClassVar[str] = "address_family"

                Import._item_type = ImportItem

                class ExportItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "address_family": {"type": str},
                        "route_targets": {"type": list, "items": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "vpn_route_filter_rcf": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "address_family")
                    _custom_data: dict[str, Any]
                    address_family: str
                    route_targets: list[str]
                    route_map: str | None
                    """Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    Only applicable if `address_family`
                    is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                    """
                    vpn_route_filter_rcf: str | None
                    """
                    RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.
                    Example:
                    MyFunction(myarg).
                    Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        address_family: str | UndefinedType = Undefined,
                        route_targets: list[str] | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        vpn_route_filter_rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ExportItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address_family: address_family
                            route_targets: route_targets
                            route_map: Only applicable if `address_family` is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               Only applicable if `address_family`
                               is one of `evpn`, `vpn-ipv4` or `vpn-ipv6`.
                            vpn_route_filter_rcf:
                               RCF function name with parenthesis for filtering VPN routes. Also requires `rcf` to be set.

                        Example:
                               MyFunction(myarg).
                               Only applicable if `address_family` is one of `vpn-ipv4` or `vpn-ipv6`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Export(AvdCollection[str, ExportItem]):
                    _primary_key: ClassVar[str] = "address_family"

                Export._item_type = ExportItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "field_import": {"type": Import, "key": "import"}, "export": {"type": Export}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                field_import: Import
                export: Export

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    field_import: Import | UndefinedType = Undefined,
                    export: Export | UndefinedType = Undefined,
                ) -> None:
                    """
                    RouteTargets.

                    Args:
                    -----
                        _custom_data: _custom_data
                        field_import: field_import
                        export: export

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworksItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                route_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworksItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Networks(AvdCollection[str, NetworksItem]):
                _primary_key: ClassVar[str] = "prefix"

            Networks._item_type = NetworksItem

            class Updates(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "wait_for_convergence": {"type": bool}, "wait_install": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                wait_for_convergence: bool | None
                """
                Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                convergence state is reached.
                """
                wait_install: bool | None
                """
                Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                This
                will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                that may not yet be installed into the forwarding plane.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    wait_for_convergence: bool | None | UndefinedType = Undefined,
                    wait_install: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Updates.

                    Args:
                    -----
                        _custom_data: _custom_data
                        wait_for_convergence:
                           Disables FIB updates and route advertisement when the BGP instance is initiated until the BGP
                           convergence state is reached.
                        wait_install:
                           Do not advertise reachability to a prefix until that prefix has been installed in hardware.
                           This
                           will eliminate any temporary black holes due to a BGP speaker advertising reachability to a prefix
                           that may not yet be installed into the forwarding plane.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ListenRangesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "prefix": {"type": str},
                    "peer_id_include_router_id": {"type": bool},
                    "peer_group": {"type": str},
                    "peer_filter": {"type": str},
                    "remote_as": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                prefix: str | None
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                peer_id_include_router_id: bool | None
                """Include router ID as part of peer filter."""
                peer_group: str | None
                """Peer-group name."""
                peer_filter: str | None
                """
                Peer-filter name.
                note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                If both
                are defined, peer_filter takes precedence.
                """
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | None | UndefinedType = Undefined,
                    peer_id_include_router_id: bool | None | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    peer_filter: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ListenRangesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        peer_id_include_router_id: Include router ID as part of peer filter.
                        peer_group: Peer-group name.
                        peer_filter:
                           Peer-filter name.
                           note: `peer_filter`` or `remote_as` is required but mutually exclusive.
                           If both
                           are defined, peer_filter takes precedence.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborsItem(AvdModel):
                class RemovePrivateAs(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}, "replace_as": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    all: bool | None
                    replace_as: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAs.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            all: all
                            replace_as: replace_as

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RemovePrivateAsIngress(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "replace_as": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    replace_as: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        replace_as: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RemovePrivateAsIngress.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            replace_as: replace_as

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AsPath(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "remote_as_replace_out": {"type": bool}, "prepend_own_disabled": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    remote_as_replace_out: bool | None
                    """Replace AS number with local AS number."""
                    prepend_own_disabled: bool | None
                    """Disable prepending own AS number to AS path."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        remote_as_replace_out: bool | None | UndefinedType = Undefined,
                        prepend_own_disabled: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AsPath.

                        Args:
                        -----
                            _custom_data: _custom_data
                            remote_as_replace_out: Replace AS number with local AS number.
                            prepend_own_disabled: Disable prepending own AS number to AS path.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BfdTimers(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}, "min_rx": {"type": int}, "multiplier": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "interval", "min_rx", "multiplier")
                    _custom_data: dict[str, Any]
                    interval: int
                    """Interval in milliseconds."""
                    min_rx: int
                    """Rate in milliseconds."""
                    multiplier: int

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        interval: int | UndefinedType = Undefined,
                        min_rx: int | UndefinedType = Undefined,
                        multiplier: int | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BfdTimers.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interval: Interval in milliseconds.
                            min_rx: Rate in milliseconds.
                            multiplier: multiplier

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RibInPrePolicyRetain(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "all": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    all: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        all: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RibInPrePolicyRetain.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            all: all

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AllowasIn(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "times": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    times: int | None
                    """Number of local ASNs allowed in a BGP update."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        times: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AllowasIn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            times: Number of local ASNs allowed in a BGP update.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DefaultOriginate(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "always": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    always: bool | None
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        always: bool | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            always: always
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class AdditionalPaths(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}, "send": {"type": str}, "send_limit": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    receive: bool | None
                    """Enable or disable reception of additional-paths."""
                    send: str | None
                    """
                    Select an option to send multiple paths for same prefix through bgp updates.
                    any: Send any eligible
                    path.
                    backup: Best path and installed backup path.
                    ecmp: All paths in best path ECMP group.
                    limit:
                    Limit to n eligible paths.
                    disabled: Disable sending any paths.
                    """
                    send_limit: int | None
                    """
                    Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                    `ecmp`.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        receive: bool | None | UndefinedType = Undefined,
                        send: str | None | UndefinedType = Undefined,
                        send_limit: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AdditionalPaths.

                        Args:
                        -----
                            _custom_data: _custom_data
                            receive: Enable or disable reception of additional-paths.
                            send:
                               Select an option to send multiple paths for same prefix through bgp updates.
                               any: Send any eligible
                               path.
                               backup: Best path and installed backup path.
                               ecmp: All paths in best path ECMP group.
                               limit:
                               Limit to n eligible paths.
                               disabled: Disable sending any paths.
                            send_limit:
                               Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                               `ecmp`.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ip_address": {"type": str},
                    "peer_group": {"type": str},
                    "remote_as": {"type": str},
                    "password": {"type": str},
                    "passive": {"type": bool},
                    "remove_private_as": {"type": RemovePrivateAs},
                    "remove_private_as_ingress": {"type": RemovePrivateAsIngress},
                    "weight": {"type": int},
                    "local_as": {"type": str},
                    "as_path": {"type": AsPath},
                    "description": {"type": str},
                    "route_reflector_client": {"type": bool},
                    "ebgp_multihop": {"type": int},
                    "next_hop_self": {"type": bool},
                    "shutdown": {"type": bool},
                    "bfd": {"type": bool},
                    "bfd_timers": {"type": BfdTimers},
                    "timers": {"type": str},
                    "rib_in_pre_policy_retain": {"type": RibInPrePolicyRetain},
                    "send_community": {"type": str},
                    "maximum_routes": {"type": int},
                    "maximum_routes_warning_limit": {"type": str},
                    "maximum_routes_warning_only": {"type": bool},
                    "allowas_in": {"type": AllowasIn},
                    "default_originate": {"type": DefaultOriginate},
                    "update_source": {"type": str},
                    "route_map_in": {"type": str},
                    "route_map_out": {"type": str},
                    "additional_paths": {"type": AdditionalPaths},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                peer_group: str | None
                """Peer-group name."""
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                password: str | None
                passive: bool | None
                remove_private_as: RemovePrivateAs
                """Remove private AS numbers in outbound AS path."""
                remove_private_as_ingress: RemovePrivateAsIngress
                weight: int | None
                local_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                as_path: AsPath
                """BGP AS-PATH options."""
                description: str | None
                route_reflector_client: bool | None
                ebgp_multihop: int | None
                """Time-to-live in range of hops."""
                next_hop_self: bool | None
                shutdown: bool | None
                bfd: bool | None
                """Enable BFD."""
                bfd_timers: BfdTimers
                """Override default BFD timers. BFD must be enabled with `bfd: true`."""
                timers: str | None
                """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
                rib_in_pre_policy_retain: RibInPrePolicyRetain
                send_community: str | None
                """'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'."""
                maximum_routes: int | None
                maximum_routes_warning_limit: str | None
                """
                Maximum number of routes after which a warning is issued (0 means never warn) or
                Percentage of
                maximum number of routes at which to warn ("<1-100> percent").
                """
                maximum_routes_warning_only: bool | None
                allowas_in: AllowasIn
                default_originate: DefaultOriginate
                update_source: str | None
                route_map_in: str | None
                """Inbound route-map name."""
                route_map_out: str | None
                """Outbound route-map name."""
                additional_paths: AdditionalPaths

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    password: str | None | UndefinedType = Undefined,
                    passive: bool | None | UndefinedType = Undefined,
                    remove_private_as: RemovePrivateAs | UndefinedType = Undefined,
                    remove_private_as_ingress: RemovePrivateAsIngress | UndefinedType = Undefined,
                    weight: int | None | UndefinedType = Undefined,
                    local_as: str | None | UndefinedType = Undefined,
                    as_path: AsPath | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    route_reflector_client: bool | None | UndefinedType = Undefined,
                    ebgp_multihop: int | None | UndefinedType = Undefined,
                    next_hop_self: bool | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bfd_timers: BfdTimers | UndefinedType = Undefined,
                    timers: str | None | UndefinedType = Undefined,
                    rib_in_pre_policy_retain: RibInPrePolicyRetain | UndefinedType = Undefined,
                    send_community: str | None | UndefinedType = Undefined,
                    maximum_routes: int | None | UndefinedType = Undefined,
                    maximum_routes_warning_limit: str | None | UndefinedType = Undefined,
                    maximum_routes_warning_only: bool | None | UndefinedType = Undefined,
                    allowas_in: AllowasIn | UndefinedType = Undefined,
                    default_originate: DefaultOriginate | UndefinedType = Undefined,
                    update_source: str | None | UndefinedType = Undefined,
                    route_map_in: str | None | UndefinedType = Undefined,
                    route_map_out: str | None | UndefinedType = Undefined,
                    additional_paths: AdditionalPaths | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        peer_group: Peer-group name.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        password: password
                        passive: passive
                        remove_private_as: Remove private AS numbers in outbound AS path.
                        remove_private_as_ingress: remove_private_as_ingress
                        weight: weight
                        local_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        as_path: BGP AS-PATH options.
                        description: description
                        route_reflector_client: route_reflector_client
                        ebgp_multihop: Time-to-live in range of hops.
                        next_hop_self: next_hop_self
                        shutdown: shutdown
                        bfd: Enable BFD.
                        bfd_timers: Override default BFD timers. BFD must be enabled with `bfd: true`.
                        timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                        rib_in_pre_policy_retain: rib_in_pre_policy_retain
                        send_community: 'all' or a combination of 'standard', 'extended', 'large' and 'link-bandwidth (w/options)'.
                        maximum_routes: maximum_routes
                        maximum_routes_warning_limit:
                           Maximum number of routes after which a warning is issued (0 means never warn) or
                           Percentage of
                           maximum number of routes at which to warn ("<1-100> percent").
                        maximum_routes_warning_only: maximum_routes_warning_only
                        allowas_in: allowas_in
                        default_originate: default_originate
                        update_source: update_source
                        route_map_in: Inbound route-map name.
                        route_map_out: Outbound route-map name.
                        additional_paths: additional_paths

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Neighbors(AvdCollection[str, NeighborsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            Neighbors._item_type = NeighborsItem

            class NeighborInterfacesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "remote_as": {"type": str},
                    "peer_group": {"type": str},
                    "peer_filter": {"type": str},
                    "description": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Interface name."""
                remote_as: str | None
                """
                BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                For asdot notation in
                YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                number.
                """
                peer_group: str | None
                """Peer-group name."""
                peer_filter: str | None
                """Peer-filter name."""
                description: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    remote_as: str | None | UndefinedType = Undefined,
                    peer_group: str | None | UndefinedType = Undefined,
                    peer_filter: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NeighborInterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Interface name.
                        remote_as:
                           BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                           For asdot notation in
                           YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                           number.
                        peer_group: Peer-group name.
                        peer_filter: Peer-filter name.
                        description: description

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NeighborInterfaces(AvdCollection[str, NeighborInterfacesItem]):
                _primary_key: ClassVar[str] = "name"

            NeighborInterfaces._item_type = NeighborInterfacesItem

            class Redistribute(AvdModel):
                class AttachedHost(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        AttachedHost.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Dynamic.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Isis(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "isis_level": {"type": str},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    isis_level: str | None
                    """Redistribute IS-IS route level."""
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        isis_level: str | None | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Isis.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            isis_level: Redistribute IS-IS route level.
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospf(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPF routes."""
                    match_external: MatchExternal
                    """Redistribute OSPF routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPF routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPF routes learned from external NSSA sources."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospf.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPF routes.
                            match_external: Redistribute OSPF routes learned from external sources.
                            match_internal: Redistribute OSPF routes learned from internal sources.
                            match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ospfv3(AvdModel):
                    class MatchExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchInternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchInternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchNssaExternal(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "nssa_type": {"type": int},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        nssa_type: int | None
                        """NSSA External Type Number."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            nssa_type: int | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchNssaExternal.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                nssa_type: NSSA External Type Number.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "match_external": {"type": MatchExternal},
                        "match_internal": {"type": MatchInternal},
                        "match_nssa_external": {"type": MatchNssaExternal},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    """Redistribute OSPFv3 routes."""
                    match_external: MatchExternal
                    """Redistribute OSPFv3 routes learned from external sources."""
                    match_internal: MatchInternal
                    """Redistribute OSPFv3 routes learned from internal sources."""
                    match_nssa_external: MatchNssaExternal
                    """Redistribute OSPFv3 routes learned from external NSSA sources."""
                    route_map: str | None
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        match_external: MatchExternal | UndefinedType = Undefined,
                        match_internal: MatchInternal | UndefinedType = Undefined,
                        match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ospfv3.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: Redistribute OSPFv3 routes.
                            match_external: Redistribute OSPFv3 routes learned from external sources.
                            match_internal: Redistribute OSPFv3 routes learned from internal sources.
                            match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                            route_map: route_map
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Rip(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Rip.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Static(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "rcf": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """
                    include_leaked: bool | None
                    """Include following routes while redistributing."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: route_map
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                            include_leaked: Include following routes while redistributing.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class User(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        User.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "attached_host": {"type": AttachedHost},
                    "bgp": {"type": Bgp},
                    "connected": {"type": Connected},
                    "dynamic": {"type": Dynamic},
                    "isis": {"type": Isis},
                    "ospf": {"type": Ospf},
                    "ospfv3": {"type": Ospfv3},
                    "rip": {"type": Rip},
                    "static": {"type": Static},
                    "user": {"type": User},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                attached_host: AttachedHost
                bgp: Bgp
                connected: Connected
                dynamic: Dynamic
                isis: Isis
                ospf: Ospf
                ospfv3: Ospfv3
                rip: Rip
                static: Static
                user: User

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    attached_host: AttachedHost | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    isis: Isis | UndefinedType = Undefined,
                    ospf: Ospf | UndefinedType = Undefined,
                    ospfv3: Ospfv3 | UndefinedType = Undefined,
                    rip: Rip | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                    user: User | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        attached_host: attached_host
                        bgp: bgp
                        connected: connected
                        dynamic: dynamic
                        isis: isis
                        ospf: ospf
                        ospfv3: ospfv3
                        rip: rip
                        static: static
                        user: user

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RedistributeRoutesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_protocol": {"type": str},
                    "route_map": {"type": str},
                    "include_leaked": {"type": bool},
                    "rcf": {"type": str},
                    "ospf_route_type": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                _custom_data: dict[str, Any]
                source_protocol: str
                route_map: str | None
                include_leaked: bool | None
                rcf: str | None
                """
                RCF function name with parenthesis.
                Example: MyFunction(myarg).
                `route_map` and `rcf` are mutually
                exclusive. `route_map` takes precedence.
                Only applicable if `source_protocol` is one of `connected`,
                `dynamic`, `isis`, `static` and `user`.
                """
                ospf_route_type: str | None
                """
                Routes learned by the OSPF protocol.
                The `ospf_route_type` is valid for source_protocols 'ospf' and
                'ospfv3'.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_protocol: str | UndefinedType = Undefined,
                    route_map: str | None | UndefinedType = Undefined,
                    include_leaked: bool | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                    ospf_route_type: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RedistributeRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_protocol: source_protocol
                        route_map: route_map
                        include_leaked: include_leaked
                        rcf:
                           RCF function name with parenthesis.
                           Example: MyFunction(myarg).
                           `route_map` and `rcf` are mutually
                           exclusive. `route_map` takes precedence.
                           Only applicable if `source_protocol` is one of `connected`,
                           `dynamic`, `isis`, `static` and `user`.
                        ospf_route_type:
                           Routes learned by the OSPF protocol.
                           The `ospf_route_type` is valid for source_protocols 'ospf' and
                           'ospfv3'.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AggregateAddressesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "prefix": {"type": str},
                    "advertise_only": {"type": bool},
                    "as_set": {"type": bool},
                    "summary_only": {"type": bool},
                    "attribute_map": {"type": str},
                    "match_map": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                advertise_only: bool | None
                as_set: bool | None
                summary_only: bool | None
                attribute_map: str | None
                match_map: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    advertise_only: bool | None | UndefinedType = Undefined,
                    as_set: bool | None | UndefinedType = Undefined,
                    summary_only: bool | None | UndefinedType = Undefined,
                    attribute_map: str | None | UndefinedType = Undefined,
                    match_map: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    AggregateAddressesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: IPv4 prefix "A.B.C.D/E" or IPv6 prefix "A:B:C:D:E:F:G:H/I".
                        advertise_only: advertise_only
                        as_set: as_set
                        summary_only: summary_only
                        attribute_map: attribute_map
                        match_map: match_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AggregateAddresses(AvdCollection[str, AggregateAddressesItem]):
                _primary_key: ClassVar[str] = "prefix"

            AggregateAddresses._item_type = AggregateAddressesItem

            class AddressFamilyIpv4(AvdModel):
                class Bgp(AvdModel):
                    class MissingPolicy(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in_action: str | None
                        direction_out_action: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in_action: str | None | UndefinedType = Undefined,
                            direction_out_action: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "install": {"type": bool},
                            "install_ecmp_primary": {"type": bool},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        install: bool | None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: str | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: str | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "redistribute_internal": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    missing_policy: MissingPolicy
                    additional_paths: AdditionalPaths
                    redistribute_internal: bool | None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        redistribute_internal: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdModel):
                    class NextHop(AvdModel):
                        class AddressFamilyIpv6(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "originate": {"type": bool}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            originate: bool | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                originate: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                AddressFamilyIpv6.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    originate: originate

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address_family_ipv6": {"type": AddressFamilyIpv6}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        address_family_ipv6: AddressFamilyIpv6

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                        ) -> None:
                            """
                            NextHop.

                            Args:
                            -----
                                _custom_data: _custom_data
                                address_family_ipv6: address_family_ipv6

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: str | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: str | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "rcf_in": {"type": str},
                        "rcf_out": {"type": str},
                        "prefix_list_in": {"type": str},
                        "prefix_list_out": {"type": str},
                        "next_hop": {"type": NextHop},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                    _custom_data: dict[str, Any]
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    rcf_in: str | None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None
                    """Outbound prefix-list name."""
                    next_hop: NextHop
                    additional_paths: AdditionalPaths

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        next_hop: NextHop | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            next_hop: next_hop
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Neighbors(AvdCollection[str, NeighborsItem]):
                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                    _custom_data: dict[str, Any]
                    prefix: str
                    """IPv4 prefix "A.B.C.D/E"."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv4 prefix "A.B.C.D/E".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Networks(AvdCollection[str, NetworksItem]):
                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    class AttachedHost(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Bgp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Connected(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Dynamic(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Isis(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        isis_level: str | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospf(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """Redistribute OSPF routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPF routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPF routes learned from external NSSA sources."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPF routes.
                                match_external: Redistribute OSPF routes learned from external sources.
                                match_internal: Redistribute OSPF routes learned from internal sources.
                                match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospfv3(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """Redistribute OSPFv3 routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPFv3 routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPFv3 routes learned from external NSSA sources."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPFv3 routes.
                                match_external: Redistribute OSPFv3 routes learned from external sources.
                                match_internal: Redistribute OSPFv3 routes learned from internal sources.
                                match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Rip(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Rip.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Static(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class User(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            User.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "attached_host": {"type": AttachedHost},
                        "bgp": {"type": Bgp},
                        "connected": {"type": Connected},
                        "dynamic": {"type": Dynamic},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "rip": {"type": Rip},
                        "static": {"type": Static},
                        "user": {"type": User},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    attached_host: AttachedHost
                    bgp: Bgp
                    connected: Connected
                    dynamic: Dynamic
                    isis: Isis
                    ospf: Ospf
                    ospfv3: Ospfv3
                    rip: Rip
                    static: Static
                    user: User

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        rip: Rip | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            attached_host: attached_host
                            bgp: bgp
                            connected: connected
                            dynamic: dynamic
                            isis: isis
                            ospf: ospf
                            ospfv3: ospfv3
                            rip: rip
                            static: static
                            user: user

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                    _custom_data: dict[str, Any]
                    source_protocol: str
                    route_map: str | None
                    include_leaked: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: str | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `dynamic`, `isis`, `static` and `user`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp: Bgp
                neighbors: Neighbors
                networks: Networks
                redistribute: Redistribute
                """Redistribute routes in to BGP."""
                redistribute_routes: list[RedistributeRoutesItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute: Redistribute routes in to BGP.
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv6(AvdModel):
                class Bgp(AvdModel):
                    class MissingPolicy(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in_action: str | None
                        direction_out_action: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in_action: str | None | UndefinedType = Undefined,
                            direction_out_action: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "install": {"type": bool},
                            "install_ecmp_primary": {"type": bool},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        install: bool | None
                        """Install BGP backup path."""
                        install_ecmp_primary: bool | None
                        """Allow additional path with ECMP primary path."""
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: str | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            install: bool | None | UndefinedType = Undefined,
                            install_ecmp_primary: bool | None | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: str | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                install: Install BGP backup path.
                                install_ecmp_primary: Allow additional path with ECMP primary path.
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                        "redistribute_internal": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    missing_policy: MissingPolicy
                    additional_paths: AdditionalPaths
                    redistribute_internal: bool | None
                    """Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                        redistribute_internal: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths
                            redistribute_internal: Allow redistribution of iBGP routes into an Interior Gateway Protocol (IGP). EOS default is true.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdModel):
                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "receive": {"type": bool},
                            "send": {"type": str},
                            "send_limit": {"type": int},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        receive: bool | None
                        """Enable or disable reception of additional-paths."""
                        send: str | None
                        """
                        Select an option to send multiple paths for same prefix through bgp updates.
                        any: Send any eligible
                        path.
                        backup: Best path and installed backup path.
                        ecmp: All paths in best path ECMP group.
                        limit:
                        Limit to n eligible paths.
                        disabled: Disable sending any paths.
                        """
                        send_limit: int | None
                        """
                        Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                        `ecmp`.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            receive: bool | None | UndefinedType = Undefined,
                            send: str | None | UndefinedType = Undefined,
                            send_limit: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: Enable or disable reception of additional-paths.
                                send:
                                   Select an option to send multiple paths for same prefix through bgp updates.
                                   any: Send any eligible
                                   path.
                                   backup: Best path and installed backup path.
                                   ecmp: All paths in best path ECMP group.
                                   limit:
                                   Limit to n eligible paths.
                                   disabled: Disable sending any paths.
                                send_limit:
                                   Number of paths to send through bgp updates. For this setting, `send` must be set to `limit` or
                                   `ecmp`.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "rcf_in": {"type": str},
                        "rcf_out": {"type": str},
                        "prefix_list_in": {"type": str},
                        "prefix_list_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                    _custom_data: dict[str, Any]
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    rcf_in: str | None
                    """
                    Inbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    rcf_out: str | None
                    """
                    Outbound RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    """
                    prefix_list_in: str | None
                    """Inbound prefix-list name."""
                    prefix_list_out: str | None
                    """Outbound prefix-list name."""
                    additional_paths: AdditionalPaths

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        rcf_in: str | None | UndefinedType = Undefined,
                        rcf_out: str | None | UndefinedType = Undefined,
                        prefix_list_in: str | None | UndefinedType = Undefined,
                        prefix_list_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            rcf_in:
                               Inbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            rcf_out:
                               Outbound RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                            prefix_list_in: Inbound prefix-list name.
                            prefix_list_out: Outbound prefix-list name.
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Neighbors(AvdCollection[str, NeighborsItem]):
                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                    _custom_data: dict[str, Any]
                    prefix: str
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Networks(AvdCollection[str, NetworksItem]):
                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    class AttachedHost(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Bgp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Bgp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Connected(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Dhcp(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dhcp.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Dynamic(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}, "rcf": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Dynamic.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Isis(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        isis_level: str | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospfv3(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """Redistribute OSPFv3 routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPFv3 routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPFv3 routes learned from external NSSA sources."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPFv3 routes.
                                match_external: Redistribute OSPFv3 routes learned from external sources.
                                match_internal: Redistribute OSPFv3 routes learned from internal sources.
                                match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Static(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class User(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            User.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "attached_host": {"type": AttachedHost},
                        "bgp": {"type": Bgp},
                        "connected": {"type": Connected},
                        "dhcp": {"type": Dhcp},
                        "dynamic": {"type": Dynamic},
                        "isis": {"type": Isis},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                        "user": {"type": User},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    attached_host: AttachedHost
                    bgp: Bgp
                    connected: Connected
                    dhcp: Dhcp
                    dynamic: Dynamic
                    isis: Isis
                    ospfv3: Ospfv3
                    static: Static
                    user: User

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        bgp: Bgp | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        dhcp: Dhcp | UndefinedType = Undefined,
                        dynamic: Dynamic | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                        user: User | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            attached_host: attached_host
                            bgp: bgp
                            connected: connected
                            dhcp: dhcp
                            dynamic: dynamic
                            isis: isis
                            ospfv3: ospfv3
                            static: static
                            user: user

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                    _custom_data: dict[str, Any]
                    source_protocol: str
                    route_map: str | None
                    include_leaked: bool | None
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is one of `connected`,
                    `dynamic`, `isis`, `static` and `user`.
                    """
                    ospf_route_type: str | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: include_leaked
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is one of `connected`,
                               `dynamic`, `isis`, `static` and `user`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp: Bgp
                neighbors: Neighbors
                networks: Networks
                redistribute: Redistribute
                """Redistribute routes in to BGP."""
                redistribute_routes: list[RedistributeRoutesItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute: Redistribute routes in to BGP.
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv4Multicast(AvdModel):
                class Bgp(AvdModel):
                    class MissingPolicy(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in_action: str | None
                        direction_out_action: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in_action: str | None | UndefinedType = Undefined,
                            direction_out_action: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        receive: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    missing_policy: MissingPolicy
                    additional_paths: AdditionalPaths

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdModel):
                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        receive: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                    _custom_data: dict[str, Any]
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    additional_paths: AdditionalPaths

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Neighbors(AvdCollection[str, NeighborsItem]):
                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                    _custom_data: dict[str, Any]
                    prefix: str
                    """IPv6 prefix "A.B.C.D/E"."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv6 prefix "A.B.C.D/E".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Networks(AvdCollection[str, NetworksItem]):
                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    class AttachedHost(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            AttachedHost.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Connected(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Isis(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        isis_level: str | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospf(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """Redistribute OSPF routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPF routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPF routes learned from external NSSA sources."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPF routes.
                                match_external: Redistribute OSPF routes learned from external sources.
                                match_internal: Redistribute OSPF routes learned from internal sources.
                                match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospfv3(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                                "include_leaked": {"type": bool},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None
                            include_leaked: bool | None
                            """Include following routes while redistributing."""

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                                include_leaked: bool | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map
                                    include_leaked: Include following routes while redistributing.

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """Redistribute OSPFv3 routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPFv3 routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPFv3 routes learned from external NSSA sources."""
                        route_map: str | None
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPFv3 routes.
                                match_external: Redistribute OSPFv3 routes learned from external sources.
                                match_internal: Redistribute OSPFv3 routes learned from internal sources.
                                match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                                route_map: route_map
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Static(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "attached_host": {"type": AttachedHost},
                        "connected": {"type": Connected},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    attached_host: AttachedHost
                    connected: Connected
                    isis: Isis
                    ospf: Ospf
                    ospfv3: Ospfv3
                    static: Static

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        attached_host: AttachedHost | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            attached_host: attached_host
                            connected: connected
                            isis: isis
                            ospf: ospf
                            ospfv3: ospfv3
                            static: static

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                    _custom_data: dict[str, Any]
                    source_protocol: str
                    route_map: str | None
                    include_leaked: bool | None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: str | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp: Bgp
                neighbors: Neighbors
                networks: Networks
                redistribute: Redistribute
                """Redistribute routes in to BGP."""
                redistribute_routes: list[RedistributeRoutesItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv4Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute: Redistribute routes in to BGP.
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyIpv6Multicast(AvdModel):
                class Bgp(AvdModel):
                    class MissingPolicy(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in_action: str | None
                        direction_out_action: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in_action: str | None | UndefinedType = Undefined,
                            direction_out_action: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        receive: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "missing_policy": {"type": MissingPolicy},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    missing_policy: MissingPolicy
                    additional_paths: AdditionalPaths

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        missing_policy: MissingPolicy | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdModel):
                    class AdditionalPaths(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "receive": {"type": bool}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        receive: bool | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, receive: bool | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            AdditionalPaths.

                            Args:
                            -----
                                _custom_data: _custom_data
                                receive: receive

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "ip_address": {"type": str},
                        "activate": {"type": bool},
                        "route_map_in": {"type": str},
                        "route_map_out": {"type": str},
                        "additional_paths": {"type": AdditionalPaths},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                    _custom_data: dict[str, Any]
                    ip_address: str
                    activate: bool | None
                    route_map_in: str | None
                    """Inbound route-map name."""
                    route_map_out: str | None
                    """Outbound route-map name."""
                    additional_paths: AdditionalPaths

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                        route_map_in: str | None | UndefinedType = Undefined,
                        route_map_out: str | None | UndefinedType = Undefined,
                        additional_paths: AdditionalPaths | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate
                            route_map_in: Inbound route-map name.
                            route_map_out: Outbound route-map name.
                            additional_paths: additional_paths

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Neighbors(AvdCollection[str, NeighborsItem]):
                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                class NetworksItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "route_map": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                    _custom_data: dict[str, Any]
                    prefix: str
                    """IPv6 prefix "A:B:C:D:E:F:G:H/I"."""
                    route_map: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefix: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NetworksItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefix: IPv6 prefix "A:B:C:D:E:F:G:H/I".
                            route_map: route_map

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Networks(AvdCollection[str, NetworksItem]):
                    _primary_key: ClassVar[str] = "prefix"

                Networks._item_type = NetworksItem

                class Redistribute(AvdModel):
                    class Connected(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Connected.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Isis(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "isis_level": {"type": str},
                            "route_map": {"type": str},
                            "rcf": {"type": str},
                            "include_leaked": {"type": bool},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        isis_level: str | None
                        """Redistribute IS-IS route level."""
                        route_map: str | None
                        rcf: str | None
                        """
                        RCF function name with parenthesis.
                        Example: MyFunction(myarg).
                        `route_map` and `rcf` are mutually
                        exclusive. `route_map` takes precedence.
                        """
                        include_leaked: bool | None
                        """Include following routes while redistributing."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            isis_level: str | None | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                            rcf: str | None | UndefinedType = Undefined,
                            include_leaked: bool | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Isis.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                isis_level: Redistribute IS-IS route level.
                                route_map: route_map
                                rcf:
                                   RCF function name with parenthesis.
                                   Example: MyFunction(myarg).
                                   `route_map` and `rcf` are mutually
                                   exclusive. `route_map` takes precedence.
                                include_leaked: Include following routes while redistributing.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospf(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPF routes."""
                        match_external: MatchExternal
                        """Redistribute OSPF routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPF routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPF routes learned from external NSSA sources."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospf.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPF routes.
                                match_external: Redistribute OSPF routes learned from external sources.
                                match_internal: Redistribute OSPF routes learned from internal sources.
                                match_nssa_external: Redistribute OSPF routes learned from external NSSA sources.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Ospfv3(AvdModel):
                        class MatchExternal(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchInternal(AvdModel):
                            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchInternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        class MatchNssaExternal(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "enabled": {"type": bool},
                                "nssa_type": {"type": int},
                                "route_map": {"type": str},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                            _custom_data: dict[str, Any]
                            enabled: bool
                            nssa_type: int | None
                            """NSSA External Type Number."""
                            route_map: str | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                enabled: bool | UndefinedType = Undefined,
                                nssa_type: int | None | UndefinedType = Undefined,
                                route_map: str | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                MatchNssaExternal.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    enabled: enabled
                                    nssa_type: NSSA External Type Number.
                                    route_map: route_map

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "enabled": {"type": bool},
                            "match_external": {"type": MatchExternal},
                            "match_internal": {"type": MatchInternal},
                            "match_nssa_external": {"type": MatchNssaExternal},
                            "route_map": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        enabled: bool | None
                        """Redistribute OSPFv3 routes."""
                        match_external: MatchExternal
                        """Redistribute OSPFv3 routes learned from external sources."""
                        match_internal: MatchInternal
                        """Redistribute OSPFv3 routes learned from internal sources."""
                        match_nssa_external: MatchNssaExternal
                        """Redistribute OSPFv3 routes learned from external NSSA sources."""
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | None | UndefinedType = Undefined,
                            match_external: MatchExternal | UndefinedType = Undefined,
                            match_internal: MatchInternal | UndefinedType = Undefined,
                            match_nssa_external: MatchNssaExternal | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Ospfv3.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: Redistribute OSPFv3 routes.
                                match_external: Redistribute OSPFv3 routes learned from external sources.
                                match_internal: Redistribute OSPFv3 routes learned from internal sources.
                                match_nssa_external: Redistribute OSPFv3 routes learned from external NSSA sources.
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class Static(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "route_map": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                        _custom_data: dict[str, Any]
                        enabled: bool
                        route_map: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            enabled: bool | UndefinedType = Undefined,
                            route_map: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            Static.

                            Args:
                            -----
                                _custom_data: _custom_data
                                enabled: enabled
                                route_map: route_map

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "connected": {"type": Connected},
                        "isis": {"type": Isis},
                        "ospf": {"type": Ospf},
                        "ospfv3": {"type": Ospfv3},
                        "static": {"type": Static},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    connected: Connected
                    isis: Isis
                    ospf: Ospf
                    ospfv3: Ospfv3
                    static: Static

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        connected: Connected | UndefinedType = Undefined,
                        isis: Isis | UndefinedType = Undefined,
                        ospf: Ospf | UndefinedType = Undefined,
                        ospfv3: Ospfv3 | UndefinedType = Undefined,
                        static: Static | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Redistribute.

                        Args:
                        -----
                            _custom_data: _custom_data
                            connected: connected
                            isis: isis
                            ospf: ospf
                            ospfv3: ospfv3
                            static: static

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class RedistributeRoutesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "source_protocol": {"type": str},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                        "rcf": {"type": str},
                        "ospf_route_type": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
                    _custom_data: dict[str, Any]
                    source_protocol: str
                    route_map: str | None
                    include_leaked: bool | None
                    """Only applicable if `source_protocol` is `isis`."""
                    rcf: str | None
                    """
                    RCF function name with parenthesis.
                    Example: MyFunction(myarg).
                    `route_map` and `rcf` are mutually
                    exclusive. `route_map` takes precedence.
                    Only applicable if `source_protocol` is `isis`.
                    """
                    ospf_route_type: str | None
                    """
                    Routes learned by the OSPF protocol.
                    The `ospf_route_type` is valid for source_protocols 'ospf' and
                    'ospfv3'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        source_protocol: str | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                        rcf: str | None | UndefinedType = Undefined,
                        ospf_route_type: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RedistributeRoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_protocol: source_protocol
                            route_map: route_map
                            include_leaked: Only applicable if `source_protocol` is `isis`.
                            rcf:
                               RCF function name with parenthesis.
                               Example: MyFunction(myarg).
                               `route_map` and `rcf` are mutually
                               exclusive. `route_map` takes precedence.
                               Only applicable if `source_protocol` is `isis`.
                            ospf_route_type:
                               Routes learned by the OSPF protocol.
                               The `ospf_route_type` is valid for source_protocols 'ospf' and
                               'ospfv3'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "bgp": {"type": Bgp},
                    "neighbors": {"type": Neighbors},
                    "networks": {"type": Networks},
                    "redistribute": {"type": Redistribute},
                    "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp: Bgp
                neighbors: Neighbors
                networks: Networks
                redistribute: Redistribute
                """Redistribute routes in to BGP."""
                redistribute_routes: list[RedistributeRoutesItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                    networks: Networks | UndefinedType = Undefined,
                    redistribute: Redistribute | UndefinedType = Undefined,
                    redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyIpv6Multicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors
                        networks: networks
                        redistribute: Redistribute routes in to BGP.
                        redistribute_routes: redistribute_routes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyFlowSpecIpv4(AvdModel):
                class Bgp(AvdModel):
                    class MissingPolicy(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in_action: str | None
                        direction_out_action: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in_action: str | None | UndefinedType = Undefined,
                            direction_out_action: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "missing_policy": {"type": MissingPolicy}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    missing_policy: MissingPolicy

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, missing_policy: MissingPolicy | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "activate": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                    _custom_data: dict[str, Any]
                    ip_address: str
                    activate: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Neighbors(AvdCollection[str, NeighborsItem]):
                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp: Bgp
                neighbors: Neighbors

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyFlowSpecIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AddressFamilyFlowSpecIpv6(AvdModel):
                class Bgp(AvdModel):
                    class MissingPolicy(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "direction_in_action": {"type": str}, "direction_out_action": {"type": str}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        direction_in_action: str | None
                        direction_out_action: str | None

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            direction_in_action: str | None | UndefinedType = Undefined,
                            direction_out_action: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MissingPolicy.

                            Args:
                            -----
                                _custom_data: _custom_data
                                direction_in_action: direction_in_action
                                direction_out_action: direction_out_action

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "missing_policy": {"type": MissingPolicy}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    missing_policy: MissingPolicy

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, missing_policy: MissingPolicy | UndefinedType = Undefined
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            missing_policy: missing_policy

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class NeighborsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "activate": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                    _custom_data: dict[str, Any]
                    ip_address: str
                    activate: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        ip_address: str | UndefinedType = Undefined,
                        activate: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        NeighborsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            ip_address: ip_address
                            activate: activate

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Neighbors(AvdCollection[str, NeighborsItem]):
                    _primary_key: ClassVar[str] = "ip_address"

                Neighbors._item_type = NeighborsItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "bgp": {"type": Bgp}, "neighbors": {"type": Neighbors}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bgp: Bgp
                neighbors: Neighbors

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                    neighbors: Neighbors | UndefinedType = Undefined,
                ) -> None:
                    """
                    AddressFamilyFlowSpecIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bgp: bgp
                        neighbors: neighbors

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "bgp": {"type": Bgp},
                "rd": {"type": str},
                "evpn_multicast": {"type": bool},
                "evpn_multicast_address_family": {"type": EvpnMulticastAddressFamily},
                "evpn_multicast_gateway_dr_election": {"type": EvpnMulticastGatewayDrElection},
                "default_route_exports": {"type": DefaultRouteExports},
                "route_targets": {"type": RouteTargets},
                "router_id": {"type": str},
                "timers": {"type": str},
                "networks": {"type": Networks},
                "updates": {"type": Updates},
                "listen_ranges": {"type": list, "items": ListenRangesItem},
                "neighbors": {"type": Neighbors},
                "neighbor_interfaces": {"type": NeighborInterfaces},
                "redistribute": {"type": Redistribute},
                "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
                "aggregate_addresses": {"type": AggregateAddresses},
                "address_family_ipv4": {"type": AddressFamilyIpv4},
                "address_family_ipv6": {"type": AddressFamilyIpv6},
                "address_family_ipv4_multicast": {"type": AddressFamilyIpv4Multicast},
                "address_family_ipv6_multicast": {"type": AddressFamilyIpv6Multicast},
                "address_family_flow_spec_ipv4": {"type": AddressFamilyFlowSpecIpv4},
                "address_family_flow_spec_ipv6": {"type": AddressFamilyFlowSpecIpv6},
                "eos_cli": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            bgp: Bgp
            rd: str | None
            """Route distinguisher."""
            evpn_multicast: bool | None
            evpn_multicast_address_family: EvpnMulticastAddressFamily
            """Enable per-AF EVPN multicast settings."""
            evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection
            default_route_exports: DefaultRouteExports
            """Enable default-originate per VRF/address-family."""
            route_targets: RouteTargets
            router_id: str | None
            """in IP address format A.B.C.D."""
            timers: str | None
            """BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>"."""
            networks: Networks
            updates: Updates
            listen_ranges: list[ListenRangesItem]
            """
            Improved "listen_ranges" data model to support multiple listen ranges and additional filter
            capabilities.
            """
            neighbors: Neighbors
            neighbor_interfaces: NeighborInterfaces
            redistribute: Redistribute
            """Redistribute routes in to BGP."""
            redistribute_routes: list[RedistributeRoutesItem]
            aggregate_addresses: AggregateAddresses
            address_family_ipv4: AddressFamilyIpv4
            address_family_ipv6: AddressFamilyIpv6
            address_family_ipv4_multicast: AddressFamilyIpv4Multicast
            address_family_ipv6_multicast: AddressFamilyIpv6Multicast
            address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4
            address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6
            eos_cli: str | None
            """
            Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                bgp: Bgp | UndefinedType = Undefined,
                rd: str | None | UndefinedType = Undefined,
                evpn_multicast: bool | None | UndefinedType = Undefined,
                evpn_multicast_address_family: EvpnMulticastAddressFamily | UndefinedType = Undefined,
                evpn_multicast_gateway_dr_election: EvpnMulticastGatewayDrElection | UndefinedType = Undefined,
                default_route_exports: DefaultRouteExports | UndefinedType = Undefined,
                route_targets: RouteTargets | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                timers: str | None | UndefinedType = Undefined,
                networks: Networks | UndefinedType = Undefined,
                updates: Updates | UndefinedType = Undefined,
                listen_ranges: list[ListenRangesItem] | UndefinedType = Undefined,
                neighbors: Neighbors | UndefinedType = Undefined,
                neighbor_interfaces: NeighborInterfaces | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
                aggregate_addresses: AggregateAddresses | UndefinedType = Undefined,
                address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
                address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
                address_family_ipv4_multicast: AddressFamilyIpv4Multicast | UndefinedType = Undefined,
                address_family_ipv6_multicast: AddressFamilyIpv6Multicast | UndefinedType = Undefined,
                address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | UndefinedType = Undefined,
                address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    bgp: bgp
                    rd: Route distinguisher.
                    evpn_multicast: evpn_multicast
                    evpn_multicast_address_family: Enable per-AF EVPN multicast settings.
                    evpn_multicast_gateway_dr_election: evpn_multicast_gateway_dr_election
                    default_route_exports: Enable default-originate per VRF/address-family.
                    route_targets: route_targets
                    router_id: in IP address format A.B.C.D.
                    timers: BGP Keepalive and Hold Timer values in seconds as string "<0-3600> <0-3600>".
                    networks: networks
                    updates: updates
                    listen_ranges:
                       Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                       capabilities.
                    neighbors: neighbors
                    neighbor_interfaces: neighbor_interfaces
                    redistribute: Redistribute routes in to BGP.
                    redistribute_routes: redistribute_routes
                    aggregate_addresses: aggregate_addresses
                    address_family_ipv4: address_family_ipv4
                    address_family_ipv6: address_family_ipv6
                    address_family_ipv4_multicast: address_family_ipv4_multicast
                    address_family_ipv6_multicast: address_family_ipv6_multicast
                    address_family_flow_spec_ipv4: address_family_flow_spec_ipv4
                    address_family_flow_spec_ipv6: address_family_flow_spec_ipv6
                    eos_cli:
                       Multiline EOS CLI rendered directly on the Router BGP, VRF definition in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class SessionTrackersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "recovery_delay": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Name of session tracker."""
            recovery_delay: int | None
            """Recovery delay in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                recovery_delay: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                SessionTrackersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Name of session tracker.
                    recovery_delay: Recovery delay in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SessionTrackers(AvdCollection[str, SessionTrackersItem]):
            _primary_key: ClassVar[str] = "name"

        SessionTrackers._item_type = SessionTrackersItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "field_as": {"type": str, "key": "as"},
            "as_notation": {"type": str},
            "router_id": {"type": str},
            "distance": {"type": Distance},
            "graceful_restart": {"type": GracefulRestart},
            "graceful_restart_helper": {"type": GracefulRestartHelper},
            "maximum_paths": {"type": MaximumPaths},
            "updates": {"type": Updates},
            "bgp_cluster_id": {"type": str},
            "bgp_defaults": {"type": list, "items": str},
            "bgp": {"type": Bgp},
            "listen_ranges": {"type": list, "items": ListenRangesItem},
            "peer_groups": {"type": PeerGroups},
            "neighbors": {"type": Neighbors},
            "neighbor_interfaces": {"type": NeighborInterfaces},
            "aggregate_addresses": {"type": AggregateAddresses},
            "redistribute": {"type": Redistribute},
            "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
            "vlan_aware_bundles": {"type": VlanAwareBundles},
            "vlans": {"type": Vlans},
            "vpws": {"type": Vpws},
            "address_family_evpn": {"type": AddressFamilyEvpn},
            "address_family_rtc": {"type": AddressFamilyRtc},
            "address_family_ipv4": {"type": AddressFamilyIpv4},
            "address_family_ipv4_labeled_unicast": {"type": AddressFamilyIpv4LabeledUnicast},
            "address_family_ipv4_multicast": {"type": AddressFamilyIpv4Multicast},
            "address_family_ipv4_sr_te": {"type": AddressFamilyIpv4SrTe},
            "address_family_ipv6": {"type": AddressFamilyIpv6},
            "address_family_ipv6_multicast": {"type": AddressFamilyIpv6Multicast},
            "address_family_ipv6_sr_te": {"type": AddressFamilyIpv6SrTe},
            "address_family_link_state": {"type": AddressFamilyLinkState},
            "address_family_flow_spec_ipv4": {"type": AddressFamilyFlowSpecIpv4},
            "address_family_flow_spec_ipv6": {"type": AddressFamilyFlowSpecIpv6},
            "address_family_path_selection": {"type": AddressFamilyPathSelection},
            "address_family_vpn_ipv4": {"type": AddressFamilyVpnIpv4},
            "address_family_vpn_ipv6": {"type": AddressFamilyVpnIpv6},
            "vrfs": {"type": Vrfs},
            "session_trackers": {"type": SessionTrackers},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        field_as: str | None
        """
        BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
        For asdot notation in
        YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
        number.
        """
        as_notation: str | None
        """
        BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
        flag indicates which mode is preferred - asplain is the default.
        """
        router_id: str | None
        """In IP address format A.B.C.D."""
        distance: Distance
        graceful_restart: GracefulRestart
        graceful_restart_helper: GracefulRestartHelper
        maximum_paths: MaximumPaths
        updates: Updates
        bgp_cluster_id: str | None
        """IP Address A.B.C.D."""
        bgp_defaults: list[str]
        """BGP command as string."""
        bgp: Bgp
        listen_ranges: list[ListenRangesItem]
        """
        Improved "listen_ranges" data model to support multiple listen ranges and additional filter
        capabilities.
        """
        peer_groups: PeerGroups
        neighbors: Neighbors
        neighbor_interfaces: NeighborInterfaces
        aggregate_addresses: AggregateAddresses
        redistribute: Redistribute
        """Redistribute routes in to BGP."""
        redistribute_routes: list[RedistributeRoutesItem]
        vlan_aware_bundles: VlanAwareBundles
        vlans: Vlans
        vpws: Vpws
        address_family_evpn: AddressFamilyEvpn
        address_family_rtc: AddressFamilyRtc
        address_family_ipv4: AddressFamilyIpv4
        address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast
        address_family_ipv4_multicast: AddressFamilyIpv4Multicast
        address_family_ipv4_sr_te: AddressFamilyIpv4SrTe
        address_family_ipv6: AddressFamilyIpv6
        address_family_ipv6_multicast: AddressFamilyIpv6Multicast
        address_family_ipv6_sr_te: AddressFamilyIpv6SrTe
        address_family_link_state: AddressFamilyLinkState
        address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4
        address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6
        address_family_path_selection: AddressFamilyPathSelection
        address_family_vpn_ipv4: AddressFamilyVpnIpv4
        address_family_vpn_ipv6: AddressFamilyVpnIpv6
        vrfs: Vrfs
        session_trackers: SessionTrackers
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            field_as: str | None | UndefinedType = Undefined,
            as_notation: str | None | UndefinedType = Undefined,
            router_id: str | None | UndefinedType = Undefined,
            distance: Distance | UndefinedType = Undefined,
            graceful_restart: GracefulRestart | UndefinedType = Undefined,
            graceful_restart_helper: GracefulRestartHelper | UndefinedType = Undefined,
            maximum_paths: MaximumPaths | UndefinedType = Undefined,
            updates: Updates | UndefinedType = Undefined,
            bgp_cluster_id: str | None | UndefinedType = Undefined,
            bgp_defaults: list[str] | UndefinedType = Undefined,
            bgp: Bgp | UndefinedType = Undefined,
            listen_ranges: list[ListenRangesItem] | UndefinedType = Undefined,
            peer_groups: PeerGroups | UndefinedType = Undefined,
            neighbors: Neighbors | UndefinedType = Undefined,
            neighbor_interfaces: NeighborInterfaces | UndefinedType = Undefined,
            aggregate_addresses: AggregateAddresses | UndefinedType = Undefined,
            redistribute: Redistribute | UndefinedType = Undefined,
            redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
            vlan_aware_bundles: VlanAwareBundles | UndefinedType = Undefined,
            vlans: Vlans | UndefinedType = Undefined,
            vpws: Vpws | UndefinedType = Undefined,
            address_family_evpn: AddressFamilyEvpn | UndefinedType = Undefined,
            address_family_rtc: AddressFamilyRtc | UndefinedType = Undefined,
            address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
            address_family_ipv4_labeled_unicast: AddressFamilyIpv4LabeledUnicast | UndefinedType = Undefined,
            address_family_ipv4_multicast: AddressFamilyIpv4Multicast | UndefinedType = Undefined,
            address_family_ipv4_sr_te: AddressFamilyIpv4SrTe | UndefinedType = Undefined,
            address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
            address_family_ipv6_multicast: AddressFamilyIpv6Multicast | UndefinedType = Undefined,
            address_family_ipv6_sr_te: AddressFamilyIpv6SrTe | UndefinedType = Undefined,
            address_family_link_state: AddressFamilyLinkState | UndefinedType = Undefined,
            address_family_flow_spec_ipv4: AddressFamilyFlowSpecIpv4 | UndefinedType = Undefined,
            address_family_flow_spec_ipv6: AddressFamilyFlowSpecIpv6 | UndefinedType = Undefined,
            address_family_path_selection: AddressFamilyPathSelection | UndefinedType = Undefined,
            address_family_vpn_ipv4: AddressFamilyVpnIpv4 | UndefinedType = Undefined,
            address_family_vpn_ipv6: AddressFamilyVpnIpv6 | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            session_trackers: SessionTrackers | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            RouterBgp.

            Args:
            -----
                _custom_data: _custom_data
                field_as:
                   BGP AS <1-4294967295> or AS number in asdot notation "<1-65535>.<0-65535>".
                   For asdot notation in
                   YAML inputs, the value must be put in quotes, to prevent it from being interpreted as a float
                   number.
                as_notation:
                   BGP AS can be deplayed in the asplain <1-4294967295> or asdot notation "<1-65535>.<0-65535>". This
                   flag indicates which mode is preferred - asplain is the default.
                router_id: In IP address format A.B.C.D.
                distance: distance
                graceful_restart: graceful_restart
                graceful_restart_helper: graceful_restart_helper
                maximum_paths: maximum_paths
                updates: updates
                bgp_cluster_id: IP Address A.B.C.D.
                bgp_defaults: BGP command as string.
                bgp: bgp
                listen_ranges:
                   Improved "listen_ranges" data model to support multiple listen ranges and additional filter
                   capabilities.
                peer_groups: peer_groups
                neighbors: neighbors
                neighbor_interfaces: neighbor_interfaces
                aggregate_addresses: aggregate_addresses
                redistribute: Redistribute routes in to BGP.
                redistribute_routes: redistribute_routes
                vlan_aware_bundles: vlan_aware_bundles
                vlans: vlans
                vpws: vpws
                address_family_evpn: address_family_evpn
                address_family_rtc: address_family_rtc
                address_family_ipv4: address_family_ipv4
                address_family_ipv4_labeled_unicast: address_family_ipv4_labeled_unicast
                address_family_ipv4_multicast: address_family_ipv4_multicast
                address_family_ipv4_sr_te: address_family_ipv4_sr_te
                address_family_ipv6: address_family_ipv6
                address_family_ipv6_multicast: address_family_ipv6_multicast
                address_family_ipv6_sr_te: address_family_ipv6_sr_te
                address_family_link_state: address_family_link_state
                address_family_flow_spec_ipv4: address_family_flow_spec_ipv4
                address_family_flow_spec_ipv6: address_family_flow_spec_ipv6
                address_family_path_selection: address_family_path_selection
                address_family_vpn_ipv4: address_family_vpn_ipv4
                address_family_vpn_ipv6: address_family_vpn_ipv6
                vrfs: vrfs
                session_trackers: session_trackers
                eos_cli: Multiline EOS CLI rendered directly on the Router BGP in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterGeneral(AvdModel):
        class RouterId(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": str}, "ipv6": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: str | None
            """IPv4 Address."""
            ipv6: str | None
            """IPv6 Address."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: str | None | UndefinedType = Undefined,
                ipv6: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RouterId.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: IPv4 Address.
                    ipv6: IPv6 Address.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            class LeakRoutesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source_vrf": {"type": str}, "subscribe_policy": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                source_vrf: str | None
                subscribe_policy: str | None
                """Route-Map Policy."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_vrf: str | None | UndefinedType = Undefined,
                    subscribe_policy: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LeakRoutesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_vrf: source_vrf
                        subscribe_policy: Route-Map Policy.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Routes(AvdModel):
                class DynamicPrefixListsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    name: str | None
                    """Dynamic Prefix List Name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                        """
                        DynamicPrefixListsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Dynamic Prefix List Name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic_prefix_lists": {"type": list, "items": DynamicPrefixListsItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic_prefix_lists: list[DynamicPrefixListsItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic_prefix_lists: list[DynamicPrefixListsItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Routes.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic_prefix_lists: dynamic_prefix_lists

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "leak_routes": {"type": list, "items": LeakRoutesItem},
                "routes": {"type": Routes},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Destination-VRF."""
            leak_routes: list[LeakRoutesItem]
            routes: Routes

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                leak_routes: list[LeakRoutesItem] | UndefinedType = Undefined,
                routes: Routes | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Destination-VRF.
                    leak_routes: leak_routes
                    routes: routes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class ControlFunctions(AvdModel):
            class CodeUnitsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "content": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name", "content")
                _custom_data: dict[str, Any]
                name: str
                """Name of the code unit."""
                content: str
                """
                Content of route control function.
                e.g.
                function ACCEPT_ALL() {
                  return true;
                  }
                EOF
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    content: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    CodeUnitsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Name of the code unit.
                        content:
                           Content of route control function.
                           e.g.
                           function ACCEPT_ALL() {
                             return true;
                             }
                           EOF

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class CodeUnits(AvdCollection[str, CodeUnitsItem]):
                _primary_key: ClassVar[str] = "name"

            CodeUnits._item_type = CodeUnitsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "code_units": {"type": CodeUnits}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            code_units: CodeUnits

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, code_units: CodeUnits | UndefinedType = Undefined) -> None:
                """
                ControlFunctions.

                Args:
                -----
                    _custom_data: _custom_data
                    code_units: code_units

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "router_id": {"type": RouterId},
            "nexthop_fast_failover": {"type": bool, "default": False},
            "vrfs": {"type": Vrfs},
            "control_functions": {"type": ControlFunctions},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        router_id: RouterId
        nexthop_fast_failover: bool | None
        vrfs: Vrfs
        control_functions: ControlFunctions
        """
        Routing control functions (RCF) used to filter and update routes from a peer or during
        redistributions.
        Warning:
        This configuration cannot be pushed with `eos_config_deploy_eapi`, because
        of limitations in `arista.eos` and `ansible.netcommon` plugins.
        The configuration can be pushed via
        CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            router_id: RouterId | UndefinedType = Undefined,
            nexthop_fast_failover: bool | None | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            control_functions: ControlFunctions | UndefinedType = Undefined,
        ) -> None:
            """
            RouterGeneral.

            Args:
            -----
                _custom_data: _custom_data
                router_id: router_id
                nexthop_fast_failover: nexthop_fast_failover
                vrfs: vrfs
                control_functions:
                   Routing control functions (RCF) used to filter and update routes from a peer or during
                   redistributions.

            Warning:
                   This configuration cannot be pushed with `eos_config_deploy_eapi`, because
                   of limitations in `arista.eos` and `ansible.netcommon` plugins.
                   The configuration can be pushed via
                   CloudVision with `eos_config_deploy_cvp` or `cv_deploy`.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterIgmp(AvdModel):
        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "host_proxy_match_mroute": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            host_proxy_match_mroute: str | None
            """
            Specify conditions for sending IGMP joins for host-proxy.
            'iif' will enable igmp host-proxy to work
            in iif aware.
            'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                host_proxy_match_mroute: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    host_proxy_match_mroute:
                       Specify conditions for sending IGMP joins for host-proxy.
                       'iif' will enable igmp host-proxy to work
                       in iif aware.
                       'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "host_proxy_match_mroute": {"type": str},
            "ssm_aware": {"type": bool},
            "vrfs": {"type": Vrfs},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        host_proxy_match_mroute: str | None
        """
        Specify conditions for sending IGMP joins for host-proxy.
        'iif' will enable igmp host-proxy to work
        in iif aware.
        'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
        """
        ssm_aware: bool | None
        vrfs: Vrfs
        """
        Configure IGMP in a VRF.
        VRF 'default' is not supported in EOS, please see keys directly under
        'router_igmp'.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            host_proxy_match_mroute: str | None | UndefinedType = Undefined,
            ssm_aware: bool | None | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            RouterIgmp.

            Args:
            -----
                _custom_data: _custom_data
                host_proxy_match_mroute:
                   Specify conditions for sending IGMP joins for host-proxy.
                   'iif' will enable igmp host-proxy to work
                   in iif aware.
                   'all' will enable igmp host-proxy to work in iif unaware mode (EOS default).
                ssm_aware: ssm_aware
                vrfs:
                   Configure IGMP in a VRF.
                   VRF 'default' is not supported in EOS, please see keys directly under
                   'router_igmp'.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterInternetExit(AvdModel):
        class PoliciesItem(AvdModel):
            class ExitGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                    """
                    ExitGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "exit_groups": {"type": list, "items": ExitGroupsItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            exit_groups: list[ExitGroupsItem]
            """
            The exit groups that are configured under a policy are strictly ordered, meaning an exit group
            appearing first has more priority than the exit group that follows it.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                exit_groups: list[ExitGroupsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    exit_groups:
                       The exit groups that are configured under a policy are strictly ordered, meaning an exit group
                       appearing first has more priority than the exit group that follows it.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdCollection[str, PoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class ExitGroupsItem(AvdModel):
            class LocalConnectionsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                    """
                    LocalConnectionsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "fib_default": {"type": bool},
                "local_connections": {"type": list, "items": LocalConnectionsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            fib_default: bool | None
            """
            Fib default exit indicates that the flows that select this exit will follow the default route
            available in the VRF of the flow.
            """
            local_connections: list[LocalConnectionsItem]
            """
            Local connections refer to connections configured under the `router_service_insertion`.
            The service-
            insertion module reports the health of the connection and the exit will qualify for use only when it
            is healthy.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                fib_default: bool | None | UndefinedType = Undefined,
                local_connections: list[LocalConnectionsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                ExitGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    fib_default:
                       Fib default exit indicates that the flows that select this exit will follow the default route
                       available in the VRF of the flow.
                    local_connections:
                       Local connections refer to connections configured under the `router_service_insertion`.
                       The service-
                       insertion module reports the health of the connection and the exit will qualify for use only when it
                       is healthy.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ExitGroups(AvdCollection[str, ExitGroupsItem]):
            _primary_key: ClassVar[str] = "name"

        ExitGroups._item_type = ExitGroupsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "policies": {"type": Policies}, "exit_groups": {"type": ExitGroups}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        policies: Policies
        """Internet-exit policy represent a policy which can be attached to a virtual topology profile."""
        exit_groups: ExitGroups
        """
        Exit groups represent a group of exit options (connections).
        Traffic flows are load balanced in a
        round robin fashion across all the members (exits) of the exit-group.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
            exit_groups: ExitGroups | UndefinedType = Undefined,
        ) -> None:
            """
            RouterInternetExit.

            Args:
            -----
                _custom_data: _custom_data
                policies: Internet-exit policy represent a policy which can be attached to a virtual topology profile.
                exit_groups:
                   Exit groups represent a group of exit options (connections).
                   Traffic flows are load balanced in a
                   round robin fashion across all the members (exits) of the exit-group.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterIsis(AvdModel):
        class Timers(AvdModel):
            class LocalConvergence(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "protected_prefixes": {"type": bool}, "delay": {"type": int, "default": 10000}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                protected_prefixes: bool | None
                delay: int | None
                """Delay in milliseconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    protected_prefixes: bool | None | UndefinedType = Undefined,
                    delay: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    LocalConvergence.

                    Args:
                    -----
                        _custom_data: _custom_data
                        protected_prefixes: protected_prefixes
                        delay: Delay in milliseconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "local_convergence": {"type": LocalConvergence}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            local_convergence: LocalConvergence

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, local_convergence: LocalConvergence | UndefinedType = Undefined
            ) -> None:
                """
                Timers.

                Args:
                -----
                    _custom_data: _custom_data
                    local_convergence: local_convergence

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SetOverloadBit(AvdModel):
            class OnStartup(AvdModel):
                class WaitForBgp(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "timeout": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    timeout: int | None
                    """Number of seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        timeout: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        WaitForBgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            timeout: Number of seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "delay": {"type": int}, "wait_for_bgp": {"type": WaitForBgp}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                delay: int | None
                """Number of seconds."""
                wait_for_bgp: WaitForBgp

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    delay: int | None | UndefinedType = Undefined,
                    wait_for_bgp: WaitForBgp | UndefinedType = Undefined,
                ) -> None:
                    """
                    OnStartup.

                    Args:
                    -----
                        _custom_data: _custom_data
                        delay: Number of seconds.
                        wait_for_bgp: wait_for_bgp

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "on_startup": {"type": OnStartup}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            on_startup: OnStartup

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                on_startup: OnStartup | UndefinedType = Undefined,
            ) -> None:
                """
                SetOverloadBit.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    on_startup: on_startup

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Authentication(AvdModel):
            class Both(AvdModel):
                class KeyIdsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "algorithm", "key_type", "key")
                    _custom_data: dict[str, Any]
                    id: int
                    """Configure authentication key-id."""
                    algorithm: str
                    key_type: str
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                        key_type: str | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        rfc_5310: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class KeyIds(AvdCollection[int, KeyIdsItem]):
                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_id": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "key_id")
                    _custom_data: dict[str, Any]
                    key_id: int

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, key_id: int | UndefinedType = Undefined) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "algorithm": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "algorithm")
                    _custom_data: dict[str, Any]
                    profile: str
                    algorithm: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        profile: str | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_type: str | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                mode: str | None
                """Authentication mode."""
                sha: Sha
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_type: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_ids: KeyIds | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    sha: Sha | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    rx_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Both.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level1(AvdModel):
                class KeyIdsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "algorithm", "key_type", "key")
                    _custom_data: dict[str, Any]
                    id: int
                    """Configure authentication key-id."""
                    algorithm: str
                    key_type: str
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                        key_type: str | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        rfc_5310: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class KeyIds(AvdCollection[int, KeyIdsItem]):
                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_id": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "key_id")
                    _custom_data: dict[str, Any]
                    key_id: int

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, key_id: int | UndefinedType = Undefined) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "algorithm": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "algorithm")
                    _custom_data: dict[str, Any]
                    profile: str
                    algorithm: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        profile: str | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_type: str | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                mode: str | None
                """Authentication mode."""
                sha: Sha
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_type: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_ids: KeyIds | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    sha: Sha | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    rx_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Level1.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level2(AvdModel):
                class KeyIdsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "algorithm", "key_type", "key")
                    _custom_data: dict[str, Any]
                    id: int
                    """Configure authentication key-id."""
                    algorithm: str
                    key_type: str
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                        key_type: str | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        rfc_5310: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class KeyIds(AvdCollection[int, KeyIdsItem]):
                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_id": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "key_id")
                    _custom_data: dict[str, Any]
                    key_id: int

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, key_id: int | UndefinedType = Undefined) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "algorithm": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "algorithm")
                    _custom_data: dict[str, Any]
                    profile: str
                    algorithm: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        profile: str | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_type: str | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                mode: str | None
                """Authentication mode."""
                sha: Sha
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_type: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_ids: KeyIds | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    sha: Sha | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    rx_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Level2.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.
            """
            level_1: Level1
            """Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings."""
            level_2: Level2
            """Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                both: Both | UndefinedType = Undefined,
                level_1: Level1 | UndefinedType = Undefined,
                level_2: Level2 | UndefinedType = Undefined,
            ) -> None:
                """
                Authentication.

                Args:
                -----
                    _custom_data: _custom_data
                    both:
                       Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                       'level_2' settings.
                    level_1: Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                    level_2: Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Advertise(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "passive_only": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            passive_only: bool | None

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, passive_only: bool | None | UndefinedType = Undefined) -> None:
                """
                Advertise.

                Args:
                -----
                    _custom_data: _custom_data
                    passive_only: passive_only

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RedistributeRoutesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "source_protocol": {"type": str},
                "route_map": {"type": str},
                "include_leaked": {"type": bool},
                "ospf_route_type": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "source_protocol")
            _custom_data: dict[str, Any]
            source_protocol: str
            route_map: str | None
            """Route-map name."""
            include_leaked: bool | None
            ospf_route_type: str | None
            """ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                source_protocol: str | UndefinedType = Undefined,
                route_map: str | None | UndefinedType = Undefined,
                include_leaked: bool | None | UndefinedType = Undefined,
                ospf_route_type: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RedistributeRoutesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source_protocol: source_protocol
                    route_map: Route-map name.
                    include_leaked: include_leaked
                    ospf_route_type: ospf_route_type is required with source_protocols 'ospf' and 'ospfv3'.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv4(AvdModel):
            class FastRerouteTiLfa(AvdModel):
                class Srlg(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "strict": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enable: bool | None
                    strict: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enable: bool | None | UndefinedType = Undefined,
                        strict: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Srlg.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enable: enable
                            strict: strict

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "level": {"type": str}, "srlg": {"type": Srlg}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                level: str | None
                srlg: Srlg
                """Shared Risk Link Group."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    srlg: Srlg | UndefinedType = Undefined,
                ) -> None:
                    """
                    FastRerouteTiLfa.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        level: level
                        srlg: Shared Risk Link Group.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelSourceLabeledUnicast(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "rcf": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                rcf: str | None
                """Route Control Function."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    rcf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TunnelSourceLabeledUnicast.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        rcf: Route Control Function.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "maximum_paths": {"type": int},
                "bfd_all_interfaces": {"type": bool},
                "fast_reroute_ti_lfa": {"type": FastRerouteTiLfa},
                "tunnel_source_labeled_unicast": {"type": TunnelSourceLabeledUnicast},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            maximum_paths: int | None
            bfd_all_interfaces: bool | None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa
            tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                maximum_paths: int | None | UndefinedType = Undefined,
                bfd_all_interfaces: bool | None | UndefinedType = Undefined,
                fast_reroute_ti_lfa: FastRerouteTiLfa | UndefinedType = Undefined,
                tunnel_source_labeled_unicast: TunnelSourceLabeledUnicast | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv4.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    maximum_paths: maximum_paths
                    bfd_all_interfaces: Enable BFD on all interfaces.
                    fast_reroute_ti_lfa: fast_reroute_ti_lfa
                    tunnel_source_labeled_unicast: tunnel_source_labeled_unicast

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class AddressFamilyIpv6(AvdModel):
            class FastRerouteTiLfa(AvdModel):
                class Srlg(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable": {"type": bool}, "strict": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enable: bool | None
                    strict: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enable: bool | None | UndefinedType = Undefined,
                        strict: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Srlg.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enable: enable
                            strict: strict

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "level": {"type": str}, "srlg": {"type": Srlg}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                mode: str | None
                level: str | None
                """Optional, default is to protect all levels."""
                srlg: Srlg
                """Shared Risk Link Group."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    level: str | None | UndefinedType = Undefined,
                    srlg: Srlg | UndefinedType = Undefined,
                ) -> None:
                    """
                    FastRerouteTiLfa.

                    Args:
                    -----
                        _custom_data: _custom_data
                        mode: mode
                        level: Optional, default is to protect all levels.
                        srlg: Shared Risk Link Group.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "maximum_paths": {"type": int},
                "bfd_all_interfaces": {"type": bool},
                "fast_reroute_ti_lfa": {"type": FastRerouteTiLfa},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            maximum_paths: int | None
            bfd_all_interfaces: bool | None
            """Enable BFD on all interfaces."""
            fast_reroute_ti_lfa: FastRerouteTiLfa

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                maximum_paths: int | None | UndefinedType = Undefined,
                bfd_all_interfaces: bool | None | UndefinedType = Undefined,
                fast_reroute_ti_lfa: FastRerouteTiLfa | UndefinedType = Undefined,
            ) -> None:
                """
                AddressFamilyIpv6.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    maximum_paths: maximum_paths
                    bfd_all_interfaces: Enable BFD on all interfaces.
                    fast_reroute_ti_lfa: fast_reroute_ti_lfa

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SegmentRoutingMpls(AvdModel):
            class PrefixSegmentsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix": {"type": str}, "index": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                prefix: str | None
                index: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | None | UndefinedType = Undefined,
                    index: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PrefixSegmentsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: prefix
                        index: index

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "router_id": {"type": str},
                "prefix_segments": {"type": list, "items": PrefixSegmentsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            router_id: str | None
            prefix_segments: list[PrefixSegmentsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                prefix_segments: list[PrefixSegmentsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                SegmentRoutingMpls.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    router_id: router_id
                    prefix_segments: prefix_segments

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SpfInterval(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "interval": {"type": int},
                "interval_unit": {"type": str},
                "wait_interval": {"type": int},
                "hold_interval": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            interval: int | None
            """
            Maximum interval between two SPFs in seconds or milliseconds.
            Range in seconds: <1-300>
            Range in
            milliseconds: <1-300000>
            """
            interval_unit: str | None
            """If interval unit is not defined EOS takes `seconds` by default."""
            wait_interval: int | None
            """Initial wait interval for SPF in milliseconds."""
            hold_interval: int | None
            """Hold interval between the first and second SPF runs in milliseconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                interval_unit: str | None | UndefinedType = Undefined,
                wait_interval: int | None | UndefinedType = Undefined,
                hold_interval: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                SpfInterval.

                Args:
                -----
                    _custom_data: _custom_data
                    interval:
                       Maximum interval between two SPFs in seconds or milliseconds.
                       Range in seconds: <1-300>
                       Range in
                       milliseconds: <1-300000>
                    interval_unit: If interval unit is not defined EOS takes `seconds` by default.
                    wait_interval: Initial wait interval for SPF in milliseconds.
                    hold_interval: Hold interval between the first and second SPF runs in milliseconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GracefulRestart(AvdModel):
            class T2(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "level_1_wait_time": {"type": int}, "level_2_wait_time": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                level_1_wait_time: int | None
                """Level-1 LSP database sync wait time in seconds."""
                level_2_wait_time: int | None
                """Level-2 LSP database sync wait time in seconds."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    level_1_wait_time: int | None | UndefinedType = Undefined,
                    level_2_wait_time: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    T2.

                    Args:
                    -----
                        _custom_data: _custom_data
                        level_1_wait_time: Level-1 LSP database sync wait time in seconds.
                        level_2_wait_time: Level-2 LSP database sync wait time in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "restart_hold_time": {"type": int}, "t2": {"type": T2}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            restart_hold_time: int | None
            """Number of seconds."""
            t2: T2

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                restart_hold_time: int | None | UndefinedType = Undefined,
                t2: T2 | UndefinedType = Undefined,
            ) -> None:
                """
                GracefulRestart.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    restart_hold_time: Number of seconds.
                    t2: t2

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "instance": {"type": str},
            "net": {"type": str},
            "router_id": {"type": str},
            "is_type": {"type": str},
            "log_adjacency_changes": {"type": bool},
            "mpls_ldp_sync_default": {"type": bool},
            "timers": {"type": Timers},
            "set_overload_bit": {"type": SetOverloadBit},
            "authentication": {"type": Authentication},
            "advertise": {"type": Advertise},
            "redistribute_routes": {"type": list, "items": RedistributeRoutesItem},
            "address_family_ipv4": {"type": AddressFamilyIpv4},
            "address_family_ipv6": {"type": AddressFamilyIpv6},
            "segment_routing_mpls": {"type": SegmentRoutingMpls},
            "spf_interval": {"type": SpfInterval},
            "graceful_restart": {"type": GracefulRestart},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "instance")
        _custom_data: dict[str, Any]
        instance: str
        """ISIS Instance Name."""
        net: str | None
        """CLNS Address like "49.0001.0001.0000.0001.00"."""
        router_id: str | None
        """IPv4 Address."""
        is_type: str | None
        log_adjacency_changes: bool | None
        mpls_ldp_sync_default: bool | None
        timers: Timers
        set_overload_bit: SetOverloadBit
        authentication: Authentication
        advertise: Advertise
        redistribute_routes: list[RedistributeRoutesItem]
        address_family_ipv4: AddressFamilyIpv4
        address_family_ipv6: AddressFamilyIpv6
        segment_routing_mpls: SegmentRoutingMpls
        spf_interval: SpfInterval
        graceful_restart: GracefulRestart
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the router isis in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            instance: str | UndefinedType = Undefined,
            net: str | None | UndefinedType = Undefined,
            router_id: str | None | UndefinedType = Undefined,
            is_type: str | None | UndefinedType = Undefined,
            log_adjacency_changes: bool | None | UndefinedType = Undefined,
            mpls_ldp_sync_default: bool | None | UndefinedType = Undefined,
            timers: Timers | UndefinedType = Undefined,
            set_overload_bit: SetOverloadBit | UndefinedType = Undefined,
            authentication: Authentication | UndefinedType = Undefined,
            advertise: Advertise | UndefinedType = Undefined,
            redistribute_routes: list[RedistributeRoutesItem] | UndefinedType = Undefined,
            address_family_ipv4: AddressFamilyIpv4 | UndefinedType = Undefined,
            address_family_ipv6: AddressFamilyIpv6 | UndefinedType = Undefined,
            segment_routing_mpls: SegmentRoutingMpls | UndefinedType = Undefined,
            spf_interval: SpfInterval | UndefinedType = Undefined,
            graceful_restart: GracefulRestart | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            RouterIsis.

            Args:
            -----
                _custom_data: _custom_data
                instance: ISIS Instance Name.
                net: CLNS Address like "49.0001.0001.0000.0001.00".
                router_id: IPv4 Address.
                is_type: is_type
                log_adjacency_changes: log_adjacency_changes
                mpls_ldp_sync_default: mpls_ldp_sync_default
                timers: timers
                set_overload_bit: set_overload_bit
                authentication: authentication
                advertise: advertise
                redistribute_routes: redistribute_routes
                address_family_ipv4: address_family_ipv4
                address_family_ipv6: address_family_ipv6
                segment_routing_mpls: segment_routing_mpls
                spf_interval: spf_interval
                graceful_restart: graceful_restart
                eos_cli: Multiline EOS CLI rendered directly on the router isis in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterL2Vpn(AvdModel):
        class ArpProxy(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix_list": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            prefix_list: str | None
            """Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list."""

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix_list: str | None | UndefinedType = Undefined) -> None:
                """
                ArpProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix_list: Prefix-list name. ARP Proxying is disabled for IPv4 addresses defined in the prefix-list.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class NdProxy(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "prefix_list": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            prefix_list: str | None
            """
            Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
            list.
            """

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, prefix_list: str | None | UndefinedType = Undefined) -> None:
                """
                NdProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    prefix_list:
                       Prefix-list name. Neighbor Discovery Proxying is disabled for IPv6 addresses defined in the prefix-
                       list.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "arp_learning_bridged": {"type": bool},
            "arp_proxy": {"type": ArpProxy},
            "arp_selective_install": {"type": bool},
            "nd_learning_bridged": {"type": bool},
            "nd_proxy": {"type": NdProxy},
            "nd_rs_flooding_disabled": {"type": bool},
            "virtual_router_nd_ra_flooding_disabled": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        arp_learning_bridged: bool | None
        arp_proxy: ArpProxy
        arp_selective_install: bool | None
        nd_learning_bridged: bool | None
        nd_proxy: NdProxy
        nd_rs_flooding_disabled: bool | None
        virtual_router_nd_ra_flooding_disabled: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            arp_learning_bridged: bool | None | UndefinedType = Undefined,
            arp_proxy: ArpProxy | UndefinedType = Undefined,
            arp_selective_install: bool | None | UndefinedType = Undefined,
            nd_learning_bridged: bool | None | UndefinedType = Undefined,
            nd_proxy: NdProxy | UndefinedType = Undefined,
            nd_rs_flooding_disabled: bool | None | UndefinedType = Undefined,
            virtual_router_nd_ra_flooding_disabled: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            RouterL2Vpn.

            Args:
            -----
                _custom_data: _custom_data
                arp_learning_bridged: arp_learning_bridged
                arp_proxy: arp_proxy
                arp_selective_install: arp_selective_install
                nd_learning_bridged: nd_learning_bridged
                nd_proxy: nd_proxy
                nd_rs_flooding_disabled: nd_rs_flooding_disabled
                virtual_router_nd_ra_flooding_disabled: virtual_router_nd_ra_flooding_disabled

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterMsdp(AvdModel):
        class GroupLimitsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source_prefix": {"type": str}, "limit": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "source_prefix", "limit")
            _custom_data: dict[str, Any]
            source_prefix: str
            """Source address prefix."""
            limit: int
            """Limit for SAs matching the source address prefix."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                source_prefix: str | UndefinedType = Undefined,
                limit: int | UndefinedType = Undefined,
            ) -> None:
                """
                GroupLimitsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    source_prefix: Source address prefix.
                    limit: Limit for SAs matching the source address prefix.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GroupLimits(AvdCollection[str, GroupLimitsItem]):
            _primary_key: ClassVar[str] = "source_prefix"

        GroupLimits._item_type = GroupLimitsItem

        class PeersItem(AvdModel):
            class DefaultPeer(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "prefix_list": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                prefix_list: str | None
                """Prefix list to filter source of SA messages."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    prefix_list: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultPeer.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        prefix_list: Prefix list to filter source of SA messages.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MeshGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Mesh group name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined) -> None:
                    """
                    MeshGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Mesh group name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class MeshGroups(AvdCollection[str, MeshGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            MeshGroups._item_type = MeshGroupsItem

            class Keepalive(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "keepalive_timer": {"type": int}, "hold_timer": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "keepalive_timer", "hold_timer")
                _custom_data: dict[str, Any]
                keepalive_timer: int
                hold_timer: int
                """Must be greater than keepalive timer."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    keepalive_timer: int | UndefinedType = Undefined,
                    hold_timer: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    Keepalive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        keepalive_timer: keepalive_timer
                        hold_timer: Must be greater than keepalive timer.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SaFilter(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "in_list": {"type": str}, "out_list": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                in_list: str | None
                """ACL to filter inbound SA messages."""
                out_list: str | None
                """ACL to filter outbound SA messages."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    in_list: str | None | UndefinedType = Undefined,
                    out_list: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SaFilter.

                    Args:
                    -----
                        _custom_data: _custom_data
                        in_list: ACL to filter inbound SA messages.
                        out_list: ACL to filter outbound SA messages.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv4_address": {"type": str},
                "default_peer": {"type": DefaultPeer},
                "local_interface": {"type": str},
                "description": {"type": str},
                "disabled": {"type": bool},
                "sa_limit": {"type": int},
                "mesh_groups": {"type": MeshGroups},
                "keepalive": {"type": Keepalive},
                "sa_filter": {"type": SaFilter},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipv4_address")
            _custom_data: dict[str, Any]
            ipv4_address: str
            """Peer IP Address."""
            default_peer: DefaultPeer
            local_interface: str | None
            description: str | None
            disabled: bool | None
            """Disable the MSDP peer."""
            sa_limit: int | None
            """Maximum number of SA messages allowed in cache."""
            mesh_groups: MeshGroups
            keepalive: Keepalive
            sa_filter: SaFilter

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4_address: str | UndefinedType = Undefined,
                default_peer: DefaultPeer | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                disabled: bool | None | UndefinedType = Undefined,
                sa_limit: int | None | UndefinedType = Undefined,
                mesh_groups: MeshGroups | UndefinedType = Undefined,
                keepalive: Keepalive | UndefinedType = Undefined,
                sa_filter: SaFilter | UndefinedType = Undefined,
            ) -> None:
                """
                PeersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_address: Peer IP Address.
                    default_peer: default_peer
                    local_interface: local_interface
                    description: description
                    disabled: Disable the MSDP peer.
                    sa_limit: Maximum number of SA messages allowed in cache.
                    mesh_groups: mesh_groups
                    keepalive: keepalive
                    sa_filter: sa_filter

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Peers(AvdCollection[str, PeersItem]):
            _primary_key: ClassVar[str] = "ipv4_address"

        Peers._item_type = PeersItem

        class VrfsItem(AvdModel):
            class GroupLimitsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source_prefix": {"type": str}, "limit": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "source_prefix", "limit")
                _custom_data: dict[str, Any]
                source_prefix: str
                """Source address prefix."""
                limit: int
                """Limit for SAs matching the source address prefix."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_prefix: str | UndefinedType = Undefined,
                    limit: int | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupLimitsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_prefix: Source address prefix.
                        limit: Limit for SAs matching the source address prefix.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class GroupLimits(AvdCollection[str, GroupLimitsItem]):
                _primary_key: ClassVar[str] = "source_prefix"

            GroupLimits._item_type = GroupLimitsItem

            class PeersItem(AvdModel):
                class DefaultPeer(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "prefix_list": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None
                    prefix_list: str | None
                    """Prefix list to filter source of SA messages."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | None | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultPeer.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            prefix_list: Prefix list to filter source of SA messages.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MeshGroupsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """Mesh group name."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined) -> None:
                        """
                        MeshGroupsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: Mesh group name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class MeshGroups(AvdCollection[str, MeshGroupsItem]):
                    _primary_key: ClassVar[str] = "name"

                MeshGroups._item_type = MeshGroupsItem

                class Keepalive(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "keepalive_timer": {"type": int}, "hold_timer": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "keepalive_timer", "hold_timer")
                    _custom_data: dict[str, Any]
                    keepalive_timer: int
                    hold_timer: int
                    """Must be greater than keepalive timer."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        keepalive_timer: int | UndefinedType = Undefined,
                        hold_timer: int | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Keepalive.

                        Args:
                        -----
                            _custom_data: _custom_data
                            keepalive_timer: keepalive_timer
                            hold_timer: Must be greater than keepalive timer.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SaFilter(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "in_list": {"type": str}, "out_list": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    in_list: str | None
                    """ACL to filter inbound SA messages."""
                    out_list: str | None
                    """ACL to filter outbound SA messages."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        in_list: str | None | UndefinedType = Undefined,
                        out_list: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SaFilter.

                        Args:
                        -----
                            _custom_data: _custom_data
                            in_list: ACL to filter inbound SA messages.
                            out_list: ACL to filter outbound SA messages.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "ipv4_address": {"type": str},
                    "default_peer": {"type": DefaultPeer},
                    "local_interface": {"type": str},
                    "description": {"type": str},
                    "disabled": {"type": bool},
                    "sa_limit": {"type": int},
                    "mesh_groups": {"type": MeshGroups},
                    "keepalive": {"type": Keepalive},
                    "sa_filter": {"type": SaFilter},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "ipv4_address")
                _custom_data: dict[str, Any]
                ipv4_address: str
                """Peer IP Address."""
                default_peer: DefaultPeer
                local_interface: str | None
                description: str | None
                disabled: bool | None
                """Disable the MSDP peer."""
                sa_limit: int | None
                """Maximum number of SA messages allowed in cache."""
                mesh_groups: MeshGroups
                keepalive: Keepalive
                sa_filter: SaFilter

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4_address: str | UndefinedType = Undefined,
                    default_peer: DefaultPeer | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    description: str | None | UndefinedType = Undefined,
                    disabled: bool | None | UndefinedType = Undefined,
                    sa_limit: int | None | UndefinedType = Undefined,
                    mesh_groups: MeshGroups | UndefinedType = Undefined,
                    keepalive: Keepalive | UndefinedType = Undefined,
                    sa_filter: SaFilter | UndefinedType = Undefined,
                ) -> None:
                    """
                    PeersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_address: Peer IP Address.
                        default_peer: default_peer
                        local_interface: local_interface
                        description: description
                        disabled: Disable the MSDP peer.
                        sa_limit: Maximum number of SA messages allowed in cache.
                        mesh_groups: mesh_groups
                        keepalive: keepalive
                        sa_filter: sa_filter

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Peers(AvdCollection[str, PeersItem]):
                _primary_key: ClassVar[str] = "ipv4_address"

            Peers._item_type = PeersItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "originator_id_local_interface": {"type": str},
                "rejected_limit": {"type": int},
                "forward_register_packets": {"type": bool},
                "connection_retry_interval": {"type": int},
                "group_limits": {"type": GroupLimits},
                "peers": {"type": Peers},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            originator_id_local_interface: str | None
            """Interface to use for originator ID."""
            rejected_limit: int | None
            """Maximum number of rejected SA messages allowed in cache."""
            forward_register_packets: bool | None
            connection_retry_interval: int | None
            group_limits: GroupLimits
            peers: Peers

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                originator_id_local_interface: str | None | UndefinedType = Undefined,
                rejected_limit: int | None | UndefinedType = Undefined,
                forward_register_packets: bool | None | UndefinedType = Undefined,
                connection_retry_interval: int | None | UndefinedType = Undefined,
                group_limits: GroupLimits | UndefinedType = Undefined,
                peers: Peers | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    originator_id_local_interface: Interface to use for originator ID.
                    rejected_limit: Maximum number of rejected SA messages allowed in cache.
                    forward_register_packets: forward_register_packets
                    connection_retry_interval: connection_retry_interval
                    group_limits: group_limits
                    peers: peers

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "originator_id_local_interface": {"type": str},
            "rejected_limit": {"type": int},
            "forward_register_packets": {"type": bool},
            "connection_retry_interval": {"type": int},
            "group_limits": {"type": GroupLimits},
            "peers": {"type": Peers},
            "vrfs": {"type": Vrfs},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        originator_id_local_interface: str | None
        """Interface to use for originator ID."""
        rejected_limit: int | None
        """Maximum number of rejected SA messages allowed in cache."""
        forward_register_packets: bool | None
        connection_retry_interval: int | None
        group_limits: GroupLimits
        peers: Peers
        vrfs: Vrfs

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            originator_id_local_interface: str | None | UndefinedType = Undefined,
            rejected_limit: int | None | UndefinedType = Undefined,
            forward_register_packets: bool | None | UndefinedType = Undefined,
            connection_retry_interval: int | None | UndefinedType = Undefined,
            group_limits: GroupLimits | UndefinedType = Undefined,
            peers: Peers | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            RouterMsdp.

            Args:
            -----
                _custom_data: _custom_data
                originator_id_local_interface: Interface to use for originator ID.
                rejected_limit: Maximum number of rejected SA messages allowed in cache.
                forward_register_packets: forward_register_packets
                connection_retry_interval: connection_retry_interval
                group_limits: group_limits
                peers: peers
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterMulticast(AvdModel):
        class Ipv4(AvdModel):
            class Counters(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rate_period_decay": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                rate_period_decay: int | None
                """Rate in seconds."""

                def __init__(
                    self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, rate_period_decay: int | None | UndefinedType = Undefined
                ) -> None:
                    """
                    Counters.

                    Args:
                    -----
                        _custom_data: _custom_data
                        rate_period_decay: Rate in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Rpf(AvdModel):
                class RoutesItem(AvdModel):
                    class DestinationsItem(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "nexthop": {"type": str}, "distance": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data", "nexthop")
                        _custom_data: dict[str, Any]
                        nexthop: str
                        """Next-hop IP address or interface name."""
                        distance: int | None
                        """Administrative distance for this route."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            nexthop: str | UndefinedType = Undefined,
                            distance: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            DestinationsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                nexthop: Next-hop IP address or interface name.
                                distance: Administrative distance for this route.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "source_prefix": {"type": str},
                        "destinations": {"type": list, "items": DestinationsItem},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source_prefix", "destinations")
                    _custom_data: dict[str, Any]
                    source_prefix: str
                    """Source address A.B.C.D or Source prefix A.B.C.D/E."""
                    destinations: list[DestinationsItem]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        source_prefix: str | UndefinedType = Undefined,
                        destinations: list[DestinationsItem] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RoutesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source_prefix: Source address A.B.C.D or Source prefix A.B.C.D/E.
                            destinations: destinations

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "routes": {"type": list, "items": RoutesItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                routes: list[RoutesItem]

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, routes: list[RoutesItem] | UndefinedType = Undefined) -> None:
                    """
                    Rpf.

                    Args:
                    -----
                        _custom_data: _custom_data
                        routes: routes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "activity_polling_interval": {"type": int},
                "counters": {"type": Counters},
                "routing": {"type": bool},
                "multipath": {"type": str},
                "software_forwarding": {"type": str},
                "rpf": {"type": Rpf},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            activity_polling_interval: int | None
            """MFIB entry activity polling interval."""
            counters: Counters
            routing: bool | None
            multipath: str | None
            software_forwarding: str | None
            rpf: Rpf

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                activity_polling_interval: int | None | UndefinedType = Undefined,
                counters: Counters | UndefinedType = Undefined,
                routing: bool | None | UndefinedType = Undefined,
                multipath: str | None | UndefinedType = Undefined,
                software_forwarding: str | None | UndefinedType = Undefined,
                rpf: Rpf | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv4.

                Args:
                -----
                    _custom_data: _custom_data
                    activity_polling_interval: MFIB entry activity polling interval.
                    counters: counters
                    routing: routing
                    multipath: multipath
                    software_forwarding: software_forwarding
                    rpf: rpf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "activity_polling_interval": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            activity_polling_interval: int | None
            """MFIB entry activity polling interval."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, activity_polling_interval: int | None | UndefinedType = Undefined
            ) -> None:
                """
                Ipv6.

                Args:
                -----
                    _custom_data: _custom_data
                    activity_polling_interval: MFIB entry activity polling interval.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            class Ipv4(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "routing": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                routing: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, routing: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        routing: routing

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "ipv4": {"type": Ipv4}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            ipv4: Ipv4

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "vrfs": {"type": Vrfs}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        ipv4: Ipv4
        ipv6: Ipv6
        vrfs: Vrfs

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            ipv4: Ipv4 | UndefinedType = Undefined,
            ipv6: Ipv6 | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            RouterMulticast.

            Args:
            -----
                _custom_data: _custom_data
                ipv4: ipv4
                ipv6: ipv6
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterOspf(AvdModel):
        class ProcessIdsItem(AvdModel):
            class Distance(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "external": {"type": int}, "inter_area": {"type": int}, "intra_area": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                external: int | None
                inter_area: int | None
                intra_area: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    external: int | None | UndefinedType = Undefined,
                    inter_area: int | None | UndefinedType = Undefined,
                    intra_area: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Distance.

                    Args:
                    -----
                        _custom_data: _custom_data
                        external: external
                        inter_area: inter_area
                        intra_area: intra_area

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworkPrefixesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_prefix": {"type": str}, "area": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "ipv4_prefix")
                _custom_data: dict[str, Any]
                ipv4_prefix: str
                area: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4_prefix: str | UndefinedType = Undefined,
                    area: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    NetworkPrefixesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4_prefix: ipv4_prefix
                        area: area

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class NetworkPrefixes(AvdCollection[str, NetworkPrefixesItem]):
                _primary_key: ClassVar[str] = "ipv4_prefix"

            NetworkPrefixes._item_type = NetworkPrefixesItem

            class DistributeListIn(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "route_map": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                route_map: str | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, route_map: str | None | UndefinedType = Undefined) -> None:
                    """
                    DistributeListIn.

                    Args:
                    -----
                        _custom_data: _custom_data
                        route_map: route_map

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timers(AvdModel):
                class Lsa(AvdModel):
                    class TxDelay(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "initial": {"type": int}, "min": {"type": int}, "max": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        initial: int | None
                        """Delay to generate first occurrence of LSA in msecs."""
                        min: int | None
                        """Min delay between originating the same LSA in msecs."""
                        max: int | None
                        """1-600000 Maximum delay between originating the same LSA in msec."""

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            initial: int | None | UndefinedType = Undefined,
                            min: int | None | UndefinedType = Undefined,
                            max: int | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            TxDelay.

                            Args:
                            -----
                                _custom_data: _custom_data
                                initial: Delay to generate first occurrence of LSA in msecs.
                                min: Min delay between originating the same LSA in msecs.
                                max: 1-600000 Maximum delay between originating the same LSA in msec.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "rx_min_interval": {"type": int}, "tx_delay": {"type": TxDelay}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    rx_min_interval: int | None
                    """Min interval in msecs between accepting the same LSA."""
                    tx_delay: TxDelay

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        rx_min_interval: int | None | UndefinedType = Undefined,
                        tx_delay: TxDelay | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Lsa.

                        Args:
                        -----
                            _custom_data: _custom_data
                            rx_min_interval: Min interval in msecs between accepting the same LSA.
                            tx_delay: tx_delay

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SpfDelay(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "initial": {"type": int}, "min": {"type": int}, "max": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    initial: int | None
                    """Initial SPF schedule delay in msecs."""
                    min: int | None
                    """Min Hold time between two SPFs in msecs."""
                    max: int | None
                    """Max wait time between two SPFs in msecs."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        initial: int | None | UndefinedType = Undefined,
                        min: int | None | UndefinedType = Undefined,
                        max: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SpfDelay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            initial: Initial SPF schedule delay in msecs.
                            min: Min Hold time between two SPFs in msecs.
                            max: Max wait time between two SPFs in msecs.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "lsa": {"type": Lsa}, "spf_delay": {"type": SpfDelay}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                lsa: Lsa
                spf_delay: SpfDelay

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    lsa: Lsa | UndefinedType = Undefined,
                    spf_delay: SpfDelay | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        lsa: lsa
                        spf_delay: spf_delay

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class DefaultInformationOriginate(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "always": {"type": bool}, "metric": {"type": int}, "metric_type": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                always: bool | None
                metric: int | None
                """Metric for default route."""
                metric_type: int | None
                """OSPF metric type for default route."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    always: bool | None | UndefinedType = Undefined,
                    metric: int | None | UndefinedType = Undefined,
                    metric_type: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultInformationOriginate.

                    Args:
                    -----
                        _custom_data: _custom_data
                        always: always
                        metric: Metric for default route.
                        metric_type: OSPF metric type for default route.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SummaryAddressesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "prefix": {"type": str},
                    "tag": {"type": int},
                    "attribute_map": {"type": str},
                    "not_advertise": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "prefix")
                _custom_data: dict[str, Any]
                prefix: str
                """Summary Prefix Address."""
                tag: int | None
                attribute_map: str | None
                not_advertise: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    prefix: str | UndefinedType = Undefined,
                    tag: int | None | UndefinedType = Undefined,
                    attribute_map: str | None | UndefinedType = Undefined,
                    not_advertise: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SummaryAddressesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        prefix: Summary Prefix Address.
                        tag: tag
                        attribute_map: attribute_map
                        not_advertise: not_advertise

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SummaryAddresses(AvdCollection[str, SummaryAddressesItem]):
                _primary_key: ClassVar[str] = "prefix"

            SummaryAddresses._item_type = SummaryAddressesItem

            class Redistribute(AvdModel):
                class Static(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Static.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: Route Map Name.
                            include_leaked: include_leaked

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Connected(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Connected.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: Route Map Name.
                            include_leaked: include_leaked

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Bgp(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "enabled": {"type": bool},
                        "route_map": {"type": str},
                        "include_leaked": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    route_map: str | None
                    """Route Map Name."""
                    include_leaked: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        route_map: str | None | UndefinedType = Undefined,
                        include_leaked: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Bgp.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            route_map: Route Map Name.
                            include_leaked: include_leaked

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "static": {"type": Static}, "connected": {"type": Connected}, "bgp": {"type": Bgp}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                static: Static
                connected: Connected
                bgp: Bgp

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    static: Static | UndefinedType = Undefined,
                    connected: Connected | UndefinedType = Undefined,
                    bgp: Bgp | UndefinedType = Undefined,
                ) -> None:
                    """
                    Redistribute.

                    Args:
                    -----
                        _custom_data: _custom_data
                        static: static
                        connected: connected
                        bgp: bgp

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AreasItem(AvdModel):
                class Filter(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "networks": {"type": list, "items": str}, "prefix_list": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    networks: list[str]
                    prefix_list: str | None
                    """Prefix-List Name."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        networks: list[str] | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Filter.

                        Args:
                        -----
                            _custom_data: _custom_data
                            networks: networks
                            prefix_list: Prefix-List Name.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class DefaultInformationOriginate(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "metric": {"type": int}, "metric_type": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    metric: int | None
                    """Metric for default route."""
                    metric_type: int | None
                    """OSPF metric type for default route."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        metric: int | None | UndefinedType = Undefined,
                        metric_type: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DefaultInformationOriginate.

                        Args:
                        -----
                            _custom_data: _custom_data
                            metric: Metric for default route.
                            metric_type: OSPF metric type for default route.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "id": {"type": str},
                    "filter": {"type": Filter},
                    "type": {"type": str, "default": "normal"},
                    "no_summary": {"type": bool},
                    "nssa_only": {"type": bool},
                    "default_information_originate": {"type": DefaultInformationOriginate},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                _custom_data: dict[str, Any]
                id: str
                filter: Filter
                type: str | None
                no_summary: bool | None
                nssa_only: bool | None
                default_information_originate: DefaultInformationOriginate

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: str | UndefinedType = Undefined,
                    filter: Filter | UndefinedType = Undefined,
                    type: str | None | UndefinedType = Undefined,
                    no_summary: bool | None | UndefinedType = Undefined,
                    nssa_only: bool | None | UndefinedType = Undefined,
                    default_information_originate: DefaultInformationOriginate | UndefinedType = Undefined,
                ) -> None:
                    """
                    AreasItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: id
                        filter: filter
                        type: type
                        no_summary: no_summary
                        nssa_only: nssa_only
                        default_information_originate: default_information_originate

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Areas(AvdCollection[str, AreasItem]):
                _primary_key: ClassVar[str] = "id"

            Areas._item_type = AreasItem

            class MaxMetric(AvdModel):
                class RouterLsa(AvdModel):
                    class ExternalLsa(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "override_metric": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        override_metric: int | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, override_metric: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            ExternalLsa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                override_metric: override_metric

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class SummaryLsa(AvdModel):
                        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "override_metric": {"type": int}}
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        override_metric: int | None

                        def __init__(
                            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, override_metric: int | None | UndefinedType = Undefined
                        ) -> None:
                            """
                            SummaryLsa.

                            Args:
                            -----
                                _custom_data: _custom_data
                                override_metric: override_metric

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "external_lsa": {"type": ExternalLsa},
                        "include_stub": {"type": bool},
                        "on_startup": {"type": str},
                        "summary_lsa": {"type": SummaryLsa},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    external_lsa: ExternalLsa
                    include_stub: bool | None
                    on_startup: str | None
                    """
                    "wait-for-bgp" or Integer 5-86400.
                    Example: "wait-for-bgp" Or "222"
                    """
                    summary_lsa: SummaryLsa

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        external_lsa: ExternalLsa | UndefinedType = Undefined,
                        include_stub: bool | None | UndefinedType = Undefined,
                        on_startup: str | None | UndefinedType = Undefined,
                        summary_lsa: SummaryLsa | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RouterLsa.

                        Args:
                        -----
                            _custom_data: _custom_data
                            external_lsa: external_lsa
                            include_stub: include_stub
                            on_startup:
                               "wait-for-bgp" or Integer 5-86400.
                               Example: "wait-for-bgp" Or "222"
                            summary_lsa: summary_lsa

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "router_lsa": {"type": RouterLsa}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                router_lsa: RouterLsa

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, router_lsa: RouterLsa | UndefinedType = Undefined) -> None:
                    """
                    MaxMetric.

                    Args:
                    -----
                        _custom_data: _custom_data
                        router_lsa: router_lsa

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "vrf": {"type": str},
                "passive_interface_default": {"type": bool},
                "router_id": {"type": str},
                "distance": {"type": Distance},
                "log_adjacency_changes_detail": {"type": bool},
                "network_prefixes": {"type": NetworkPrefixes},
                "bfd_enable": {"type": bool},
                "bfd_adjacency_state_any": {"type": bool},
                "no_passive_interfaces": {"type": list, "items": str},
                "distribute_list_in": {"type": DistributeListIn},
                "max_lsa": {"type": int},
                "timers": {"type": Timers},
                "default_information_originate": {"type": DefaultInformationOriginate},
                "summary_addresses": {"type": SummaryAddresses},
                "redistribute": {"type": Redistribute},
                "auto_cost_reference_bandwidth": {"type": int},
                "areas": {"type": Areas},
                "maximum_paths": {"type": int},
                "max_metric": {"type": MaxMetric},
                "mpls_ldp_sync_default": {"type": bool},
                "eos_cli": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """OSPF Process ID."""
            vrf: str | None
            """VRF Name for OSPF Process."""
            passive_interface_default: bool | None
            router_id: str | None
            """IPv4 Address."""
            distance: Distance
            log_adjacency_changes_detail: bool | None
            network_prefixes: NetworkPrefixes
            bfd_enable: bool | None
            bfd_adjacency_state_any: bool | None
            no_passive_interfaces: list[str]
            distribute_list_in: DistributeListIn
            max_lsa: int | None
            timers: Timers
            default_information_originate: DefaultInformationOriginate
            summary_addresses: SummaryAddresses
            redistribute: Redistribute
            auto_cost_reference_bandwidth: int | None
            """Bandwidth in mbps."""
            areas: Areas
            maximum_paths: int | None
            max_metric: MaxMetric
            mpls_ldp_sync_default: bool | None
            eos_cli: str | None
            """Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                passive_interface_default: bool | None | UndefinedType = Undefined,
                router_id: str | None | UndefinedType = Undefined,
                distance: Distance | UndefinedType = Undefined,
                log_adjacency_changes_detail: bool | None | UndefinedType = Undefined,
                network_prefixes: NetworkPrefixes | UndefinedType = Undefined,
                bfd_enable: bool | None | UndefinedType = Undefined,
                bfd_adjacency_state_any: bool | None | UndefinedType = Undefined,
                no_passive_interfaces: list[str] | UndefinedType = Undefined,
                distribute_list_in: DistributeListIn | UndefinedType = Undefined,
                max_lsa: int | None | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                default_information_originate: DefaultInformationOriginate | UndefinedType = Undefined,
                summary_addresses: SummaryAddresses | UndefinedType = Undefined,
                redistribute: Redistribute | UndefinedType = Undefined,
                auto_cost_reference_bandwidth: int | None | UndefinedType = Undefined,
                areas: Areas | UndefinedType = Undefined,
                maximum_paths: int | None | UndefinedType = Undefined,
                max_metric: MaxMetric | UndefinedType = Undefined,
                mpls_ldp_sync_default: bool | None | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ProcessIdsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: OSPF Process ID.
                    vrf: VRF Name for OSPF Process.
                    passive_interface_default: passive_interface_default
                    router_id: IPv4 Address.
                    distance: distance
                    log_adjacency_changes_detail: log_adjacency_changes_detail
                    network_prefixes: network_prefixes
                    bfd_enable: bfd_enable
                    bfd_adjacency_state_any: bfd_adjacency_state_any
                    no_passive_interfaces: no_passive_interfaces
                    distribute_list_in: distribute_list_in
                    max_lsa: max_lsa
                    timers: timers
                    default_information_originate: default_information_originate
                    summary_addresses: summary_addresses
                    redistribute: redistribute
                    auto_cost_reference_bandwidth: Bandwidth in mbps.
                    areas: areas
                    maximum_paths: maximum_paths
                    max_metric: max_metric
                    mpls_ldp_sync_default: mpls_ldp_sync_default
                    eos_cli: Multiline EOS CLI rendered directly on the Router OSPF process ID in the final EOS configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ProcessIds(AvdCollection[int, ProcessIdsItem]):
            _primary_key: ClassVar[str] = "id"

        ProcessIds._item_type = ProcessIdsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "process_ids": {"type": ProcessIds}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        process_ids: ProcessIds

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, process_ids: ProcessIds | UndefinedType = Undefined) -> None:
            """
            RouterOspf.

            Args:
            -----
                _custom_data: _custom_data
                process_ids: process_ids

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterPathSelection(AvdModel):
        class PathGroupsItem(AvdModel):
            class LocalInterfacesItem(AvdModel):
                class Stun(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "server_profiles": {"type": list, "items": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "server_profiles")
                    _custom_data: dict[str, Any]
                    server_profiles: list[str]
                    """STUN server-profile names."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, server_profiles: list[str] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Stun.

                        Args:
                        -----
                            _custom_data: _custom_data
                            server_profiles: STUN server-profile names.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "public_address": {"type": str}, "stun": {"type": Stun}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Local interface name."""
                public_address: str | None
                """Public IP assigned by NAT."""
                stun: Stun

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    public_address: str | None | UndefinedType = Undefined,
                    stun: Stun | UndefinedType = Undefined,
                ) -> None:
                    """
                    LocalInterfacesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Local interface name.
                        public_address: Public IP assigned by NAT.
                        stun: stun

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LocalInterfaces(AvdCollection[str, LocalInterfacesItem]):
                _primary_key: ClassVar[str] = "name"

            LocalInterfaces._item_type = LocalInterfacesItem

            class LocalIpsItem(AvdModel):
                class Stun(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "server_profiles": {"type": list, "items": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "server_profiles")
                    _custom_data: dict[str, Any]
                    server_profiles: list[str]
                    """STUN server-profile names."""

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, server_profiles: list[str] | UndefinedType = Undefined
                    ) -> None:
                        """
                        Stun.

                        Args:
                        -----
                            _custom_data: _custom_data
                            server_profiles: STUN server-profile names.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_address": {"type": str}, "public_address": {"type": str}, "stun": {"type": Stun}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "ip_address")
                _custom_data: dict[str, Any]
                ip_address: str
                public_address: str | None
                """Public IP assigned by NAT."""
                stun: Stun

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ip_address: str | UndefinedType = Undefined,
                    public_address: str | None | UndefinedType = Undefined,
                    stun: Stun | UndefinedType = Undefined,
                ) -> None:
                    """
                    LocalIpsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ip_address: ip_address
                        public_address: Public IP assigned by NAT.
                        stun: stun

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class LocalIps(AvdCollection[str, LocalIpsItem]):
                _primary_key: ClassVar[str] = "ip_address"

            LocalIps._item_type = LocalIpsItem

            class DynamicPeers(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "ip_local": {"type": bool}, "ipsec": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                """Enable `peer dynamic`."""
                ip_local: bool | None
                """Prefer local IP address."""
                ipsec: bool | None
                """IPsec configuration for dynamic peers."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    ip_local: bool | None | UndefinedType = Undefined,
                    ipsec: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DynamicPeers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: Enable `peer dynamic`.
                        ip_local: Prefer local IP address.
                        ipsec: IPsec configuration for dynamic peers.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StaticPeersItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "router_ip": {"type": str},
                    "name": {"type": str},
                    "ipv4_addresses": {"type": list, "items": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "router_ip")
                _custom_data: dict[str, Any]
                router_ip: str
                """Peer router IP."""
                name: str | None
                """Name of the site."""
                ipv4_addresses: list[str]
                """Static IPv4 addresses."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    router_ip: str | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    ipv4_addresses: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    StaticPeersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        router_ip: Peer router IP.
                        name: Name of the site.
                        ipv4_addresses: Static IPv4 addresses.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class StaticPeers(AvdCollection[str, StaticPeersItem]):
                _primary_key: ClassVar[str] = "router_ip"

            StaticPeers._item_type = StaticPeersItem

            class Keepalive(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "auto": {"type": bool, "default": False},
                    "interval": {"type": int},
                    "failure_threshold": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                auto: bool | None
                """Enable adaptive keepalive and feedback interval."""
                interval: int | None
                """Interval in milliseconds."""
                failure_threshold: int | None
                """Failure threshold in number of intervals. Required when `interval` is set."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    auto: bool | None | UndefinedType = Undefined,
                    interval: int | None | UndefinedType = Undefined,
                    failure_threshold: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Keepalive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        auto: Enable adaptive keepalive and feedback interval.
                        interval: Interval in milliseconds.
                        failure_threshold: Failure threshold in number of intervals. Required when `interval` is set.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "id": {"type": int},
                "ipsec_profile": {"type": str},
                "flow_assignment": {"type": str},
                "local_interfaces": {"type": LocalInterfaces},
                "local_ips": {"type": LocalIps},
                "dynamic_peers": {"type": DynamicPeers},
                "static_peers": {"type": StaticPeers},
                "keepalive": {"type": Keepalive},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Path group name."""
            id: int | None
            """Path group ID."""
            ipsec_profile: str | None
            """IPSec profile for the path group."""
            flow_assignment: str | None
            """Flow assignment `lan` can not be configured in a path group with dynamic peers."""
            local_interfaces: LocalInterfaces
            local_ips: LocalIps
            dynamic_peers: DynamicPeers
            """Flow assignment `lan` can not be configured in a path group with dynamic peers."""
            static_peers: StaticPeers
            keepalive: Keepalive

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                id: int | None | UndefinedType = Undefined,
                ipsec_profile: str | None | UndefinedType = Undefined,
                flow_assignment: str | None | UndefinedType = Undefined,
                local_interfaces: LocalInterfaces | UndefinedType = Undefined,
                local_ips: LocalIps | UndefinedType = Undefined,
                dynamic_peers: DynamicPeers | UndefinedType = Undefined,
                static_peers: StaticPeers | UndefinedType = Undefined,
                keepalive: Keepalive | UndefinedType = Undefined,
            ) -> None:
                """
                PathGroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Path group name.
                    id: Path group ID.
                    ipsec_profile: IPSec profile for the path group.
                    flow_assignment: Flow assignment `lan` can not be configured in a path group with dynamic peers.
                    local_interfaces: local_interfaces
                    local_ips: local_ips
                    dynamic_peers: Flow assignment `lan` can not be configured in a path group with dynamic peers.
                    static_peers: static_peers
                    keepalive: keepalive

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PathGroups(AvdCollection[str, PathGroupsItem]):
            _primary_key: ClassVar[str] = "name"

        PathGroups._item_type = PathGroupsItem

        class LoadBalancePoliciesItem(AvdModel):
            class PathGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "priority": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Path-group name."""
                priority: int | None
                """
                Priority for this path-group.
                The EOS default value is 1.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    priority: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PathGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Path-group name.
                        priority:
                           Priority for this path-group.
                           The EOS default value is 1.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class PathGroups(AvdCollection[str, PathGroupsItem]):
                _primary_key: ClassVar[str] = "name"

            PathGroups._item_type = PathGroupsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "lowest_hop_count": {"type": bool},
                "jitter": {"type": int},
                "latency": {"type": int},
                "loss_rate": {"type": str},
                "path_groups": {"type": PathGroups},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Load-balance policy name."""
            lowest_hop_count: bool | None
            """Prefer paths with lowest hop-count."""
            jitter: int | None
            """Jitter requirement for this load balance policy in milliseconds."""
            latency: int | None
            """One way delay requirement for this load balance policy in milliseconds."""
            loss_rate: str | None
            """
            Loss Rate requirement in percentage for this load balance policy.
            Value between 0.00 and 100.00.
            """
            path_groups: PathGroups
            """List of path-groups to use for this load balance policy."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                lowest_hop_count: bool | None | UndefinedType = Undefined,
                jitter: int | None | UndefinedType = Undefined,
                latency: int | None | UndefinedType = Undefined,
                loss_rate: str | None | UndefinedType = Undefined,
                path_groups: PathGroups | UndefinedType = Undefined,
            ) -> None:
                """
                LoadBalancePoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Load-balance policy name.
                    lowest_hop_count: Prefer paths with lowest hop-count.
                    jitter: Jitter requirement for this load balance policy in milliseconds.
                    latency: One way delay requirement for this load balance policy in milliseconds.
                    loss_rate:
                       Loss Rate requirement in percentage for this load balance policy.
                       Value between 0.00 and 100.00.
                    path_groups: List of path-groups to use for this load balance policy.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LoadBalancePolicies(AvdCollection[str, LoadBalancePoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        LoadBalancePolicies._item_type = LoadBalancePoliciesItem

        class PoliciesItem(AvdModel):
            class DefaultMatch(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "load_balance": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                load_balance: str | None
                """Name of the load-balance policy."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, load_balance: str | None | UndefinedType = Undefined) -> None:
                    """
                    DefaultMatch.

                    Args:
                    -----
                        _custom_data: _custom_data
                        load_balance: Name of the load-balance policy.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class RulesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "id": {"type": int},
                    "application_profile": {"type": str},
                    "load_balance": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "id", "application_profile")
                _custom_data: dict[str, Any]
                id: int
                """Rule ID."""
                application_profile: str
                load_balance: str | None
                """Name of the load-balance policy."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: int | UndefinedType = Undefined,
                    application_profile: str | UndefinedType = Undefined,
                    load_balance: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RulesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: Rule ID.
                        application_profile: application_profile
                        load_balance: Name of the load-balance policy.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Rules(AvdCollection[int, RulesItem]):
                _primary_key: ClassVar[str] = "id"

            Rules._item_type = RulesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "default_match": {"type": DefaultMatch}, "rules": {"type": Rules}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """DPS policy name."""
            default_match: DefaultMatch
            rules: Rules

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                default_match: DefaultMatch | UndefinedType = Undefined,
                rules: Rules | UndefinedType = Undefined,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: DPS policy name.
                    default_match: default_match
                    rules: rules

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdCollection[str, PoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "path_selection_policy": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            path_selection_policy: str | None
            """DPS policy name to use for this VRF."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                path_selection_policy: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    path_selection_policy: DPS policy name to use for this VRF.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class TcpMssCeiling(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4_segment_size": {"type": str}, "direction": {"type": str, "default": "ingress"}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4_segment_size: str | None
            """
            Segment Size for IPv4.
            Can be an integer in the range 64-65515 or "auto".
            "auto" will enable auto-
            discovery which clamps the TCP MSS value to the minimum of all the direct paths
            and multi-hop path
            MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
            """
            direction: str | None
            """
            Enforce on packets through DPS tunnel for a specific direction.
            Only 'ingress' direction is
            supported.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4_segment_size: str | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4_segment_size:
                       Segment Size for IPv4.
                       Can be an integer in the range 64-65515 or "auto".
                       "auto" will enable auto-
                       discovery which clamps the TCP MSS value to the minimum of all the direct paths
                       and multi-hop path
                       MTU towards a remote VTEP (minus 40bytes to account for IP + TCP header).
                    direction:
                       Enforce on packets through DPS tunnel for a specific direction.
                       Only 'ingress' direction is
                       supported.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "peer_dynamic_source": {"type": str},
            "path_groups": {"type": PathGroups},
            "load_balance_policies": {"type": LoadBalancePolicies},
            "policies": {"type": Policies},
            "vrfs": {"type": Vrfs},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        peer_dynamic_source: str | None
        """Source of dynamic peer discovery."""
        path_groups: PathGroups
        load_balance_policies: LoadBalancePolicies
        policies: Policies
        vrfs: Vrfs
        tcp_mss_ceiling: TcpMssCeiling

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            peer_dynamic_source: str | None | UndefinedType = Undefined,
            path_groups: PathGroups | UndefinedType = Undefined,
            load_balance_policies: LoadBalancePolicies | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
        ) -> None:
            """
            RouterPathSelection.

            Args:
            -----
                _custom_data: _custom_data
                peer_dynamic_source: Source of dynamic peer discovery.
                path_groups: path_groups
                load_balance_policies: load_balance_policies
                policies: policies
                vrfs: vrfs
                tcp_mss_ceiling: tcp_mss_ceiling

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterPimSparseMode(AvdModel):
        class Ipv4(AvdModel):
            class RpAddressesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "address": {"type": str},
                    "groups": {"type": list, "items": str},
                    "access_lists": {"type": list, "items": str},
                    "priority": {"type": int},
                    "hashmask": {"type": int},
                    "override": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                _custom_data: dict[str, Any]
                address: str
                """RP Address."""
                groups: list[str]
                access_lists: list[str]
                priority: int | None
                hashmask: int | None
                override: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    address: str | UndefinedType = Undefined,
                    groups: list[str] | UndefinedType = Undefined,
                    access_lists: list[str] | UndefinedType = Undefined,
                    priority: int | None | UndefinedType = Undefined,
                    hashmask: int | None | UndefinedType = Undefined,
                    override: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RpAddressesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: RP Address.
                        groups: groups
                        access_lists: access_lists
                        priority: priority
                        hashmask: hashmask
                        override: override

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AnycastRpsItem(AvdModel):
                class OtherAnycastRpAddressesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}, "register_count": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                    _custom_data: dict[str, Any]
                    address: str
                    """Other Anycast RP Address."""
                    register_count: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        address: str | UndefinedType = Undefined,
                        register_count: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        OtherAnycastRpAddressesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address: Other Anycast RP Address.
                            register_count: register_count

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class OtherAnycastRpAddresses(AvdCollection[str, OtherAnycastRpAddressesItem]):
                    _primary_key: ClassVar[str] = "address"

                OtherAnycastRpAddresses._item_type = OtherAnycastRpAddressesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "address": {"type": str},
                    "other_anycast_rp_addresses": {"type": OtherAnycastRpAddresses},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                _custom_data: dict[str, Any]
                address: str
                """Anycast RP Address."""
                other_anycast_rp_addresses: OtherAnycastRpAddresses

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    address: str | UndefinedType = Undefined,
                    other_anycast_rp_addresses: OtherAnycastRpAddresses | UndefinedType = Undefined,
                ) -> None:
                    """
                    AnycastRpsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Anycast RP Address.
                        other_anycast_rp_addresses: other_anycast_rp_addresses

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AnycastRps(AvdCollection[str, AnycastRpsItem]):
                _primary_key: ClassVar[str] = "address"

            AnycastRps._item_type = AnycastRpsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "bfd": {"type": bool},
                "ssm_range": {"type": str},
                "rp_addresses": {"type": list, "items": RpAddressesItem},
                "anycast_rps": {"type": AnycastRps},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bfd: bool | None
            """Enable/Disable BFD."""
            ssm_range: str | None
            """IPv4 Prefix associated with SSM."""
            rp_addresses: list[RpAddressesItem]
            anycast_rps: AnycastRps

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bfd: bool | None | UndefinedType = Undefined,
                ssm_range: str | None | UndefinedType = Undefined,
                rp_addresses: list[RpAddressesItem] | UndefinedType = Undefined,
                anycast_rps: AnycastRps | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv4.

                Args:
                -----
                    _custom_data: _custom_data
                    bfd: Enable/Disable BFD.
                    ssm_range: IPv4 Prefix associated with SSM.
                    rp_addresses: rp_addresses
                    anycast_rps: anycast_rps

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            class Ipv4(AvdModel):
                class RpAddressesItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "address": {"type": str},
                        "groups": {"type": list, "items": str},
                        "access_lists": {"type": list, "items": str},
                        "priority": {"type": int},
                        "hashmask": {"type": int},
                        "override": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                    _custom_data: dict[str, Any]
                    address: str
                    """RP Address."""
                    groups: list[str]
                    access_lists: list[str]
                    priority: int | None
                    hashmask: int | None
                    override: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        address: str | UndefinedType = Undefined,
                        groups: list[str] | UndefinedType = Undefined,
                        access_lists: list[str] | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        hashmask: int | None | UndefinedType = Undefined,
                        override: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        RpAddressesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            address: RP Address.
                            groups: groups
                            access_lists: access_lists
                            priority: priority
                            hashmask: hashmask
                            override: override

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "bfd": {"type": bool}, "rp_addresses": {"type": list, "items": RpAddressesItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                bfd: bool | None
                """Enable/Disable BFD."""
                rp_addresses: list[RpAddressesItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    rp_addresses: list[RpAddressesItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        bfd: Enable/Disable BFD.
                        rp_addresses: rp_addresses

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "ipv4": {"type": Ipv4}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF Name."""
            ipv4: Ipv4

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF Name.
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}, "vrfs": {"type": Vrfs}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        ipv4: Ipv4
        vrfs: Vrfs

        def __init__(
            self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined, vrfs: Vrfs | UndefinedType = Undefined
        ) -> None:
            """
            RouterPimSparseMode.

            Args:
            -----
                _custom_data: _custom_data
                ipv4: ipv4
                vrfs: vrfs

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterSegmentSecurity(AvdModel):
        class PoliciesItem(AvdModel):
            class SequenceNumbersItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "sequence": {"type": int},
                    "application": {"type": str},
                    "action": {"type": str},
                    "log": {"type": bool},
                    "stateless": {"type": bool, "default": True},
                    "next_hop": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "application", "action")
                _custom_data: dict[str, Any]
                sequence: int
                """Sequence ID."""
                application: str
                """The name of the application."""
                action: str
                """
                The action to take - note that platform support for the redirect action is limited. The "redirect"
                action also requires the 'next_hop' to be configured.
                """
                log: bool | None
                """Enable logging - note that platform support is limited."""
                stateless: bool | None
                """Take action, regardless of state. Should be set to 'true' for MSS-G."""
                next_hop: str | None
                """When the action is 'redirect', this indicates the IPv4 next hop to redirect to."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    sequence: int | UndefinedType = Undefined,
                    application: str | UndefinedType = Undefined,
                    action: str | UndefinedType = Undefined,
                    log: bool | None | UndefinedType = Undefined,
                    stateless: bool | None | UndefinedType = Undefined,
                    next_hop: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SequenceNumbersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        sequence: Sequence ID.
                        application: The name of the application.
                        action:
                           The action to take - note that platform support for the redirect action is limited. The "redirect"
                           action also requires the 'next_hop' to be configured.
                        log: Enable logging - note that platform support is limited.
                        stateless: Take action, regardless of state. Should be set to 'true' for MSS-G.
                        next_hop: When the action is 'redirect', this indicates the IPv4 next hop to redirect to.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
                _primary_key: ClassVar[str] = "sequence"

            SequenceNumbers._item_type = SequenceNumbersItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "sequence_numbers": {"type": SequenceNumbers}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
            _custom_data: dict[str, Any]
            name: str
            """Policy name."""
            sequence_numbers: SequenceNumbers

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Policy name.
                    sequence_numbers: sequence_numbers

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdCollection[str, PoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        class VrfsItem(AvdModel):
            class SegmentsItem(AvdModel):
                class Definition(AvdModel):
                    class MatchListsItem(AvdModel):
                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "address_family": {"type": str},
                            "covered_prefix_list": {"type": str},
                            "prefix": {"type": str},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data", "address_family")
                        _custom_data: dict[str, Any]
                        address_family: str
                        """Indicate which address-family the match list belongs to e.g. ipv4 or ipv6."""
                        covered_prefix_list: str | None
                        """
                        The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of match_list.  If both are configured prefix takes precedence.
                        """
                        prefix: str | None
                        """
                        The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                        the use of covered_prefix_list. If both are configured prefix takes precedence.
                        """

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            address_family: str | UndefinedType = Undefined,
                            covered_prefix_list: str | None | UndefinedType = Undefined,
                            prefix: str | None | UndefinedType = Undefined,
                        ) -> None:
                            """
                            MatchListsItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                address_family: Indicate which address-family the match list belongs to e.g. ipv4 or ipv6.
                                covered_prefix_list:
                                   The name of the prefix-list. You can have a maximum of one per address-family. Mutually exclusive to
                                   the use of match_list.  If both are configured prefix takes precedence.
                                prefix:
                                   The name of the match-list. You can have a maximum of one per address-family. Mutually exclusive to
                                   the use of covered_prefix_list. If both are configured prefix takes precedence.

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    class MatchLists(AvdCollection[str, MatchListsItem]):
                        _primary_key: ClassVar[str] = "address_family"

                    MatchLists._item_type = MatchListsItem

                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interfaces": {"type": list, "items": str}, "match_lists": {"type": MatchLists}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    interfaces: list[str]
                    """The names of the source interface e.g. Port-Channel1 - note that platform support is limited."""
                    match_lists: MatchLists
                    """The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        interfaces: list[str] | UndefinedType = Undefined,
                        match_lists: MatchLists | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Definition.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interfaces: The names of the source interface e.g. Port-Channel1 - note that platform support is limited.
                            match_lists: The set of lists that define the segment. These can be a mix of IPv4 and IPv6 prefix or match lists.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class PoliciesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "field_from": {"type": str, "key": "from"}, "policy": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "field_from")
                    _custom_data: dict[str, Any]
                    field_from: str
                    """The name of the source segment or 'forwarding-segments' for all segments."""
                    policy: str | None
                    """
                    The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                    all'.
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        field_from: str | UndefinedType = Undefined,
                        policy: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        PoliciesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            field_from: The name of the source segment or 'forwarding-segments' for all segments.
                            policy:
                               The name of the policy to apply. The built-in policies are 'policy-forward-all' and 'policy-drop-
                               all'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Policies(AvdCollection[str, PoliciesItem]):
                    _primary_key: ClassVar[str] = "from"

                Policies._item_type = PoliciesItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "definition": {"type": Definition},
                    "policies": {"type": Policies},
                    "fallback_policy": {"type": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Segment name."""
                definition: Definition
                policies: Policies
                """The policies controlling traffic into the segment."""
                fallback_policy: str | None
                """
                Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                by name.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    definition: Definition | UndefinedType = Undefined,
                    policies: Policies | UndefinedType = Undefined,
                    fallback_policy: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SegmentsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Segment name.
                        definition: definition
                        policies: The policies controlling traffic into the segment.
                        fallback_policy:
                           Only supported on the R3 series platforms, this allows a per-segment default policy to be specified
                           by name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Segments(AvdCollection[str, SegmentsItem]):
                _primary_key: ClassVar[str] = "name"

            Segments._item_type = SegmentsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "segments": {"type": Segments}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "segments")
            _custom_data: dict[str, Any]
            name: str
            segments: Segments

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                segments: Segments | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    segments: segments

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "policies": {"type": Policies}, "vrfs": {"type": Vrfs}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None
        policies: Policies
        """
        Customised application policies.
        Using the Application Traffic Recognition L4 profiles, custom
        policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
        Note that this is stateless, so both the source and destination flows need to be considered.
        """
        vrfs: Vrfs
        """The name of the VRF that the segments and policies are defined in."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
        ) -> None:
            """
            RouterSegmentSecurity.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                policies:
                   Customised application policies.
                   Using the Application Traffic Recognition L4 profiles, custom
                   policies can be defined. The built-in application 'app-match-all' can be used to match any packets.
                   Note that this is stateless, so both the source and destination flows need to be considered.
                vrfs: The name of the VRF that the segments and policies are defined in.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterServiceInsertion(AvdModel):
        class ConnectionsItem(AvdModel):
            class EthernetInterface(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "next_hop": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name", "next_hop")
                _custom_data: dict[str, Any]
                name: str
                """e.g. Ethernet2 or Ethernet2/2.2"""
                next_hop: str
                """Next-hop IPv4 address (without mask)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    next_hop: str | UndefinedType = Undefined,
                ) -> None:
                    """
                    EthernetInterface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: e.g. Ethernet2 or Ethernet2/2.2
                        next_hop: Next-hop IPv4 address (without mask).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TunnelInterface(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "primary": {"type": str}, "secondary": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                primary: str | None
                """e.g. Tunnel2"""
                secondary: str | None
                """e.g. Tunnel3"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    primary: str | None | UndefinedType = Undefined,
                    secondary: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TunnelInterface.

                    Args:
                    -----
                        _custom_data: _custom_data
                        primary: e.g. Tunnel2
                        secondary: e.g. Tunnel3

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "ethernet_interface": {"type": EthernetInterface},
                "tunnel_interface": {"type": TunnelInterface},
                "monitor_connectivity_host": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Connection name."""
            ethernet_interface: EthernetInterface
            """
            Outgoing physical interface or subinterface to use for the connection.
            If both `ethernet_interface`
            and `tunnel_interface` are configured, `ethernet_interface` will be used.
            """
            tunnel_interface: TunnelInterface
            """
            Outgoing tunnel interface(s) to use for this connection.
            If both `ethernet_interface` and
            `tunnel_interface` are configured, `ethernet_interface` will be used.
            """
            monitor_connectivity_host: str | None
            """
            Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
            connection.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                ethernet_interface: EthernetInterface | UndefinedType = Undefined,
                tunnel_interface: TunnelInterface | UndefinedType = Undefined,
                monitor_connectivity_host: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ConnectionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Connection name.
                    ethernet_interface:
                       Outgoing physical interface or subinterface to use for the connection.
                       If both `ethernet_interface`
                       and `tunnel_interface` are configured, `ethernet_interface` will be used.
                    tunnel_interface:
                       Outgoing tunnel interface(s) to use for this connection.
                       If both `ethernet_interface` and
                       `tunnel_interface` are configured, `ethernet_interface` will be used.
                    monitor_connectivity_host:
                       Name of the host defined under `monitor_connectivity.hosts` used to derive the health of the
                       connection.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Connections(AvdCollection[str, ConnectionsItem]):
            _primary_key: ClassVar[str] = "name"

        Connections._item_type = ConnectionsItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "connections": {"type": Connections}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        enabled: bool | None
        connections: Connections

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | None | UndefinedType = Undefined,
            connections: Connections | UndefinedType = Undefined,
        ) -> None:
            """
            RouterServiceInsertion.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                connections: connections

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class RouterTrafficEngineering(AvdModel):
        class RouterId(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": str}, "ipv6": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: str | None
            ipv6: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: str | None | UndefinedType = Undefined,
                ipv6: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                RouterId.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SegmentRouting(AvdModel):
            class PolicyEndpointsItem(AvdModel):
                class ColorsItem(AvdModel):
                    class PathGroupItem(AvdModel):
                        class SegmentListItem(AvdModel):
                            _fields: ClassVar[dict] = {
                                "_custom_data": {"type": dict},
                                "label_stack": {"type": str},
                                "weight": {"type": int},
                                "index": {"type": int},
                            }
                            _required_fields: ClassVar[tuple] = ("_custom_data",)
                            _custom_data: dict[str, Any]
                            label_stack: str | None
                            """
                            Label Stack as string.
                            Example: "100 2000 30"
                            """
                            weight: int | None
                            index: int | None

                            def __init__(
                                self,
                                *,
                                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                                label_stack: str | None | UndefinedType = Undefined,
                                weight: int | None | UndefinedType = Undefined,
                                index: int | None | UndefinedType = Undefined,
                            ) -> None:
                                """
                                SegmentListItem.

                                Args:
                                -----
                                    _custom_data: _custom_data
                                    label_stack:
                                       Label Stack as string.
                                       Example: "100 2000 30"
                                    weight: weight
                                    index: index

                                """
                                for arg, arg_value in locals().items():
                                    if arg_value is Undefined or arg in ("self", "kwargs"):
                                        continue
                                    setattr(self, arg, arg_value)

                        _fields: ClassVar[dict] = {
                            "_custom_data": {"type": dict},
                            "preference": {"type": int},
                            "explicit_null": {"type": str},
                            "segment_list": {"type": list, "items": SegmentListItem},
                        }
                        _required_fields: ClassVar[tuple] = ("_custom_data",)
                        _custom_data: dict[str, Any]
                        preference: int | None
                        explicit_null: str | None
                        segment_list: list[SegmentListItem]

                        def __init__(
                            self,
                            *,
                            _custom_data: dict[str, Any] | UndefinedType = Undefined,
                            preference: int | None | UndefinedType = Undefined,
                            explicit_null: str | None | UndefinedType = Undefined,
                            segment_list: list[SegmentListItem] | UndefinedType = Undefined,
                        ) -> None:
                            """
                            PathGroupItem.

                            Args:
                            -----
                                _custom_data: _custom_data
                                preference: preference
                                explicit_null: explicit_null
                                segment_list: segment_list

                            """
                            for arg, arg_value in locals().items():
                                if arg_value is Undefined or arg in ("self", "kwargs"):
                                    continue
                                setattr(self, arg, arg_value)

                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "value": {"type": int},
                        "binding_sid": {"type": int},
                        "description": {"type": str},
                        "name": {"type": str},
                        "sbfd_remote_discriminator": {"type": str},
                        "path_group": {"type": list, "items": PathGroupItem},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "value")
                    _custom_data: dict[str, Any]
                    value: int
                    binding_sid: int | None
                    description: str | None
                    name: str | None
                    sbfd_remote_discriminator: str | None
                    """IPv4 address or 32 bit integer."""
                    path_group: list[PathGroupItem]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        value: int | UndefinedType = Undefined,
                        binding_sid: int | None | UndefinedType = Undefined,
                        description: str | None | UndefinedType = Undefined,
                        name: str | None | UndefinedType = Undefined,
                        sbfd_remote_discriminator: str | None | UndefinedType = Undefined,
                        path_group: list[PathGroupItem] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ColorsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            value: value
                            binding_sid: binding_sid
                            description: description
                            name: name
                            sbfd_remote_discriminator: IPv4 address or 32 bit integer.
                            path_group: path_group

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Colors(AvdCollection[int, ColorsItem]):
                    _primary_key: ClassVar[str] = "value"

                Colors._item_type = ColorsItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}, "colors": {"type": Colors}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                address: str | None
                """IPv4 or IPv6 address."""
                colors: Colors

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    colors: Colors | UndefinedType = Undefined,
                ) -> None:
                    """
                    PolicyEndpointsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: IPv4 or IPv6 address.
                        colors: colors

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "colored_tunnel_rib": {"type": bool},
                "policy_endpoints": {"type": list, "items": PolicyEndpointsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            colored_tunnel_rib: bool | None
            policy_endpoints: list[PolicyEndpointsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                colored_tunnel_rib: bool | None | UndefinedType = Undefined,
                policy_endpoints: list[PolicyEndpointsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                SegmentRouting.

                Args:
                -----
                    _custom_data: _custom_data
                    colored_tunnel_rib: colored_tunnel_rib
                    policy_endpoints: policy_endpoints

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "enabled": {"type": bool},
            "router_id": {"type": RouterId},
            "segment_routing": {"type": SegmentRouting},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
        _custom_data: dict[str, Any]
        enabled: bool
        router_id: RouterId
        segment_routing: SegmentRouting

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            enabled: bool | UndefinedType = Undefined,
            router_id: RouterId | UndefinedType = Undefined,
            segment_routing: SegmentRouting | UndefinedType = Undefined,
        ) -> None:
            """
            RouterTrafficEngineering.

            Args:
            -----
                _custom_data: _custom_data
                enabled: enabled
                router_id: router_id
                segment_routing: segment_routing

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ServiceRoutingConfigurationBgp(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "no_equals_default": {"type": bool}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        no_equals_default: bool | None

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, no_equals_default: bool | None | UndefinedType = Undefined) -> None:
            """
            ServiceRoutingConfigurationBgp.

            Args:
            -----
                _custom_data: _custom_data
                no_equals_default: no_equals_default

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class ServiceUnsupportedTransceiver(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "license_name": {"type": str}, "license_key": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        license_name: str | None
        license_key: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            license_name: str | None | UndefinedType = Undefined,
            license_key: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            ServiceUnsupportedTransceiver.

            Args:
            -----
                _custom_data: _custom_data
                license_name: license_name
                license_key: license_key

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Sflow(AvdModel):
        class VrfsItem(AvdModel):
            class DestinationsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination": {"type": str}, "port": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "destination")
                _custom_data: dict[str, Any]
                destination: str
                """Sflow Destination IP Address."""
                port: int | None
                """Port Number"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    destination: str | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    DestinationsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        destination: Sflow Destination IP Address.
                        port: Port Number

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Destinations(AvdCollection[str, DestinationsItem]):
                _primary_key: ClassVar[str] = "destination"

            Destinations._item_type = DestinationsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "destinations": {"type": Destinations},
                "source": {"type": str},
                "source_interface": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            destinations: Destinations
            source: str | None
            """
            Source IP Address.
            "source" and "source_interface" are mutually exclusive. If both are defined,
            "source_interface" takes precedence.
            """
            source_interface: str | None
            """Source Interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                destinations: Destinations | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: name
                    destinations: destinations
                    source:
                       Source IP Address.
                       "source" and "source_interface" are mutually exclusive. If both are defined,
                       "source_interface" takes precedence.
                    source_interface: Source Interface.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        class DestinationsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination": {"type": str}, "port": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "destination")
            _custom_data: dict[str, Any]
            destination: str
            """Sflow Destination IP Address."""
            port: int | None
            """Port Number."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                destination: str | UndefinedType = Undefined,
                port: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                DestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: Sflow Destination IP Address.
                    port: Port Number.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Destinations(AvdCollection[str, DestinationsItem]):
            _primary_key: ClassVar[str] = "destination"

        Destinations._item_type = DestinationsItem

        class ExtensionsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enabled": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name", "enabled")
            _custom_data: dict[str, Any]
            name: str
            """Extension Name."""
            enabled: bool
            """Enable or Disable Extension."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
            ) -> None:
                """
                ExtensionsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Extension Name.
                    enabled: Enable or Disable Extension.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Extensions(AvdCollection[str, ExtensionsItem]):
            _primary_key: ClassVar[str] = "name"

        Extensions._item_type = ExtensionsItem

        class Interface(AvdModel):
            class Disable(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                default: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, default: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Disable.

                    Args:
                    -----
                        _custom_data: _custom_data
                        default: default

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Egress(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enable_default": {"type": bool}, "unmodified": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enable_default: bool | None
                """Enable egress sFlow by default."""
                unmodified: bool | None
                """
                Enable egress sFlow unmodified.
                Platform dependent feature.
                """

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enable_default: bool | None | UndefinedType = Undefined,
                    unmodified: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Egress.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enable_default: Enable egress sFlow by default.
                        unmodified:
                           Enable egress sFlow unmodified.
                           Platform dependent feature.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "disable": {"type": Disable}, "egress": {"type": Egress}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            disable: Disable
            egress: Egress

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                disable: Disable | UndefinedType = Undefined,
                egress: Egress | UndefinedType = Undefined,
            ) -> None:
                """
                Interface.

                Args:
                -----
                    _custom_data: _custom_data
                    disable: disable
                    egress: egress

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HardwareAcceleration(AvdModel):
            class ModulesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enabled": {"type": bool, "default": True}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                enabled: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ModulesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        enabled: enabled

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Modules(AvdCollection[str, ModulesItem]):
                _primary_key: ClassVar[str] = "name"

            Modules._item_type = ModulesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "sample": {"type": int}, "modules": {"type": Modules}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            sample: int | None
            modules: Modules

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                sample: int | None | UndefinedType = Undefined,
                modules: Modules | UndefinedType = Undefined,
            ) -> None:
                """
                HardwareAcceleration.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    sample: sample
                    modules: modules

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "sample": {"type": int},
            "sample_input_subinterface": {"type": bool},
            "sample_output_subinterface": {"type": bool},
            "dangerous": {"type": bool},
            "polling_interval": {"type": int},
            "vrfs": {"type": Vrfs},
            "destinations": {"type": Destinations},
            "source": {"type": str},
            "source_interface": {"type": str},
            "extensions": {"type": Extensions},
            "interface": {"type": Interface},
            "run": {"type": bool},
            "hardware_acceleration": {"type": HardwareAcceleration},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        sample: int | None
        sample_input_subinterface: bool | None
        sample_output_subinterface: bool | None
        dangerous: bool | None
        polling_interval: int | None
        """Polling interval in seconds."""
        vrfs: Vrfs
        destinations: Destinations
        source: str | None
        """
        Source IP Address.
        "source" and "source_interface" are mutually exclusive. If both are defined,
        "source_interface" takes precedence.
        """
        source_interface: str | None
        """Source Interface."""
        extensions: Extensions
        interface: Interface
        run: bool | None
        hardware_acceleration: HardwareAcceleration

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            sample: int | None | UndefinedType = Undefined,
            sample_input_subinterface: bool | None | UndefinedType = Undefined,
            sample_output_subinterface: bool | None | UndefinedType = Undefined,
            dangerous: bool | None | UndefinedType = Undefined,
            polling_interval: int | None | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            destinations: Destinations | UndefinedType = Undefined,
            source: str | None | UndefinedType = Undefined,
            source_interface: str | None | UndefinedType = Undefined,
            extensions: Extensions | UndefinedType = Undefined,
            interface: Interface | UndefinedType = Undefined,
            run: bool | None | UndefinedType = Undefined,
            hardware_acceleration: HardwareAcceleration | UndefinedType = Undefined,
        ) -> None:
            """
            Sflow.

            Args:
            -----
                _custom_data: _custom_data
                sample: sample
                sample_input_subinterface: sample_input_subinterface
                sample_output_subinterface: sample_output_subinterface
                dangerous: dangerous
                polling_interval: Polling interval in seconds.
                vrfs: vrfs
                destinations: destinations
                source:
                   Source IP Address.
                   "source" and "source_interface" are mutually exclusive. If both are defined,
                   "source_interface" takes precedence.
                source_interface: Source Interface.
                extensions: extensions
                interface: interface
                run: run
                hardware_acceleration: hardware_acceleration

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SnmpServer(AvdModel):
        class EngineIds(AvdModel):
            class RemotesItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": str}, "address": {"type": str}, "udp_port": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                id: str | None
                """Remote engine ID in hexadecimal."""
                address: str | None
                """Hostname or IP of remote engine."""
                udp_port: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    id: str | None | UndefinedType = Undefined,
                    address: str | None | UndefinedType = Undefined,
                    udp_port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    RemotesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        id: Remote engine ID in hexadecimal.
                        address: Hostname or IP of remote engine.
                        udp_port: udp_port

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "local": {"type": str}, "remotes": {"type": list, "items": RemotesItem}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            local: str | None
            """Engine ID in hexadecimal."""
            remotes: list[RemotesItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                local: str | None | UndefinedType = Undefined,
                remotes: list[RemotesItem] | UndefinedType = Undefined,
            ) -> None:
                """
                EngineIds.

                Args:
                -----
                    _custom_data: _custom_data
                    local: Engine ID in hexadecimal.
                    remotes: remotes

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class CommunitiesItem(AvdModel):
            class AccessListIpv4(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """IPv4 access list name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                    """
                    AccessListIpv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 access list name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessListIpv6(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """IPv6 access list name."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | None | UndefinedType = Undefined) -> None:
                    """
                    AccessListIpv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv6 access list name.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "access": {"type": str},
                "access_list_ipv4": {"type": AccessListIpv4},
                "access_list_ipv6": {"type": AccessListIpv6},
                "view": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Community name."""
            access: str | None
            access_list_ipv4: AccessListIpv4
            access_list_ipv6: AccessListIpv6
            view: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                access: str | None | UndefinedType = Undefined,
                access_list_ipv4: AccessListIpv4 | UndefinedType = Undefined,
                access_list_ipv6: AccessListIpv6 | UndefinedType = Undefined,
                view: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                CommunitiesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Community name.
                    access: access
                    access_list_ipv4: access_list_ipv4
                    access_list_ipv6: access_list_ipv6
                    view: view

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Communities(AvdCollection[str, CommunitiesItem]):
            _primary_key: ClassVar[str] = "name"

        Communities._item_type = CommunitiesItem

        class Ipv4AclsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """IPv4 access list name."""
            vrf: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv4AclsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IPv4 access list name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AclsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """IPv6 access list name."""
            vrf: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6AclsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: IPv6 access list name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LocalInterfacesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Interface name."""
            vrf: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                LocalInterfacesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Interface name.
                    vrf: vrf

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class LocalInterfaces(AvdCollection[str, LocalInterfacesItem]):
            _primary_key: ClassVar[str] = "name"

        LocalInterfaces._item_type = LocalInterfacesItem

        class ViewsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "mib_family_name": {"type": str}, "included": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """SNMP view name."""
            mib_family_name: str | None
            included: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                mib_family_name: str | None | UndefinedType = Undefined,
                included: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                ViewsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: SNMP view name.
                    mib_family_name: mib_family_name
                    included: included

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class GroupsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "version": {"type": str},
                "authentication": {"type": str},
                "read": {"type": str},
                "write": {"type": str},
                "notify": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Group name."""
            version: str | None
            authentication: str | None
            read: str | None
            """Read view."""
            write: str | None
            """Write view."""
            notify: str | None
            """Notify view."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                version: str | None | UndefinedType = Undefined,
                authentication: str | None | UndefinedType = Undefined,
                read: str | None | UndefinedType = Undefined,
                write: str | None | UndefinedType = Undefined,
                notify: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                GroupsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Group name.
                    version: version
                    authentication: authentication
                    read: Read view.
                    write: Write view.
                    notify: Notify view.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class UsersItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "group": {"type": str},
                "remote_address": {"type": str},
                "udp_port": {"type": int},
                "version": {"type": str},
                "localized": {"type": str},
                "auth": {"type": str},
                "auth_passphrase": {"type": str},
                "priv": {"type": str},
                "priv_passphrase": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            name: str | None
            """Username."""
            group: str | None
            """Group name."""
            remote_address: str | None
            """
            Hostname or ip of remote engine.
            The remote_address and udp_port are used for remote users.
            """
            udp_port: int | None
            """udp_port will not be used if no remote_address is configured."""
            version: str | None
            localized: str | None
            """Engine ID in hexadecimal for localizing auth and/or priv."""
            auth: str | None
            """Hash algorithm."""
            auth_passphrase: str | None
            """Hashed authentication passphrase if localized is used else cleartext authentication passphrase."""
            priv: str | None
            """Encryption algorithm."""
            priv_passphrase: str | None
            """Hashed privacy passphrase if localized is used else cleartext privacy passphrase."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | None | UndefinedType = Undefined,
                group: str | None | UndefinedType = Undefined,
                remote_address: str | None | UndefinedType = Undefined,
                udp_port: int | None | UndefinedType = Undefined,
                version: str | None | UndefinedType = Undefined,
                localized: str | None | UndefinedType = Undefined,
                auth: str | None | UndefinedType = Undefined,
                auth_passphrase: str | None | UndefinedType = Undefined,
                priv: str | None | UndefinedType = Undefined,
                priv_passphrase: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                UsersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Username.
                    group: Group name.
                    remote_address:
                       Hostname or ip of remote engine.
                       The remote_address and udp_port are used for remote users.
                    udp_port: udp_port will not be used if no remote_address is configured.
                    version: version
                    localized: Engine ID in hexadecimal for localizing auth and/or priv.
                    auth: Hash algorithm.
                    auth_passphrase: Hashed authentication passphrase if localized is used else cleartext authentication passphrase.
                    priv: Encryption algorithm.
                    priv_passphrase: Hashed privacy passphrase if localized is used else cleartext privacy passphrase.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class HostsItem(AvdModel):
            class UsersItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "username": {"type": str}, "authentication_level": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                username: str | None
                authentication_level: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    username: str | None | UndefinedType = Undefined,
                    authentication_level: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    UsersItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        username: username
                        authentication_level: authentication_level

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "host": {"type": str},
                "vrf": {"type": str},
                "version": {"type": str},
                "community": {"type": str},
                "users": {"type": list, "items": UsersItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            version: str | None
            community: str | None
            """Community name."""
            users: list[UsersItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                host: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                version: str | None | UndefinedType = Undefined,
                community: str | None | UndefinedType = Undefined,
                users: list[UsersItem] | UndefinedType = Undefined,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf: vrf
                    version: version
                    community: Community name.
                    users: users

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Traps(AvdModel):
            class SnmpTrapsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enabled": {"type": bool, "default": True}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                """
                Enable or disable specific snmp-traps and their sub_traps.
                Examples:
                - "bgp"
                - "bgp established"
                """
                enabled: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SnmpTrapsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name:
                           Enable or disable specific snmp-traps and their sub_traps.

                    Examples:
                           - "bgp"
                           - "bgp established"
                        enabled: enabled

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enable": {"type": bool, "default": False},
                "snmp_traps": {"type": list, "items": SnmpTrapsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enable: bool | None
            """Enable or disable all snmp-traps."""
            snmp_traps: list[SnmpTrapsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
                snmp_traps: list[SnmpTrapsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                Traps.

                Args:
                -----
                    _custom_data: _custom_data
                    enable: Enable or disable all snmp-traps.
                    snmp_traps: snmp_traps

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrfsItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "enable": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """VRF name."""
            enable: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                enable: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                VrfsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: VRF name.
                    enable: enable

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vrfs(AvdCollection[str, VrfsItem]):
            _primary_key: ClassVar[str] = "name"

        Vrfs._item_type = VrfsItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "engine_ids": {"type": EngineIds},
            "contact": {"type": str},
            "location": {"type": str},
            "communities": {"type": Communities},
            "ipv4_acls": {"type": list, "items": Ipv4AclsItem},
            "ipv6_acls": {"type": list, "items": Ipv6AclsItem},
            "local_interfaces": {"type": LocalInterfaces},
            "views": {"type": list, "items": ViewsItem},
            "groups": {"type": list, "items": GroupsItem},
            "users": {"type": list, "items": UsersItem},
            "hosts": {"type": list, "items": HostsItem},
            "traps": {"type": Traps},
            "vrfs": {"type": Vrfs},
            "ifmib_ifspeed_shape_rate": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        engine_ids: EngineIds
        contact: str | None
        """SNMP contact."""
        location: str | None
        """SNMP location."""
        communities: Communities
        ipv4_acls: list[Ipv4AclsItem]
        ipv6_acls: list[Ipv6AclsItem]
        local_interfaces: LocalInterfaces
        views: list[ViewsItem]
        groups: list[GroupsItem]
        users: list[UsersItem]
        hosts: list[HostsItem]
        traps: Traps
        vrfs: Vrfs
        ifmib_ifspeed_shape_rate: bool | None
        """SNMP ifspeed reflecting shaping rate."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            engine_ids: EngineIds | UndefinedType = Undefined,
            contact: str | None | UndefinedType = Undefined,
            location: str | None | UndefinedType = Undefined,
            communities: Communities | UndefinedType = Undefined,
            ipv4_acls: list[Ipv4AclsItem] | UndefinedType = Undefined,
            ipv6_acls: list[Ipv6AclsItem] | UndefinedType = Undefined,
            local_interfaces: LocalInterfaces | UndefinedType = Undefined,
            views: list[ViewsItem] | UndefinedType = Undefined,
            groups: list[GroupsItem] | UndefinedType = Undefined,
            users: list[UsersItem] | UndefinedType = Undefined,
            hosts: list[HostsItem] | UndefinedType = Undefined,
            traps: Traps | UndefinedType = Undefined,
            vrfs: Vrfs | UndefinedType = Undefined,
            ifmib_ifspeed_shape_rate: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            SnmpServer.

            Args:
            -----
                _custom_data: _custom_data
                engine_ids: engine_ids
                contact: SNMP contact.
                location: SNMP location.
                communities: communities
                ipv4_acls: ipv4_acls
                ipv6_acls: ipv6_acls
                local_interfaces: local_interfaces
                views: views
                groups: groups
                users: users
                hosts: hosts
                traps: traps
                vrfs: vrfs
                ifmib_ifspeed_shape_rate: SNMP ifspeed reflecting shaping rate.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SpanningTree(AvdModel):
        class EdgePort(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "bpdufilter_default": {"type": bool}, "bpduguard_default": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            bpdufilter_default: bool | None
            bpduguard_default: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                bpdufilter_default: bool | None | UndefinedType = Undefined,
                bpduguard_default: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                EdgePort.

                Args:
                -----
                    _custom_data: _custom_data
                    bpdufilter_default: bpdufilter_default
                    bpduguard_default: bpduguard_default

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class BpduguardRateLimit(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "default": {"type": bool}, "count": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            default: bool | None
            count: int | None
            """Maximum number of BPDUs per timer interval."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                default: bool | None | UndefinedType = Undefined,
                count: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                BpduguardRateLimit.

                Args:
                -----
                    _custom_data: _custom_data
                    default: default
                    count: Maximum number of BPDUs per timer interval.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mst(AvdModel):
            class Configuration(AvdModel):
                class InstancesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "vlans": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                    _custom_data: dict[str, Any]
                    id: int
                    """Instance ID."""
                    vlans: str | None
                    """
                    "< vlan_id >, < vlan_id >-< vlan_id >"
                    Example: 15,16,17,18
                    """

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        vlans: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        InstancesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Instance ID.
                            vlans:
                               "< vlan_id >, < vlan_id >-< vlan_id >"
                               Example: 15,16,17,18

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Instances(AvdCollection[int, InstancesItem]):
                    _primary_key: ClassVar[str] = "id"

                Instances._item_type = InstancesItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "revision": {"type": int}, "instances": {"type": Instances}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                name: str | None
                revision: int | None
                """0-65535."""
                instances: Instances

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | None | UndefinedType = Undefined,
                    revision: int | None | UndefinedType = Undefined,
                    instances: Instances | UndefinedType = Undefined,
                ) -> None:
                    """
                    Configuration.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        revision: 0-65535.
                        instances: instances

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pvst_border": {"type": bool}, "configuration": {"type": Configuration}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            pvst_border: bool | None
            configuration: Configuration

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                pvst_border: bool | None | UndefinedType = Undefined,
                configuration: Configuration | UndefinedType = Undefined,
            ) -> None:
                """
                Mst.

                Args:
                -----
                    _custom_data: _custom_data
                    pvst_border: pvst_border
                    configuration: configuration

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MstInstancesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": str}, "priority": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: str
            """Instance ID."""
            priority: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: str | UndefinedType = Undefined,
                priority: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                MstInstancesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: Instance ID.
                    priority: priority

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class MstInstances(AvdCollection[str, MstInstancesItem]):
            _primary_key: ClassVar[str] = "id"

        MstInstances._item_type = MstInstancesItem

        class RapidPvstInstancesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": str}, "priority": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: str
            """
            "< vlan_id >, < vlan_id >-< vlan_id >"
            Example: 105,202,505-506
            """
            priority: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: str | UndefinedType = Undefined,
                priority: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                RapidPvstInstancesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id:
                       "< vlan_id >, < vlan_id >-< vlan_id >"
                       Example: 105,202,505-506
                    priority: priority

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class RapidPvstInstances(AvdCollection[str, RapidPvstInstancesItem]):
            _primary_key: ClassVar[str] = "id"

        RapidPvstInstances._item_type = RapidPvstInstancesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "root_super": {"type": bool},
            "edge_port": {"type": EdgePort},
            "mode": {"type": str},
            "bpduguard_rate_limit": {"type": BpduguardRateLimit},
            "rstp_priority": {"type": int},
            "mst": {"type": Mst},
            "mst_instances": {"type": MstInstances},
            "no_spanning_tree_vlan": {"type": str},
            "rapid_pvst_instances": {"type": RapidPvstInstances},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        root_super: bool | None
        edge_port: EdgePort
        mode: str | None
        bpduguard_rate_limit: BpduguardRateLimit
        rstp_priority: int | None
        mst: Mst
        mst_instances: MstInstances
        no_spanning_tree_vlan: str | None
        """
        "< vlan_id >, < vlan_id >-< vlan_id >"
        Example: 105,202,505-506
        """
        rapid_pvst_instances: RapidPvstInstances

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            root_super: bool | None | UndefinedType = Undefined,
            edge_port: EdgePort | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            bpduguard_rate_limit: BpduguardRateLimit | UndefinedType = Undefined,
            rstp_priority: int | None | UndefinedType = Undefined,
            mst: Mst | UndefinedType = Undefined,
            mst_instances: MstInstances | UndefinedType = Undefined,
            no_spanning_tree_vlan: str | None | UndefinedType = Undefined,
            rapid_pvst_instances: RapidPvstInstances | UndefinedType = Undefined,
        ) -> None:
            """
            SpanningTree.

            Args:
            -----
                _custom_data: _custom_data
                root_super: root_super
                edge_port: edge_port
                mode: mode
                bpduguard_rate_limit: bpduguard_rate_limit
                rstp_priority: rstp_priority
                mst: mst
                mst_instances: mst_instances
                no_spanning_tree_vlan:
                   "< vlan_id >, < vlan_id >-< vlan_id >"
                   Example: 105,202,505-506
                rapid_pvst_instances: rapid_pvst_instances

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class StandardAccessListsItem(AvdModel):
        class SequenceNumbersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "sequence": {"type": int}, "action": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "sequence", "action")
            _custom_data: dict[str, Any]
            sequence: int
            """Sequence ID."""
            action: str
            """
            Action as string.
            Example: "deny ip any any"
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                sequence: int | UndefinedType = Undefined,
                action: str | UndefinedType = Undefined,
            ) -> None:
                """
                SequenceNumbersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    sequence: Sequence ID.
                    action:
                       Action as string.
                       Example: "deny ip any any"

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class SequenceNumbers(AvdCollection[int, SequenceNumbersItem]):
            _primary_key: ClassVar[str] = "sequence"

        SequenceNumbers._item_type = SequenceNumbersItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "counters_per_entry": {"type": bool},
            "sequence_numbers": {"type": SequenceNumbers},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "sequence_numbers")
        _custom_data: dict[str, Any]
        name: str
        """Access-list Name."""
        counters_per_entry: bool | None
        sequence_numbers: SequenceNumbers

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            counters_per_entry: bool | None | UndefinedType = Undefined,
            sequence_numbers: SequenceNumbers | UndefinedType = Undefined,
        ) -> None:
            """
            StandardAccessListsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Access-list Name.
                counters_per_entry: counters_per_entry
                sequence_numbers: sequence_numbers

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class StandardAccessLists(AvdCollection[str, StandardAccessListsItem]):
        _primary_key: ClassVar[str] = "name"

    StandardAccessLists._item_type = StandardAccessListsItem

    class StaticRoutesItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "vrf": {"type": str},
            "destination_address_prefix": {"type": str},
            "interface": {"type": str},
            "gateway": {"type": str},
            "track_bfd": {"type": bool},
            "distance": {"type": int},
            "tag": {"type": int},
            "name": {"type": str},
            "metric": {"type": int},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        vrf: str | None
        """VRF Name."""
        destination_address_prefix: str | None
        """IPv4_network/Mask."""
        interface: str | None
        gateway: str | None
        """IPv4 Address."""
        track_bfd: bool | None
        """Track next-hop using BFD."""
        distance: int | None
        tag: int | None
        name: str | None
        """Description."""
        metric: int | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            destination_address_prefix: str | None | UndefinedType = Undefined,
            interface: str | None | UndefinedType = Undefined,
            gateway: str | None | UndefinedType = Undefined,
            track_bfd: bool | None | UndefinedType = Undefined,
            distance: int | None | UndefinedType = Undefined,
            tag: int | None | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            metric: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            StaticRoutesItem.

            Args:
            -----
                _custom_data: _custom_data
                vrf: VRF Name.
                destination_address_prefix: IPv4_network/Mask.
                interface: interface
                gateway: IPv4 Address.
                track_bfd: Track next-hop using BFD.
                distance: distance
                tag: tag
                name: Description.
                metric: metric

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Stun(AvdModel):
        class Client(AvdModel):
            class ServerProfilesItem(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "ip_address": {"type": str},
                    "ssl_profile": {"type": str},
                    "port": {"type": int},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                ip_address: str | None
                ssl_profile: str | None
                """SSL profile name."""
                port: int | None
                """Destination port for the request STUN server (default - 3478)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    ip_address: str | None | UndefinedType = Undefined,
                    ssl_profile: str | None | UndefinedType = Undefined,
                    port: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    ServerProfilesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name
                        ip_address: ip_address
                        ssl_profile: SSL profile name.
                        port: Destination port for the request STUN server (default - 3478).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class ServerProfiles(AvdCollection[str, ServerProfilesItem]):
                _primary_key: ClassVar[str] = "name"

            ServerProfiles._item_type = ServerProfilesItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "server_profiles": {"type": ServerProfiles}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            server_profiles: ServerProfiles
            """List of server profiles for the client."""

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, server_profiles: ServerProfiles | UndefinedType = Undefined
            ) -> None:
                """
                Client.

                Args:
                -----
                    _custom_data: _custom_data
                    server_profiles: List of server profiles for the client.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Server(AvdModel):
            class SslConnectionLifetime(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "minutes": {"type": int}, "hours": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                minutes: int | None
                """SSL connection lifetime in minutes (default - 120)."""
                hours: int | None
                """SSL connection lifetime in hours (default - 2)."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    minutes: int | None | UndefinedType = Undefined,
                    hours: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    SslConnectionLifetime.

                    Args:
                    -----
                        _custom_data: _custom_data
                        minutes: SSL connection lifetime in minutes (default - 120).
                        hours: SSL connection lifetime in hours (default - 2).

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "local_interfaces": {"type": list, "items": str},
                "bindings_timeout": {"type": int},
                "ssl_profile": {"type": str},
                "ssl_connection_lifetime": {"type": SslConnectionLifetime},
                "port": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            local_interfaces: list[str]
            bindings_timeout: int | None
            """Timeout for bindings stored on STUN server in seconds."""
            ssl_profile: str | None
            """SSL profile name."""
            ssl_connection_lifetime: SslConnectionLifetime
            """
            SSL connection lifetime in minutes or hours.
            If both are specified, minutes is given higher
            precedence.
            """
            port: int | None
            """Listening port for STUN server (default - 3478)."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                local_interfaces: list[str] | UndefinedType = Undefined,
                bindings_timeout: int | None | UndefinedType = Undefined,
                ssl_profile: str | None | UndefinedType = Undefined,
                ssl_connection_lifetime: SslConnectionLifetime | UndefinedType = Undefined,
                port: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Server.

                Args:
                -----
                    _custom_data: _custom_data
                    local_interfaces: local_interfaces
                    bindings_timeout: Timeout for bindings stored on STUN server in seconds.
                    ssl_profile: SSL profile name.
                    ssl_connection_lifetime:
                       SSL connection lifetime in minutes or hours.
                       If both are specified, minutes is given higher
                       precedence.
                    port: Listening port for STUN server (default - 3478).

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "client": {"type": Client}, "server": {"type": Server}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        client: Client
        """STUN client settings."""
        server: Server
        """STUN server settings."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            client: Client | UndefinedType = Undefined,
            server: Server | UndefinedType = Undefined,
        ) -> None:
            """
            Stun.

            Args:
            -----
                _custom_data: _custom_data
                client: STUN client settings.
                server: STUN server settings.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SwitchportDefault(AvdModel):
        class Phone(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "cos": {"type": int}, "trunk": {"type": str}, "vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            cos: int | None
            trunk: str | None
            vlan: int | None
            """VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                cos: int | None | UndefinedType = Undefined,
                trunk: str | None | UndefinedType = Undefined,
                vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Phone.

                Args:
                -----
                    _custom_data: _custom_data
                    cos: cos
                    trunk: trunk
                    vlan: VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "mode": {"type": str}, "phone": {"type": Phone}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mode: str | None
        phone: Phone

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            mode: str | None | UndefinedType = Undefined,
            phone: Phone | UndefinedType = Undefined,
        ) -> None:
            """
            SwitchportDefault.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode
                phone: phone

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SwitchportPortSecurity(AvdModel):
        class MacAddress(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "aging": {"type": bool}, "moveable": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            aging: bool | None
            moveable: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                aging: bool | None | UndefinedType = Undefined,
                moveable: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                MacAddress.

                Args:
                -----
                    _custom_data: _custom_data
                    aging: aging
                    moveable: moveable

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "mac_address": {"type": MacAddress},
            "persistence_disabled": {"type": bool},
            "violation_protect_chip_based": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mac_address: MacAddress
        persistence_disabled: bool | None
        violation_protect_chip_based: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            mac_address: MacAddress | UndefinedType = Undefined,
            persistence_disabled: bool | None | UndefinedType = Undefined,
            violation_protect_chip_based: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            SwitchportPortSecurity.

            Args:
            -----
                _custom_data: _custom_data
                mac_address: mac_address
                persistence_disabled: persistence_disabled
                violation_protect_chip_based: violation_protect_chip_based

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class SyncE(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "network_option": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "network_option")
        _custom_data: dict[str, Any]
        network_option: int

        def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, network_option: int | UndefinedType = Undefined) -> None:
            """
            SyncE.

            Args:
            -----
                _custom_data: _custom_data
                network_option: network_option

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class System(AvdModel):
        class ControlPlane(AvdModel):
            class TcpMss(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": int}, "ipv6": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4: int | None
                """Segment size."""
                ipv6: int | None
                """Segment size."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4: int | None | UndefinedType = Undefined,
                    ipv6: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TcpMss.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: Segment size.
                        ipv6: Segment size.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4AccessGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "acl_name": {"type": str}, "vrf": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "acl_name")
                _custom_data: dict[str, Any]
                acl_name: str
                vrf: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    acl_name: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4AccessGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        acl_name: acl_name
                        vrf: vrf

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6AccessGroupsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "acl_name": {"type": str}, "vrf": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "acl_name")
                _custom_data: dict[str, Any]
                acl_name: str
                vrf: str | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    acl_name: str | UndefinedType = Undefined,
                    vrf: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6AccessGroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        acl_name: acl_name
                        vrf: vrf

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "tcp_mss": {"type": TcpMss},
                "ipv4_access_groups": {"type": list, "items": Ipv4AccessGroupsItem},
                "ipv6_access_groups": {"type": list, "items": Ipv6AccessGroupsItem},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            tcp_mss: TcpMss
            ipv4_access_groups: list[Ipv4AccessGroupsItem]
            ipv6_access_groups: list[Ipv6AccessGroupsItem]

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                tcp_mss: TcpMss | UndefinedType = Undefined,
                ipv4_access_groups: list[Ipv4AccessGroupsItem] | UndefinedType = Undefined,
                ipv6_access_groups: list[Ipv6AccessGroupsItem] | UndefinedType = Undefined,
            ) -> None:
                """
                ControlPlane.

                Args:
                -----
                    _custom_data: _custom_data
                    tcp_mss: tcp_mss
                    ipv4_access_groups: ipv4_access_groups
                    ipv6_access_groups: ipv6_access_groups

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class L1(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "unsupported_speed_action": {"type": str},
                "unsupported_error_correction_action": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            unsupported_speed_action: str | None
            unsupported_error_correction_action: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                unsupported_speed_action: str | None | UndefinedType = Undefined,
                unsupported_error_correction_action: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                L1.

                Args:
                -----
                    _custom_data: _custom_data
                    unsupported_speed_action: unsupported_speed_action
                    unsupported_error_correction_action: unsupported_error_correction_action

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "control_plane": {"type": ControlPlane}, "l1": {"type": L1}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        control_plane: ControlPlane
        l1: L1

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            control_plane: ControlPlane | UndefinedType = Undefined,
            l1: L1 | UndefinedType = Undefined,
        ) -> None:
            """
            System.

            Args:
            -----
                _custom_data: _custom_data
                control_plane: control_plane
                l1: l1

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TacacsServers(AvdModel):
        class HostsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "host": {"type": str},
                "vrf": {"type": str},
                "key": {"type": str},
                "key_type": {"type": str, "default": "7"},
                "single_connection": {"type": bool},
                "timeout": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            host: str | None
            """Host IP address or name."""
            vrf: str | None
            key: str | None
            """Encrypted key."""
            key_type: str | None
            single_connection: bool | None
            timeout: int | None
            """Timeout in seconds."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                host: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
                key_type: str | None | UndefinedType = Undefined,
                single_connection: bool | None | UndefinedType = Undefined,
                timeout: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                HostsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    host: Host IP address or name.
                    vrf: vrf
                    key: Encrypted key.
                    key_type: key_type
                    single_connection: single_connection
                    timeout: Timeout in seconds.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "timeout": {"type": int},
            "hosts": {"type": list, "items": HostsItem},
            "policy_unknown_mandatory_attribute_ignore": {"type": bool},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        timeout: int | None
        """Timeout in seconds."""
        hosts: list[HostsItem]
        policy_unknown_mandatory_attribute_ignore: bool | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            timeout: int | None | UndefinedType = Undefined,
            hosts: list[HostsItem] | UndefinedType = Undefined,
            policy_unknown_mandatory_attribute_ignore: bool | None | UndefinedType = Undefined,
        ) -> None:
            """
            TacacsServers.

            Args:
            -----
                _custom_data: _custom_data
                timeout: Timeout in seconds.
                hosts: hosts
                policy_unknown_mandatory_attribute_ignore: policy_unknown_mandatory_attribute_ignore

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TapAggregation(AvdModel):
        class Mode(AvdModel):
            class Exclusive(AvdModel):
                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "enabled": {"type": bool},
                    "profile": {"type": str},
                    "no_errdisable": {"type": list, "items": str},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                enabled: bool | None
                profile: str | None
                """Profile Name."""
                no_errdisable: list[str]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | None | UndefinedType = Undefined,
                    profile: str | None | UndefinedType = Undefined,
                    no_errdisable: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Exclusive.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        profile: Profile Name.
                        no_errdisable: no_errdisable

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "exclusive": {"type": Exclusive}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            exclusive: Exclusive

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, exclusive: Exclusive | UndefinedType = Undefined) -> None:
                """
                Mode.

                Args:
                -----
                    _custom_data: _custom_data
                    exclusive: exclusive

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Mac(AvdModel):
            class Timestamp(AvdModel):
                class Header(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "format": {"type": str}, "eth_type": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    format: str | None
                    eth_type: int | None
                    """EtherType."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        format: str | None | UndefinedType = Undefined,
                        eth_type: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Header.

                        Args:
                        -----
                            _custom_data: _custom_data
                            format: format
                            eth_type: EtherType.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "replace_source_mac": {"type": bool}, "header": {"type": Header}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                replace_source_mac: bool | None
                header: Header

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    replace_source_mac: bool | None | UndefinedType = Undefined,
                    header: Header | UndefinedType = Undefined,
                ) -> None:
                    """
                    Timestamp.

                    Args:
                    -----
                        _custom_data: _custom_data
                        replace_source_mac: replace_source_mac
                        header: header

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "timestamp": {"type": Timestamp},
                "fcs_append": {"type": bool},
                "fcs_error": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            timestamp: Timestamp
            """
            mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
            defined, replace_source_mac takes precedence.
            """
            fcs_append: bool | None
            """
            mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
            precedence.
            """
            fcs_error: str | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                timestamp: Timestamp | UndefinedType = Undefined,
                fcs_append: bool | None | UndefinedType = Undefined,
                fcs_error: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Mac.

                Args:
                -----
                    _custom_data: _custom_data
                    timestamp:
                       mac.timestamp.replace_source_mac and mac.timestamp.header.format are mutually exclsuive. If both are
                       defined, replace_source_mac takes precedence.
                    fcs_append:
                       mac.fcs_append and mac.fcs_error are mutually exclusive. If both are defined, mac.fcs_append takes
                       precedence.
                    fcs_error: fcs_error

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "mode": {"type": Mode},
            "encapsulation_dot1br_strip": {"type": bool},
            "encapsulation_vn_tag_strip": {"type": bool},
            "protocol_lldp_trap": {"type": bool},
            "truncation_size": {"type": int},
            "mac": {"type": Mac},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        mode: Mode
        encapsulation_dot1br_strip: bool | None
        encapsulation_vn_tag_strip: bool | None
        protocol_lldp_trap: bool | None
        truncation_size: int | None
        """Allowed truncation_size values vary depending on the platform."""
        mac: Mac

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            mode: Mode | UndefinedType = Undefined,
            encapsulation_dot1br_strip: bool | None | UndefinedType = Undefined,
            encapsulation_vn_tag_strip: bool | None | UndefinedType = Undefined,
            protocol_lldp_trap: bool | None | UndefinedType = Undefined,
            truncation_size: int | None | UndefinedType = Undefined,
            mac: Mac | UndefinedType = Undefined,
        ) -> None:
            """
            TapAggregation.

            Args:
            -----
                _custom_data: _custom_data
                mode: mode
                encapsulation_dot1br_strip: encapsulation_dot1br_strip
                encapsulation_vn_tag_strip: encapsulation_vn_tag_strip
                protocol_lldp_trap: protocol_lldp_trap
                truncation_size: Allowed truncation_size values vary depending on the platform.
                mac: mac

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TcamProfile(AvdModel):
        class ProfilesItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "config": {"type": str}, "source": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Tcam-Profile Name."""
            config: str | None
            """
            TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
            a file.
            Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
            """
            source: str | None
            """
            TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
            device.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                config: str | None | UndefinedType = Undefined,
                source: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                ProfilesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Tcam-Profile Name.
                    config:
                       TCAM Profile Config. Since these can be very long, it is often a good idea to import the config from
                       a file.
                       Example: "{{ lookup('file', 'TCAM_TRAFFIC_POLICY.conf') }}"
                    source:
                       TCAM profile local source path. Used to read the TCAM profile from a local path existing on the
                       device.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Profiles(AvdCollection[str, ProfilesItem]):
            _primary_key: ClassVar[str] = "name"

        Profiles._item_type = ProfilesItem

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "system": {"type": str}, "profiles": {"type": Profiles}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        system: str | None
        """TCAM profile name to activate."""
        profiles: Profiles

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            system: str | None | UndefinedType = Undefined,
            profiles: Profiles | UndefinedType = Undefined,
        ) -> None:
            """
            TcamProfile.

            Args:
            -----
                _custom_data: _custom_data
                system: TCAM profile name to activate.
                profiles: profiles

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Terminal(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "length": {"type": int}, "width": {"type": int}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        length: int | None
        width: int | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            length: int | None | UndefinedType = Undefined,
            width: int | None | UndefinedType = Undefined,
        ) -> None:
            """
            Terminal.

            Args:
            -----
                _custom_data: _custom_data
                length: length
                width: width

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TrackersItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "interface": {"type": str},
            "tracked_property": {"type": str, "default": "line-protocol"},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name", "interface")
        _custom_data: dict[str, Any]
        name: str
        """Name of tracker object."""
        interface: str
        """Name of tracked interface."""
        tracked_property: str | None
        """Property to track."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            interface: str | UndefinedType = Undefined,
            tracked_property: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            TrackersItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Name of tracker object.
                interface: Name of tracked interface.
                tracked_property: Property to track.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Trackers(AvdCollection[str, TrackersItem]):
        _primary_key: ClassVar[str] = "name"

    Trackers._item_type = TrackersItem

    class TrafficPolicies(AvdModel):
        class Options(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "counter_per_interface": {"type": bool}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            counter_per_interface: bool | None

            def __init__(
                self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, counter_per_interface: bool | None | UndefinedType = Undefined
            ) -> None:
                """
                Options.

                Args:
                -----
                    _custom_data: _custom_data
                    counter_per_interface: counter_per_interface

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class FieldSets(AvdModel):
            class Ipv4Item(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "prefixes": {"type": list, "items": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """IPv4 Prefix Field Set Name."""
                prefixes: list[str]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    prefixes: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4Item.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv4 Prefix Field Set Name.
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv4(AvdCollection[str, Ipv4Item]):
                _primary_key: ClassVar[str] = "name"

            Ipv4._item_type = Ipv4Item

            class Ipv6Item(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "prefixes": {"type": list, "items": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """IPv6 Prefix Field Set Name."""
                prefixes: list[str]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    prefixes: list[str] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6Item.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: IPv6 Prefix Field Set Name.
                        prefixes: prefixes

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdCollection[str, Ipv6Item]):
                _primary_key: ClassVar[str] = "name"

            Ipv6._item_type = Ipv6Item

            class PortsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "port_range": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """L4 Port Field Set Name."""
                port_range: str | None
                """Example: '10,20,80,440-450'"""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    port_range: str | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    PortsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: L4 Port Field Set Name.
                        port_range: Example: '10,20,80,440-450'

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ports(AvdCollection[str, PortsItem]):
                _primary_key: ClassVar[str] = "name"

            Ports._item_type = PortsItem

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}, "ports": {"type": Ports}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: Ipv4
            ipv6: Ipv6
            ports: Ports

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: Ipv4 | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
                ports: Ports | UndefinedType = Undefined,
            ) -> None:
                """
                FieldSets.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6
                    ports: ports

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class PoliciesItem(AvdModel):
            class MatchesItem(AvdModel):
                class Source(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "prefixes": {"type": list, "items": str},
                        "prefix_lists": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    prefixes: list[str]
                    prefix_lists: list[str]
                    """Field-set prefix lists."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefixes: list[str] | UndefinedType = Undefined,
                        prefix_lists: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Source.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefixes: prefixes
                            prefix_lists: Field-set prefix lists.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Destination(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "prefixes": {"type": list, "items": str},
                        "prefix_lists": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    prefixes: list[str]
                    prefix_lists: list[str]
                    """Field-set prefix lists."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        prefixes: list[str] | UndefinedType = Undefined,
                        prefix_lists: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Destination.

                        Args:
                        -----
                            _custom_data: _custom_data
                            prefixes: prefixes
                            prefix_lists: Field-set prefix lists.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Fragment(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "offset": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    offset: str | None
                    """Fragment offset range."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, offset: str | None | UndefinedType = Undefined) -> None:
                        """
                        Fragment.

                        Args:
                        -----
                            _custom_data: _custom_data
                            offset: Fragment offset range.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ProtocolsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "protocol": {"type": str},
                        "src_port": {"type": str},
                        "dst_port": {"type": str},
                        "src_field": {"type": str},
                        "dst_field": {"type": str},
                        "flags": {"type": list, "items": str},
                        "icmp_type": {"type": list, "items": str},
                        "enforce_gtsm": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "protocol")
                    _custom_data: dict[str, Any]
                    protocol: str
                    src_port: str | None
                    """Port range."""
                    dst_port: str | None
                    """Port range."""
                    src_field: str | None
                    """L4 port range field set."""
                    dst_field: str | None
                    """L4 port range field set."""
                    flags: list[str]
                    icmp_type: list[str]
                    enforce_gtsm: bool | None
                    """Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        protocol: str | UndefinedType = Undefined,
                        src_port: str | None | UndefinedType = Undefined,
                        dst_port: str | None | UndefinedType = Undefined,
                        src_field: str | None | UndefinedType = Undefined,
                        dst_field: str | None | UndefinedType = Undefined,
                        flags: list[str] | UndefinedType = Undefined,
                        icmp_type: list[str] | UndefinedType = Undefined,
                        enforce_gtsm: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        ProtocolsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            protocol: protocol
                            src_port: Port range.
                            dst_port: Port range.
                            src_field: L4 port range field set.
                            dst_field: L4 port range field set.
                            flags: flags
                            icmp_type: icmp_type
                            enforce_gtsm: Enforce the GTSM for BGP speakers. Only supported when protocol is set to 'neighbors'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Protocols(AvdCollection[str, ProtocolsItem]):
                    _primary_key: ClassVar[str] = "protocol"

                Protocols._item_type = ProtocolsItem

                class Actions(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        dscp: int | None | UndefinedType = Undefined,
                        traffic_class: int | None | UndefinedType = Undefined,
                        count: str | None | UndefinedType = Undefined,
                        drop: bool | None | UndefinedType = Undefined,
                        log: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Actions.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp: dscp
                            traffic_class: Traffic class ID.
                            count: Counter name.
                            drop: drop
                            log: Only supported when action is set to drop.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "name": {"type": str},
                    "type": {"type": str},
                    "source": {"type": Source},
                    "destination": {"type": Destination},
                    "ttl": {"type": str},
                    "fragment": {"type": Fragment},
                    "protocols": {"type": Protocols},
                    "actions": {"type": Actions},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data", "name", "type")
                _custom_data: dict[str, Any]
                name: str
                """Traffic Policy Item."""
                type: str
                source: Source
                destination: Destination
                ttl: str | None
                """TTL range."""
                fragment: Fragment
                """
                The 'fragment' command is not supported when 'source port'
                or 'destination port' command is
                configured.
                """
                protocols: Protocols
                actions: Actions

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    type: str | UndefinedType = Undefined,
                    source: Source | UndefinedType = Undefined,
                    destination: Destination | UndefinedType = Undefined,
                    ttl: str | None | UndefinedType = Undefined,
                    fragment: Fragment | UndefinedType = Undefined,
                    protocols: Protocols | UndefinedType = Undefined,
                    actions: Actions | UndefinedType = Undefined,
                ) -> None:
                    """
                    MatchesItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Traffic Policy Item.
                        type: type
                        source: source
                        destination: destination
                        ttl: TTL range.
                        fragment:
                           The 'fragment' command is not supported when 'source port'
                           or 'destination port' command is
                           configured.
                        protocols: protocols
                        actions: actions

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Matches(AvdCollection[str, MatchesItem]):
                _primary_key: ClassVar[str] = "name"

            Matches._item_type = MatchesItem

            class DefaultActions(AvdModel):
                class Ipv4(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        dscp: int | None | UndefinedType = Undefined,
                        traffic_class: int | None | UndefinedType = Undefined,
                        count: str | None | UndefinedType = Undefined,
                        drop: bool | None | UndefinedType = Undefined,
                        log: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv4.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp: dscp
                            traffic_class: Traffic class ID.
                            count: Counter name.
                            drop: drop
                            log: Only supported when action is set to drop.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Ipv6(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "dscp": {"type": int},
                        "traffic_class": {"type": int},
                        "count": {"type": str},
                        "drop": {"type": bool},
                        "log": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    dscp: int | None
                    traffic_class: int | None
                    """Traffic class ID."""
                    count: str | None
                    """Counter name."""
                    drop: bool | None
                    log: bool | None
                    """Only supported when action is set to drop."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        dscp: int | None | UndefinedType = Undefined,
                        traffic_class: int | None | UndefinedType = Undefined,
                        count: str | None | UndefinedType = Undefined,
                        drop: bool | None | UndefinedType = Undefined,
                        log: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Ipv6.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp: dscp
                            traffic_class: Traffic class ID.
                            count: Counter name.
                            drop: drop
                            log: Only supported when action is set to drop.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                ipv4: Ipv4
                ipv6: Ipv6

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    ipv4: Ipv4 | UndefinedType = Undefined,
                    ipv6: Ipv6 | UndefinedType = Undefined,
                ) -> None:
                    """
                    DefaultActions.

                    Args:
                    -----
                        _custom_data: _custom_data
                        ipv4: ipv4
                        ipv6: ipv6

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "name": {"type": str},
                "matches": {"type": Matches},
                "default_actions": {"type": DefaultActions},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "name")
            _custom_data: dict[str, Any]
            name: str
            """Traffic Policy Name."""
            matches: Matches
            default_actions: DefaultActions

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                name: str | UndefinedType = Undefined,
                matches: Matches | UndefinedType = Undefined,
                default_actions: DefaultActions | UndefinedType = Undefined,
            ) -> None:
                """
                PoliciesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    name: Traffic Policy Name.
                    matches: matches
                    default_actions: default_actions

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Policies(AvdCollection[str, PoliciesItem]):
            _primary_key: ClassVar[str] = "name"

        Policies._item_type = PoliciesItem

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "options": {"type": Options},
            "field_sets": {"type": FieldSets},
            "policies": {"type": Policies},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        options: Options
        field_sets: FieldSets
        policies: Policies

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            options: Options | UndefinedType = Undefined,
            field_sets: FieldSets | UndefinedType = Undefined,
            policies: Policies | UndefinedType = Undefined,
        ) -> None:
            """
            TrafficPolicies.

            Args:
            -----
                _custom_data: _custom_data
                options: options
                field_sets: field_sets
                policies: policies

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TunnelInterfacesItem(AvdModel):
        class TcpMssCeiling(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": int}, "ipv6": {"type": int}, "direction": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: int | None
            """Segment Size for IPv4."""
            ipv6: int | None
            """Segment Size for IPv6."""
            direction: str | None
            """Optional direction ('ingress', 'egress')  for tcp mss ceiling."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: int | None | UndefinedType = Undefined,
                ipv6: int | None | UndefinedType = Undefined,
                direction: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                TcpMssCeiling.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: Segment Size for IPv4.
                    ipv6: Segment Size for IPv6.
                    direction: Optional direction ('ingress', 'egress')  for tcp mss ceiling.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "shutdown": {"type": bool},
            "mtu": {"type": int},
            "vrf": {"type": str},
            "underlay_vrf": {"type": str},
            "ip_address": {"type": str},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "tcp_mss_ceiling": {"type": TcpMssCeiling},
            "tunnel_mode": {"type": str},
            "source_interface": {"type": str},
            "destination": {"type": str},
            "path_mtu_discovery": {"type": bool},
            "ipsec_profile": {"type": str},
            "nat_profile": {"type": str},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Tunnel Interface Name."""
        description: str | None
        shutdown: bool | None
        mtu: int | None
        vrf: str | None
        """VRF Name."""
        underlay_vrf: str | None
        """Underlay VRF Name."""
        ip_address: str | None
        """IPv4_address/Mask."""
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        access_group_in: str | None
        """IPv4 ACL Name for ingress."""
        access_group_out: str | None
        """IPv4 ACL Name for egress."""
        ipv6_access_group_in: str | None
        """IPv6 ACL Name for ingress."""
        ipv6_access_group_out: str | None
        """IPv6 ACL Name for egress."""
        tcp_mss_ceiling: TcpMssCeiling
        tunnel_mode: str | None
        """
        Tunnel encapsulation method.
        `gre`: Generic route encapsulation protocol,
        `ipsec`: IPsec-over-IP
        encapsulation.
        """
        source_interface: str | None
        """Tunnel Source Interface Name."""
        destination: str | None
        """IPv4 or IPv6 Address Tunnel Destination."""
        path_mtu_discovery: bool | None
        """Enable Path MTU Discovery On Tunnel."""
        ipsec_profile: str | None
        """
        Used only when `tunnel_mode` is set to `ipsec`.
        It must target a defined IPsec profile.
        """
        nat_profile: str | None
        """NAT interface profile."""
        eos_cli: str | None
        """
        Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
        configuration.
        """

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            underlay_vrf: str | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            access_group_in: str | None | UndefinedType = Undefined,
            access_group_out: str | None | UndefinedType = Undefined,
            ipv6_access_group_in: str | None | UndefinedType = Undefined,
            ipv6_access_group_out: str | None | UndefinedType = Undefined,
            tcp_mss_ceiling: TcpMssCeiling | UndefinedType = Undefined,
            tunnel_mode: str | None | UndefinedType = Undefined,
            source_interface: str | None | UndefinedType = Undefined,
            destination: str | None | UndefinedType = Undefined,
            path_mtu_discovery: bool | None | UndefinedType = Undefined,
            ipsec_profile: str | None | UndefinedType = Undefined,
            nat_profile: str | None | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            TunnelInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Tunnel Interface Name.
                description: description
                shutdown: shutdown
                mtu: mtu
                vrf: VRF Name.
                underlay_vrf: Underlay VRF Name.
                ip_address: IPv4_address/Mask.
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                access_group_in: IPv4 ACL Name for ingress.
                access_group_out: IPv4 ACL Name for egress.
                ipv6_access_group_in: IPv6 ACL Name for ingress.
                ipv6_access_group_out: IPv6 ACL Name for egress.
                tcp_mss_ceiling: tcp_mss_ceiling
                tunnel_mode:
                   Tunnel encapsulation method.
                   `gre`: Generic route encapsulation protocol,
                   `ipsec`: IPsec-over-IP
                   encapsulation.
                source_interface: Tunnel Source Interface Name.
                destination: IPv4 or IPv6 Address Tunnel Destination.
                path_mtu_discovery: Enable Path MTU Discovery On Tunnel.
                ipsec_profile:
                   Used only when `tunnel_mode` is set to `ipsec`.
                   It must target a defined IPsec profile.
                nat_profile: NAT interface profile.
                eos_cli:
                   Multiline String with EOS CLI rendered directly on the Tunnel interface in the final EOS
                   configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class TunnelInterfaces(AvdCollection[str, TunnelInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    TunnelInterfaces._item_type = TunnelInterfacesItem

    class VirtualSourceNatVrfsItem(AvdModel):
        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "ip_address": {"type": str}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """VRF Name."""
        ip_address: str | None
        """IPv4 Address."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            VirtualSourceNatVrfsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: VRF Name.
                ip_address: IPv4 Address.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VirtualSourceNatVrfs(AvdCollection[str, VirtualSourceNatVrfsItem]):
        _primary_key: ClassVar[str] = "name"

    VirtualSourceNatVrfs._item_type = VirtualSourceNatVrfsItem

    class VlanInterfacesItem(AvdModel):
        class Logging(AvdModel):
            class Event(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "link_status": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                link_status: bool | None

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, link_status: bool | None | UndefinedType = Undefined) -> None:
                    """
                    Event.

                    Args:
                    -----
                        _custom_data: _custom_data
                        link_status: link_status

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "event": {"type": Event}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            event: Event

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, event: Event | UndefinedType = Undefined) -> None:
                """
                Logging.

                Args:
                -----
                    _custom_data: _custom_data
                    event: event

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpIgmpHostProxy(AvdModel):
            class GroupsItem(AvdModel):
                class ExcludeItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source")
                    _custom_data: dict[str, Any]
                    source: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source: str | UndefinedType = Undefined) -> None:
                        """
                        ExcludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Exclude(AvdCollection[str, ExcludeItem]):
                    _primary_key: ClassVar[str] = "source"

                Exclude._item_type = ExcludeItem

                class IncludeItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "source": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "source")
                    _custom_data: dict[str, Any]
                    source: str

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, source: str | UndefinedType = Undefined) -> None:
                        """
                        IncludeItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            source: source

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Include(AvdCollection[str, IncludeItem]):
                    _primary_key: ClassVar[str] = "source"

                Include._item_type = IncludeItem

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "group": {"type": str}, "exclude": {"type": Exclude}, "include": {"type": Include}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "group")
                _custom_data: dict[str, Any]
                group: str
                """Multicast Address."""
                exclude: Exclude
                """The same source must not be present both in `exclude` and `include` list."""
                include: Include
                """The same source must not be present both in `exclude` and `include` list."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    group: str | UndefinedType = Undefined,
                    exclude: Exclude | UndefinedType = Undefined,
                    include: Include | UndefinedType = Undefined,
                ) -> None:
                    """
                    GroupsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        group: Multicast Address.
                        exclude: The same source must not be present both in `exclude` and `include` list.
                        include: The same source must not be present both in `exclude` and `include` list.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Groups(AvdCollection[str, GroupsItem]):
                _primary_key: ClassVar[str] = "group"

            Groups._item_type = GroupsItem

            class AccessListsItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, name: str | UndefinedType = Undefined) -> None:
                    """
                    AccessListsItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: name

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class AccessLists(AvdCollection[str, AccessListsItem]):
                _primary_key: ClassVar[str] = "name"

            AccessLists._item_type = AccessListsItem

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "enabled": {"type": bool},
                "groups": {"type": Groups},
                "report_interval": {"type": int},
                "access_lists": {"type": AccessLists},
                "version": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            enabled: bool | None
            groups: Groups
            report_interval: int | None
            """Time interval between unsolicited reports."""
            access_lists: AccessLists
            """Non-standard Access List name."""
            version: int | None
            """IGMP version on IGMP host-proxy interface."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | None | UndefinedType = Undefined,
                groups: Groups | UndefinedType = Undefined,
                report_interval: int | None | UndefinedType = Undefined,
                access_lists: AccessLists | UndefinedType = Undefined,
                version: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpIgmpHostProxy.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    groups: groups
                    report_interval: Time interval between unsolicited reports.
                    access_lists: Non-standard Access List name.
                    version: IGMP version on IGMP host-proxy interface.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpersItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ip_helper": {"type": str}, "source_interface": {"type": str}, "vrf": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "ip_helper")
            _custom_data: dict[str, Any]
            ip_helper: str
            """IP address or hostname of DHCP server."""
            source_interface: str | None
            """Interface used as source for forwarded DHCP packets."""
            vrf: str | None
            """VRF where DHCP server can be reached."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ip_helper: str | UndefinedType = Undefined,
                source_interface: str | None | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpHelpersItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ip_helper: IP address or hostname of DHCP server.
                    source_interface: Interface used as source for forwarded DHCP packets.
                    vrf: VRF where DHCP server can be reached.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IpHelpers(AvdCollection[str, IpHelpersItem]):
            _primary_key: ClassVar[str] = "ip_helper"

        IpHelpers._item_type = IpHelpersItem

        class IpNat(AvdModel):
            class Destination(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "pool_name")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    pool_name: str
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        pool_name: str | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            pool_name: pool_name
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Destination.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Source(AvdModel):
                class DynamicItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "nat_type": {"type": str},
                        "pool_name": {"type": str},
                        "priority": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "access_list", "nat_type")
                    _custom_data: dict[str, Any]
                    access_list: str
                    comment: str | None
                    nat_type: str
                    pool_name: str | None
                    """
                    required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                    ignored if 'nat_type' is
                    overload.
                    """
                    priority: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        nat_type: str | UndefinedType = Undefined,
                        pool_name: str | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        DynamicItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: access_list
                            comment: comment
                            nat_type: nat_type
                            pool_name:
                               required if 'nat_type' is pool, pool-address-only or pool-full-cone.
                               ignored if 'nat_type' is
                               overload.
                            priority: priority

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Dynamic(AvdCollection[str, DynamicItem]):
                    _primary_key: ClassVar[str] = "access_list"

                Dynamic._item_type = DynamicItem

                class StaticItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "access_list": {"type": str},
                        "comment": {"type": str},
                        "direction": {"type": str},
                        "group": {"type": int},
                        "original_ip": {"type": str},
                        "original_port": {"type": int},
                        "priority": {"type": int},
                        "protocol": {"type": str},
                        "translated_ip": {"type": str},
                        "translated_port": {"type": int},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "translated_ip")
                    _custom_data: dict[str, Any]
                    access_list: str | None
                    """'access_list' and 'group' are mutual exclusive."""
                    comment: str | None
                    direction: str | None
                    """
                    Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                    platform.
                    EOS might remove this keyword in the configuration. So, check the configuration on
                    targeted HW/SW.
                    """
                    group: int | None
                    """'access_list' and 'group' are mutual exclusive."""
                    original_ip: str | None
                    """IPv4 address. The combination of `original_ip` and `original_port` must be unique."""
                    original_port: int | None
                    """TCP/UDP port. The combination of `original_ip` and `original_port` must be unique."""
                    priority: int | None
                    protocol: str | None
                    translated_ip: str
                    """IPv4 address."""
                    translated_port: int | None
                    """requires 'original_port'."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        access_list: str | None | UndefinedType = Undefined,
                        comment: str | None | UndefinedType = Undefined,
                        direction: str | None | UndefinedType = Undefined,
                        group: int | None | UndefinedType = Undefined,
                        original_ip: str | None | UndefinedType = Undefined,
                        original_port: int | None | UndefinedType = Undefined,
                        priority: int | None | UndefinedType = Undefined,
                        protocol: str | None | UndefinedType = Undefined,
                        translated_ip: str | UndefinedType = Undefined,
                        translated_port: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        StaticItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            access_list: 'access_list' and 'group' are mutual exclusive.
                            comment: comment
                            direction:
                               Egress or ingress can be the default. This depends on source/destination, EOS version, and hardware
                               platform.
                               EOS might remove this keyword in the configuration. So, check the configuration on
                               targeted HW/SW.
                            group: 'access_list' and 'group' are mutual exclusive.
                            original_ip: IPv4 address. The combination of `original_ip` and `original_port` must be unique.
                            original_port: TCP/UDP port. The combination of `original_ip` and `original_port` must be unique.
                            priority: priority
                            protocol: protocol
                            translated_ip: IPv4 address.
                            translated_port: requires 'original_port'.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "dynamic": {"type": Dynamic}, "static": {"type": list, "items": StaticItem}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                dynamic: Dynamic
                static: list[StaticItem]

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    dynamic: Dynamic | UndefinedType = Undefined,
                    static: list[StaticItem] | UndefinedType = Undefined,
                ) -> None:
                    """
                    Source.

                    Args:
                    -----
                        _custom_data: _custom_data
                        dynamic: dynamic
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "destination": {"type": Destination}, "source": {"type": Source}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            destination: Destination
            source: Source

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                destination: Destination | UndefinedType = Undefined,
                source: Source | UndefinedType = Undefined,
            ) -> None:
                """
                IpNat.

                Args:
                -----
                    _custom_data: _custom_data
                    destination: destination
                    source: source

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdCache(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "dynamic_capacity": {"type": int},
                "expire": {"type": int},
                "refresh_always": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            dynamic_capacity: int | None
            """Capacity of dynamic cache entries."""
            expire: int | None
            """Cache entries expirery in seconds."""
            refresh_always: bool | None
            """Force refresh on cache expiry."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                dynamic_capacity: int | None | UndefinedType = Undefined,
                expire: int | None | UndefinedType = Undefined,
                refresh_always: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6NdCache.

                Args:
                -----
                    _custom_data: _custom_data
                    dynamic_capacity: Capacity of dynamic cache entries.
                    expire: Cache entries expirery in seconds.
                    refresh_always: Force refresh on cache expiry.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixesItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "ipv6_prefix": {"type": str},
                "valid_lifetime": {"type": str},
                "preferred_lifetime": {"type": str},
                "no_autoconfig_flag": {"type": bool},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "ipv6_prefix")
            _custom_data: dict[str, Any]
            ipv6_prefix: str
            """IPv6_address/Mask."""
            valid_lifetime: str | None
            """In seconds <0-4294967295> or infinite."""
            preferred_lifetime: str | None
            """In seconds <0-4294967295> or infinite."""
            no_autoconfig_flag: bool | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv6_prefix: str | UndefinedType = Undefined,
                valid_lifetime: str | None | UndefinedType = Undefined,
                preferred_lifetime: str | None | UndefinedType = Undefined,
                no_autoconfig_flag: bool | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6NdPrefixesItem.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv6_prefix: IPv6_address/Mask.
                    valid_lifetime: In seconds <0-4294967295> or infinite.
                    preferred_lifetime: In seconds <0-4294967295> or infinite.
                    no_autoconfig_flag: no_autoconfig_flag

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6NdPrefixes(AvdCollection[str, Ipv6NdPrefixesItem]):
            _primary_key: ClassVar[str] = "ipv6_prefix"

        Ipv6NdPrefixes._item_type = Ipv6NdPrefixesItem

        class Ipv6DhcpRelayDestinationsItem(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "address": {"type": str},
                "vrf": {"type": str},
                "local_interface": {"type": str},
                "source_address": {"type": str},
                "link_address": {"type": str},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "address")
            _custom_data: dict[str, Any]
            address: str
            """DHCP server's IPv6 address."""
            vrf: str | None
            local_interface: str | None
            """Local interface to communicate with DHCP server - mutually exclusive to source_address."""
            source_address: str | None
            """Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface."""
            link_address: str | None
            """Override the default link address specified in the relayed DHCP packet."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                address: str | UndefinedType = Undefined,
                vrf: str | None | UndefinedType = Undefined,
                local_interface: str | None | UndefinedType = Undefined,
                source_address: str | None | UndefinedType = Undefined,
                link_address: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6DhcpRelayDestinationsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    address: DHCP server's IPv6 address.
                    vrf: vrf
                    local_interface: Local interface to communicate with DHCP server - mutually exclusive to source_address.
                    source_address: Source IPv6 address to communicate with DHCP server - mutually exclusive to local_interface.
                    link_address: Override the default link address specified in the relayed DHCP packet.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6DhcpRelayDestinations(AvdCollection[str, Ipv6DhcpRelayDestinationsItem]):
            _primary_key: ClassVar[str] = "address"

        Ipv6DhcpRelayDestinations._item_type = Ipv6DhcpRelayDestinationsItem

        class Multicast(AvdModel):
            class Ipv4(AvdModel):
                class BoundariesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "boundary": {"type": str}, "out": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "boundary")
                    _custom_data: dict[str, Any]
                    boundary: str
                    """IPv4 access-list name or IPv4 multicast group prefix with mask."""
                    out: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        boundary: str | UndefinedType = Undefined,
                        out: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: IPv4 access-list name or IPv4 multicast group prefix with mask.
                            out: out

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Boundaries(AvdCollection[str, BoundariesItem]):
                    _primary_key: ClassVar[str] = "boundary"

                Boundaries._item_type = BoundariesItem

                class SourceRouteExport(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "administrative_distance": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    administrative_distance: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        administrative_distance: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SourceRouteExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            administrative_distance: administrative_distance

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "boundaries": {"type": Boundaries},
                    "source_route_export": {"type": SourceRouteExport},
                    "static": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                boundaries: Boundaries
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.
                """
                source_route_export: SourceRouteExport
                static: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    boundaries: Boundaries | UndefinedType = Undefined,
                    source_route_export: SourceRouteExport | UndefinedType = Undefined,
                    static: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries:
                           Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                           of both.
                        source_route_export: source_route_export
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdModel):
                class BoundariesItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "boundary": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "boundary")
                    _custom_data: dict[str, Any]
                    boundary: str
                    """IPv6 access-list name or IPv6 multicast group prefix with mask."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, boundary: str | UndefinedType = Undefined) -> None:
                        """
                        BoundariesItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            boundary: IPv6 access-list name or IPv6 multicast group prefix with mask.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Boundaries(AvdCollection[str, BoundariesItem]):
                    _primary_key: ClassVar[str] = "boundary"

                Boundaries._item_type = BoundariesItem

                class SourceRouteExport(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "administrative_distance": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                    _custom_data: dict[str, Any]
                    enabled: bool
                    administrative_distance: int | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        enabled: bool | UndefinedType = Undefined,
                        administrative_distance: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SourceRouteExport.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled
                            administrative_distance: administrative_distance

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "boundaries": {"type": Boundaries},
                    "source_route_export": {"type": SourceRouteExport},
                    "static": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                boundaries: Boundaries
                """
                Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                of both.
                """
                source_route_export: SourceRouteExport
                static: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    boundaries: Boundaries | UndefinedType = Undefined,
                    source_route_export: SourceRouteExport | UndefinedType = Undefined,
                    static: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        boundaries:
                           Boundaries can be either 1 ACL or a list of multicast IP address_range(s)/prefix but not combination
                           of both.
                        source_route_export: source_route_export
                        static: static

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}, "ipv6": {"type": Ipv6}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: Ipv4
            ipv6: Ipv6

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                ipv4: Ipv4 | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
            ) -> None:
                """
                Multicast.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeysItem(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "id": {"type": int}, "hash_algorithm": {"type": str}, "key": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            hash_algorithm: str | None
            key: str | None
            """Encrypted password."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                hash_algorithm: str | None | UndefinedType = Undefined,
                key: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                OspfMessageDigestKeysItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: id
                    hash_algorithm: hash_algorithm
                    key: Encrypted password.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class OspfMessageDigestKeys(AvdCollection[int, OspfMessageDigestKeysItem]):
            _primary_key: ClassVar[str] = "id"

        OspfMessageDigestKeys._item_type = OspfMessageDigestKeysItem

        class Pim(AvdModel):
            class Ipv4(AvdModel):
                class Hello(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "count": {"type": str}, "interval": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    count: str | None
                    """Number of missed hellos after which the neighbor expires. Range <1.5-65535>."""
                    interval: int | None
                    """PIM hello interval in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        count: str | None | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Hello.

                        Args:
                        -----
                            _custom_data: _custom_data
                            count: Number of missed hellos after which the neighbor expires. Range <1.5-65535>.
                            interval: PIM hello interval in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "border_router": {"type": bool},
                    "dr_priority": {"type": int},
                    "sparse_mode": {"type": bool},
                    "local_interface": {"type": str},
                    "bfd": {"type": bool},
                    "bidirectional": {"type": bool},
                    "hello": {"type": Hello},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                border_router: bool | None
                """Configure PIM border router. EOS default is false."""
                dr_priority: int | None
                sparse_mode: bool | None
                local_interface: str | None
                bfd: bool | None
                """Set the default for whether Bidirectional Forwarding Detection is enabled for PIM."""
                bidirectional: bool | None
                hello: Hello

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    border_router: bool | None | UndefinedType = Undefined,
                    dr_priority: int | None | UndefinedType = Undefined,
                    sparse_mode: bool | None | UndefinedType = Undefined,
                    local_interface: str | None | UndefinedType = Undefined,
                    bfd: bool | None | UndefinedType = Undefined,
                    bidirectional: bool | None | UndefinedType = Undefined,
                    hello: Hello | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        border_router: Configure PIM border router. EOS default is false.
                        dr_priority: dr_priority
                        sparse_mode: sparse_mode
                        local_interface: local_interface
                        bfd: Set the default for whether Bidirectional Forwarding Detection is enabled for PIM.
                        bidirectional: bidirectional
                        hello: hello

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "ipv4": {"type": Ipv4}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            ipv4: Ipv4

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, ipv4: Ipv4 | UndefinedType = Undefined) -> None:
                """
                Pim.

                Args:
                -----
                    _custom_data: _custom_data
                    ipv4: ipv4

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class IsisAuthentication(AvdModel):
            class Both(AvdModel):
                class KeyIdsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "algorithm", "key_type", "key")
                    _custom_data: dict[str, Any]
                    id: int
                    """Configure authentication key-id."""
                    algorithm: str
                    key_type: str
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                        key_type: str | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        rfc_5310: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class KeyIds(AvdCollection[int, KeyIdsItem]):
                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_id": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "key_id")
                    _custom_data: dict[str, Any]
                    key_id: int

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, key_id: int | UndefinedType = Undefined) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "algorithm": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "algorithm")
                    _custom_data: dict[str, Any]
                    profile: str
                    algorithm: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        profile: str | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_type: str | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                mode: str | None
                """Authentication mode."""
                sha: Sha
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_type: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_ids: KeyIds | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    sha: Sha | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    rx_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Both.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level1(AvdModel):
                class KeyIdsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "algorithm", "key_type", "key")
                    _custom_data: dict[str, Any]
                    id: int
                    """Configure authentication key-id."""
                    algorithm: str
                    key_type: str
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                        key_type: str | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        rfc_5310: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class KeyIds(AvdCollection[int, KeyIdsItem]):
                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_id": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "key_id")
                    _custom_data: dict[str, Any]
                    key_id: int

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, key_id: int | UndefinedType = Undefined) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "algorithm": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "algorithm")
                    _custom_data: dict[str, Any]
                    profile: str
                    algorithm: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        profile: str | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_type: str | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                mode: str | None
                """Authentication mode."""
                sha: Sha
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_type: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_ids: KeyIds | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    sha: Sha | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    rx_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Level1.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Level2(AvdModel):
                class KeyIdsItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "algorithm": {"type": str},
                        "key_type": {"type": str},
                        "key": {"type": str},
                        "rfc_5310": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id", "algorithm", "key_type", "key")
                    _custom_data: dict[str, Any]
                    id: int
                    """Configure authentication key-id."""
                    algorithm: str
                    key_type: str
                    """Configure authentication key type."""
                    key: str
                    """Password string."""
                    rfc_5310: bool | None
                    """SHA digest computation according to rfc5310."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                        key_type: str | UndefinedType = Undefined,
                        key: str | UndefinedType = Undefined,
                        rfc_5310: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        KeyIdsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: Configure authentication key-id.
                            algorithm: algorithm
                            key_type: Configure authentication key type.
                            key: Password string.
                            rfc_5310: SHA digest computation according to rfc5310.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class KeyIds(AvdCollection[int, KeyIdsItem]):
                    _primary_key: ClassVar[str] = "id"

                KeyIds._item_type = KeyIdsItem

                class Sha(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "key_id": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "key_id")
                    _custom_data: dict[str, Any]
                    key_id: int

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, key_id: int | UndefinedType = Undefined) -> None:
                        """
                        Sha.

                        Args:
                        -----
                            _custom_data: _custom_data
                            key_id: key_id

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class SharedSecret(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "profile": {"type": str}, "algorithm": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "profile", "algorithm")
                    _custom_data: dict[str, Any]
                    profile: str
                    algorithm: str

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        profile: str | UndefinedType = Undefined,
                        algorithm: str | UndefinedType = Undefined,
                    ) -> None:
                        """
                        SharedSecret.

                        Args:
                        -----
                            _custom_data: _custom_data
                            profile: profile
                            algorithm: algorithm

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "key_type": {"type": str},
                    "key": {"type": str},
                    "key_ids": {"type": KeyIds},
                    "mode": {"type": str},
                    "sha": {"type": Sha},
                    "shared_secret": {"type": SharedSecret},
                    "rx_disabled": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                key_type: str | None
                """Configure authentication key type."""
                key: str | None
                """Password string. `key_type` is required for this setting."""
                key_ids: KeyIds
                mode: str | None
                """Authentication mode."""
                sha: Sha
                """Required settings for authentication mode 'sha'."""
                shared_secret: SharedSecret
                """Required settings for authentication mode 'shared_secret'."""
                rx_disabled: bool | None
                """Disable authentication check on the receive side."""

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    key_type: str | None | UndefinedType = Undefined,
                    key: str | None | UndefinedType = Undefined,
                    key_ids: KeyIds | UndefinedType = Undefined,
                    mode: str | None | UndefinedType = Undefined,
                    sha: Sha | UndefinedType = Undefined,
                    shared_secret: SharedSecret | UndefinedType = Undefined,
                    rx_disabled: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Level2.

                    Args:
                    -----
                        _custom_data: _custom_data
                        key_type: Configure authentication key type.
                        key: Password string. `key_type` is required for this setting.
                        key_ids: key_ids
                        mode: Authentication mode.
                        sha: Required settings for authentication mode 'sha'.
                        shared_secret: Required settings for authentication mode 'shared_secret'.
                        rx_disabled: Disable authentication check on the receive side.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "both": {"type": Both}, "level_1": {"type": Level1}, "level_2": {"type": Level2}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            both: Both
            """
            Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
            'level_2' settings.
            """
            level_1: Level1
            """Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings."""
            level_2: Level2
            """Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                both: Both | UndefinedType = Undefined,
                level_1: Level1 | UndefinedType = Undefined,
                level_2: Level2 | UndefinedType = Undefined,
            ) -> None:
                """
                IsisAuthentication.

                Args:
                -----
                    _custom_data: _custom_data
                    both:
                       Authentication settings for level-1 and level-2. 'both' takes precedence over 'level_1' and
                       'level_2' settings.
                    level_1: Authentication settings for level-1. 'both' takes precedence over 'level_1' and 'level_2' settings.
                    level_2: Authentication settings for level-2. 'both' takes precedence over 'level_1' and 'level_2' settings.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrrpIdsItem(AvdModel):
            class Advertisement(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "interval": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                interval: int | None
                """Interval in seconds."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, interval: int | None | UndefinedType = Undefined) -> None:
                    """
                    Advertisement.

                    Args:
                    -----
                        _custom_data: _custom_data
                        interval: Interval in seconds.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Preempt(AvdModel):
                class Delay(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "minimum": {"type": int}, "reload": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    minimum: int | None
                    """Minimum preempt delay in seconds."""
                    reload: int | None
                    """Reload preempt delay in seconds."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        minimum: int | None | UndefinedType = Undefined,
                        reload: int | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            minimum: Minimum preempt delay in seconds.
                            reload: Reload preempt delay in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "delay": {"type": Delay}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
                _custom_data: dict[str, Any]
                enabled: bool
                delay: Delay

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    enabled: bool | UndefinedType = Undefined,
                    delay: Delay | UndefinedType = Undefined,
                ) -> None:
                    """
                    Preempt.

                    Args:
                    -----
                        _custom_data: _custom_data
                        enabled: enabled
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Timers(AvdModel):
                class Delay(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "reload": {"type": int}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    reload: int | None
                    """Delay after reload in seconds."""

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, reload: int | None | UndefinedType = Undefined) -> None:
                        """
                        Delay.

                        Args:
                        -----
                            _custom_data: _custom_data
                            reload: Delay after reload in seconds.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "delay": {"type": Delay}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                delay: Delay

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, delay: Delay | UndefinedType = Undefined) -> None:
                    """
                    Timers.

                    Args:
                    -----
                        _custom_data: _custom_data
                        delay: delay

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackedObjectItem(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "decrement": {"type": int}, "shutdown": {"type": bool}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                _custom_data: dict[str, Any]
                name: str
                """Tracked object name."""
                decrement: int | None
                """Decrement VRRP priority by 1-254."""
                shutdown: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    name: str | UndefinedType = Undefined,
                    decrement: int | None | UndefinedType = Undefined,
                    shutdown: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    TrackedObjectItem.

                    Args:
                    -----
                        _custom_data: _custom_data
                        name: Tracked object name.
                        decrement: Decrement VRRP priority by 1-254.
                        shutdown: shutdown

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class TrackedObject(AvdCollection[str, TrackedObjectItem]):
                _primary_key: ClassVar[str] = "name"

            TrackedObject._item_type = TrackedObjectItem

            class Ipv4(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}, "version": {"type": int}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                _custom_data: dict[str, Any]
                address: str
                """Virtual IPv4 address."""
                version: int | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    address: str | UndefinedType = Undefined,
                    version: int | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Ipv4.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv4 address.
                        version: version

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            class Ipv6(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "address": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data", "address")
                _custom_data: dict[str, Any]
                address: str
                """Virtual IPv6 address."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, address: str | UndefinedType = Undefined) -> None:
                    """
                    Ipv6.

                    Args:
                    -----
                        _custom_data: _custom_data
                        address: Virtual IPv6 address.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "id": {"type": int},
                "priority_level": {"type": int},
                "advertisement": {"type": Advertisement},
                "preempt": {"type": Preempt},
                "timers": {"type": Timers},
                "tracked_object": {"type": TrackedObject},
                "ipv4": {"type": Ipv4},
                "ipv6": {"type": Ipv6},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data", "id")
            _custom_data: dict[str, Any]
            id: int
            """VRID."""
            priority_level: int | None
            """Instance priority."""
            advertisement: Advertisement
            preempt: Preempt
            timers: Timers
            tracked_object: TrackedObject
            ipv4: Ipv4
            ipv6: Ipv6

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                id: int | UndefinedType = Undefined,
                priority_level: int | None | UndefinedType = Undefined,
                advertisement: Advertisement | UndefinedType = Undefined,
                preempt: Preempt | UndefinedType = Undefined,
                timers: Timers | UndefinedType = Undefined,
                tracked_object: TrackedObject | UndefinedType = Undefined,
                ipv4: Ipv4 | UndefinedType = Undefined,
                ipv6: Ipv6 | UndefinedType = Undefined,
            ) -> None:
                """
                VrrpIdsItem.

                Args:
                -----
                    _custom_data: _custom_data
                    id: VRID.
                    priority_level: Instance priority.
                    advertisement: advertisement
                    preempt: preempt
                    timers: timers
                    tracked_object: tracked_object
                    ipv4: ipv4
                    ipv6: ipv6

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class VrrpIds(AvdCollection[int, VrrpIdsItem]):
            _primary_key: ClassVar[str] = "id"

        VrrpIds._item_type = VrrpIdsItem

        class IpAttachedHostRouteExport(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "distance": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            distance: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                distance: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                IpAttachedHostRouteExport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    distance: distance

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Ipv6AttachedHostRouteExport(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}, "distance": {"type": int}, "prefix_length": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "enabled")
            _custom_data: dict[str, Any]
            enabled: bool
            distance: int | None
            """Administrative distance for generated routes."""
            prefix_length: int | None
            """Prefix length for generated routes."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                enabled: bool | UndefinedType = Undefined,
                distance: int | None | UndefinedType = Undefined,
                prefix_length: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Ipv6AttachedHostRouteExport.

                Args:
                -----
                    _custom_data: _custom_data
                    enabled: enabled
                    distance: Administrative distance for generated routes.
                    prefix_length: Prefix length for generated routes.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Bfd(AvdModel):
            _fields: ClassVar[dict] = {
                "_custom_data": {"type": dict},
                "echo": {"type": bool},
                "interval": {"type": int},
                "min_rx": {"type": int},
                "multiplier": {"type": int},
            }
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            echo: bool | None
            interval: int | None
            """Rate in milliseconds."""
            min_rx: int | None
            """Minimum RX hold time in milliseconds."""
            multiplier: int | None

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                echo: bool | None | UndefinedType = Undefined,
                interval: int | None | UndefinedType = Undefined,
                min_rx: int | None | UndefinedType = Undefined,
                multiplier: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                Bfd.

                Args:
                -----
                    _custom_data: _custom_data
                    echo: echo
                    interval: Rate in milliseconds.
                    min_rx: Minimum RX hold time in milliseconds.
                    multiplier: multiplier

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class ServicePolicy(AvdModel):
            class Pbr(AvdModel):
                _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "input": {"type": str}}
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                input: str | None
                """Name of policy-map used for policy based routing."""

                def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, input: str | None | UndefinedType = Undefined) -> None:
                    """
                    Pbr.

                    Args:
                    -----
                        _custom_data: _custom_data
                        input: Name of policy-map used for policy based routing.

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "pbr": {"type": Pbr}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            pbr: Pbr

            def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, pbr: Pbr | UndefinedType = Undefined) -> None:
                """
                ServicePolicy.

                Args:
                -----
                    _custom_data: _custom_data
                    pbr: pbr

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "logging": {"type": Logging},
            "shutdown": {"type": bool},
            "vrf": {"type": str},
            "arp_aging_timeout": {"type": int},
            "arp_cache_dynamic_capacity": {"type": int},
            "arp_gratuitous_accept": {"type": bool},
            "arp_monitor_mac_address": {"type": bool},
            "ip_proxy_arp": {"type": bool},
            "ip_directed_broadcast": {"type": bool},
            "ip_address": {"type": str},
            "ip_address_secondaries": {"type": list, "items": str},
            "ip_virtual_router_addresses": {"type": list, "items": str},
            "ip_address_virtual": {"type": str},
            "ip_address_virtual_secondaries": {"type": list, "items": str},
            "ip_verify_unicast_source_reachable_via": {"type": str},
            "ip_igmp": {"type": bool},
            "ip_igmp_version": {"type": int},
            "ip_igmp_host_proxy": {"type": IpIgmpHostProxy},
            "ip_helpers": {"type": IpHelpers},
            "ip_dhcp_relay_all_subnets": {"type": bool},
            "ip_nat": {"type": IpNat},
            "ipv6_enable": {"type": bool},
            "ipv6_address": {"type": str},
            "ipv6_address_virtuals": {"type": list, "items": str},
            "ipv6_address_link_local": {"type": str},
            "ipv6_virtual_router_addresses": {"type": list, "items": str},
            "ipv6_nd_ra_disabled": {"type": bool},
            "ipv6_nd_managed_config_flag": {"type": bool},
            "ipv6_nd_other_config_flag": {"type": bool},
            "ipv6_nd_cache": {"type": Ipv6NdCache},
            "ipv6_nd_prefixes": {"type": Ipv6NdPrefixes},
            "ipv6_dhcp_relay_destinations": {"type": Ipv6DhcpRelayDestinations},
            "ipv6_dhcp_relay_all_subnets": {"type": bool},
            "access_group_in": {"type": str},
            "access_group_out": {"type": str},
            "ipv6_access_group_in": {"type": str},
            "ipv6_access_group_out": {"type": str},
            "multicast": {"type": Multicast},
            "ospf_network_point_to_point": {"type": bool},
            "ospf_area": {"type": str},
            "ospf_cost": {"type": int},
            "ospf_authentication": {"type": str},
            "ospf_authentication_key": {"type": str},
            "ospf_message_digest_keys": {"type": OspfMessageDigestKeys},
            "pim": {"type": Pim},
            "isis_enable": {"type": str},
            "isis_bfd": {"type": bool},
            "isis_passive": {"type": bool},
            "isis_metric": {"type": int},
            "isis_network_point_to_point": {"type": bool},
            "isis_authentication": {"type": IsisAuthentication},
            "mtu": {"type": int},
            "no_autostate": {"type": bool},
            "vrrp_ids": {"type": VrrpIds},
            "ip_attached_host_route_export": {"type": IpAttachedHostRouteExport},
            "ipv6_attached_host_route_export": {"type": Ipv6AttachedHostRouteExport},
            "bfd": {"type": Bfd},
            "service_policy": {"type": ServicePolicy},
            "pvlan_mapping": {"type": str},
            "tenant": {"type": str},
            "tags": {"type": list, "items": str},
            "type": {"type": str},
            "eos_cli": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """VLAN interface name like "Vlan123"."""
        description: str | None
        logging: Logging
        shutdown: bool | None
        vrf: str | None
        """VRF name."""
        arp_aging_timeout: int | None
        """In seconds."""
        arp_cache_dynamic_capacity: int | None
        arp_gratuitous_accept: bool | None
        arp_monitor_mac_address: bool | None
        ip_proxy_arp: bool | None
        ip_directed_broadcast: bool | None
        ip_address: str | None
        """IPv4_address/Mask."""
        ip_address_secondaries: list[str]
        ip_virtual_router_addresses: list[str]
        ip_address_virtual: str | None
        """IPv4_address/Mask."""
        ip_address_virtual_secondaries: list[str]
        ip_verify_unicast_source_reachable_via: str | None
        ip_igmp: bool | None
        ip_igmp_version: int | None
        ip_igmp_host_proxy: IpIgmpHostProxy
        ip_helpers: IpHelpers
        """List of DHCP servers."""
        ip_dhcp_relay_all_subnets: bool | None
        """Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field."""
        ip_nat: IpNat
        ipv6_enable: bool | None
        ipv6_address: str | None
        """IPv6_address/Mask."""
        ipv6_address_virtuals: list[str]
        """The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses."""
        ipv6_address_link_local: str | None
        """IPv6_address/Mask."""
        ipv6_virtual_router_addresses: list[str]
        """Improved "VARPv6" data model to support multiple VARPv6 addresses."""
        ipv6_nd_ra_disabled: bool | None
        ipv6_nd_managed_config_flag: bool | None
        ipv6_nd_other_config_flag: bool | None
        """Set the "other stateful configuration" flag in IPv6 router advertisements."""
        ipv6_nd_cache: Ipv6NdCache
        """IPv6 neighbor cache options."""
        ipv6_nd_prefixes: Ipv6NdPrefixes
        ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations
        ipv6_dhcp_relay_all_subnets: bool | None
        """Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field."""
        access_group_in: str | None
        """IPv4 access-list name."""
        access_group_out: str | None
        """IPv4 access-list name."""
        ipv6_access_group_in: str | None
        """IPv6 access-list name."""
        ipv6_access_group_out: str | None
        """IPv6 access-list name."""
        multicast: Multicast
        ospf_network_point_to_point: bool | None
        ospf_area: str | None
        ospf_cost: int | None
        ospf_authentication: str | None
        ospf_authentication_key: str | None
        """Encrypted password used for simple authentication."""
        ospf_message_digest_keys: OspfMessageDigestKeys
        """Keys used for message-digest authentication."""
        pim: Pim
        isis_enable: str | None
        """ISIS instance name."""
        isis_bfd: bool | None
        """Enable BFD for ISIS."""
        isis_passive: bool | None
        isis_metric: int | None
        isis_network_point_to_point: bool | None
        isis_authentication: IsisAuthentication
        mtu: int | None
        no_autostate: bool | None
        vrrp_ids: VrrpIds
        """Improved "vrrp" data model to support multiple VRRP IDs."""
        ip_attached_host_route_export: IpAttachedHostRouteExport
        ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport
        bfd: Bfd
        service_policy: ServicePolicy
        pvlan_mapping: str | None
        """List of VLANs as string."""
        tenant: str | None
        """Key only used for documentation or validation purposes."""
        tags: list[str]
        """Key only used for documentation or validation purposes."""
        type: str | None
        """Key only used for documentation or validation purposes."""
        eos_cli: str | None
        """Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            logging: Logging | UndefinedType = Undefined,
            shutdown: bool | None | UndefinedType = Undefined,
            vrf: str | None | UndefinedType = Undefined,
            arp_aging_timeout: int | None | UndefinedType = Undefined,
            arp_cache_dynamic_capacity: int | None | UndefinedType = Undefined,
            arp_gratuitous_accept: bool | None | UndefinedType = Undefined,
            arp_monitor_mac_address: bool | None | UndefinedType = Undefined,
            ip_proxy_arp: bool | None | UndefinedType = Undefined,
            ip_directed_broadcast: bool | None | UndefinedType = Undefined,
            ip_address: str | None | UndefinedType = Undefined,
            ip_address_secondaries: list[str] | UndefinedType = Undefined,
            ip_virtual_router_addresses: list[str] | UndefinedType = Undefined,
            ip_address_virtual: str | None | UndefinedType = Undefined,
            ip_address_virtual_secondaries: list[str] | UndefinedType = Undefined,
            ip_verify_unicast_source_reachable_via: str | None | UndefinedType = Undefined,
            ip_igmp: bool | None | UndefinedType = Undefined,
            ip_igmp_version: int | None | UndefinedType = Undefined,
            ip_igmp_host_proxy: IpIgmpHostProxy | UndefinedType = Undefined,
            ip_helpers: IpHelpers | UndefinedType = Undefined,
            ip_dhcp_relay_all_subnets: bool | None | UndefinedType = Undefined,
            ip_nat: IpNat | UndefinedType = Undefined,
            ipv6_enable: bool | None | UndefinedType = Undefined,
            ipv6_address: str | None | UndefinedType = Undefined,
            ipv6_address_virtuals: list[str] | UndefinedType = Undefined,
            ipv6_address_link_local: str | None | UndefinedType = Undefined,
            ipv6_virtual_router_addresses: list[str] | UndefinedType = Undefined,
            ipv6_nd_ra_disabled: bool | None | UndefinedType = Undefined,
            ipv6_nd_managed_config_flag: bool | None | UndefinedType = Undefined,
            ipv6_nd_other_config_flag: bool | None | UndefinedType = Undefined,
            ipv6_nd_cache: Ipv6NdCache | UndefinedType = Undefined,
            ipv6_nd_prefixes: Ipv6NdPrefixes | UndefinedType = Undefined,
            ipv6_dhcp_relay_destinations: Ipv6DhcpRelayDestinations | UndefinedType = Undefined,
            ipv6_dhcp_relay_all_subnets: bool | None | UndefinedType = Undefined,
            access_group_in: str | None | UndefinedType = Undefined,
            access_group_out: str | None | UndefinedType = Undefined,
            ipv6_access_group_in: str | None | UndefinedType = Undefined,
            ipv6_access_group_out: str | None | UndefinedType = Undefined,
            multicast: Multicast | UndefinedType = Undefined,
            ospf_network_point_to_point: bool | None | UndefinedType = Undefined,
            ospf_area: str | None | UndefinedType = Undefined,
            ospf_cost: int | None | UndefinedType = Undefined,
            ospf_authentication: str | None | UndefinedType = Undefined,
            ospf_authentication_key: str | None | UndefinedType = Undefined,
            ospf_message_digest_keys: OspfMessageDigestKeys | UndefinedType = Undefined,
            pim: Pim | UndefinedType = Undefined,
            isis_enable: str | None | UndefinedType = Undefined,
            isis_bfd: bool | None | UndefinedType = Undefined,
            isis_passive: bool | None | UndefinedType = Undefined,
            isis_metric: int | None | UndefinedType = Undefined,
            isis_network_point_to_point: bool | None | UndefinedType = Undefined,
            isis_authentication: IsisAuthentication | UndefinedType = Undefined,
            mtu: int | None | UndefinedType = Undefined,
            no_autostate: bool | None | UndefinedType = Undefined,
            vrrp_ids: VrrpIds | UndefinedType = Undefined,
            ip_attached_host_route_export: IpAttachedHostRouteExport | UndefinedType = Undefined,
            ipv6_attached_host_route_export: Ipv6AttachedHostRouteExport | UndefinedType = Undefined,
            bfd: Bfd | UndefinedType = Undefined,
            service_policy: ServicePolicy | UndefinedType = Undefined,
            pvlan_mapping: str | None | UndefinedType = Undefined,
            tenant: str | None | UndefinedType = Undefined,
            tags: list[str] | UndefinedType = Undefined,
            type: str | None | UndefinedType = Undefined,
            eos_cli: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            VlanInterfacesItem.

            Args:
            -----
                _custom_data: _custom_data
                name: VLAN interface name like "Vlan123".
                description: description
                logging: logging
                shutdown: shutdown
                vrf: VRF name.
                arp_aging_timeout: In seconds.
                arp_cache_dynamic_capacity: arp_cache_dynamic_capacity
                arp_gratuitous_accept: arp_gratuitous_accept
                arp_monitor_mac_address: arp_monitor_mac_address
                ip_proxy_arp: ip_proxy_arp
                ip_directed_broadcast: ip_directed_broadcast
                ip_address: IPv4_address/Mask.
                ip_address_secondaries: ip_address_secondaries
                ip_virtual_router_addresses: ip_virtual_router_addresses
                ip_address_virtual: IPv4_address/Mask.
                ip_address_virtual_secondaries: ip_address_virtual_secondaries
                ip_verify_unicast_source_reachable_via: ip_verify_unicast_source_reachable_via
                ip_igmp: ip_igmp
                ip_igmp_version: ip_igmp_version
                ip_igmp_host_proxy: ip_igmp_host_proxy
                ip_helpers: List of DHCP servers.
                ip_dhcp_relay_all_subnets: Allow forwarding requests with secondary IP addresses in the gateway address "giaddr" field.
                ip_nat: ip_nat
                ipv6_enable: ipv6_enable
                ipv6_address: IPv6_address/Mask.
                ipv6_address_virtuals: The new "ipv6_address_virtuals" key support multiple virtual ipv6 addresses.
                ipv6_address_link_local: IPv6_address/Mask.
                ipv6_virtual_router_addresses: Improved "VARPv6" data model to support multiple VARPv6 addresses.
                ipv6_nd_ra_disabled: ipv6_nd_ra_disabled
                ipv6_nd_managed_config_flag: ipv6_nd_managed_config_flag
                ipv6_nd_other_config_flag: Set the "other stateful configuration" flag in IPv6 router advertisements.
                ipv6_nd_cache: IPv6 neighbor cache options.
                ipv6_nd_prefixes: ipv6_nd_prefixes
                ipv6_dhcp_relay_destinations: ipv6_dhcp_relay_destinations
                ipv6_dhcp_relay_all_subnets: Allow forwarding requests with additional IPv6 addresses in the gateway address "giaddr" field.
                access_group_in: IPv4 access-list name.
                access_group_out: IPv4 access-list name.
                ipv6_access_group_in: IPv6 access-list name.
                ipv6_access_group_out: IPv6 access-list name.
                multicast: multicast
                ospf_network_point_to_point: ospf_network_point_to_point
                ospf_area: ospf_area
                ospf_cost: ospf_cost
                ospf_authentication: ospf_authentication
                ospf_authentication_key: Encrypted password used for simple authentication.
                ospf_message_digest_keys: Keys used for message-digest authentication.
                pim: pim
                isis_enable: ISIS instance name.
                isis_bfd: Enable BFD for ISIS.
                isis_passive: isis_passive
                isis_metric: isis_metric
                isis_network_point_to_point: isis_network_point_to_point
                isis_authentication: isis_authentication
                mtu: mtu
                no_autostate: no_autostate
                vrrp_ids: Improved "vrrp" data model to support multiple VRRP IDs.
                ip_attached_host_route_export: ip_attached_host_route_export
                ipv6_attached_host_route_export: ipv6_attached_host_route_export
                bfd: bfd
                service_policy: service_policy
                pvlan_mapping: List of VLANs as string.
                tenant: Key only used for documentation or validation purposes.
                tags: Key only used for documentation or validation purposes.
                type: Key only used for documentation or validation purposes.
                eos_cli: Multiline EOS CLI rendered directly on the VLAN interface in the final EOS configuration.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VlanInterfaces(AvdCollection[str, VlanInterfacesItem]):
        _primary_key: ClassVar[str] = "name"

    VlanInterfaces._item_type = VlanInterfacesItem

    class VlanInternalOrder(AvdModel):
        class Range(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "beginning": {"type": int}, "ending": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data", "beginning", "ending")
            _custom_data: dict[str, Any]
            beginning: int
            """First VLAN ID."""
            ending: int
            """Last VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                beginning: int | UndefinedType = Undefined,
                ending: int | UndefinedType = Undefined,
            ) -> None:
                """
                Range.

                Args:
                -----
                    _custom_data: _custom_data
                    beginning: First VLAN ID.
                    ending: Last VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "allocation": {"type": str}, "range": {"type": Range}}
        _required_fields: ClassVar[tuple] = ("_custom_data", "allocation", "range")
        _custom_data: dict[str, Any]
        allocation: str
        range: Range

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            allocation: str | UndefinedType = Undefined,
            range: Range | UndefinedType = Undefined,
        ) -> None:
            """
            VlanInternalOrder.

            Args:
            -----
                _custom_data: _custom_data
                allocation: allocation
                range: range

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VlansItem(AvdModel):
        class PrivateVlan(AvdModel):
            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "type": {"type": str}, "primary_vlan": {"type": int}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            type: str | None
            primary_vlan: int | None
            """Primary VLAN ID."""

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                type: str | None | UndefinedType = Undefined,
                primary_vlan: int | None | UndefinedType = Undefined,
            ) -> None:
                """
                PrivateVlan.

                Args:
                -----
                    _custom_data: _custom_data
                    type: type
                    primary_vlan: Primary VLAN ID.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "id": {"type": int},
            "name": {"type": str},
            "state": {"type": str},
            "trunk_groups": {"type": list, "items": str},
            "private_vlan": {"type": PrivateVlan},
            "tenant": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "id")
        _custom_data: dict[str, Any]
        id: int
        """VLAN ID."""
        name: str | None
        """VLAN Name."""
        state: str | None
        trunk_groups: list[str]
        private_vlan: PrivateVlan
        tenant: str | None
        """Key only used for documentation or validation purposes."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            id: int | UndefinedType = Undefined,
            name: str | None | UndefinedType = Undefined,
            state: str | None | UndefinedType = Undefined,
            trunk_groups: list[str] | UndefinedType = Undefined,
            private_vlan: PrivateVlan | UndefinedType = Undefined,
            tenant: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            VlansItem.

            Args:
            -----
                _custom_data: _custom_data
                id: VLAN ID.
                name: VLAN Name.
                state: state
                trunk_groups: trunk_groups
                private_vlan: private_vlan
                tenant: Key only used for documentation or validation purposes.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Vlans(AvdCollection[int, VlansItem]):
        _primary_key: ClassVar[str] = "id"

    Vlans._item_type = VlansItem

    class VmtracerSessionsItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "url": {"type": str},
            "username": {"type": str},
            "password": {"type": str},
            "autovlan_disable": {"type": bool},
            "source_interface": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """Vmtracer Session Name."""
        url: str | None
        username: str | None
        password: str | None
        """Type 7 Password Hash."""
        autovlan_disable: bool | None
        source_interface: str | None

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            url: str | None | UndefinedType = Undefined,
            username: str | None | UndefinedType = Undefined,
            password: str | None | UndefinedType = Undefined,
            autovlan_disable: bool | None | UndefinedType = Undefined,
            source_interface: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            VmtracerSessionsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: Vmtracer Session Name.
                url: url
                username: username
                password: Type 7 Password Hash.
                autovlan_disable: autovlan_disable
                source_interface: source_interface

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class VmtracerSessions(AvdCollection[str, VmtracerSessionsItem]):
        _primary_key: ClassVar[str] = "name"

    VmtracerSessions._item_type = VmtracerSessionsItem

    class VrfsItem(AvdModel):
        _fields: ClassVar[dict] = {
            "_custom_data": {"type": dict},
            "name": {"type": str},
            "description": {"type": str},
            "ip_routing": {"type": bool},
            "ipv6_routing": {"type": bool},
            "ip_routing_ipv6_interfaces": {"type": bool},
            "tenant": {"type": str},
        }
        _required_fields: ClassVar[tuple] = ("_custom_data", "name")
        _custom_data: dict[str, Any]
        name: str
        """VRF Name."""
        description: str | None
        ip_routing: bool | None
        ipv6_routing: bool | None
        ip_routing_ipv6_interfaces: bool | None
        tenant: str | None
        """Key only used for documentation or validation purposes."""

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            name: str | UndefinedType = Undefined,
            description: str | None | UndefinedType = Undefined,
            ip_routing: bool | None | UndefinedType = Undefined,
            ipv6_routing: bool | None | UndefinedType = Undefined,
            ip_routing_ipv6_interfaces: bool | None | UndefinedType = Undefined,
            tenant: str | None | UndefinedType = Undefined,
        ) -> None:
            """
            VrfsItem.

            Args:
            -----
                _custom_data: _custom_data
                name: VRF Name.
                description: description
                ip_routing: ip_routing
                ipv6_routing: ipv6_routing
                ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
                tenant: Key only used for documentation or validation purposes.

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    class Vrfs(AvdCollection[str, VrfsItem]):
        _primary_key: ClassVar[str] = "name"

    Vrfs._item_type = VrfsItem

    class VxlanInterface(AvdModel):
        class Vxlan1(AvdModel):
            class Vxlan(AvdModel):
                class Multicast(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "headend_replication": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    headend_replication: bool | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, headend_replication: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Multicast.

                        Args:
                        -----
                            _custom_data: _custom_data
                            headend_replication: headend_replication

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ControllerClient(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                        """
                        ControllerClient.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BfdVtepEvpn(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "interval": {"type": int},
                        "min_rx": {"type": int},
                        "multiplier": {"type": int},
                        "prefix_list": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    interval: int | None
                    min_rx: int | None
                    multiplier: int | None
                    prefix_list: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                        min_rx: int | None | UndefinedType = Undefined,
                        multiplier: int | None | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BfdVtepEvpn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interval: interval
                            min_rx: min_rx
                            multiplier: multiplier
                            prefix_list: prefix_list

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Qos(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "dscp_propagation_encapsulation": {"type": bool},
                        "ecn_propagation": {"type": bool},
                        "map_dscp_to_traffic_class_decapsulation": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    dscp_propagation_encapsulation: bool | None
                    ecn_propagation: bool | None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        dscp_propagation_encapsulation: bool | None | UndefinedType = Undefined,
                        ecn_propagation: bool | None | UndefinedType = Undefined,
                        map_dscp_to_traffic_class_decapsulation: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Qos.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp_propagation_encapsulation: dscp_propagation_encapsulation
                            ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                            map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "flood_vteps": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                    _custom_data: dict[str, Any]
                    id: int
                    """VLAN ID."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    flood_vteps: list[str]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        vni: int | None | UndefinedType = Undefined,
                        multicast_group: str | None | UndefinedType = Undefined,
                        flood_vteps: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: VLAN ID.
                            vni: vni
                            multicast_group: IP Multicast Group Address.
                            flood_vteps: flood_vteps

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vlans(AvdCollection[int, VlansItem]):
                    _primary_key: ClassVar[str] = "id"

                Vlans._item_type = VlansItem

                class VrfsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vni": {"type": int}, "multicast_group": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """VRF Name."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        vni: int | None | UndefinedType = Undefined,
                        multicast_group: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: VRF Name.
                            vni: vni
                            multicast_group: IP Multicast Group Address.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vrfs(AvdCollection[str, VrfsItem]):
                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_interface": {"type": str},
                    "multicast": {"type": Multicast},
                    "controller_client": {"type": ControllerClient},
                    "mlag_source_interface": {"type": str},
                    "udp_port": {"type": int},
                    "vtep_to_vtep_bridging": {"type": bool},
                    "virtual_router_encapsulation_mac_address": {"type": str},
                    "bfd_vtep_evpn": {"type": BfdVtepEvpn},
                    "qos": {"type": Qos},
                    "vlans": {"type": Vlans},
                    "vrfs": {"type": Vrfs},
                    "flood_vteps": {"type": list, "items": str},
                    "flood_vtep_learned_data_plane": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                source_interface: str | None
                """Source Interface Name."""
                multicast: Multicast
                controller_client: ControllerClient
                """Client to CVX Controllers."""
                mlag_source_interface: str | None
                udp_port: int | None
                vtep_to_vtep_bridging: bool | None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn
                qos: Qos
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                """
                vlans: Vlans
                vrfs: Vrfs
                flood_vteps: list[str]
                flood_vtep_learned_data_plane: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    multicast: Multicast | UndefinedType = Undefined,
                    controller_client: ControllerClient | UndefinedType = Undefined,
                    mlag_source_interface: str | None | UndefinedType = Undefined,
                    udp_port: int | None | UndefinedType = Undefined,
                    vtep_to_vtep_bridging: bool | None | UndefinedType = Undefined,
                    virtual_router_encapsulation_mac_address: str | None | UndefinedType = Undefined,
                    bfd_vtep_evpn: BfdVtepEvpn | UndefinedType = Undefined,
                    qos: Qos | UndefinedType = Undefined,
                    vlans: Vlans | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                    flood_vteps: list[str] | UndefinedType = Undefined,
                    flood_vtep_learned_data_plane: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: Source Interface Name.
                        multicast: multicast
                        controller_client: Client to CVX Controllers.
                        mlag_source_interface: mlag_source_interface
                        udp_port: udp_port
                        vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                        virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                        bfd_vtep_evpn: bfd_vtep_evpn
                        qos:
                           For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                           core ports must be in "DSCP Trust" mode.
                           !!!Warning, only few hardware types with software version
                           >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                        vlans: vlans
                        vrfs: vrfs
                        flood_vteps: flood_vteps
                        flood_vtep_learned_data_plane: flood_vtep_learned_data_plane

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "description": {"type": str}, "vxlan": {"type": Vxlan}, "eos_cli": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            description: str | None
            vxlan: Vxlan
            eos_cli: str | None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                vxlan: Vxlan | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Vxlan1.

                Args:
                -----
                    _custom_data: _custom_data
                    description: description
                    vxlan: vxlan
                    eos_cli:
                       Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        class Vxlan1(AvdModel):
            class Vxlan(AvdModel):
                class Multicast(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "headend_replication": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    headend_replication: bool | None

                    def __init__(
                        self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, headend_replication: bool | None | UndefinedType = Undefined
                    ) -> None:
                        """
                        Multicast.

                        Args:
                        -----
                            _custom_data: _custom_data
                            headend_replication: headend_replication

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class ControllerClient(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "enabled": {"type": bool}}
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    enabled: bool | None

                    def __init__(self, *, _custom_data: dict[str, Any] | UndefinedType = Undefined, enabled: bool | None | UndefinedType = Undefined) -> None:
                        """
                        ControllerClient.

                        Args:
                        -----
                            _custom_data: _custom_data
                            enabled: enabled

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class BfdVtepEvpn(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "interval": {"type": int},
                        "min_rx": {"type": int},
                        "multiplier": {"type": int},
                        "prefix_list": {"type": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    interval: int | None
                    min_rx: int | None
                    multiplier: int | None
                    prefix_list: str | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        interval: int | None | UndefinedType = Undefined,
                        min_rx: int | None | UndefinedType = Undefined,
                        multiplier: int | None | UndefinedType = Undefined,
                        prefix_list: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        BfdVtepEvpn.

                        Args:
                        -----
                            _custom_data: _custom_data
                            interval: interval
                            min_rx: min_rx
                            multiplier: multiplier
                            prefix_list: prefix_list

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Qos(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "dscp_propagation_encapsulation": {"type": bool},
                        "ecn_propagation": {"type": bool},
                        "map_dscp_to_traffic_class_decapsulation": {"type": bool},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data",)
                    _custom_data: dict[str, Any]
                    dscp_propagation_encapsulation: bool | None
                    ecn_propagation: bool | None
                    """Enable copying the ECN marking to/from encapsulated packets."""
                    map_dscp_to_traffic_class_decapsulation: bool | None

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        dscp_propagation_encapsulation: bool | None | UndefinedType = Undefined,
                        ecn_propagation: bool | None | UndefinedType = Undefined,
                        map_dscp_to_traffic_class_decapsulation: bool | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        Qos.

                        Args:
                        -----
                            _custom_data: _custom_data
                            dscp_propagation_encapsulation: dscp_propagation_encapsulation
                            ecn_propagation: Enable copying the ECN marking to/from encapsulated packets.
                            map_dscp_to_traffic_class_decapsulation: map_dscp_to_traffic_class_decapsulation

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class VlansItem(AvdModel):
                    _fields: ClassVar[dict] = {
                        "_custom_data": {"type": dict},
                        "id": {"type": int},
                        "vni": {"type": int},
                        "multicast_group": {"type": str},
                        "flood_vteps": {"type": list, "items": str},
                    }
                    _required_fields: ClassVar[tuple] = ("_custom_data", "id")
                    _custom_data: dict[str, Any]
                    id: int
                    """VLAN ID."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""
                    flood_vteps: list[str]

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        id: int | UndefinedType = Undefined,
                        vni: int | None | UndefinedType = Undefined,
                        multicast_group: str | None | UndefinedType = Undefined,
                        flood_vteps: list[str] | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VlansItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            id: VLAN ID.
                            vni: vni
                            multicast_group: IP Multicast Group Address.
                            flood_vteps: flood_vteps

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vlans(AvdCollection[int, VlansItem]):
                    _primary_key: ClassVar[str] = "id"

                Vlans._item_type = VlansItem

                class VrfsItem(AvdModel):
                    _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "name": {"type": str}, "vni": {"type": int}, "multicast_group": {"type": str}}
                    _required_fields: ClassVar[tuple] = ("_custom_data", "name")
                    _custom_data: dict[str, Any]
                    name: str
                    """VRF Name."""
                    vni: int | None
                    multicast_group: str | None
                    """IP Multicast Group Address."""

                    def __init__(
                        self,
                        *,
                        _custom_data: dict[str, Any] | UndefinedType = Undefined,
                        name: str | UndefinedType = Undefined,
                        vni: int | None | UndefinedType = Undefined,
                        multicast_group: str | None | UndefinedType = Undefined,
                    ) -> None:
                        """
                        VrfsItem.

                        Args:
                        -----
                            _custom_data: _custom_data
                            name: VRF Name.
                            vni: vni
                            multicast_group: IP Multicast Group Address.

                        """
                        for arg, arg_value in locals().items():
                            if arg_value is Undefined or arg in ("self", "kwargs"):
                                continue
                            setattr(self, arg, arg_value)

                class Vrfs(AvdCollection[str, VrfsItem]):
                    _primary_key: ClassVar[str] = "name"

                Vrfs._item_type = VrfsItem

                _fields: ClassVar[dict] = {
                    "_custom_data": {"type": dict},
                    "source_interface": {"type": str},
                    "multicast": {"type": Multicast},
                    "controller_client": {"type": ControllerClient},
                    "mlag_source_interface": {"type": str},
                    "udp_port": {"type": int},
                    "vtep_to_vtep_bridging": {"type": bool},
                    "virtual_router_encapsulation_mac_address": {"type": str},
                    "bfd_vtep_evpn": {"type": BfdVtepEvpn},
                    "qos": {"type": Qos},
                    "vlans": {"type": Vlans},
                    "vrfs": {"type": Vrfs},
                    "flood_vteps": {"type": list, "items": str},
                    "flood_vtep_learned_data_plane": {"type": bool},
                }
                _required_fields: ClassVar[tuple] = ("_custom_data",)
                _custom_data: dict[str, Any]
                source_interface: str | None
                """Source Interface Name."""
                multicast: Multicast
                controller_client: ControllerClient
                """Client to CVX Controllers."""
                mlag_source_interface: str | None
                udp_port: int | None
                vtep_to_vtep_bridging: bool | None
                """Enable bridging between different VTEPs in vxlan overlay."""
                virtual_router_encapsulation_mac_address: str | None
                """"mlag-system-id" or ethernet_address (H.H.H)."""
                bfd_vtep_evpn: BfdVtepEvpn
                qos: Qos
                """
                For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                core ports must be in "DSCP Trust" mode.
                !!!Warning, only few hardware types with software version
                >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                """
                vlans: Vlans
                vrfs: Vrfs
                flood_vteps: list[str]
                flood_vtep_learned_data_plane: bool | None

                def __init__(
                    self,
                    *,
                    _custom_data: dict[str, Any] | UndefinedType = Undefined,
                    source_interface: str | None | UndefinedType = Undefined,
                    multicast: Multicast | UndefinedType = Undefined,
                    controller_client: ControllerClient | UndefinedType = Undefined,
                    mlag_source_interface: str | None | UndefinedType = Undefined,
                    udp_port: int | None | UndefinedType = Undefined,
                    vtep_to_vtep_bridging: bool | None | UndefinedType = Undefined,
                    virtual_router_encapsulation_mac_address: str | None | UndefinedType = Undefined,
                    bfd_vtep_evpn: BfdVtepEvpn | UndefinedType = Undefined,
                    qos: Qos | UndefinedType = Undefined,
                    vlans: Vlans | UndefinedType = Undefined,
                    vrfs: Vrfs | UndefinedType = Undefined,
                    flood_vteps: list[str] | UndefinedType = Undefined,
                    flood_vtep_learned_data_plane: bool | None | UndefinedType = Undefined,
                ) -> None:
                    """
                    Vxlan.

                    Args:
                    -----
                        _custom_data: _custom_data
                        source_interface: Source Interface Name.
                        multicast: multicast
                        controller_client: Client to CVX Controllers.
                        mlag_source_interface: mlag_source_interface
                        udp_port: udp_port
                        vtep_to_vtep_bridging: Enable bridging between different VTEPs in vxlan overlay.
                        virtual_router_encapsulation_mac_address: "mlag-system-id" or ethernet_address (H.H.H).
                        bfd_vtep_evpn: bfd_vtep_evpn
                        qos:
                           For the Traffic Class to be derived based on the outer DSCP field of the incoming VxLan packet, the
                           core ports must be in "DSCP Trust" mode.
                           !!!Warning, only few hardware types with software version
                           >= 4.26.0 support the below knobs to configure Vxlan DSCP mapping.
                        vlans: vlans
                        vrfs: vrfs
                        flood_vteps: flood_vteps
                        flood_vtep_learned_data_plane: flood_vtep_learned_data_plane

                    """
                    for arg, arg_value in locals().items():
                        if arg_value is Undefined or arg in ("self", "kwargs"):
                            continue
                        setattr(self, arg, arg_value)

            _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "description": {"type": str}, "vxlan": {"type": Vxlan}, "eos_cli": {"type": str}}
            _required_fields: ClassVar[tuple] = ("_custom_data",)
            _custom_data: dict[str, Any]
            description: str | None
            vxlan: Vxlan
            eos_cli: str | None
            """
            Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
            configuration.
            """

            def __init__(
                self,
                *,
                _custom_data: dict[str, Any] | UndefinedType = Undefined,
                description: str | None | UndefinedType = Undefined,
                vxlan: Vxlan | UndefinedType = Undefined,
                eos_cli: str | None | UndefinedType = Undefined,
            ) -> None:
                """
                Vxlan1.

                Args:
                -----
                    _custom_data: _custom_data
                    description: description
                    vxlan: vxlan
                    eos_cli:
                       Multiline String with EOS CLI rendered directly on the Vxlan interface in the final EOS
                       configuration.

                """
                for arg, arg_value in locals().items():
                    if arg_value is Undefined or arg in ("self", "kwargs"):
                        continue
                    setattr(self, arg, arg_value)

        _fields: ClassVar[dict] = {"_custom_data": {"type": dict}, "vxlan1": {"type": Vxlan1}, "field_Vxlan1": {"type": Vxlan1, "key": "Vxlan1"}}
        _required_fields: ClassVar[tuple] = ("_custom_data",)
        _custom_data: dict[str, Any]
        vxlan1: Vxlan1
        field_Vxlan1: Vxlan1

        def __init__(
            self,
            *,
            _custom_data: dict[str, Any] | UndefinedType = Undefined,
            vxlan1: Vxlan1 | UndefinedType = Undefined,
            field_Vxlan1: Vxlan1 | UndefinedType = Undefined,
        ) -> None:
            """
            VxlanInterface.

            Args:
            -----
                _custom_data: _custom_data
                vxlan1: vxlan1
                field_Vxlan1: field_Vxlan1

            """
            for arg, arg_value in locals().items():
                if arg_value is Undefined or arg in ("self", "kwargs"):
                    continue
                setattr(self, arg, arg_value)

    _fields: ClassVar[dict] = {
        "aaa_accounting": {"type": AaaAccounting},
        "aaa_authentication": {"type": AaaAuthentication},
        "aaa_authorization": {"type": AaaAuthorization},
        "aaa_root": {"type": AaaRoot},
        "aaa_server_groups": {"type": AaaServerGroups},
        "access_lists": {"type": AccessLists},
        "address_locking": {"type": AddressLocking},
        "agents": {"type": Agents},
        "aliases": {"type": str},
        "application_traffic_recognition": {"type": ApplicationTrafficRecognition},
        "arp": {"type": Arp},
        "as_path": {"type": AsPath},
        "avd_data_validation_mode": {"type": str, "default": "error"},
        "banners": {"type": Banners},
        "bgp_groups": {"type": BgpGroups},
        "boot": {"type": Boot},
        "class_maps": {"type": ClassMaps},
        "clock": {"type": Clock},
        "community_lists": {"type": CommunityLists},
        "config_comment": {"type": str},
        "config_end": {"type": bool, "default": False},
        "custom_templates": {"type": list, "items": str},
        "cvx": {"type": Cvx},
        "daemon_terminattr": {"type": DaemonTerminattr},
        "daemons": {"type": Daemons},
        "dhcp_relay": {"type": DhcpRelay},
        "dhcp_servers": {"type": DhcpServers},
        "dns_domain": {"type": str},
        "domain_list": {"type": list, "items": str},
        "dot1x": {"type": Dot1x},
        "dps_interfaces": {"type": DpsInterfaces},
        "dynamic_prefix_lists": {"type": list, "items": DynamicPrefixListsItem},
        "enable_password": {"type": EnablePassword},
        "eos_cli": {"type": str},
        "eos_cli_config_gen_configuration": {"type": EosCliConfigGenConfiguration},
        "eos_cli_config_gen_documentation": {"type": EosCliConfigGenDocumentation},
        "errdisable": {"type": Errdisable},
        "ethernet_interfaces": {"type": EthernetInterfaces},
        "event_handlers": {"type": EventHandlers},
        "event_monitor": {"type": EventMonitor},
        "flow_tracking": {"type": FlowTracking},
        "generate_default_config": {"type": bool, "default": False},
        "generate_device_documentation": {"type": bool, "default": True},
        "hardware": {"type": Hardware},
        "hardware_counters": {"type": HardwareCounters},
        "hostname": {"type": str},
        "interface_defaults": {"type": InterfaceDefaults},
        "interface_groups": {"type": InterfaceGroups},
        "interface_profiles": {"type": InterfaceProfiles},
        "ip_access_lists": {"type": IpAccessLists},
        "ip_access_lists_max_entries": {"type": int},
        "ip_community_lists": {"type": IpCommunityLists},
        "ip_dhcp_relay": {"type": IpDhcpRelay},
        "ip_dhcp_snooping": {"type": IpDhcpSnooping},
        "ip_domain_lookup": {"type": IpDomainLookup},
        "ip_extcommunity_lists": {"type": IpExtcommunityLists},
        "ip_extcommunity_lists_regexp": {"type": IpExtcommunityListsRegexp},
        "ip_ftp_client_source_interfaces": {"type": list, "items": IpFtpClientSourceInterfacesItem},
        "ip_hardware": {"type": IpHardware},
        "ip_http_client_source_interfaces": {"type": list, "items": IpHttpClientSourceInterfacesItem},
        "ip_icmp_redirect": {"type": bool},
        "ip_igmp_snooping": {"type": IpIgmpSnooping},
        "ip_name_servers": {"type": list, "items": IpNameServersItem},
        "ip_nat": {"type": IpNat},
        "ip_radius_source_interfaces": {"type": list, "items": IpRadiusSourceInterfacesItem},
        "ip_routing": {"type": bool},
        "ip_routing_ipv6_interfaces": {"type": bool},
        "ip_security": {"type": IpSecurity},
        "ip_ssh_client_source_interfaces": {"type": list, "items": IpSshClientSourceInterfacesItem},
        "ip_tacacs_source_interfaces": {"type": list, "items": IpTacacsSourceInterfacesItem},
        "ip_telnet_client_source_interfaces": {"type": list, "items": IpTelnetClientSourceInterfacesItem},
        "ip_tftp_client_source_interfaces": {"type": list, "items": IpTftpClientSourceInterfacesItem},
        "ip_virtual_router_mac_address": {"type": str},
        "ipv6_access_lists": {"type": Ipv6AccessLists},
        "ipv6_dhcp_relay": {"type": Ipv6DhcpRelay},
        "ipv6_hardware": {"type": Ipv6Hardware},
        "ipv6_icmp_redirect": {"type": bool},
        "ipv6_neighbor": {"type": Ipv6Neighbor},
        "ipv6_prefix_lists": {"type": Ipv6PrefixLists},
        "ipv6_standard_access_lists": {"type": Ipv6StandardAccessLists},
        "ipv6_static_routes": {"type": list, "items": Ipv6StaticRoutesItem},
        "ipv6_unicast_routing": {"type": bool},
        "is_deployed": {"type": bool, "default": True},
        "l2_protocol": {"type": L2Protocol},
        "lacp": {"type": Lacp},
        "link_tracking_groups": {"type": LinkTrackingGroups},
        "lldp": {"type": Lldp},
        "load_interval": {"type": LoadInterval},
        "local_users": {"type": LocalUsers},
        "logging": {"type": Logging},
        "loopback_interfaces": {"type": LoopbackInterfaces},
        "mac_access_lists": {"type": MacAccessLists},
        "mac_address_table": {"type": MacAddressTable},
        "mac_security": {"type": MacSecurity},
        "maintenance": {"type": Maintenance},
        "management_accounts": {"type": ManagementAccounts},
        "management_api_gnmi": {"type": ManagementApiGnmi},
        "management_api_http": {"type": ManagementApiHttp},
        "management_api_models": {"type": ManagementApiModels},
        "management_console": {"type": ManagementConsole},
        "management_cvx": {"type": ManagementCvx},
        "management_defaults": {"type": ManagementDefaults},
        "management_interfaces": {"type": ManagementInterfaces},
        "management_security": {"type": ManagementSecurity},
        "management_ssh": {"type": ManagementSsh},
        "management_tech_support": {"type": ManagementTechSupport},
        "match_list_input": {"type": MatchListInput},
        "mcs_client": {"type": McsClient},
        "metadata": {"type": Metadata},
        "mlag_configuration": {"type": MlagConfiguration},
        "monitor_connectivity": {"type": MonitorConnectivity},
        "monitor_layer1": {"type": MonitorLayer1},
        "monitor_session_default_encapsulation_gre": {"type": MonitorSessionDefaultEncapsulationGre},
        "monitor_sessions": {"type": list, "items": MonitorSessionsItem},
        "monitor_telemetry_influx": {"type": MonitorTelemetryInflux},
        "monitor_telemetry_postcard_policy": {"type": MonitorTelemetryPostcardPolicy},
        "mpls": {"type": Mpls},
        "ntp": {"type": Ntp},
        "patch_panel": {"type": PatchPanel},
        "peer_filters": {"type": PeerFilters},
        "platform": {"type": Platform},
        "poe": {"type": Poe},
        "policy_maps": {"type": PolicyMaps},
        "port_channel_interfaces": {"type": PortChannelInterfaces},
        "prefix_lists": {"type": PrefixLists},
        "priority_flow_control": {"type": PriorityFlowControl},
        "prompt": {"type": str},
        "ptp": {"type": Ptp},
        "qos": {"type": Qos},
        "qos_profiles": {"type": QosProfiles},
        "queue_monitor_length": {"type": QueueMonitorLength},
        "queue_monitor_streaming": {"type": QueueMonitorStreaming},
        "radius_server": {"type": RadiusServer},
        "redundancy": {"type": Redundancy},
        "roles": {"type": Roles},
        "route_maps": {"type": RouteMaps},
        "router_adaptive_virtual_topology": {"type": RouterAdaptiveVirtualTopology},
        "router_bfd": {"type": RouterBfd},
        "router_bgp": {"type": RouterBgp},
        "router_general": {"type": RouterGeneral},
        "router_igmp": {"type": RouterIgmp},
        "router_internet_exit": {"type": RouterInternetExit},
        "router_isis": {"type": RouterIsis},
        "router_l2_vpn": {"type": RouterL2Vpn},
        "router_msdp": {"type": RouterMsdp},
        "router_multicast": {"type": RouterMulticast},
        "router_ospf": {"type": RouterOspf},
        "router_path_selection": {"type": RouterPathSelection},
        "router_pim_sparse_mode": {"type": RouterPimSparseMode},
        "router_segment_security": {"type": RouterSegmentSecurity},
        "router_service_insertion": {"type": RouterServiceInsertion},
        "router_traffic_engineering": {"type": RouterTrafficEngineering},
        "service_routing_configuration_bgp": {"type": ServiceRoutingConfigurationBgp},
        "service_routing_protocols_model": {"type": str},
        "service_unsupported_transceiver": {"type": ServiceUnsupportedTransceiver},
        "sflow": {"type": Sflow},
        "snmp_server": {"type": SnmpServer},
        "spanning_tree": {"type": SpanningTree},
        "standard_access_lists": {"type": StandardAccessLists},
        "static_routes": {"type": list, "items": StaticRoutesItem},
        "stun": {"type": Stun},
        "switchport_default": {"type": SwitchportDefault},
        "switchport_port_security": {"type": SwitchportPortSecurity},
        "sync_e": {"type": SyncE},
        "system": {"type": System},
        "tacacs_servers": {"type": TacacsServers},
        "tap_aggregation": {"type": TapAggregation},
        "tcam_profile": {"type": TcamProfile},
        "terminal": {"type": Terminal},
        "trackers": {"type": Trackers},
        "traffic_policies": {"type": TrafficPolicies},
        "transceiver_qsfp_default_mode_4x10": {"type": bool, "default": True},
        "tunnel_interfaces": {"type": TunnelInterfaces},
        "virtual_source_nat_vrfs": {"type": VirtualSourceNatVrfs},
        "vlan_interfaces": {"type": VlanInterfaces},
        "vlan_internal_order": {"type": VlanInternalOrder},
        "vlans": {"type": Vlans},
        "vmtracer_sessions": {"type": VmtracerSessions},
        "vrfs": {"type": Vrfs},
        "vxlan_interface": {"type": VxlanInterface},
    }
    _required_fields: ClassVar[tuple] = ()
    _allow_other_keys: ClassVar[bool] = True
    aaa_accounting: AaaAccounting
    aaa_authentication: AaaAuthentication
    aaa_authorization: AaaAuthorization
    aaa_root: AaaRoot
    aaa_server_groups: AaaServerGroups
    access_lists: AccessLists
    address_locking: AddressLocking
    agents: Agents
    aliases: str | None
    """
    Multi-line string with one or more alias commands.

    Example:

    ```yaml
    aliases: |
      alias wr copy
    running-config startup-config
      alias siib show ip interface brief
    ```
    """
    application_traffic_recognition: ApplicationTrafficRecognition
    """Application traffic recognition configuration."""
    arp: Arp
    as_path: AsPath
    avd_data_validation_mode: str | None
    """
    Validation Mode for AVD input data validation.
    Input data validation will validate the input
    variables according to the schema.
    During validation, messages will generated with information about
    the host(s) and key(s) which failed validation.
    "error" will produce error messages and fail the
    task.
    "warning" will produce warning messages.
    """
    banners: Banners
    bgp_groups: BgpGroups
    boot: Boot
    """Set the Aboot password."""
    class_maps: ClassMaps
    clock: Clock
    community_lists: CommunityLists
    config_comment: str | None
    """
    Add a comment to provide information about the configuration.
    This comment will be rendered at the
    top of the generated configuration.
    """
    config_end: bool | None
    """Render `end` at the end of the configuration."""
    custom_templates: list[str]
    """
    - Custom templates can be added below the playbook directory.
    - If a location above the directory is
    desired, a symbolic link can be used.
    - Example under the `playbooks` directory create symbolic link
    with the following command:

      ```bash
      ln -s ../../shared_repo/custom_avd_templates/
    ./custom_avd_templates
      ```

    - The output will be rendered at the end of the configuration.
    - The
    order of custom templates in the list can be important if they overlap.
    - It is recommended to use a
    `!` delimiter at the top of each custom template.

    Add `custom_templates` to group/host variables:
    """
    cvx: Cvx
    """
    CVX server features are not supported on physical switches. See `management_cvx` for client
    configurations.
    """
    daemon_terminattr: DaemonTerminattr
    """
    You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
    for your Cloudvision as a Service instance.
    Streaming to multiple clusters both on-prem and cloud
    service is supported.

    !!! note
        For TerminAttr version recommendation and EOS compatibility
    matrix, please refer to the latest TerminAttr Release Notes
        which always contain the latest
    recommended versions and minimum required versions per EOS release.
    """
    daemons: Daemons
    """
    This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
    clients like ocprometheus.
    """
    dhcp_relay: DhcpRelay
    dhcp_servers: DhcpServers
    dns_domain: str | None
    """Domain Name."""
    domain_list: list[str]
    """Search list of DNS domains."""
    dot1x: Dot1x
    dps_interfaces: DpsInterfaces
    dynamic_prefix_lists: list[DynamicPrefixListsItem]
    enable_password: EnablePassword
    eos_cli: str | None
    """Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration."""
    eos_cli_config_gen_configuration: EosCliConfigGenConfiguration
    eos_cli_config_gen_documentation: EosCliConfigGenDocumentation
    errdisable: Errdisable
    ethernet_interfaces: EthernetInterfaces
    event_handlers: EventHandlers
    """
    Gives the ability to monitor and react to Syslog messages.
    Event Handlers provide a powerful and
    flexible tool that can be used to apply self-healing actions,
    customize the system behavior, and
    implement workarounds to problems discovered in the field.
    """
    event_monitor: EventMonitor
    flow_tracking: FlowTracking
    generate_default_config: bool | None
    """
    The `generate_default_config` knob allows to omit default EOS configuration.
    This can be useful when
    leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

    The following commands
    will be omitted when `generate_default_config` is set to `false`:

    - RANCID Content Type
    - Hostname
    (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
    -
    Default configuration for `aaa`
    - Default configuration for `enable password`
    - Transceiver qsfp
    default mode
    - End of configuration delimiter
    """
    generate_device_documentation: bool | None
    hardware: Hardware
    hardware_counters: HardwareCounters
    hostname: str | None
    interface_defaults: InterfaceDefaults
    interface_groups: InterfaceGroups
    interface_profiles: InterfaceProfiles
    ip_access_lists: IpAccessLists
    ip_access_lists_max_entries: int | None
    """Limit ACL entries defined under the `ip_access_lists`."""
    ip_community_lists: IpCommunityLists
    """Communities and regexp entries MUST not be configured in the same community-list."""
    ip_dhcp_relay: IpDhcpRelay
    ip_dhcp_snooping: IpDhcpSnooping
    ip_domain_lookup: IpDomainLookup
    ip_extcommunity_lists: IpExtcommunityLists
    ip_extcommunity_lists_regexp: IpExtcommunityListsRegexp
    ip_ftp_client_source_interfaces: list[IpFtpClientSourceInterfacesItem]
    ip_hardware: IpHardware
    ip_http_client_source_interfaces: list[IpHttpClientSourceInterfacesItem]
    ip_icmp_redirect: bool | None
    ip_igmp_snooping: IpIgmpSnooping
    ip_name_servers: list[IpNameServersItem]
    ip_nat: IpNat
    ip_radius_source_interfaces: list[IpRadiusSourceInterfacesItem]
    ip_routing: bool | None
    ip_routing_ipv6_interfaces: bool | None
    ip_security: IpSecurity
    ip_ssh_client_source_interfaces: list[IpSshClientSourceInterfacesItem]
    ip_tacacs_source_interfaces: list[IpTacacsSourceInterfacesItem]
    ip_telnet_client_source_interfaces: list[IpTelnetClientSourceInterfacesItem]
    ip_tftp_client_source_interfaces: list[IpTftpClientSourceInterfacesItem]
    ip_virtual_router_mac_address: str | None
    """MAC address (hh:hh:hh:hh:hh:hh)."""
    ipv6_access_lists: Ipv6AccessLists
    ipv6_dhcp_relay: Ipv6DhcpRelay
    ipv6_hardware: Ipv6Hardware
    ipv6_icmp_redirect: bool | None
    ipv6_neighbor: Ipv6Neighbor
    ipv6_prefix_lists: Ipv6PrefixLists
    ipv6_standard_access_lists: Ipv6StandardAccessLists
    ipv6_static_routes: list[Ipv6StaticRoutesItem]
    ipv6_unicast_routing: bool | None
    is_deployed: bool | None
    """Key only used for documentation or validation purposes."""
    l2_protocol: L2Protocol
    lacp: Lacp
    """Set Link Aggregation Control Protocol (LACP) parameters."""
    link_tracking_groups: LinkTrackingGroups
    lldp: Lldp
    load_interval: LoadInterval
    local_users: LocalUsers
    logging: Logging
    loopback_interfaces: LoopbackInterfaces
    mac_access_lists: MacAccessLists
    mac_address_table: MacAddressTable
    mac_security: MacSecurity
    maintenance: Maintenance
    management_accounts: ManagementAccounts
    management_api_gnmi: ManagementApiGnmi
    management_api_http: ManagementApiHttp
    management_api_models: ManagementApiModels
    management_console: ManagementConsole
    management_cvx: ManagementCvx
    management_defaults: ManagementDefaults
    management_interfaces: ManagementInterfaces
    management_security: ManagementSecurity
    management_ssh: ManagementSsh
    management_tech_support: ManagementTechSupport
    match_list_input: MatchListInput
    mcs_client: McsClient
    metadata: Metadata
    """
    The data under `metadata` is used for documentation, validation or integration purposes.
    It will not
    affect the generated EOS configuration.
    """
    mlag_configuration: MlagConfiguration
    monitor_connectivity: MonitorConnectivity
    monitor_layer1: MonitorLayer1
    """Enable SYSLOG messages on transceiver SMBus communication failures."""
    monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre
    monitor_sessions: list[MonitorSessionsItem]
    monitor_telemetry_influx: MonitorTelemetryInflux
    monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy
    mpls: Mpls
    ntp: Ntp
    patch_panel: PatchPanel
    peer_filters: PeerFilters
    platform: Platform
    """Every key below this point is platform dependent."""
    poe: Poe
    policy_maps: PolicyMaps
    port_channel_interfaces: PortChannelInterfaces
    prefix_lists: PrefixLists
    priority_flow_control: PriorityFlowControl
    """Global Priority Flow Control settings."""
    prompt: str | None
    ptp: Ptp
    qos: Qos
    qos_profiles: QosProfiles
    queue_monitor_length: QueueMonitorLength
    queue_monitor_streaming: QueueMonitorStreaming
    radius_server: RadiusServer
    redundancy: Redundancy
    roles: Roles
    route_maps: RouteMaps
    router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology
    router_bfd: RouterBfd
    router_bgp: RouterBgp
    router_general: RouterGeneral
    router_igmp: RouterIgmp
    router_internet_exit: RouterInternetExit
    """Internet-exit feature to configure internet bound service for virtual topologies."""
    router_isis: RouterIsis
    router_l2_vpn: RouterL2Vpn
    router_msdp: RouterMsdp
    router_multicast: RouterMulticast
    router_ospf: RouterOspf
    router_path_selection: RouterPathSelection
    """Dynamic path selection configuration."""
    router_pim_sparse_mode: RouterPimSparseMode
    router_segment_security: RouterSegmentSecurity
    router_service_insertion: RouterServiceInsertion
    """Configure network services inserted to data forwarding."""
    router_traffic_engineering: RouterTrafficEngineering
    service_routing_configuration_bgp: ServiceRoutingConfigurationBgp
    service_routing_protocols_model: str | None
    service_unsupported_transceiver: ServiceUnsupportedTransceiver
    sflow: Sflow
    snmp_server: SnmpServer
    """SNMP settings."""
    spanning_tree: SpanningTree
    standard_access_lists: StandardAccessLists
    static_routes: list[StaticRoutesItem]
    stun: Stun
    """STUN configuration."""
    switchport_default: SwitchportDefault
    switchport_port_security: SwitchportPortSecurity
    sync_e: SyncE
    system: System
    tacacs_servers: TacacsServers
    tap_aggregation: TapAggregation
    tcam_profile: TcamProfile
    terminal: Terminal
    trackers: Trackers
    traffic_policies: TrafficPolicies
    transceiver_qsfp_default_mode_4x10: bool | None
    """
    On all front panel ports which support this feature, the following global configuration command
    changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
    QSFP mode back to 40G.
    """
    tunnel_interfaces: TunnelInterfaces
    virtual_source_nat_vrfs: VirtualSourceNatVrfs
    vlan_interfaces: VlanInterfaces
    vlan_internal_order: VlanInternalOrder
    vlans: Vlans
    vmtracer_sessions: VmtracerSessions
    vrfs: Vrfs
    """These keys are ignored if the name of the vrf is 'default'."""
    vxlan_interface: VxlanInterface

    def __init__(
        self,
        *,
        aaa_accounting: AaaAccounting | UndefinedType = Undefined,
        aaa_authentication: AaaAuthentication | UndefinedType = Undefined,
        aaa_authorization: AaaAuthorization | UndefinedType = Undefined,
        aaa_root: AaaRoot | UndefinedType = Undefined,
        aaa_server_groups: AaaServerGroups | UndefinedType = Undefined,
        access_lists: AccessLists | UndefinedType = Undefined,
        address_locking: AddressLocking | UndefinedType = Undefined,
        agents: Agents | UndefinedType = Undefined,
        aliases: str | None | UndefinedType = Undefined,
        application_traffic_recognition: ApplicationTrafficRecognition | UndefinedType = Undefined,
        arp: Arp | UndefinedType = Undefined,
        as_path: AsPath | UndefinedType = Undefined,
        avd_data_validation_mode: str | None | UndefinedType = Undefined,
        banners: Banners | UndefinedType = Undefined,
        bgp_groups: BgpGroups | UndefinedType = Undefined,
        boot: Boot | UndefinedType = Undefined,
        class_maps: ClassMaps | UndefinedType = Undefined,
        clock: Clock | UndefinedType = Undefined,
        community_lists: CommunityLists | UndefinedType = Undefined,
        config_comment: str | None | UndefinedType = Undefined,
        config_end: bool | None | UndefinedType = Undefined,
        custom_templates: list[str] | UndefinedType = Undefined,
        cvx: Cvx | UndefinedType = Undefined,
        daemon_terminattr: DaemonTerminattr | UndefinedType = Undefined,
        daemons: Daemons | UndefinedType = Undefined,
        dhcp_relay: DhcpRelay | UndefinedType = Undefined,
        dhcp_servers: DhcpServers | UndefinedType = Undefined,
        dns_domain: str | None | UndefinedType = Undefined,
        domain_list: list[str] | UndefinedType = Undefined,
        dot1x: Dot1x | UndefinedType = Undefined,
        dps_interfaces: DpsInterfaces | UndefinedType = Undefined,
        dynamic_prefix_lists: list[DynamicPrefixListsItem] | UndefinedType = Undefined,
        enable_password: EnablePassword | UndefinedType = Undefined,
        eos_cli: str | None | UndefinedType = Undefined,
        eos_cli_config_gen_configuration: EosCliConfigGenConfiguration | UndefinedType = Undefined,
        eos_cli_config_gen_documentation: EosCliConfigGenDocumentation | UndefinedType = Undefined,
        errdisable: Errdisable | UndefinedType = Undefined,
        ethernet_interfaces: EthernetInterfaces | UndefinedType = Undefined,
        event_handlers: EventHandlers | UndefinedType = Undefined,
        event_monitor: EventMonitor | UndefinedType = Undefined,
        flow_tracking: FlowTracking | UndefinedType = Undefined,
        generate_default_config: bool | None | UndefinedType = Undefined,
        generate_device_documentation: bool | None | UndefinedType = Undefined,
        hardware: Hardware | UndefinedType = Undefined,
        hardware_counters: HardwareCounters | UndefinedType = Undefined,
        hostname: str | None | UndefinedType = Undefined,
        interface_defaults: InterfaceDefaults | UndefinedType = Undefined,
        interface_groups: InterfaceGroups | UndefinedType = Undefined,
        interface_profiles: InterfaceProfiles | UndefinedType = Undefined,
        ip_access_lists: IpAccessLists | UndefinedType = Undefined,
        ip_access_lists_max_entries: int | None | UndefinedType = Undefined,
        ip_community_lists: IpCommunityLists | UndefinedType = Undefined,
        ip_dhcp_relay: IpDhcpRelay | UndefinedType = Undefined,
        ip_dhcp_snooping: IpDhcpSnooping | UndefinedType = Undefined,
        ip_domain_lookup: IpDomainLookup | UndefinedType = Undefined,
        ip_extcommunity_lists: IpExtcommunityLists | UndefinedType = Undefined,
        ip_extcommunity_lists_regexp: IpExtcommunityListsRegexp | UndefinedType = Undefined,
        ip_ftp_client_source_interfaces: list[IpFtpClientSourceInterfacesItem] | UndefinedType = Undefined,
        ip_hardware: IpHardware | UndefinedType = Undefined,
        ip_http_client_source_interfaces: list[IpHttpClientSourceInterfacesItem] | UndefinedType = Undefined,
        ip_icmp_redirect: bool | None | UndefinedType = Undefined,
        ip_igmp_snooping: IpIgmpSnooping | UndefinedType = Undefined,
        ip_name_servers: list[IpNameServersItem] | UndefinedType = Undefined,
        ip_nat: IpNat | UndefinedType = Undefined,
        ip_radius_source_interfaces: list[IpRadiusSourceInterfacesItem] | UndefinedType = Undefined,
        ip_routing: bool | None | UndefinedType = Undefined,
        ip_routing_ipv6_interfaces: bool | None | UndefinedType = Undefined,
        ip_security: IpSecurity | UndefinedType = Undefined,
        ip_ssh_client_source_interfaces: list[IpSshClientSourceInterfacesItem] | UndefinedType = Undefined,
        ip_tacacs_source_interfaces: list[IpTacacsSourceInterfacesItem] | UndefinedType = Undefined,
        ip_telnet_client_source_interfaces: list[IpTelnetClientSourceInterfacesItem] | UndefinedType = Undefined,
        ip_tftp_client_source_interfaces: list[IpTftpClientSourceInterfacesItem] | UndefinedType = Undefined,
        ip_virtual_router_mac_address: str | None | UndefinedType = Undefined,
        ipv6_access_lists: Ipv6AccessLists | UndefinedType = Undefined,
        ipv6_dhcp_relay: Ipv6DhcpRelay | UndefinedType = Undefined,
        ipv6_hardware: Ipv6Hardware | UndefinedType = Undefined,
        ipv6_icmp_redirect: bool | None | UndefinedType = Undefined,
        ipv6_neighbor: Ipv6Neighbor | UndefinedType = Undefined,
        ipv6_prefix_lists: Ipv6PrefixLists | UndefinedType = Undefined,
        ipv6_standard_access_lists: Ipv6StandardAccessLists | UndefinedType = Undefined,
        ipv6_static_routes: list[Ipv6StaticRoutesItem] | UndefinedType = Undefined,
        ipv6_unicast_routing: bool | None | UndefinedType = Undefined,
        is_deployed: bool | None | UndefinedType = Undefined,
        l2_protocol: L2Protocol | UndefinedType = Undefined,
        lacp: Lacp | UndefinedType = Undefined,
        link_tracking_groups: LinkTrackingGroups | UndefinedType = Undefined,
        lldp: Lldp | UndefinedType = Undefined,
        load_interval: LoadInterval | UndefinedType = Undefined,
        local_users: LocalUsers | UndefinedType = Undefined,
        logging: Logging | UndefinedType = Undefined,
        loopback_interfaces: LoopbackInterfaces | UndefinedType = Undefined,
        mac_access_lists: MacAccessLists | UndefinedType = Undefined,
        mac_address_table: MacAddressTable | UndefinedType = Undefined,
        mac_security: MacSecurity | UndefinedType = Undefined,
        maintenance: Maintenance | UndefinedType = Undefined,
        management_accounts: ManagementAccounts | UndefinedType = Undefined,
        management_api_gnmi: ManagementApiGnmi | UndefinedType = Undefined,
        management_api_http: ManagementApiHttp | UndefinedType = Undefined,
        management_api_models: ManagementApiModels | UndefinedType = Undefined,
        management_console: ManagementConsole | UndefinedType = Undefined,
        management_cvx: ManagementCvx | UndefinedType = Undefined,
        management_defaults: ManagementDefaults | UndefinedType = Undefined,
        management_interfaces: ManagementInterfaces | UndefinedType = Undefined,
        management_security: ManagementSecurity | UndefinedType = Undefined,
        management_ssh: ManagementSsh | UndefinedType = Undefined,
        management_tech_support: ManagementTechSupport | UndefinedType = Undefined,
        match_list_input: MatchListInput | UndefinedType = Undefined,
        mcs_client: McsClient | UndefinedType = Undefined,
        metadata: Metadata | UndefinedType = Undefined,
        mlag_configuration: MlagConfiguration | UndefinedType = Undefined,
        monitor_connectivity: MonitorConnectivity | UndefinedType = Undefined,
        monitor_layer1: MonitorLayer1 | UndefinedType = Undefined,
        monitor_session_default_encapsulation_gre: MonitorSessionDefaultEncapsulationGre | UndefinedType = Undefined,
        monitor_sessions: list[MonitorSessionsItem] | UndefinedType = Undefined,
        monitor_telemetry_influx: MonitorTelemetryInflux | UndefinedType = Undefined,
        monitor_telemetry_postcard_policy: MonitorTelemetryPostcardPolicy | UndefinedType = Undefined,
        mpls: Mpls | UndefinedType = Undefined,
        ntp: Ntp | UndefinedType = Undefined,
        patch_panel: PatchPanel | UndefinedType = Undefined,
        peer_filters: PeerFilters | UndefinedType = Undefined,
        platform: Platform | UndefinedType = Undefined,
        poe: Poe | UndefinedType = Undefined,
        policy_maps: PolicyMaps | UndefinedType = Undefined,
        port_channel_interfaces: PortChannelInterfaces | UndefinedType = Undefined,
        prefix_lists: PrefixLists | UndefinedType = Undefined,
        priority_flow_control: PriorityFlowControl | UndefinedType = Undefined,
        prompt: str | None | UndefinedType = Undefined,
        ptp: Ptp | UndefinedType = Undefined,
        qos: Qos | UndefinedType = Undefined,
        qos_profiles: QosProfiles | UndefinedType = Undefined,
        queue_monitor_length: QueueMonitorLength | UndefinedType = Undefined,
        queue_monitor_streaming: QueueMonitorStreaming | UndefinedType = Undefined,
        radius_server: RadiusServer | UndefinedType = Undefined,
        redundancy: Redundancy | UndefinedType = Undefined,
        roles: Roles | UndefinedType = Undefined,
        route_maps: RouteMaps | UndefinedType = Undefined,
        router_adaptive_virtual_topology: RouterAdaptiveVirtualTopology | UndefinedType = Undefined,
        router_bfd: RouterBfd | UndefinedType = Undefined,
        router_bgp: RouterBgp | UndefinedType = Undefined,
        router_general: RouterGeneral | UndefinedType = Undefined,
        router_igmp: RouterIgmp | UndefinedType = Undefined,
        router_internet_exit: RouterInternetExit | UndefinedType = Undefined,
        router_isis: RouterIsis | UndefinedType = Undefined,
        router_l2_vpn: RouterL2Vpn | UndefinedType = Undefined,
        router_msdp: RouterMsdp | UndefinedType = Undefined,
        router_multicast: RouterMulticast | UndefinedType = Undefined,
        router_ospf: RouterOspf | UndefinedType = Undefined,
        router_path_selection: RouterPathSelection | UndefinedType = Undefined,
        router_pim_sparse_mode: RouterPimSparseMode | UndefinedType = Undefined,
        router_segment_security: RouterSegmentSecurity | UndefinedType = Undefined,
        router_service_insertion: RouterServiceInsertion | UndefinedType = Undefined,
        router_traffic_engineering: RouterTrafficEngineering | UndefinedType = Undefined,
        service_routing_configuration_bgp: ServiceRoutingConfigurationBgp | UndefinedType = Undefined,
        service_routing_protocols_model: str | None | UndefinedType = Undefined,
        service_unsupported_transceiver: ServiceUnsupportedTransceiver | UndefinedType = Undefined,
        sflow: Sflow | UndefinedType = Undefined,
        snmp_server: SnmpServer | UndefinedType = Undefined,
        spanning_tree: SpanningTree | UndefinedType = Undefined,
        standard_access_lists: StandardAccessLists | UndefinedType = Undefined,
        static_routes: list[StaticRoutesItem] | UndefinedType = Undefined,
        stun: Stun | UndefinedType = Undefined,
        switchport_default: SwitchportDefault | UndefinedType = Undefined,
        switchport_port_security: SwitchportPortSecurity | UndefinedType = Undefined,
        sync_e: SyncE | UndefinedType = Undefined,
        system: System | UndefinedType = Undefined,
        tacacs_servers: TacacsServers | UndefinedType = Undefined,
        tap_aggregation: TapAggregation | UndefinedType = Undefined,
        tcam_profile: TcamProfile | UndefinedType = Undefined,
        terminal: Terminal | UndefinedType = Undefined,
        trackers: Trackers | UndefinedType = Undefined,
        traffic_policies: TrafficPolicies | UndefinedType = Undefined,
        transceiver_qsfp_default_mode_4x10: bool | None | UndefinedType = Undefined,
        tunnel_interfaces: TunnelInterfaces | UndefinedType = Undefined,
        virtual_source_nat_vrfs: VirtualSourceNatVrfs | UndefinedType = Undefined,
        vlan_interfaces: VlanInterfaces | UndefinedType = Undefined,
        vlan_internal_order: VlanInternalOrder | UndefinedType = Undefined,
        vlans: Vlans | UndefinedType = Undefined,
        vmtracer_sessions: VmtracerSessions | UndefinedType = Undefined,
        vrfs: Vrfs | UndefinedType = Undefined,
        vxlan_interface: VxlanInterface | UndefinedType = Undefined,
        **kwargs: Any,
    ) -> None:
        """
        EosCliConfigGen.

        Args:
        -----
            aaa_accounting: aaa_accounting
            aaa_authentication: aaa_authentication
            aaa_authorization: aaa_authorization
            aaa_root: aaa_root
            aaa_server_groups: aaa_server_groups
            access_lists: access_lists
            address_locking: address_locking
            agents: agents
            aliases:
               Multi-line string with one or more alias commands.

        Example:
               ```yaml
               aliases: |
                 alias wr copy
               running-config startup-config
                 alias siib show ip interface brief
               ```
            application_traffic_recognition: Application traffic recognition configuration.
            arp: arp
            as_path: as_path
            avd_data_validation_mode:
               Validation Mode for AVD input data validation.
               Input data validation will validate the input
               variables according to the schema.
               During validation, messages will generated with information about
               the host(s) and key(s) which failed validation.
               "error" will produce error messages and fail the
               task.
               "warning" will produce warning messages.
            banners: banners
            bgp_groups: bgp_groups
            boot: Set the Aboot password.
            class_maps: class_maps
            clock: clock
            community_lists: community_lists
            config_comment:
               Add a comment to provide information about the configuration.
               This comment will be rendered at the
               top of the generated configuration.
            config_end: Render `end` at the end of the configuration.
            custom_templates:
               - Custom templates can be added below the playbook directory.
               - If a location above the directory is
               desired, a symbolic link can be used.
               - Example under the `playbooks` directory create symbolic link
               with the following command:

                 ```bash
                 ln -s ../../shared_repo/custom_avd_templates/
               ./custom_avd_templates
                 ```

               - The output will be rendered at the end of the configuration.
               - The
               order of custom templates in the list can be important if they overlap.
               - It is recommended to use a
               `!` delimiter at the top of each custom template.

               Add `custom_templates` to group/host variables:
            cvx:
               CVX server features are not supported on physical switches. See `management_cvx` for client
               configurations.
            daemon_terminattr:
               You can either provide a list of IPs/FQDNs to target on-premise Cloudvision cluster or use DNS name
               for your Cloudvision as a Service instance.
               Streaming to multiple clusters both on-prem and cloud
               service is supported.

               !!! note
                   For TerminAttr version recommendation and EOS compatibility
               matrix, please refer to the latest TerminAttr Release Notes
                   which always contain the latest
               recommended versions and minimum required versions per EOS release.
            daemons:
               This will add a daemon to the eos configuration that is most useful when trying to run OpenConfig
               clients like ocprometheus.
            dhcp_relay: dhcp_relay
            dhcp_servers: dhcp_servers
            dns_domain: Domain Name.
            domain_list: Search list of DNS domains.
            dot1x: dot1x
            dps_interfaces: dps_interfaces
            dynamic_prefix_lists: dynamic_prefix_lists
            enable_password: enable_password
            eos_cli: Multiline string with EOS CLI rendered directly on the root level of the final EOS configuration.
            eos_cli_config_gen_configuration: eos_cli_config_gen_configuration
            eos_cli_config_gen_documentation: eos_cli_config_gen_documentation
            errdisable: errdisable
            ethernet_interfaces: ethernet_interfaces
            event_handlers:
               Gives the ability to monitor and react to Syslog messages.
               Event Handlers provide a powerful and
               flexible tool that can be used to apply self-healing actions,
               customize the system behavior, and
               implement workarounds to problems discovered in the field.
            event_monitor: event_monitor
            flow_tracking: flow_tracking
            generate_default_config:
               The `generate_default_config` knob allows to omit default EOS configuration.
               This can be useful when
               leveraging `eos_cli_config_gen` to generate configlets with CloudVision.

               The following commands
               will be omitted when `generate_default_config` is set to `false`:

               - RANCID Content Type
               - Hostname
               (even if `hostname` variable is not set. Then the hostname is picked up from `inventory_hostname`)
               -
               Default configuration for `aaa`
               - Default configuration for `enable password`
               - Transceiver qsfp
               default mode
               - End of configuration delimiter
            generate_device_documentation: generate_device_documentation
            hardware: hardware
            hardware_counters: hardware_counters
            hostname: hostname
            interface_defaults: interface_defaults
            interface_groups: interface_groups
            interface_profiles: interface_profiles
            ip_access_lists: ip_access_lists
            ip_access_lists_max_entries: Limit ACL entries defined under the `ip_access_lists`.
            ip_community_lists: Communities and regexp entries MUST not be configured in the same community-list.
            ip_dhcp_relay: ip_dhcp_relay
            ip_dhcp_snooping: ip_dhcp_snooping
            ip_domain_lookup: ip_domain_lookup
            ip_extcommunity_lists: ip_extcommunity_lists
            ip_extcommunity_lists_regexp: ip_extcommunity_lists_regexp
            ip_ftp_client_source_interfaces: ip_ftp_client_source_interfaces
            ip_hardware: ip_hardware
            ip_http_client_source_interfaces: ip_http_client_source_interfaces
            ip_icmp_redirect: ip_icmp_redirect
            ip_igmp_snooping: ip_igmp_snooping
            ip_name_servers: ip_name_servers
            ip_nat: ip_nat
            ip_radius_source_interfaces: ip_radius_source_interfaces
            ip_routing: ip_routing
            ip_routing_ipv6_interfaces: ip_routing_ipv6_interfaces
            ip_security: ip_security
            ip_ssh_client_source_interfaces: ip_ssh_client_source_interfaces
            ip_tacacs_source_interfaces: ip_tacacs_source_interfaces
            ip_telnet_client_source_interfaces: ip_telnet_client_source_interfaces
            ip_tftp_client_source_interfaces: ip_tftp_client_source_interfaces
            ip_virtual_router_mac_address: MAC address (hh:hh:hh:hh:hh:hh).
            ipv6_access_lists: ipv6_access_lists
            ipv6_dhcp_relay: ipv6_dhcp_relay
            ipv6_hardware: ipv6_hardware
            ipv6_icmp_redirect: ipv6_icmp_redirect
            ipv6_neighbor: ipv6_neighbor
            ipv6_prefix_lists: ipv6_prefix_lists
            ipv6_standard_access_lists: ipv6_standard_access_lists
            ipv6_static_routes: ipv6_static_routes
            ipv6_unicast_routing: ipv6_unicast_routing
            is_deployed: Key only used for documentation or validation purposes.
            l2_protocol: l2_protocol
            lacp: Set Link Aggregation Control Protocol (LACP) parameters.
            link_tracking_groups: link_tracking_groups
            lldp: lldp
            load_interval: load_interval
            local_users: local_users
            logging: logging
            loopback_interfaces: loopback_interfaces
            mac_access_lists: mac_access_lists
            mac_address_table: mac_address_table
            mac_security: mac_security
            maintenance: maintenance
            management_accounts: management_accounts
            management_api_gnmi: management_api_gnmi
            management_api_http: management_api_http
            management_api_models: management_api_models
            management_console: management_console
            management_cvx: management_cvx
            management_defaults: management_defaults
            management_interfaces: management_interfaces
            management_security: management_security
            management_ssh: management_ssh
            management_tech_support: management_tech_support
            match_list_input: match_list_input
            mcs_client: mcs_client
            metadata:
               The data under `metadata` is used for documentation, validation or integration purposes.
               It will not
               affect the generated EOS configuration.
            mlag_configuration: mlag_configuration
            monitor_connectivity: monitor_connectivity
            monitor_layer1: Enable SYSLOG messages on transceiver SMBus communication failures.
            monitor_session_default_encapsulation_gre: monitor_session_default_encapsulation_gre
            monitor_sessions: monitor_sessions
            monitor_telemetry_influx: monitor_telemetry_influx
            monitor_telemetry_postcard_policy: monitor_telemetry_postcard_policy
            mpls: mpls
            ntp: ntp
            patch_panel: patch_panel
            peer_filters: peer_filters
            platform: Every key below this point is platform dependent.
            poe: poe
            policy_maps: policy_maps
            port_channel_interfaces: port_channel_interfaces
            prefix_lists: prefix_lists
            priority_flow_control: Global Priority Flow Control settings.
            prompt: prompt
            ptp: ptp
            qos: qos
            qos_profiles: qos_profiles
            queue_monitor_length: queue_monitor_length
            queue_monitor_streaming: queue_monitor_streaming
            radius_server: radius_server
            redundancy: redundancy
            roles: roles
            route_maps: route_maps
            router_adaptive_virtual_topology: router_adaptive_virtual_topology
            router_bfd: router_bfd
            router_bgp: router_bgp
            router_general: router_general
            router_igmp: router_igmp
            router_internet_exit: Internet-exit feature to configure internet bound service for virtual topologies.
            router_isis: router_isis
            router_l2_vpn: router_l2_vpn
            router_msdp: router_msdp
            router_multicast: router_multicast
            router_ospf: router_ospf
            router_path_selection: Dynamic path selection configuration.
            router_pim_sparse_mode: router_pim_sparse_mode
            router_segment_security: router_segment_security
            router_service_insertion: Configure network services inserted to data forwarding.
            router_traffic_engineering: router_traffic_engineering
            service_routing_configuration_bgp: service_routing_configuration_bgp
            service_routing_protocols_model: service_routing_protocols_model
            service_unsupported_transceiver: service_unsupported_transceiver
            sflow: sflow
            snmp_server: SNMP settings.
            spanning_tree: spanning_tree
            standard_access_lists: standard_access_lists
            static_routes: static_routes
            stun: STUN configuration.
            switchport_default: switchport_default
            switchport_port_security: switchport_port_security
            sync_e: sync_e
            system: system
            tacacs_servers: tacacs_servers
            tap_aggregation: tap_aggregation
            tcam_profile: tcam_profile
            terminal: terminal
            trackers: trackers
            traffic_policies: traffic_policies
            transceiver_qsfp_default_mode_4x10:
               On all front panel ports which support this feature, the following global configuration command
               changes the QSFP mode from 40G to 4x10G (default). When set to false the command reverts the default
               QSFP mode back to 40G.
            tunnel_interfaces: tunnel_interfaces
            virtual_source_nat_vrfs: virtual_source_nat_vrfs
            vlan_interfaces: vlan_interfaces
            vlan_internal_order: vlan_internal_order
            vlans: vlans
            vmtracer_sessions: vmtracer_sessions
            vrfs: These keys are ignored if the name of the vrf is 'default'.
            vxlan_interface: vxlan_interface

        """
        for arg, arg_value in locals().items():
            if arg_value is Undefined or arg in ("self", "kwargs"):
                continue
            setattr(self, arg, arg_value)
